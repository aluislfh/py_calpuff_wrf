c----------------------------------------------------------------------
c --- CALPUFF -- Non-steady-state Puff Model
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262     Level: 080725                 MAIN
c
c     Copyright (c) 1998-2008 by TRC Environmental Corporation         
c
c --- CALPUFF MOD5 - Developed by:
c                    Joe Scire and David Strimaitis
c ---                e-mail: jss@src.com or jscire@alum.mit.edu
c
c----------------------------------------------------------------------
c --- Model Change Bulletin Updates Included:           MCB-A (040716)
c                                                       MCB-B (051216)
c                                                       MCB-C (060804)
c                                                       MCB-D (070623)
c                                                       MCB-E (080613)
c----------------------------------------------------------------------
c
c --- Version 6.261, Level 080520 to Version 6.262, Level 080725
c
c     1) Modified check for invalid gradual rise factor that halted
c        a valid run in which the final plume rise was nearly zero
c        and the gradual rise was slightly negative due to precision.
c        A zero rise factor should result.  This change does not alter
c        results other than allowing a valid run to continue.
c        Modified: GRISE
c     2) Bug in GRISE assigned rise method to 2 (SS downwash) instead
c        of 3 (tabulated rise) for point sources that are not subject
c        to downwash and that are modeled with numerical plume rise.
c        Modified: GRISE
c
c --- Version 6.26, Level 080430 to Version 6.261, Level 080520
c
c     1) Add puff-based storage of arrays related to plume rise
c        tabulations.  This is implemented via a direct access (DA)
c        file.  IMET logic to only use current met period table is 
c        disabled by assigning IMET=1 (should be removed entirely).
c        New:      SRCTAB.PUF
c                  SWAPTAB, SRCTABIN
c        Modified: PARAMS.PUF,
c                  PT1.PUF, PT2.PUF, AR2.PUF, LN1.PUF, LN2.PUF 
c                  POINTS1, POINTS2, AREAS2, LINES1, LINES2,
c                  AREAS1, VOLS, BCS1,
c                  OPENOT, SWAP, COMP, GRISE, WAKE_TAB, RECSPEC0,
c                  RESTARTQ, RESTARTO, RESTARTI
c     2) Fix argument order in call to WAKE_FIN from POINTS2.  This
c        typically creates a runtime error that halts a run.
c        Modified: POINTS2
c     3) Place call to PRSS into GRISE to treat Schulman-Scire building
c        downwash cases, and remove calls to PRSS in the other
c        routines.  This also addresses bug in RISEWIND that should
c        have called PRSS.
c        Modified: GRISE, PUFRECS, SLGRECS, PLGRECS, ZTRACE
c     4) Fix QA test for MTILT restrictions on other model options
c        Modified: QAINP
c
c --- Version 6.251, Level 080407 to Version 6.26, Level 080430
c
c     1) Add new output file for reporting along-plume properties
c        during rise from the numerical rise module.  Restrict to
c        single source for now to limit file size, but code for
c        multiple sources.
c        New:      NRISEHD, NRISEOUT
c        Modified: BLOCK DATA, PARAMS.PUF, FILNAM.PUF, OUTPT.PUF
c                  READCF, READFN, WRFILES, QAINP, OPENOT
c                  WROUT1, INITPUF, POINTS1, POINTS2, AREAS2, NUMRISE
c     2) Fix declaration of work arrays to dimensions used in CALUTILS
c        This bug caused code added at end of file after GEOFMT (in this
c        case the new NRISEHD and NRISEOUT subroutines) to be altered
c        at runtime when GEOFMT is called.
c        Modified: GEOFMT
c     3) Add choice of either Briggs or Numerical plume rise for
c        point sources (except when downwash is active).  Include tip
c        downwash in NUMRISE results without building downwash.
c        Modified: BLOCK DATA, FLAGS.PUF
c                  READCF, QAINP, SETUP, POINTS1, POINTS2, NUMCLIP,
c                  GRISE
c
c --- Version 6.25, Level 080227 to Version 6.251, Level 080421
c
c    (1) Updated CALUTILS from v2.55 Level 070327 to v2.56 Level 080407
c        Control file entries in exponential notation were not correct
c        if decimal point was missing (2e-02 was read as 0.2e-02).
c        Modified: ALTONU
c    (2) Refine purpose of MPARTLBA to be an explicit switch for
c        selecting partial penetration for BUOYANT AREA sources.  MPARTL
c        now controls this option only for point sources.
c        Modified:  FLAGS.PUF,
c                   QAINP, AREAS2
c
c --- Version 6.24, Level 080208 to Version 6.25, Level 080227
c
c    (1) Revise variable sampling configuration subroutine to align
c        it with version 5.  Sampling steps are structured to use the
c        sampling step length for steady emissions for all steps
c        between the emitting step and the final sampling step of the
c        timestep.  The number of the starting step increases as puffs
c        are released, while the total number of sampling steps is
c        steady.
c        Modified:  COMP, VARSAM
c    (2) Revise test for allowing sampling substeps (LSUBSAM) from 
c        nsam.EQ.mxsam to nsam.GE.mxsam because NSAM is limited by MXNEW
c        during the emitting timestep, and MXNEW might be greater than
c        MXSAM.  The default is MNEW=MXSAM=99 so most applications are
c        not altered by this revision.
c        Modified:  COMP
c    (3) Change the warning response to sources located beyond the
c        computational grid to a fatal response (model stops).  Sources
c        in the PTEMARB and BAEMARB variable emissions files were tested
c        and warnings were written to the list file whenever a source
c        was off of the grid.  Now, all sources must be on the grid, or
c        the run is halted.
c        Modified:  POINTS2, AREAS2
c    (4) Set search radius for nearest land and water cells used in the
c        subgrid TIBL module from control file input (NLUTIBL)
c        Modified:  COMPARM.PUF
c                   BLOCK DATA, READCF, QAINP, TIBLSET
c
c --- Version 6.23, Level 080204 to Version 6.24, Level 080208
c
c    (1) Introduce control file switch MPARTLBA to toggle application
c        of the partial penetration option MPARTL to buoyant area
c        sources. This allows these sources to be modeled without
c        partial penetration as was done in the concurrent version 5
c        code.
c        Modified:  FLAGS.PUF
c                   BLOCK DATA, READCF, QAINP, AREAS2
c    (2) Add check to use the stored value of the emission period
c        sampling step duration rather than the computed step when
c        these two times are equal to within the precision of stored
c        real numbers.  This allows hourly variable emissions files to
c        be modeled the same way as the concurrent version 5 code.
c        Modified:  VARSAM
c    (3) Compute wind speed for call to VARSAM using the same methods
c        as in the puff-generating subroutines:  MAX of the release-ht
c        and effective-height winds.
c        Modified:  COMP
c
c --- Version 6.22, Level 070921 to Version 6.23, Level 080204
c
c    (1) Refine mixing height adjustment of the top of the layer
c        containing a target height in PUFFDZ so that the layer-top
c        returned is always greater than the target height.
c        Add checks for a layer top less than a layer bottom to routines
c        that define or use layer interfaces to obtain mean winds.
c        Modified:  PUFFDZ, ADVECT
c    (2) Trap case of falling puff in the RISEWIND procedure because it
c        may lead to the 'bottom' of the layer exceeding the 'top' of
c        the layer used to obtain the mean advection during rise.
c        Modified:  RISEWIND
c    (3) RISEWIND samples winds across the current gradual rise path
c        via calls to GRISE.  However, GRISE does not include stack-tip
c        downwash and RISEWIND does not apply it either.  Add the tip
c        downwash adjustment to GRISE and remove the adjustment
c        elsewhere.
c        Modified:  GRISE, PUFRECS, SLGRECS, PLGRECS, ZTRACE
c
c --- Version 6.21, Level 070801 to Version 6.22, Level 070921
c
c    (1) When performing cavity sampling for PRIME downwash, restrict
c        primary source calculations to receptors downwind of primary
c        source and add screen for receptors located far to the side
c        (no impact).  Without this restriction, the model may halt with
c        an attempted division by zero.  Receptors upwind of the source
c        are processed for cavity impacts starting with Version 5.8,
c        Level 070629.  Remove unused CAV_SRC.
c        Modified:  CAV_SAMP
c    (2) Add source tabulations stored for previous met periods, and
c        introduce dataset name and version record to RESTART file.
c        This currently applies only to line sources, which use rise
c        tables for the current and previous met periods (MXMETSAV=2).
c        Without the table for the previous met period in a restart
c        file, table values starting as zero may be accessed and
c        halt the run with a divide-by-zero.
c        Enforce MXMETSAV=2 as LN1 and LN2 arrays are explicitly
c        dimensioned to 2, and add checks for the met period pointer
c        to trap IMET<1 (should never happen).
c        New:       RESTARTHD.PUF
c        Modified:  RESTARTQ, RESTARTI, RESTARTO
c                   INITPUF
c                   COMP, SETPUF, PUFRECS, GRISE
c    (3) Fix bug in LN2SWAP argument list that reversed the input and
c        output index pointers (created problem only for variable line
c        sources with more than 1 emission step per model timestep).
c        Fix bug in RDEM2 argument list that used the undefined variable
c        name NSRC2 instead of NPT2.  This is used to declare arrays
c        that are passed through RDEM2, but this bug does not affect
c        reading data correctly in RDEM2.
c        Modified:  INITPUF
c    (4) Fix bug in wet flux calculation for sampling puffs (not slugs).
c        The horizontal sampling factors were calculated only if puff
c        mass diffused to the surface producing non-zero concentrations.
c        These factors are needed for the wet fluxes due to elevated
c        puffs as well.  Wet removal mass depletion calculations are
c        correct, as are wet fluxes at receptors with non-zero
c        concentration.
c        Modified:  CALCPF
c    (5) Condition strings of geo-reference data read from headers of
c        ASCII input data files to remove format errors.
c        New:       GEOFMT
c        Modified:  RDHDAQ, RDHDEM2/3/4/5
c    (6) Impose explicit upper limit (MXSAM) on number of sampling steps
c        for variable emissions sources.  Without this clamp, number of
c        sampling steps for each puff emitted can exceed the limit
c        imposed on constant sources described within the control file,
c        as these may be limited by MXSAM.  This change is made to
c        promote consistency between constant (control file) sources
c        and nearly constant variable sources.
c        Modified:  VARSAM, COMP
c    (7) Volume sources with variable emissions file:  Revise MVOLUME
c        if-loop error traps and set TMTOTB variable needed in VARSAM
c        to properly compute the number of sampling steps to take in
c        the portion of the timestep after a puff is released.  TMTOTB
c        had been initialized to zero, which resulted in new puffs
c        moving only the emission timestep during the first time step.
c        Modified:  VOLS
c    (8) Add check for ATAN2(0.0,0.0) in FOGREC, as function will halt
c        execution if both arguments are zero.  This behavior changed
c        between F77 and F95 compilations.
c        Modified:  FOGREC
c    (9) Replace intrinsic function AMIN0() with MIN() when both result
c        and arguments are integers (no change in results)
c        Modified:  POINTS2, AREAS2, LINES2, VOLS
c   (10) Fix several undefined variable bugs that do not affect results:
c        - Call to RDEM5 from RDEMSRC uses LPRT in place of LDB
c        - PROBLEM variable initialized to false in LN2FILL
c        - Calm logical is not set in call to VCBAR from DRY, so
c          a frozen puff treatment for dry depletion in calms is
c          never triggered.  This would have made a single calculation
c          of the vertical distribution at the middle of the step in
c          place of 3 calculations during a step.  Logical is explicitly
c          set to false to ensure current 3-step calculation is always
c          done.
c        - Initialize ISTA=ILQ=IPRECIP=0 in WET for debug output
c          (they may not be computed)
c        - Change J to I in debug output in VOLS, AREAS1/2
c        - Initialize INDEX=0 in POINTS1/2 for debug output
c        - Initialize DUMMY=0.0 in RDTIEM3
c        Modified:  RDEMSRC, LN2FILL, RDTIEM3
c                   DRY, VCBAR, WET,
c                   VOLS, POINTS1/2, AREAS1/2
c   (11) COORDLIB from v1.98 Level 060911 to v1.99 Level 070921
c        - Conversion of point in S. hemisphere to UTM-N returned coord.
c          as UTM-S instead, for conversions from all map projections
c          except lat/lon.
c        - Initialization of a few work arrays were missing.  These have
c          no effect on results.
c        Modified:  COORDS
c
c --- Version 6.2, Level 070629 to Version 6.21, Level 070801
c
c    (1) Add cap on sigma-z to avoid a floating-point error when
c        computing virtuals.  Default cap is 5e06 m (5000km), which is
c        expected to have no influence on normal concentrations.
c        Modified:  COMPARM.PUF
c                   BLOCK DATA, READCF, COMP
c    (2) Relax requirement that the input restart file be from the same
c        version and level of the code to a WARNING.
c        Modified:  RESTARTQ
c
c --- Version 6.116, Level 070404 to Version 6.2, Level 070629
c
c    (1) Add (MREG) regulatory constraint that overwater and over land
c        minimum sigma-v values must be 0.5 m/s
c        Modified:  QAINP
c    (2) Always write the control file variables to the list file to
c        confirm values used
c        Modified:  READCF
c    (3) Address problem in PRIME downwash when a cavity source puff
c        reaches a "calm" zone in the wake region.  Downwash algorithms
c        were turned off once such a puff was sampled at a receptor.
c        This should be done as soon as such a puff is advected into a
c        calm region so that the puff growth and trajectory remain
c        independent of the sampling receptors.  Move the re-assignment
c        from PUFRECS/SLGRECS to SETPUF/SETSLG.
c        Modified:  SETPUF, SETSLG, PUFRECS, SLGRECS
c    (4) Pass CALM processing result (LCALM) from SETPUF/SETSLG for use
c        later in calls to PUFRECS/SLGRECS.  Previously determined CALM
c        setting was made at the start of a sampling sub-step and may
c        not be current.
c        Modified:  COMP, SETPUF, SETSLG
c    (5) Puff virtual times at the time of release obtained for
c        PRIME downwash during very strong wind speed shear in the
c        vertical can lead to much larger or much smaller sigmas than
c        those tabulated within the wake zone, if time-based disperision
c        rates are selected.  Although the tabulated PRIME sigmas are
c        used for concentrations at receptors in the wake zone, the
c        lateral sampling screen uses the virtual-time sigmas.  This can
c        lead to screening out receptors in the wake zone that should be
c        sampled.  Assign sigmas to the puff in the wake zone from the
c        PRIME sigma tables, and compute the corresponding virtual times.
c        Modified:  SETPUF
c    (6) Initialize the following variables (results are not affected
c        but execution may halt with some compilers)
c          IGRDVL = 0  (READCF)
c          HB, HW, HEFF2, ZLY, RINIT = 0. (POINTS1, POINTS2)
c          YKDUM, SYDUM, ZKDUM, SZDUM = 0.0 (WAKE_DFSN)
c          DBDUW = 0.0  (WAKE_DBG)
c          XMAX, FZMAX = 0.0 (WAKE_FQC)
c          DZDS=0.0 (NUMRISE)
c        Modified:  READCF, POINTS1, POINTS2, WAKE_DFSN, WAKE_DBG,
c                   WAKE_FQC, NUMRISE
c    (7) Assign PTGRAD value to default so it is always available for
c        debug output even when not used (does not change results)
c        Modified:  NUMMET
c    (8) Typo in argument IRU (0=rural, 1=urban) in call to WAKE_INI
c        results in rural dispersion curves in PRIME calculations when
c        making the wake-zone sigma tables (PG dispersion option) if
c        the compiler initializes variables to zero.  Without such
c        initialization, run may halt with invalid IRU value.
c        Modified:  POINTS1, POINTS2
c    (9) Local receptor height ZRC for PRIME cavity-source impact was
c        not set in the wake downwind of the cavity.  Applications that
c        place receptors on the ground are not affected because ZRC is
c        always zero.  (ZRC is set to zero for receptors in the cavity,
c        and it is set to the receptor elevation above the top of the
c        cavity for any receptors placed above a cavity.)  Initialize
c        ZRC to the actual receptor height above the ground.
c        Modified:  CAV_SAMP
c   (10) Cavity concentrations were not computed at receptors in cavity
c        if they were upwind of the source.  Logic updated to account
c        for mass recirculating in cavity.
c        Modified:  CAV_CONC
c   (11) PRIME cavity concentrations are calculated but not reported due
c        to array initializations introduced for the source contribution 
c        option in V5.72.  The cavity concentrations are now placed in
c        the TOTAL concentration arrays which are not zeroed in the
c        source loop, and the source contribution output option is not
c        allowed with the PRIME downwash option.
c        Modified:  QAINP, COMP, CAV_CONC
c   (12) RDHDAQ Typos: call to YR4 for Ozone dataset version 1.5a left
c        header years undefined (or zero);  call to RDHDAQ from CHEMI
c        used LPRT instead of LDB, so header info was not written
c        Modified:  CHEMI, RDHDAQ
c   (13) Recast SMXI2 in calculation of NSAM to match numerical
c        represention obtained in Version 5
c        Modified:  COMP
c
c --- Version 6.115, Level 061020 to Version 6.116, Level 070404
c
c    (1) Modify test of header of restart file to read just the first 
c        variable.  This avoids the possibility of attempting to read
c        past the end of the first record, causing the program to halt.
c        Modified:  FILVERS
c    (2) CALUTILS from v2.54 Level 061020 to v2.55 Level 070327
c        Fixed format bug in subroutine BASRUTC for the case of
c        time zone zero (output string was 'UTC+0  0' instead of
c        'UTC+0000'
c        Modified:  UTCBASR, BASRUTC
c    (3) COORDLIB from v1.97 Level 060626 to v1.98 Level 060911
c        Changes in COORDS that allow a higher level of FORTRAN error
c        checking.  Compiler checks had identified constant arguments
c        and 2 uninitialized variables.  None of these is known to
c        have produced errors in cooerdinate conversions.
c        Modified:  COORDS
c
c --- Version 6.114, Level 060725 to Version 6.115, Level 061020
c
c    (1) Screen discrete receptors for any locations that are not 
c        within the computational grid
c        Modified:  QAINP
c    (2) CALUTILS from v2.52 Level 060519 to v2.54 Level 061020
c        Move GLOBE1 to COORDLIB;
c        Allow negative increments in INCRS
c        Modified:  INCRS
c        Removed:   GLOBE1
c    (3) COORDLIB from v1.95 Level 050126 to v1.97 Level 060626
c        Add Albers Conical Equal Area projection
c        Add GLOBE1 (from CALUTILS)
c
c --- Version 6.113, Level 060519 to Version 6.114, Level 060725
c
c    (1) Restart file option fails due to typo in naming variables and
c        also assigning old value of data format flag MTVER.
c        These changes were identified by: Peter D’Abreton
c        Modified:  RESTARTI
c    (2) Fix PTLAPS case where upper height of layer for extracting
c        the potential temperature gradient exceeds the middle of the 
c        top layer of the model (search index was not assigned in this
c        case which leads to an invalid array index)
c        Contributed by:  Bart Brashers, Geomatrix Consultants
c        Modified:  PTLAPS
c    (3) Ozone.dat dataset version 2.1 header is processed for LL, LCC,
c        and UTM map projections, but not others.  Add PS,EM,LAZA,TTM.
c        Modified:  RDHDAQ
c
c --- Version 6.112, Level 060412 to Version 6.113, Level 060519
c
c    (1) CALUTILS from v2.51 Level 051019 to v2.52 Level 060519
c        Variable names in control file are not processed correctly
c        if there are too many characters (including blanks) to the
c        left of the "=" sign (run stops in setup phase).
c        Modified:  READIN
c
c --- Version 6.111, Level 060329 to Version 6.112, Level 060412
c
c    (1) Remove check on time in METQA that improperly stopped run
c        with multiple CALMET files, and add screen message to
c        time-check in RDMET
c        Modified:  METQA, RDMET
c
c --- Version 6.11, Level 060309 to Version 6.111, Level 060329
c
c    (1) Revise text for last period time
c
c --- Version 6.102, Level 051130 to Version 6.11, Level 060309
c
c    (1) COORDLIB from v1.95 Level 050126 to v1.96 Level 051010
c    (2) CALUTILS from v2.5 Level 041123 to v2.51 Level 051019
c    (3) Filnames changed from c*70 to c*132 (for CALUTILS V2.3
c        and later)
c        Modified:  FILNAM.PUF
c                   READFN, WRFILES, FILVERS, OPENAB
c    (4) Changed LDBG to .FALSE. to remove debug output to list file
c        when SLUG option is used
c        Modified:  RECSPEC0
c    (5) Correct bugs in QAINP that did not properly identify the EPA
c        guidance selections when checking user inputs:
c         -- Allow either CALMET or ISCMET (METFM=1,2)
c         -- Allow either MESOPUFF II of RIVAD chemistry (MCHEM=1,3)
c         -- Allow either PG or turbulence-based dispersion (MDISP=2,3)
c         -- Require PDF option with turbulence-based dispersion
c        Modified: QAINP
c    (6) Screen call to TIBLGRO using heat flux at start of step, as
c        calculated from u-star and M-O length, to conform to what is
c        done within TIBLGRO.  The heat flux had been computed for the
c        mid-point of the step, which can lead to a run-time error.
c        Test for small/negative heat flux during step in TIBLGRO.
c        Modified: COMP, TIBLGRO
c    (7) Add minimum Sigma-v and Sigma-w inputs for overwater cells as
c        distinct from the inputs for overland cells
c        Modified: COMPARM.PUF
c                  BLOCK DATA, READCF, QAINP, COMP, RLSMET, TURBSET
c
c
c --- Version 6.101, Level 051020 to Version 6.102, Level 051130
c
c    (1) Revise header information for Air Quality files (e.g., 
c        OZONE.DAT) that have coordinates specified in Lat/Lon to
c        remove the LLORDER string.  These files require the order
c        to be (lat,lon), and values include N/S or E/W explicitly
c        so that the model will stop with an error message if the
c        order is not correct.  Also, fix bug in reading the UTM zone
c        and hemispere.
c        Modified: RDHDAQ, RDTIAQ, CHEMI
c
c    (2) Add QA plot output files for OZONE and H2O2 stations
c        Modified: QAPLOT1
c
c --- Version 6.1, Level 050915 to Version 6.101, Level 051020
c
c    (1) Fix bug in skipping LNEMARB header records, and in assigning
c        current emissions time to buoyant line source arrays
c        Modified: SKIPHDEM5, INITPUF
c
c    (2) Modify WET to output XLAM as the scavenging RATIO rather
c        than the scavenging COEFFICIENT.  This bug caused all non-zero
c        wet fluxes for SLUGs to be based on a 1 mm/hr precipitation
c        rate.  Concentrations and dry fluxes are not affected.  This
c        bug does not affect any PUFF results.
c        Modified: WET
c
c --- Version 5.751, Level 050805 to Version 6.1, Level 050915
c
c    (1) Update date-time used throughout code to reference time
c        intervals by begin-time / end-time pairs in place of just
c        the end-time, and include seconds
c
c    (2) Update variable point and area emissions files to allow
c        variations down to the second (old file formats supported)
c
c    (3) Update variable line and volume emissions files to allow
c        variations down to the second (old file formats supported)
c
c    (4) Update met data files to allow update steps as short as 1
c        second (chemistry time-of-day functions are not updated)
c
c ?? (5) Add emissivity for numerical rise (EPSRAD) to control file
c
c    (6) Add emission-step index to puff arrays in /PUFF/
c        Modified: PUFF.PUF
c                  SWAP, RESTARTI, RESTARTO
c
c    (7) Force the output averaging period to be the model timestep
c        period (source contribution loop structure precludes averaging
c        across timesteps) --- STOP run if the timestep exceeds the
c        meteorological update step.
c
c --- Version 5.75, Level 050225 to Version 5.751, Level 050805
c
c    (1) Add check in trajectory/coastline intercept (onshore flow)
c        calculation for parallel lines (equal slope).  The vector
c        cross-product (previous check) should be zero when the slopes
c        are equal, but precision can lead to a slightly positive
c        cross-product.  Identical slopes produces divide-by-zero.
c        Modified: TIBLON
c
c    (2) Place water cell mixing height (not ht0) into TIBL array
c        locations upwind of the coast, and use land cell pointer in
c        call to TIBLGRO so that shore properties are consistent with
c        coastline as puff crosses coast
c        Modified: TIBLGRO, TIBLON, COMP
c
c    (3) Add turbulence advection option for including advection
c        effects with decay to modify the local sigma-v and sigma-w
c        for puff growth (MDISP=2) --- Draft implementation for
c        testing
c        Modified: FLAGS.PUF
c                  TURBSET, COMP, RLSMET, READCF, BLOCK DATA
c
c --- Version 5.741, Level 040913 to Version 5.75, Level 050225
c
c    (1) Add building downwash adjustment for elevated (platform)
c        structures with an open area between the surface and the bulk
c        of the structures.  Currently implemented for ISC downwash
c        method (MBDW = 1).
c        Modified: PT1.PUF, PT2.PUF
c                  BLOCK DATA, SETUP, READCF, QAINP, RDTIEM2, COMP
c                  POINTS1, POINTS2, DWSIGS, PUFRECS, SLGRECS, PLGRECS
c
c    (2) Add option for computing turbulence profiles using the AERMOD
c        subroutines.
c        Modified: FLAGS.PUF
c                  BLOCK DATA, READCF, QAINP, TURBSET, COMP, RLSMET
c        New:      AERSWV
c        AERMOD:   REFSV, REFSVC, REFSVM, REFWV, REFSWC, REFSWM, GINTRP
c
c    (3) Add Lagrangian timescale option for lateral growth when
c        dispersion options MDISP=1,2 or MDISP2=1,2 are used.
c        1/Fy = 1 + 0.9 SQRT(t/1.62T)
c        [DIAGNOSTIC FEATURE]
c        Option choices are:
c          - Draxler default 617.284 (s)
c          - Computed as Length Scale / (.75 q) -- after SCIPUFF
c          - Direct user input (s)
c        Modified: FLAGS.PUF
c                  BLOCK DATA, READCF, QAINP, SETCSIG, COMP
c                  PUFRECS, SLGRECS, PLGRECS, SETPUF, SETSLG
c                  CALCPF, CALCSL, PLMFOG
c                  POINTS1, POINTS2, LINES1, LINES2
c        New:      TAULY (called from SETCSIG)
c
c
c    (4) Change the control parameter MGRAV to MTILT, and augment the
c        "tilted plume" calulations by:
c        - increasing the ratio of sigma-z to zmix at which the 
c          well-mixed puff flag is set (subr. VMASS)
c
c  Additional modifications implemented in Version 5.75, Level 050225
c                    from Version 5.722, Level 040610 
c                    to   Version 5.727, Level 050309 
c
c
c    (1) Drop the requirement that the UTM zone in the OZONE.DAT file
c        matches the UTM zone in the CALPUFF control file when the UTM
c        projection is NOT used.  Instead, require that the zone be
c        zero in the header of OZONE.DAT (when present).
c        Modified: CHEMI
c
c    (2) Replace restriction that Boundary Condition (BC) segments must
c        match the computational grid cell size with a warning that
c        they do not match, and allow the BC segments to be larger than
c        the grid cell size (but not smaller).
c        Modified: RDHDBC
c
c    (3) Fix bug in GRISE associated with the rise factor for the PRIME
c        module.  The rise factor used to adjust the buoyancy-induced
c        dispersion from that at final rise to that at a gradual rise
c        height should exclude streamline deflections induced by the
c        building.  The gradual rise (without streamline deflection) was
c        divided by the final rise (with streamline deflection).  This
c        may cause any buoyancy-induced dispersion to be overestimated
c        in the gradual rise region, when using the PRIME option,
c        leading to larger puff sigmas.  Receptors located beyond the
c        distance to final rise are not affected.
c        Modified: GRISE
c
c    (4) Fix bug in PUFRECS that did not update the rise factor when the
c        PRIME wake tables are used to obtain receptor-specific sigmas.
c        The rise factor is used after the PUFRECS call to adjust
c        the sigmas for the PDF option.  This may cause a runtime
c        error that halts an application.  Concentrations are affected
c        at receptors withing a building wake during daytime periods
c        only if both the PRIME and PDF options are used.
c        Modified: PUFRECS
c
c    (5) COORDLIB updated to stop UTM conversions with a DATUM that is
c        not mapped to the list in the USGS UTM subroutine.  An example
c        is the sphere datum NWS-84 (Earth radius 6370km), since only
c        the sphere datum ESR-S (Earth radius 6371km) is available.
c        Unmapped datums had defaulted to the Clarke 1866 spheroid.
c        LAZA Projection:  removed assignment of 6370 km earth
c        radius (NWS-84 datum) when a value less than 6000 km is
c        found.  This assignment can override a requested radius
c        of 6371 (ESR-S datum) if the NWS-84 datum is used with
c        any valid projection prior to the request for ESR-S.
c        LAZA(NWS-84) coordinate distances from the projection
c        origin are about 0.016% smaller than LAZA(ESR-S).
c        Error message and version strings added to COORDS calls
c        and new subroutine COORDSVER to report COORDS version
c        documentation.
c        (Version 1.95, Level 050126)
c        COORDLIB updated to fix UTM conversion in the S.
c        hemisphere when the ouput UTM zone is forced as N. 
c        hemisphere, and the DATUM changes (completes changes
c        started in version 1.93).
c        (Version: 1.94, Level: 041007)
c
c    (6) Added call to COORDSVER to access the COORDS version info and
c        passed string to list file and comment section of output files.
c        Modified: READCF, WROUT1
c
c    (7) LUSE.CLR color scale file modified to better distinguish
c        wetlands, and a RED strip is added at the top of the bar for
c        a marker LU of 99.
c        Modified: QAPLOT1
c
c    (8) Added new files TK2D.DAT and RHO2D.DAT along with the output
c        control variables IT2D and IRHO respectively.  This complements
c        the VISB.DAT output file of 2D Relative Humidity
c        fields with the corresponding 2D Temperature and Density fields
c        written in the same file format.
c        Modified: FILNAM.PUF, OUTPT.PUF
c                  BLOCK DATA, READFN, READCF, WRFILES, OPENOT,
c                  WROUT1, OUTPUT
c
c    (9) Fix number of arguments in call to LN2FILL from RDEMSRC.  The
c        last argument PROBLEM had been omitted.
c        Modified: RDEMSRC
c
c   (10) Initialize first element of MXNW numerical rise arrays to stack
c        conditions to avoid problems with an old NN index being used.
c        This could affect buoyant area sources and point sources with
c        the PRIME downwash option when these sources are non-buoyant
c        and are given very small (but non-zero) exit velocity.
c        Modified: NUMRISE
c
c   (11) Add test for a zero lofting rise in PDFPATH to avoid potential
c        attempt to divide by zero.
c        Modified: PDFPATH
c                    
c   (12) Change the GRD file format for SURFER Image files (QALUSE.GRD)
c        This applies to GRD files that are plotted as image maps (not
c        contours) -- Landuse.  SURFER 7 required a range
c        adjustment to properly register the grid cell blocks that
c        make up the image.  SURFER 8 registers cells properly without
c        the adjustment, so the standard GRD works for both image and
c        contour maps.  The revised output follows the SURFER 8
c        convention in which all GRD files are alike.
c        (We presume that the SURFER 7 format will seldom be needed.)
c        Modified: QAPLOT1
c
c   (13) Enlarge output format for the QATERR.DAT plot-file to allow
c        terrain heights below sea level (subroutine QAPLOT1).
c
c --- Version 5.74, Level 040715 to Version 5.741, Level 040913
c
c    (1) Fix bug in XERFDIF that produced an error in integral F1.
c        The F1 integral in the analytic sampling done for attached
c        slugs is not coded correctly.  F1 is used only for slugs as
c        they are being emitted (youngest end is at the source), and 
c        is multiplied by the change in effective emission rate during 
c        the sampling step (due to chemical transformation or
c        deposition removal).
c
c    (2) Add stop in QAINP if DATUM in control file is UNKNOWN
c
c    (3) COORDLIB updated to respond to UTM conversion across the
c        equator from S. hemisphere to N. hemisphere, when the S.
c        hemisphere zone is forced.  Also fixed a problem with the
c        conversion to/from spherical NWS-84 datum when using UTM
c        projection (USGS program input array conflicts).
c        (Version: 1.93, Level: 040713)
c
c    (4) Add puff-age cutoff control MXAGEHR (hours) in Group 12.
c        Puffs older than MXAGEHR (>0) are de-activated.
c        Feature typically NOT appropriate for Regulatory applications!
c        Modified COMPARM.PUF
c                 BLOCK DATA, READCF, QAINP, COMP
c
c    (5) Change the control parameter MGRAV to MTILT, and augment the
c        "tilted plume" calulations by:
c        - increasing the ratio of sigma-z to zmix at which the 
c          well-mixed puff flag is set (subr. VMASS)
c
c --- Version 5.73, Level 040611 to Version 5.74, Level 040715
c
c    (1) Add AERMET version of SURFACE and PROFILE met data files
c        Modified FLAGS.PUF, GEN.PUF
c                 BlockData, READCF, QAINP, COMP, ADVECT, WINDSET,
c                 POINTS1, POINTS2, LINES1, LINES2, AREAS2, NUMPR1,
c                 NUMMET, WRFILES, SETUP, OPENOT, PTLAPS
c        New      RDMET5, RDPROF5
c                 
c
c --- Version 5.722, Level 040610 to Version 5.73, Level 040611
c
c    (1) Add gravitational settling (plume-tilt) option to allow
c        puffs with 1 particle species to fall at the gravitational
c        settling velocity for that species.  Restrictions:
c        - MGRAV = 1  Turns option on (new variable)
c        - NSPEC = 1  (must be particle species as well)
c        - sg    = 0  GEOMETRIC STANDARD DEVIATION in Group 8 is
c                     set to zero to make single particle diameter
c        - MCTADJ= 0,1,3  (Interaction with option 2 not supported)
c        Modified FLAGS.PUF, CURRENT.PUF
c                 BLOCK DATA, READCF, QAINP, VCBAR
c                 SETPUF, PUFRECS, SETSLG, SLGRECS, RECSPEC0
c
c    (2) Change number of particle sizes name from NINT to NPSINT to
c        avoid overlap with function NINT.
c        Modified DRYPART.PUF, BLOCK DATA, READCF, 
c                 DRYI, VDP, VDP1, VDCOMP
c
c --- Version 5.721, Level 040503 to Version 5.722, Level 040610
c
c    (1) Fix array assignments in RESTART subroutines by using the
c        /puff/ and /slug/ include files.  Restart option
c        did not work in V5.72+ (QA stopped run).
c
c --- Version 5.72, Level 031017 to Version 5.721, Level 040503
c
c    (1) VERY small negative virtual time/distance is reset to ZERO
c        in SIGTY and SIGTZ (PRIME module)
c
c    (2) Added list-file report of largest (most) negative 
c        increments encountered in SIGTY.  New routine WARN added.
c        Modified SIGTY, FIN
c
c    (3) COORDLIB updated to respond to projection parameter
c        changes when both the projection type and datum do not change
c        (Version: 1.92, Level: 031201)
c
c    (4) Fix array declaration in CALCSL:  species mass array for wet
c        deposition declared using mxspec (had been declared nspec).
c        This bug causes erroneous wet fluxes to be output from
c        slug sampling.  Total mass of each species in slugs is not
c        affected.
c
c    (5) File unit passed to subroutine YR4 for listfile output was
c        not defined so that error reports attempted to write to 
c        unit 0.  Changed io1 to io6 in call to YR4 from subroutines
c        RDHDBC2 and GETRCRD.
c
c    (6) Function XVZ altered to improve single precision accuracy
c        of solution for stability classes A and B
c        (NOT connected, revision is called XVZ2)
c
c --- Version 5.713, Level 030905 to Version 5.72, Level 031017
c
c    (1) Fix QA output file for gridded receptors (QARECG.DAT)
c        [incorrect terrain elevations reported]
c        and add control file switch to disable QAPLOT feature
c          - CALPUFF.INP, OUTPT.PUF, BLOCK DATA, READCF, SETUP
c
c    (2) Replace the puff ID (ppptssss) with individual integer arrays
c        to allow for more puffs/source and more sources: IRLSNUM,
c        ISRCNUM, and ISRCTYP repace IPUFID.
c          - PUFF.PUF, COMP, SWAP, RESTARTI, RESTARTO, SPLIT,
c            POINTS1, POINTS2, AREAS1, AREAS2, VOLS,
c            LINES1, LINES2, BCS1, ZTRACE
c
c    (3) Add source contribution output feature.  Output data file
c        format is revised (version 2.1).
c          - CALPUFF.INP, FLAGS.PUF, PARAMS.PUF, CHIFLX.PUF,
c            PT1.PUF, AR1.PUF, LN1.PUF, VOL1.PUF
c          - BLOCK DATA, READCF, QAINP, SETUP, COMP, OPENOT,
c            OUTPUT, WROUT1
c          - RDEMSRC, TCHIFLX
c
c    (4) Change control file source names from character*12 to
c        character*16 to match string length used in variable emission
c        files.
c
c    (5) WGS-72 DATUM bug for UTM calls fixed in COORDLIB
c        (Version: 1.91, Level: 031017) 
c
c --- Version 5.712, Level 030822 to Version 5.713, Level 030905
c
c    (1) DATUMs updated in COORDLIB (Version: 1.9, Level: 030905)
c    (2) Default DATUMs reset
c
c --- Version 5.711, Level 030625 to Version 5.712, Level 030822
c
c    (1) Address PRIME module bug that produced a negative virtual
c        travel time increment due to numerical precision (seen when
c        using turbulence-based sigma option with PRIME downwash)
c        Modified:  WAKE_DFSN
c
c --- Version 5.71, Level 030528 to Version 5.711, Level 030625
c
c    (1) Address TIBL module bug that left cell index (i,j) undefined
c        Modified:  TIBLGRO
c
c --- Version 5.7, Level 030402 to Version 5.71, Level 030528
c
c    (1) Assign inputs for LCC projection to internal variables used
c        in QA checks
c
c    (2) Remove old UTM zone check in METQA that does not screen out
c        PMAP.NE.UTM cases
c
c    (3) Add MBCON=2 option to read a CONC.DAT file from another
c        CALPUFF run and use receptor concentrations as boundary
c        condition
c        New:       HEADBC2.PUF
c                   RDHDBC2, BC2DOC, RDEMBC2, GETRCRD, UNCOMPRS
c        Modified:  BCS.PUF, FLAGS.PUF
c                   SETUP, OPENOT, RDHDBC, INITPUF
c
c    (4) Fix xmesh,ymesh definition for computing MBCON=1 segment
c        grid coordinates (mesh becomes 1/mesh)
c
c    (5) Add Input Group 12 variables for MBCON option to configure
c        the BC puff depth, the search radius for identifying BC
c        impacts, and a switch to control the near-surface depletion
c        adjustment for the BC puffs.
c        Modified:  BCS.PUF
c                   READCF, BLOCK DATA, BCS1, CALCBC, COMP,
c                   RDHDBC, RDHDBC2
c
c    (6) Add QA checks for MBCON configuration and write QA ALERT
c        notice to screen (QAINP); require that species 'BCON' be
c        modeled when MBCON > 0.  Boundary puffs will be emitted
c        with non-zero mass of BCON to model clean air the same way
c        as polluted air.
c
c    (7) Update COORDLIB (Version: 1.15  Level: 030528)
c        Update CALUTILS (Version: 2.2  Level: 030528)
c
c    (8) Modify use of MAX function in WAKE_FQC and args of MIN in
c        NUMRISE to conform to compiler type rules
c
c    (9) Trap zero bldg length with MBDW=2 (PRIME) in READCF
c
c   (10) Require non-negative emissions in READCF, INITPUF, LN2FIL
c
c   (11) Add RESTART notice to list file each time a restart file
c        is rewritten (RESTARTO)
c 
c --- Version 5.5, Level 010730_1 to Version 5.7, Level 030402
c
c    (1) Accommodate the CALMET no-observation mode, 
c        [Originally denoted as Ver 5.5  Level 010901]  (FRR)
c        Changes to:
c        - COMP, RDMET, EXMET, SUNDATA, GETPRFM, WET
c          AREAS1, VOLS, POINTS1, POINTS2, LINES1, NUMMET, TIBLON
c          TIBLGRO, BCS1, FOGOUT, OUTPUT, WROUT1
c        - METHD (new i2dmet) and METHR (2D arrays)
c        - New subroutine METLATLON: computes latitude and longitude
c          of all CALMET gridpoints
c
c    (2) Updated on 03/31/02  to fix bug in WRDAT
c
c    (3) Added i2dmet in header record for all types of output, 
c        subroutine WROUT1.  
c        [Originally denoted as Ver 5.5  Level 021028]  (FRR)
c
c    (4) Bug fix in RDMET (ipcode2d data was not read when npsta=-1)
c        [Originally denoted as Ver 5.5  Level 030119]  (FRR)
c
c    (5) Accept revised CALMET.DAT 2.0 header format
c
c    (6) Implement CALUTILS packaging (Version: 2.1  Level: 030402)
c
c    (7) Implement the full map projection/datum transformation
c        routines using COORDLIB (Version: 1.14  Level: 030402)
c
c    (8) Move Y2K processing of system date into subroutine DATETM
c        and change rdate from (MM-DD-YY) to (MM-DD-YYYY)
c
c    (9) Change UNDER0 call to generic UNDRFLW, and place compiler-
c        specific implementation routines there
c
c   (10) Alter format of QA plot-file header for SURFER 'bug'
c
c   (11) Screen output from VCOUP with sigma_z ~ '0'
c
c   (12) Dataset version 2.0 header format implemented for output
c        data files with control file images, and /MAP/ variables
c
c   (13) Replace OPENAB with explicit ASCII/BINARY option
c        (Set to ASCII for now --- PTEMARB and VOLEMARB only!)
c
c   (14) Add PRIME downwash modules.
c        Modified: NUMPARM.PUF, PT1.PUF, PT2.PUF, FLAGS.PUF, COMPARM.PUF
c                  BLOCK DATA, SETUP, READCF, RDTIEM2, NUMMET, NUMRISE,
c                  POINTS1, POINTS2, GRISE, PUFRECS, SETPUF,
c                  COMP, CALCPF, PLMFOG
c        New:      WAKEDFSN.PUF, WAKEDAT.PUF,
c                  WAKE_CAV0, WAKE_DBG, WAKE_DFSN, WAKE_DIM, WAKE_DRDX,
c                  WAKE_FQC, WAKE_FIN, WAKE_INI, WAKE_SCALES,WAKE-SIGA,
c                  WAKE_SIG, WAKE_TURB, WAKE_U, WAKE_XA, WAKE_XSIG,
c                  CAVITY_HT, CAV_SRC, CAV_CONC CAV_SAMP, FRGAUSS,
c                  NUMGRAD, POSITION, ZSTREAM, INTERTAB, WAKE_TAB
c
c   (15) Add IMET and MXMETSAV to manage source tabulations such as
c        plume rise that are saved over multiple met periods
c        (current.puf, params.puf)
c
c   (16) Set the time to Heffter transition (sigma-y) within SETCSIG
c
c   (17) Revise lower threshold for computing a virtual time/distance
c        from szmin,symin to 0.001m in SIGTY and SIGTZ
c
c   (18) Revise default plume rise-angle criterion for wake effects
c        from 45 degrees to 20 degrees
c
c
c --- Version 5.5, Level 010730 to Version 5.5, Level 010730_1
c
c    (1) Remove conditioning of initial sigmas for control file
c        point sources so that a zero is not reset to symin or
c        szmin (READCF)
c
c --- Version 5.4, Level 000602_8 to Version 5.5, Level 010730
c
c    (1) Add IWAT2 to list file output in subr. MET1.
c
c    (2) Revise treatment of sigmas at receptors in the building
c        downwash zone of point sources to properly account for
c        initial sigmas at the source.  The changes made in Version 5.4,
c        Level 000602_2, introduced a sigma that already contained the
c        downwash contribution, resulting in overprediction of the
c        sigmas in the wake (which will typically increase ground-level
c        concentrations in the wake).
c
c    (3) Revise wind-direction-specific building information selection
c        to match that used in ISCST3 (treatment of directions that lie
c        on sector boundaries.)
c
c --- Version 5.4, Level 000602_7 to Version 5.4, Level 000602_8
c
c    (1) Fix declaration of character*16 variables in /AR2/, /PT2/,
c        and /VOL2/ ('include' files -- no change to CALPUFF.FOR).
c
c    (2) Add constraint that buoyancy flux (FLUXB) be greater than zero
c        to conditions that must be met for calling partial penetration
c        subroutine (PRFPP) in subroutine POINTS2, which processes the
c        PTEMARB source data file.  This condition was already used
c        in subroutine POINTS1 (control file source data).  A run-time
c        divide-by-zero error stops CALPUFF if PRFPP is called with
c        FLUXB=0.0 (emission temperature LE ambient temperature).
c
c --- Version 5.4, Level 000602_6 to Version 5.4, Level 000602_7
c
c    (1) Fix call to READIN in subr. RDVD to allow for more than 5
c        species with user-specified deposition velocities.
c
c --- Version 5.4, Level 000602_5 to Version 5.4, Level 000602_6
c
c    (1) Fix call to RDEM3 (data records for BAEMARB.DAT files) to use
c        the file unit number 'io' instead of 'io17', which was removed
c        in CALPUFF 5.4, Level 000602.  File unit io17 (which is zero
c        because it is not defined) is not open so the call to RDEM3
c        generates a runtime error which halts the run.  This affects
c        previous CALPUFF versions starting with version 5.4.
c
c    (2) Change name of LCC longitude stored in /PT2/, /AR2/, /LN2/,
c        and /VOL2/ from '-ELON-' to '-WLON-' to match variable
c        returned from XTRACTLL (variables are not currently used).
c
c --- Version 5.4, Level 000602_4 to Version 5.4, Level 000602_5
c
c    (1) Add new 'qaplot' files to facilitate making maps of layout
c        [qaplot1, setup]
c
c    (2) Initialize QAFAIL before MREG if-block in qainp
c
c --- Version 5.4, Level 000602_3 to Version 5.4, Level 000602_4
c
c    (1) Remove XLAT,XLONG,XTZ variables from Input Group 4 of control
c        file, and place XBTZ into Input Group 1 [changes to METHD.PUF,
c        DATEHR.PUF, GRID.PUF, block data, readcf, qainp, met1, metqa,
c        sundata]
c
c    (2) Fix ZFRISE assignment before call to RISEWIND and in ZTRACE.
c        The height at final rise was used instead of the rise at
c        final rise.  This has no apparent effect on computations
c        made in these subroutines.
c
c    (3) Screen hourly data in ISC met file for invalid entries [rdisc,
c        qahrisc]
c
c    (4) Add monthly background O3, NH3, and H2O2 arrays
c        [CHEMDAT.PUF, block data, comp, readcf, qainp, chembk]
c
c --- Version 5.4, Level 000602_2 to Version 5.4, Level 000602_3
c
c    (1) Add aqueous phase chemistry option (not enabled)
c
c --- Version 5.4, Level 000602_1 to Version 5.4, Level 000602_2
c
c    (1) Revise MFOG=1 (Plume Mode) option to treat multiple sources;
c        actual receptor locations vary with wind direction and
c        impact of plumes from all sources is summed as in receptor
c        mode; range of receptor distances and heights are selected
c        internally
c
c    (2) Revise FOG.DAT structure to remove restriction on number of
c        receptors; add new header to report compression logical in
c        receptor mode
c
c    (3) Add initial sigmas to downwash sigmas in wake of point sources
c
c --- Version 5.4, Level 000602 to Version 5.4, Level 000602_1
c
c    (1) Set LADTFOG=FALSE in block data.  This corrects problem
c        resulting in zero species #2 (usually SO4) concentrations
c        at discrete receptors.  Versions of CALPUFF earlier
c        than 000602 were not affected by the error.  Also, gridded
c        receptor concentrations were not affected in any version.
c
c --- Version 5.3, Level 991222 to Version 5.4, Level 000602
c
c    (1)  Replace VOLEM.DAT structures with new VOLEMARB.DAT structures
c         that include multiple emissions files
c
c    (2)  Use QAFAIL in QAINP when testing MREG option;  Add reference
c         to list-file at all "stop" statements (message to screen)
c
c    (3)  Add message to "stop" statements to identify subroutine where
c         model run is halted, and refer user to list file
c
c    (4)  Add units choice (g/s or g/m**2/s) to header of BAEMARB.DAT
c
c    (5)  Add initial sigmas and vertical momentum flux factor to
c         PTEMARB.DAT
c
c    (6)  Revise puff sampling (vertical) in depletion calculation
c         to match methods used for receptors during calms (VCBAR)
c
c    (7)  Report NMETDAT>MXMETDAT to unit '*' (io6 not yet assigned)
c
c    (8)  Add Horizontal puff splitting option (Block Data, READCF,
c         QAINP, SPLIT)
c
c    (9)  Revise treatment of exponentials in crosswind impact slug
c         sampling (SLUGINT) for receptors at the fringe of a slug
c
c    (10) Add specialized FOG module for use with the fog analysis
c         package of processors designed to evaluate the frequency
c         of fogging/icing events associated with mechanical-draft
c         cooling towers
c
c    (11) Allow multiple emissions files for point and buoyant area
c         sources
c
c    (12) Add new header record to all variable emissions files to
c         document the parameters for the Lambert Conformal map
c         projection
c
c    (13) Add CALMET version number to test for format before
c         Version 5.0 (980304) in MET1, and add window of 950101-980304
c         for level check in SSLATLON.
c
c    (a1/5.3)  Sigma-w data should not be extracted from a SWPRF array
c         when turbulence data are provided in a PLMMET.DAT file,
c         and a PROFILE.DAT file should not be reported to the
c         list file when turbulence data (sigma-theta) in PLMMET.DAT
c         are used.  (Subroutines TURBSET and WRFILES modified.)
c      ** Change suggested by Dennis Hearn, EPA of Victoria, Australia.
c
c    (a2/5.3)  Profile arrays for turbulence data initialized to missing
c         in BLOCK DATA.
c
c    (a3/5.3)  Complete logic to allow turbulence data to be read from
c         PROFILE.DAT when PLMMET.DAT is the primary met file.
c         (Subroutines QAINP, RDPLM, and COMP modified.)
c
c    (b1/5.3)  Add a momentum flux factor (FMFAC) for point sources to
c         simulate the reduction in vertical momentum caused by stack
c         structures (e.g., rain-hats).  Current implementation allows
c         only 0 or 1 for the factor.  (Subroutines POINTS1, POINTS2,
c         READCF, QAINP, PRFIN, STKTIP, PUFRECS, SLGRECS, PLGRECS,
c         BLOCK DATA)
c
c    (b2/5.3)  Fix bug in READCF processing of FMFAC input array for
c         point sources that updated only the value for the first source
c
c --- Version 5.2, Level 991104 to Version 5.3, Level 991222
c
c    (1)  Add boundary flux module (inflow at edge of computational
c         domain).  This brings in a new source type whose puffs are
c         initially mixed (puff code 6).  These are advected with normal
c         transformation/removal, but they do not grow laterally and
c         the (uniform) concentration from just the nearest such puff
c         is summed to obtain the impact at a given receptor.
c
c    (2)  Enable SOA option
c
c    (a1/5.2) Use MIN,MAX in place of MIN1,MAX1 in TIBLGRO, and move
c         in-line format to format statements in TRACK (removes
c         compiler warnings)
c
c    (a2/5.2)  Bug in CHEM: replace PIVOLM with PIVOLU in assigning
c         puff volume for the Upper layer used to compute the mean puff
c         concentration for the call to CHEMTF  (the M denotes the
c         mixed layer puff volume, the U denotes the upper layer
c         puff volume)
c
c    (a3/5.2)  Condition sigma-z ratio R in CTADJ2 to be <= 1.
c
c    (a4/5.2) Logic added to 3 coordinate routines (MAPG2L, LL2UTM,
c        and UTM2LL) to accommodate -180 to +180 longitude boundary
c        -- taken directly from CALMET V5.1 (991104a) --
c
c --- Version 5.0, Level 990228 to Version 5.2, Level 991104
c
c    (a1/5.0) Add capability to read a list of CALMET.DAT filenames and
c         process them in sequence.
c
c    (a2/5.0) Fix runtime /0 in terrain adjustment option 2 for ground
c         level non-buoyant sources.
c
c    (b1/5.0) Add elevated discrete receptors (gridded and CTSG receptors
c         remain on the surface).
c
c    (c1/5.0) Add ability to track mass flux across user-specified
c         boundaries, using puff centers.
c
c    (d1/5.0) Add ability to track mass balance hourly for all species,
c         for the computational domain.
c
c    (d2/5.0) Add IPFDEB variable to input group 5 to identify puff index
c         at which to begin debug output.
c
c    (d3/5.0) Fix argument type for MIN/MAX functions in MFLXCMP, and 
c         assign ZERO/0.0/ in MFLXINI.
c
c    (e1/5.0) Expand search for nearest land and water cells in TIBLSET
c         and fix loop over cells touched in TIBLON.
c
c    (e2/5.0) Add transition from TIBL to inland mixing heights
c
c    (e3/5.0) Recast IXREMN arrays as map to FULL advected species array
c
c    (a1/5.1) Fix coding error in call to SLGRECS in CALCSL (introduced 
c         in (b1/5.0))
c
c    (b1/5.1) Add PGTIME to control file
c
c    (b2/5.1) Incorporate mmodel='AUSPUFF' options (except metric tons).
c
c    (1) Allow zero exit velocity in numerical rise (rise = 0)
c                                                             <990729>
c
c    (2) Use plume w-velocity < 0 rather than plume angle (phi<0)
c        to stop numerical rise during stable conditions
c                                                             <990729>
c
c    (3) Enforce SYMIN limit on crosswind area source projection
c                                                             <990729>
c
c    (4) Implement Y2K logic (YYYY format for year)
c
c    (5) Add metric tons/yr as 7th option in emission units
c
c    (6) Add numerical rise integration step DSRISE(m) to control file
c
c    (7) Add check on nx,ny provided in control file (mxnx,mxny)
c
c    (8) Revise distance to final momentum rise calculation in NUMRISE
c
c    (9) Write error messages to list file as well as screen (VEMFAC,
c        VWIDTH, HDUN, SIGMA, SIGSET, RESTARTO, TIBLSET, TIBLGRO, 
c        MFLXSET, YR4, QAYR4)
c
c----------------------------------------------------------------------
c --- MOD5 adapted from CALPUFF (MOD4 - V3.0, V4.0, V4.0t, V4.07, V4.1)
c
c --- Original CALPUFF written by:
c
c                  J. Scire, R. Yamartino, D. Strimaitis
c                  EARTH TECH / Sigma Research
c                  196 Baker Avenue
c                  Concord, MA  01742
c                  TEL:(978) 371-4200
c                  FAX:(978) 371-2468
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'qa.puf'
      include 'outpt.puf'
c
      logical lflag
c
c --- Set underflow treatment (compiler-dependent)
      lflag=.true.
      call UNDRFLW(lflag)
c
c --- set version and level number of program
      ver='6.262'
      level='080725'
c
c --- SETUP PHASE -- initialization & program setup operations
      itest=2
      call setup(itest)
c
c --- Skip COMPUTATIONAL phase and STOP program execution if in TEST
c --- mode
      if(itest.eq.1)go to 999
c
c --- COMPUTATIONAL PHASE -- basic time loop with scientific modules
      call comp
c
c --- TERMINATION PHASE -- program termination functions
999   continue
      call fin(itest)
c
      stop
      end

c----------------------------------------------------------------------
      BLOCK DATA
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430            BLOCK DATA
c                J. Scire, D. Strimaitis
c
c --- Include parameter statements
      include 'params.puf'
      parameter(mxem1=mxemdat-1)
c
c --- Include common blocks
      include 'ar1.puf'
      include 'ar2.puf'
      include 'bcs.puf'
      include 'chemdat.puf'
      include 'comparm.puf'
      include 'csigma.puf'
      include 'ctsgdat.puf'
      include 'dataset.puf'
      include 'datehr.puf'
      include 'dispdat.puf'
      include 'drydep.puf'
      include 'drygas.puf'
      include 'drypart.puf'
      include 'filnam.puf'
      include 'flags.puf'
      include 'fog.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'map.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'outpt.puf'
      include 'pdf.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'puff.puf'
      include 'vol1.puf'
      include 'vol2.puf'
      include 'wakedfsn.puf'
      include 'wrkspc.puf'
c
c --- AR1 common block (control file area sources)
      data nvert1/mxarea*4/
      data iaru/1/
      data ivar1/mxspar*0/
      data iq12ar1/mxspar*0/
c
c --- AR2 common block (external file area sources)
      data nvert2/mxarea*4/,ntr0/10/
c
c --- BCS common block (BCON.DAT file)
      data ibcu/1/
      data ivbc/mxspbc*0/
      data iq12bc/mxspbc*0/
      data mdepbc/1/
      data htminbc/500./, rsampbc/10./, conbc0/1.0e-06/
c --- Initialize air-mass type names to blank
      data cnamtyp/mxbc*'            '/
c --- Set array of concentration conversion factors to convert user
c --- units to g/m**3.  Note that ppm and ppb are converted using
c --- molecular weight (g/g-mole) and molar volume (.0224 m^3/kg-mole)
c --- at STP (0 C, 1 atm)  
      data funitsbc/1.0, 1.0E-06, 4.4643E-05, 4.4643E-08/
c --- Name those factors
      data cunitsbc/'   g/m**3   ','  ug/m**3   ',
     &              '    ppm     ','    ppb     '/
c
c --- CHEMDAT common block
      data moz/1/,bcko3m/12*80./,bcknh3m/12*10./
      data mh2o2/1/,bckh2o2m/12*1.0/
      data rnite1/0.2/,rnite2/2.0/,rnite3/2.0/
      data bckpmf/12*1.0/
      data vcnx/12*50.0/
      data ofrac/2*.15,9*.20,.15/
c
c --- COMPARM common block
      data xmxlen/1.0/,mxnew/99/,xsamlen/1.0/,mxsam/99/
      data mxagehr/0/
      data xminzi/50.0/,xmaxzi/3000./
      data symin/1.0/,szmin/1.0/
      data sl2pf/10.0/,svmin/6*0.5,6*0.37/
      data swmin/.20,.12,.08,.06,.03,.016,
     &           .20,.12,.08,.06,.03,.016/
c --- Divergence criterion for initiating sigma-z enhancement
      data cdiv/0.000,0.000/
c --- Default for minimum wind speed for non-"calm"
      data wscalm/0.5/
c --- Default limits (m/s) for wind speed classes (class 6 has no limit)
      data wscat/1.54,3.09,5.14,8.23,10.8/
c --- Number of groups of 12 emission rate scaling factors for each
c --- variable emissions option
      data iqnum/2,1,8,3,1/
c --- Initialize the index pointer for the variable emissions scaling
c --- factor array (VQFAC)
      data iqnext/1/
c --- Default for maximum sigma-z allowed (sigma-z cap)
      data szcap_m/5.0e06/

c --- ISC rural defaults for wind profile power law exponents (6)
      data plx0/.07,.07,.10,.15,.35,.55/
c --- ISC defaults for array of potential temperatures (2)
      data ptg0/0.020,0.035/
c --- Defaults for array of plume path coefficients (6)
      data ppc/0.5,0.5,0.5,0.5,0.35,0.35/
c --- Default for using ISC transition-point between downwash schemes
      data tbd/0.5/
c --- Puff splitting defaults
      data nsplit/3/
      data iresplit/17*0,1,6*0/
      data zisplit/100./,roldmax/0.25/
      data nsplith/5/,sysplith/1./,cnsplith/mxspec*1.0E-07/
      data shsplith/2./
c --- Convergence fractions for numerical integration
      data epsslug/1.0e-04/,epsarea/1.0e-06/
c --- Number of iterations used to estimate transport wind for sampling
c --- step prior to final rise
      data ncount/2/
c --- Distance parameters for sub-grid TIBL module
      data tibldist/1.0, 10., 9.0/
      data nlutibl/4/
c --- Step distance for numerical plume rise
      data dsrise/1.0/
c --- Set trajectory inclination angle, ignoring streamline descent,
c --- at which check is made for PRIME wake influence
c --- (Current default = 20 deg = 0.3490659 radians)
      data trajincl/20.0/
c
c --- CSIGMA common block
      data tyidr,tzidr,tzisdr/0.001,0.002,0.01/
      data syh/300./,szh/88./
c
c --- The following from from MESOPUFF II   VERSION 4.01   LEVEL 821201
      data ayt/0.5/,azt/5.0,3.873,2.739,1.871,1.225,0.707/
      data aypgt/0.36,0.25,0.19,0.13,0.096,0.063/,bypgt/6*0.9/
      data azpgt/0.00023,0.058,0.11,0.57,0.85,0.77/
      data bzpgt/2.10,1.09,0.91,0.58,0.47,0.42/
c
c --- The following from from ISC6-8
      data ayurb/2*0.32,0.22,0.16,2*0.11/
      data xiyurb/6*0.0004/
      data azurb/2*0.24,0.20,0.14,2*0.08/
      data xizurb/3*0.001,0.0003,2*0.0015/
c
      data nzbrur/8,3,1,6,9,10/
c
      data xzbrur/0.10, 0.15, 0.20, 0.25, 0.30,
     1            0.40, 0.50, 3.11, 2*1.e20,
     2            0.20, 0.40, 8*1.e20,
     3            10*1.e20,
     4            0.30, 1.00, 3.00, 10.0, 30.0, 5*1.e20,
     5            0.10, 0.30, 1.00, 2.00, 4.00,
     5            10.0, 20.0, 40.0, 2*1.e20,
     6            0.20, 0.70, 1.00, 2.00, 3.00,
     6            7.00, 15.0, 30.0, 60.0, 1.e20/
c
      data szbrur/60*1.0e20/
c
      data azrur/122.80, 158.08, 170.22, 179.52, 217.41,
     1           258.89, 346.75, 3*453.85,
     2           90.673, 98.483, 8*109.3,
     3           10*61.141,
     4           34.459, 32.093, 32.093, 33.504, 36.65 ,5*44.053,
     5           24.26 , 23.331, 21.628, 21.628, 22.534,
     5           24.703, 26.97 , 35.42 , 2*47.618,
     6           15.209, 14.457, 13.953, 13.953, 14.823,
     6           16.187, 17.836, 22.651, 27.074, 34.219/
c
      data bzrur/0.9447 , 1.0542 , 1.0932 , 1.1262 , 1.2644 ,
     1           1.4094 , 1.7283,  3*2.1166,
     2           0.93198, 0.98332, 8*1.0971,
     3           10*0.91465,
     4           0.86974, 0.81066, 0.64403, 0.60486, 0.56589, 5*0.51179,
     5           0.8366 , 0.81956, 0.75660, 0.63077, 0.57154,
     5           0.50527, 0.46713, 0.37615, 2*0.29592,
     6           0.81558, 0.78407, 0.68465, 0.63227, 0.54503,
     6           0.46490, 0.41507, 0.32681, 0.27436, 0.21716/
c
c --- CTSGDAT common block
      data nhill/0/,nctrec/0/,xhill2m/1.0/,zhill2m/1.0/
c
c --- DATASET common block
c --- Initialize dataset versions to 0.0
      data vercmet/'0.0'/, verisc/'0.0'/, verplm/'0.0'/
      data verprf/'0.0'/, versfc/'0.0'/
      data verparb/mxemdat*'0.0'/, veraarb/mxemdat*'0.0'/
      data verlarb/'0.0'/, vervarb/mxemdat*'0.0'/
      data veroz/'0.0'/, verh2o2/'0.0'/, vercoast/'0.0'/
      data verflxb/'0.0'/, verbcon/'0.0'/, verrest/'0.0'/
c
c --- DATEHR common block
      data xbtz/-999./
c
c --- DISPDAT common block
      data sytdep/550./
      data jsup/5/,conk1/0.01/,conk2/0.1/,iurb1/10/,iurb2/19/
      data avet/60./,pgtime/60./
c
c --- DRYDEP common block
      data idryflg/mxspec*0/,iveg/1/
c
c --- DRYGAS common block
      data rcutr/30.0/,rgr/10.0/,reactr/8.0/
      data pconst/2.3e-8/,bmax/2.5e-6/,bmin/0.1e-6/,qswmax/600./
      data dconst1/2.0/,dconst2/0.6666667/,dconst3/4.8e-4/
      data pdiff/mxspec*-999./,alphas/mxspec*-999./,
     1 react/mxspec*-999./,rm/mxspec*-999./,henry/mxspec*-999./
c
c --- DRYPART common block
      data rho/mxpdep*1.0/,npsint/9/,dconst4/0.6666667/
c
c --- FILNAM, FILLOG common blocks
      data pufinp/'calpuff.inp'/,metdat/'calmet.dat'/,
     1 iscdat/'iscmet.dat'/,plmdat/'plmmet.dat'/,puflst/'calpuff.lst'/,
     2 condat/'conc.dat'/,dfdat/'df.dat'/,wfdat/'wf.dat'/,
     3 visdat/'visb.dat'/,t2ddat/'tk2d.dat'/,rhodat/'rho2d.dat'/,
     4 ptdat/'ptemarb.dat',mxem1*' '/,voldat/'volemarb.dat',mxem1*' '/,
     5 ardat/'baemarb.dat',mxem1*' '/,lndat/'lnemarb.dat'/,
     6 ozdat/'ozone.dat'/,vddat/'vd.dat'/,chemdat/'chem.dat'/,
     7 hildat/'hill.dat'/,rctdat/'hillrct.dat'/,
     8 rstartb/'restartb.dat'/,rstarte/'restarte.dat'/,
     9 cstdat/'coastln.dat'/,bdydat/'fluxbdy.dat'/
      data flxdat/'massflx.dat'/,baldat/'massbal.dat'/,
     1 debug/'debug.dat'/bcndat/'bcon.dat'/,fogdat/'fog.dat'/,
     2 h2o2dat/'h2o2.dat'/,risdat/'rise.dat'/
      data nptdat/0/, nardat/0/, nvoldat/0/
      data lcfiles/.true./
c
c --- FLAGS common block
      data mgauss/1/,mctadj/3/,mctsg/0/,mslug/0/,mtrans/1/,mtip/1/
      data mshear/0/,msplit/0/,mchem/1/,mwet/1/,mdry/1/
      data mdisp/3/,mturbvw/3/,mdisp2/3/,mrough/0/,mpartl/1/
      data mtinv/0/,mpdf/0/,mhftsz/0/,msgtibl/0/,mreg/1/
      data mfog/0/,maqchem/0/,mbdw/1/,mtilt/0/,mcturb/1/,mtauly/0/
      data mtauadv/0/
      data ldevel/.FALSE./
c --- Set default flag for applying partial penetration to buoyant
c --- area sources to 'YES'
      data mpartlba/1/
      data mrise/1/
c
c --- FOG common block
      data nfpts/1/,ipcp/51*0/,ifdays/366*0/
      data lpmode/.FALSE./
      data ladtfog/.FALSE./
c
c --- GEN common block
      data nspec/5/,nse/3/
      data metfm/1/,metrun/0/,mprffm/1/
      data iavg/1/,nsecdt/3600/,irlg/0/
      data ibsec/0/,iesec/0/
      data mrestart/0/, nrespd/0/
c --- Activate this block for MXSPEC=35
c *** data cspec/ 'SO2', 'SO4', 'NOX', 'HNO3', 'NO3', 30*' '/
c *** data cgrup/ 35*'      '/
c *** data isplst/3*1,0, 3*1,0, 3*1,0, 1,0,1,0, 1,0,1,0, 120*0/
c --- Activate this block for MXSPEC=20
      data cspec/ 'SO2', 'SO4', 'NOX', 'HNO3', 'NO3', 15*' '/
      data cgrup/ 20*'      '/
      data isplst/3*1,0, 3*1,0, 3*1,0, 1,0,1,0, 1,0,1,0, 60*0/
c --- Activate this block for MXSPEC=5
c *** data cspec/ 'SO2', 'SO4', 'NOX', 'HNO3',   'NO3'/
c *** data cgrup/ 5*'      '/
c *** data isplst/3*1,0, 3*1,0, 3*1,0, 1,0,1,0, 1,0,1,0/
c
c --- GRID common block
      data lsamp/.true./,meshdn/1/
      data xtz/-999.0/
c
c --- LN1 common block
      data ilnu/1/
      data ivln1/mxspln*0/
      data iq12ln1/mxspln*0/
c --- Default for the maximum number of segments along one line source
c --- from which a slug is released, and for number of points used to
c --- tabulate rise
      data mxnseg/7/,nlrise/6/
c
c --- LN2 common block
      data nln2/0/
      data rnlat1ln2/0./,rnlat2ln2/0./,rnlat0ln2/0./,relon0ln2/0./
c
c --- MAP common block
      data pmap/'UTM     '/
      data datum/'WGS-84  '/
      data utmhem/'N   '/
      data iutmzn/-999/
      data xlat1 /-999./, xlat2 /-999./
      data rlon0 /-999./, rlat0 /-999./
      data relon0 /-999./, rnlat0 /-999./
      data feast/0.0/, fnorth/0.0/
c --- Derived variables
      data lutm/.false./, llcc/.false./, lps/.false./
      data lem/.false./, llaza/.false./, lttm/.false./
c
c --- METHD common block
      data datumm/'WGS-84  '/
      data iutmznm/-999/
      data xlat1m /-999./, xlat2m /-999./
      data rlon0m /-999./, rlat0m /-999./
      data feastm/0.0/, fnorthm/0.0/
c --- Nulls for using "old" CALMET met data file (METFM=1)
      data llconfm/.FALSE./
      data xlat0m/-999./,xlon0m/-999./
c --- Defaults for using single-point met data files (METFM=2,3,4,5)
      data i2dmet/0/
      data anemht/10./,isigmav/1/,imixctdm/0/
      data ilanduin/20/,z0in/.25/,xlaiin/3.0/
      data elevin/0.0/,xlatin/-999./,xlonin/-999./
      data nss/0/,xlatss/mxss*-999./,xlonss/mxss*-999./
      data xbtzm/-999./
c
c --- METHR common block
c --- ISC defaults for potential temperature gradient (KST=5,6)
      data ptg/0.020,0.035/
c --- Initialize observed inversion strength to missing (-999.)
      data dptinvo/-999./
c --- Initialize observed turbulence profiles to missing (-999.)
      data svprf/mxprfz*-999./
      data swprf/mxprfz*-999./
c
c --- OUTPT common block
      data icon/1/,idry/1/,iwet/1/,icprt/0/,idprt/0/,iwprt/0/
      data icfrq/1/,idfrq/1/,iwfrq/1/
      data iprtu/1/
      data ioutop/mx7*0/,imesg/2/
c --- Add a flag for supplying Rel. Hum. (%) in a VISB.DAT file for
c --- visibility applications
      data ivis/1/
c --- Add a flags for creating 2D Temperature(K) and Density(kg/m3)
c --- output files
      data it2d/0/, irho/0/
      data ldebug/.FALSE./,ipfdeb/1/,npfdeb/1/,nn1/1/,nn2/10/
      data lcomprs/.true./
      data imflx/0/,imbal/0/
c --- Add a flag for FOG.DAT file (need MFOG>0 to be used)
      data ifog/0/
c --- QA plot files and source contributions
      data iqaplot/1/,msource/0/
c --- Flag for RISE.DAT file (need MFOG>0 to be used)
      data inrise/0/
c
c --- PDF common block
      data lpdf/.FALSE./
c
c --- PT1 common block (control file point sources)
      data iptu/1/
      data ivpt1/mxsppt1*0/
      data iq12pt1/mxsppt1*0/
      data fmfpt1/mxpt1*1.0/
      data zplatpt1/mxpt1*0.0/
c
c --- PT2 common block (external file point sources)
      data rnlat1pt2/mxemdat*0./,rnlat2pt2/mxemdat*0./
      data rnlat0pt2/mxemdat*0./,relon0pt2/mxemdat*0./
      data zplatpt2/mxpt2*0.0/
c
c --- PUFF common block
      data npuffs/0/
      data tcon/mxpuf6*0.0/
      data isplit/mxpuff*1/
c
c --- VOL1 common block (control file volume sources)
      data ivlu/1/
      data ivvl1/mxspvl*0/
      data iq12vl1/mxspvl*0/
c
c --- VOL2 common block (control file volume sources)
      data rnlat1vl2/mxemdat*0./,rnlat2vl2/mxemdat*0./
      data rnlat0vl2/mxemdat*0./,relon0vl2/mxemdat*0./
c
c --- WAKEDFSN common block
c --- Ambient turbulence intensities are inferred from Briggs (1973)
c --- "Diffusion estimation for small emissions", ATDL-106;
      data rurliz/.20,.12,.08,.06,.03,.016/
      data rurliy/.22,.16,.11,.08,.06,.04/
      data urbniz/.24,.24,.20,.14,.08,.08/
      data urbniy/.32,.32,.22,.16,.11,.11/
c --- Set the factor for defining when turb Approaches Asymptotic
c --- value, and also define the maximum allowed scaled distance
      data afac/1.3/, xbyrmax/15./
c --- Turbulence intensities in wake (from Briggs rural curves)
      data wiz0/0.06/, wiy0/0.08/
c --- Wake Factors for sigw and sigv from Weil (1996)
      data wfz/1.7/, wfy/1.7/
c --- DeltaU0/U0
      data dua_ua/0.7/
c --- Power-law exponent for turbulence intensity change in distance
      data xdecay/0.666667/, xdecayi/1.5/
c
c --- WRKSPC common block
      data nw1/mxnxy/,nw2/mxnxy/
c
      end

c----------------------------------------------------------------------
c --- BRING IN CALPUFF SYSTEM UTILITY SUBROUTINES
      include 'calutils.for'
      include 'coordlib.for'
c----------------------------------------------------------------------

c----------------------------------------------------------------------
      subroutine advwnd(u,v,zface,nzp1,zbot,ztop,uave,vave)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940430                 ADVWND
c                J. Scire, SRC
c
c --- PURPOSE:  Compute the vertically-averaged winds (U, V) through
c               the layer ZBOT through ZTOP
c
c --- INPUTS:
c         U(mxnz) - real array - U-component of wind (m/s) for each
c                                layer
c         V(mxnz) - real array - V-component of wind (m/s) for each
c                                layer
c   ZFACE(mxnzp1) - real array - Cell face heights (m) for each layer
c            NZP1 - integer    - Number of cell face heights (NZ + 1)
c            ZBOT - real       - Height (m) of BOTTOM of averaging layer
c            ZTOP - real       - Height (m) of TOP of averaging layer
c
c     Parameters:
c           MXNZ, MXNZP1, IO6
c
c --- OUTPUT:
c            UAVE - real       - Vertically-averaged U-component of the
c                                wind (m/s)
c            VAVE - real       - Vertically-averaged V-component of the
c                                wind (m/s)
c
c --- ADVWND called by:  ADVECT
c --- ADVWND calls:      ZFIND
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      real u(mxnz),v(mxnz)
      real zface(mxnzp1)
c
c --- Set the limits of the averaging depth to ensure overlap
c --- with the meteorological fields
      zabot=zbot
      if(zabot.lt.zface(1))zabot=zface(1)
      if(zabot.gt.zface(nzp1))zabot=zface(nzp1)
c
      zatop=ztop
      if(zatop.lt.zface(1))zatop=zface(1)
      if(zatop.gt.zface(nzp1))zatop=zface(nzp1)
c
c --- Find the met. layer containing the height "ZABOT" (adjusted ZBOT)
      call zfind(zabot,zface,nzp1,IBOT)
c
c --- Find the met. layer containing the height "ZATOP" (adjusted ZTOP)
      call zfind(zatop,zface,nzp1,ITOP)
c
c ------------------------------------
c --- Compute the layer-averaged winds
c ------------------------------------
c
      if(IBOT.eq.ITOP)then
c
c ---    Averaging layer is completely within one met. layer
         uave=u(ibot)
         vave=v(ibot)
      else
c
c ---    Averaging layer extends into two or more met. layers
c ---    Sum through each met. layer
c
c ---    Lowest met. layer containing ZABOT -- ZFACE(ibot+1) is the
c ---    height of the TOP of layer IBOT
         delz=zface(ibot+1)-zabot
         sumu=delz*u(ibot)
         sumv=delz*v(ibot)
         sumz=delz
c
c ---    Highest met. layer containing ZATOP -- ZFACE(itop) is the
c ---    height of the BOTTOM of layer ITOP
         delz=zatop-zface(itop)
         sumu=sumu+delz*u(itop)
         sumv=sumv+delz*v(itop)
         sumz=sumz+delz
c
c ---    Sum through met. layers between IBOT and ITOP
         ibotp1=ibot+1
         itopm1=itop-1
         if(itopm1.lt.ibotp1)go to 102
         do 100 i=ibotp1,itopm1
            delz=zface(i+1)-zface(i)
            sumu=sumu+delz*u(i)
            sumv=sumv+delz*v(i)
            sumz=sumz+delz
100      continue
102      continue
c
c ---    Compute the layer-averaged winds
         UAVE=sumu/sumz
         VAVE=sumv/sumz
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine advect(ldbg,ix,iy,z0m,el,dpbl,istab,ht,zbot,ztop,
     &                  uadv,vadv)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080204                 ADVECT
c ---            D. Strimaitis
c
c --- PURPOSE:  Obtain puff advection wind
c
c --- UPDATE
c --- V5.74-V6.23   080204  (DGS): add screen for ZTOP<ZBOT
c --- V5.4-V5.74    040715  (DGS): add AERMET option (METFM=5)
c --- V4.0a-V5.4    000602  (DGS): add message to "stop"
c --- V4.0-V4.0a    971107  (DGS): initialize ibot & itop (METFM=4)
c                   971107  (DGS): modify search for profile levels
c                                  within puff
c                   971107  (DGS): check PROBLEM returned by XTPRF
c
c --- INPUTS:
c            LDBG - logical      - Write debug output if .TRUE.
c           IX,IY - integer      - Cell index of puff in MET grid
c             Z0M - real         - Surface roughness (m)
c              EL - real         - Monin-Obukhov length (m)
c            DPBL - real         - Depth of boundary layer (m)
c           ISTAB - integer      - PG stability class
c              HT - real         - Initial puff height, at release (m)
c            ZBOT - real         - Bottom of puff (m)
c            ZTOP - real         - Top of puff (m)
c
c    Common block /COMPARM/ variables:
c         WSCALM
c     Common Block /GEN/ variables:
c         METFM
c     Common Block /GRID/ variables:
c         NZ, NZP1, ZGPT(mxnz), ZFACE(mxnzp1)
c    Common block /METHR/ variables:
c         UMET(mxnx,mxny,mxnz), VMET(mxnx,mxny,mxnz)
c         PTG(2), PLEXP, SSPRF(mxprfz), WDPRF(mxprfz), ZPRF(mxprfz)
c         NZPRF
c    Parameters:
c         MXNX, MXNY, MXNZ, MXNZP1, MXPRFZ, IO6
c
c --- OUTPUT:
c            UADV - real         - Vertically-averaged U-component
c                                  of the wind (m/s)
c            VADV - real         - Vertically-averaged V-component
c                                  of the wind (m/s)
c
c --- ADVECT called by:  COMP, RISEWIND
c --- ADVECT calls:      ADVWND, POWLAW, XTPRF
c----------------------------------------------------------------------
      include 'params.puf'
      include 'comparm.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'methr.puf'

      real u(mxnz),v(mxnz)
      logical ldbg,problem
      data dtor/0.0174533/


      if(ldbg) then
         write(io6,*)
         write(io6,*)'ADVECT:      metfm =  ',metfm
         write(io6,*)'zbot,ztop,ht(release) ',zbot,ztop,ht
      endif

c --- Stop if ztop<zbot
      if(ztop.LT.zbot) then
         write(io6,*)
         write(io6,*)'ADVECT: Bottom EXCEEDS Top!'
         write(io6,*)'zbot,ztop,ht(release) ',zbot,ztop,ht
         stop 'Halted in ADVECT'
      endif

      if(metfm.LE.3) then
c ---    3-D gridded MET field:  transfer U,V to 1-D arrays
         do iz=1,nz
            u(iz)=umet(ix,iy,iz)
            v(iz)=vmet(ix,iy,iz)
         enddo

         if(metfm.EQ.2 .OR. metfm.EQ.3) then
c ---       ISC/PLUME treatment (1-layer)
c ---       Profile non-calm wind speed in layer to RELEASE height
            wsold=sqrt(u(1)**2+v(1)**2)
            if(wsold.LT.wscalm) then
               uadv=u(1)
               vadv=v(1)
            else
               call POWLAW(ht,zgpt(1),wsold,plexp,ws)
               ratio=ws/wsold
               uadv=u(1)*ratio
               vadv=v(1)*ratio
            endif
            if(ldbg) then
               write(io6,*)'uadv,vadv= ',uadv,vadv
            endif
         else
c ---       Full 3-D gridded layer-averaged MET treatment
            call ADVWND(u,v,zface,nzp1,zbot,ztop,uadv,vadv)
            if(ldbg) then
               write(io6,*)'uadv,vadv= ',uadv,vadv
            endif
         endif

      elseif(metfm.EQ.4 .OR. metfm.EQ.5) then
c ---    PROFILE.DAT met data
c ---    Use scalar speed as in CTDM
         problem=.FALSE.
         if(zbot.EQ.ztop) then
c ---       Get wind at ZBOT
            call XTPRF(nzprf,ssprf,zprf,zbot,'spd',z0m,el,
     &                 dpbl,istab,ptg,ws,problem)
            call XTPRF(nzprf,wdprf,zprf,zbot,'dir',z0m,el,
     &                 dpbl,istab,ptg,wd,problem)
            wdrad=wd*dtor
            uadv=-ws*SIN(wdrad)
            vadv=-ws*COS(wdrad)
            if(ldbg) then
               write(io6,*)'ws,wd    = ',ws,wd
            endif
         else
c ---       Get wind at top and bottom of puff
            call XTPRF(nzprf,ssprf,zprf,ztop,'spd',z0m,el,
     &                 dpbl,istab,ptg,wstop,problem)
            call XTPRF(nzprf,wdprf,zprf,ztop,'dir',z0m,el,
     &                 dpbl,istab,ptg,wdtop,problem)
            toprad=wdtop*dtor
            utop=-wstop*SIN(toprad)
            vtop=-wstop*COS(toprad)
            call XTPRF(nzprf,ssprf,zprf,zbot,'spd',z0m,el,
     &                 dpbl,istab,ptg,wsbot,problem)
            call XTPRF(nzprf,wdprf,zprf,zbot,'dir',z0m,el,
     &                 dpbl,istab,ptg,wdbot,problem)
            botrad=wdbot*dtor
            ubot=-wsbot*SIN(botrad)
            vbot=-wsbot*COS(botrad)
            if(ldbg) then
               write(io6,*)'wstop,wsbot = ',wstop,wsbot
               write(io6,*)'wdtop,wdbot = ',wdtop,wdbot
            endif
c ---       Find range of indices of profile array within puff
            ibot=0
            itop=0
            do iz=1,nzprf
               if(zprf(iz).LT.zbot) ibot=iz+1
               if(zprf(iz).LT.ztop) itop=iz
            enddo
            if(ibot.GT.itop .OR. ibot.EQ.0) then
c ---          No profile levels are within puff
               uadv=0.5*(utop+ubot)
               vadv=0.5*(vtop+vbot)
            else
               denomi=0.5/(ztop-zbot)
c ---          Bottom edge
               usum=ubot*(zprf(ibot)-zbot)
               vsum=vbot*(zprf(ibot)-zbot)
c ---          Top edge
               usum=usum+utop*(ztop-zprf(itop))
               vsum=vsum+vtop*(ztop-zprf(itop))
c ---          Middle layer(s)
               do iz=ibot,itop
                  call XTPRF(nzprf,ssprf,zprf,zprf(iz),'spd',z0m,el,
     &                       dpbl,istab,ptg,wsiz,problem)
                  call XTPRF(nzprf,wdprf,zprf,zprf(iz),'dir',z0m,el,
     &                       dpbl,istab,ptg,wdiz,problem)
                  drad=wdiz*dtor
                  ui=-wsiz*SIN(drad)
                  vi=-wsiz*COS(drad)
                  if(iz.EQ.ibot) then
                     zb=zbot
                  else
                     zb=zprf(iz-1)
                  endif
                  if(iz.EQ.itop) then
                     zt=ztop
                  else
                     zt=zprf(iz+1)
                  endif
                  usum=usum+ui*(zt-zb)
                  vsum=vsum+vi*(zt-zb)
               enddo
c ---          Average
               uadv=usum*denomi
               vadv=vsum*denomi
               if(ldbg) then
                  write(io6,*)'itop,ibot   = ',itop,ibot
                  write(io6,*)'usum,vsum   = ',usum,vsum
               endif
            endif
            if(ldbg) then
               write(io6,*)'uadv,vadv= ',uadv,vadv
            endif
         endif

c ---    Results are invalid if XTPRF reported PROBLEM=TRUE
         if(PROBLEM) then
            write(io6,*) 'ADVECT:  FATAL ERROR reported when ',
     &                   'extracting winds from PROFILE ---'
            write(io6,*) 'There are no valid data'
            write(*,*)
            stop 'Halted in ADVECT -- see list file'
         endif

      endif

      return
      end
c----------------------------------------------------------------------
      subroutine windset(ht,ilayer,ix,iy,z0m,el,dpbl,istab,ws,wd)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040715                WINDSET
c ---            D. Strimaitis  SRC
c
c --- PURPOSE:  Obtain wind at height HT
c
c --- UPDATE
c --- V5.4-V5.74    040715  (DGS): Add AERMET option (METFM=5)
c --- V5.0-V5.4     000602  (DGS): Add message to "stop"
c --- V5.0-V5.0     980731  (DGS): Use CALM WD=180.0 for absolute
c                                  calms (ws=0.0)
c --- V4.0-V5.0     971107  (DGS): Set wd to ZERO if CALM to avoid
c                                  potential numerical problem with
c                                  ATAN2 function
c                   971107  (DGS): Use (WS.GE.WSCALM) to signal NON Calm
c                   971107  (DGS): check PROBLEM returned by XTPRF
c
c --- INPUTS:
c              HT - real         - Puff height (m)
c          ILAYER - integer      - Met layer containing HT
c           IX,IY - integer      - Cell index of puff in MET grid
c             Z0M - real         - Surface roughness (m)
c              EL - real         - Monin-Obukhov length (m)
c            DPBL - real         - Depth of boundary layer (m)
c           ISTAB - integer      - PG stability class
c
c    Common block /COMPARM/ variables:
c         WSCALM
c     Common Block /GEN/ variables:
c         METFM
c     Common Block /GRID/ variables:
c         ZGPT(mxnz)
c    Common block /METHR/ variables:
c         UMET(mxnx,mxny,mxnz), VMET(mxnx,mxny,mxnz)
c         PTG(2), PLEXP, SSPRF(mxprfz), WDPRF(mxprfz), ZPRF(mxprfz)
c         NZPRF
c    Parameters:
c         MXNX, MXNY, MXNZ, MXPRFZ, IO6
c
c --- OUTPUT:
c              WS - real         - Value of wind speed at HT (m/s)
c              WD - real         - Value of wind direction at HT (deg)
c
c --- WINDSET called by:  RLSMET, COMP
c --- WINDSET calls:      POWLAW, XTPRF
c----------------------------------------------------------------------
      include 'params.puf'
      include 'comparm.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'methr.puf'

      logical problem
      data rtod/57.29578/,wdcalm/180.0/

      if(metfm.LE.3) then
c ---    3-D gridded MET field
c ---    Form wind speed from components
         ws=SQRT(umet(ix,iy,ilayer)**2+vmet(ix,iy,ilayer)**2)
         if(metfm.EQ.2 .OR. metfm.EQ.3) then
c ---       Adjustment for ISC/PLUME treatment !!
c ---       Profile non-calm wind speed in layer to puff height
            if(ws.GE.wscalm) then
               wsold=ws
               call POWLAW(ht,zgpt(ilayer),wsold,plexp,ws)
            endif
         endif
         if(ws.GT.0.0) then
            wd=270.-(ATAN2(vmet(ix,iy,ilayer),umet(ix,iy,ilayer)))*rtod
         else
c ---       Absolute calm
            wd=wdcalm
         endif

      elseif(metfm.EQ.4 .OR. metfm.EQ.5) then
c ---    PROFILE.DAT met data
c ---    Use scalar speed as in CTDM
         problem=.FALSE.
         call XTPRF(nzprf,ssprf,zprf,ht,'spd',z0m,el,
     &              dpbl,istab,ptg,ws,problem)
         call XTPRF(nzprf,wdprf,zprf,ht,'dir',z0m,el,
     &              dpbl,istab,ptg,wd,problem)

c ---    Results are invalid if XTPRF reported PROBLEM=TRUE
         if(PROBLEM) then
            write(io6,*) 'WINDSET:  FATAL ERROR reported when ',
     &                   'extracting winds from PROFILE ---'
            write(io6,*) 'There are no valid data'
            write(*,*)
            stop 'Halted in WINDSET -- see list file.'
         endif

      endif

      return
      end
c----------------------------------------------------------------------
      subroutine puffdz(ii,icode,lpuff,istab,ilayer,htmet,dpbl,
     &                  ztop,zbot)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080204                 PUFFDZ
c                D. Strimaitis
c
c --- PURPOSE:  Computes the top and bottom of the puff/slug for
c               use in obtaining the advection wind
c
c --- UPDATE
c --- V5.4-V6.23    080204  (DGS): Add screen for ZTOP<ZBOT, and
c                                  refine logic that places a limit on
c                                  ztop that accounts for past mixing
c                                  heights that are less than HTMET.
c --- V5.0-V5.4     000602  (DGS): Add message to "stop"
c --- V5.0-V5.0     980821  (DGS): Impose lid height on ZTOP for class
c                                  D as well as A,B, and C
c
c --- INPUTS:
c               II - integer - Puff index
c            ICODE - integer - Puff code
c            LPUFF - logical - Puff if .TRUE. (SLUG if .FALSE.)
c            ISTAB - integer - Stability class
c           ILAYER - integer - Met grid layer containing puff
c            HTMET - real    - Ht at which to center puff (m)
c             DPBL - real    - Current planetary boundary layer depth (m)
c
c     Common block /GEN/ variables:
c           NSPEC
c     Common block /GRID/ variables:
c           ZFACE(mxnzp1)
c     Common block /PUFF/ variables:
c           SIGZB(mxpuff), ZIOLD(mxpuff), ZIMAX(mxpuff),
c           QM(mxspec,mxpuff), QU(mxspec,mxpuff)
c     Common block /SLUG/ variables:
c           SIGZE(mxpuff)
c     Parameters:
c           MXNZP1, MXPUFF, MXSPEC, IO6
c
c --- OUTPUT:
c             ZTOP - real    - Top of puff
c             ZBOT - real    - Bottom of puff
c
c --- PUFFDZ called by: COMP, SPLIT
c --- PUFFDZ calls:     none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      include 'gen.puf'
      include 'grid.puf'
      include 'puff.puf'
      include 'slug.puf'
c
      logical lpuff
c
c --- Compute the height of the bottom and top of the puff/slug
c --- at the end of previous step
      if(mod(icode,2).eq.1)then
c ---    Gaussian if ICODE=1,3,5 (puff) or 11,13,15 (slug)
c ---    (height +/- sigma-z; ignore BID)
         if(lpuff) then
c ---       PUFF
            sigmaz=sigzb(ii)
         else
c ---       SLUG
            sigmaz=0.5*(sigzb(ii)+sigze(ii))
         endif
         zbot=htmet-sigmaz
         if(zbot.LT.0.) zbot=0.0
         ztop=htmet+sigmaz
c ---    For non-stable surface layer, check for lid cap on ztop
         if(icode.NE.3 .and. icode.NE.13 .AND. istab.LE.4) then
            if(dpbl.GT.htmet) then
               ztop=amin1(ztop,dpbl)
            elseif(ziold(ii).GT.htmet) then
               ztop=amin1(ztop,ziold(ii))
            elseif(zimax(ii).GT.htmet) then
               ztop=amin1(ztop,zimax(ii))
            endif
         endif
      else
c ---    Uniformly mixed if ICODE=2,4,6 (puff) or 12,14,16 (slug)
         if(icode.eq.2.or.icode.eq.12)then
c ---       Puff is within mixed layer (ICODE=2 or 12)
            zbot=0.0
c            ztop=amax1(dpbl,zimax(ii))
            ztop=zimax(ii)
         else if(icode.eq.4.or.icode.eq.14)then
c ---       Puff is above mixed layer since release (ICODE=4,14)
            zbot=zface(ilayer)
            ztop=zface(ilayer+1)
         else if(icode.eq.6.or.icode.eq.16)then
c ---       Puff is within 2-layer, mixed structure (ICODE=6,16)
            zbot=0.0
            ztop=zimax(ii)
c ---       Revise ZBOT if mass in upper layer > 2*mass in lower
            qmtot=0.0
            qutot=0.0
            do is=1,nspec
               qmtot=qmtot+qm(is,ii)
               qutot=qutot+qu(is,ii)
            enddo
            if(qutot.GT.(2.*qmtot)) zbot=ziold(ii)*(1-2.*qmtot/qutot)
         else
            write(io6,*)'ERROR in SUBR. PUFFDZ -- Invalid value of ',
     &      'ICODE -- ICODE = ',icode,' PUFF NO. (II) = ',ii
            write(*,*)
            stop 'Halted in PUFFDZ -- see list file.'
         endif
      endif
c
c --- Stop if ztop<zbot
      if(ztop.LT.zbot) then
         write(io6,*)
         write(io6,*)'PUFFDZ: Bottom EXCEEDS Top!'
         write(io6,*)'zbot,ztop,htmet ',zbot,ztop,htmet
         stop 'Halted in PUFFDZ -- see list file.'
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine areaint(x,y,lwflux,z,hlid,
     &                   zrterr,zstak,zbase,ppcf,ldbhr,
     &                   ccqb,ccdq,ccizqb,ccizdq)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980430                AREAINT
c                R. Yamartino, SRC
c
c --- PURPOSE:  For a polygon AREA source, INTegrate the
c               time-averaged concentration for the case of the
c               unaged slug (i.e., IAGE=0) for a receptor at (X,Y)
c
c --- UPDATE
c --- V5.0-V5.0     980430  (DGS): drop dt from argument list
c --- V4.0-V5.0     971107  (DGS): add /COMPARM/ with "eps" variable for
c                                  use in CPQROMB
c
c --- INPUTS:
c
c                 X - real    - X coord. of receptor.
c                 Y - real    - Y coord. of receptor.
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c                 Z - real    - Z coord. of receptor.
c              HLID - real    - Relevant mixing depth (m) at receptor.
c            ZRTERR - real    - Terrain elevation (m MSL) at receptor
c             ZSTAK - real    - Stack height of source of puff (m)
c             ZBASE - real    - Stack base elevation MSL (m)
c              PPCF - real    - Plume Path Coefficient
c             LDBHR - logical - Flag for debugging write-statements
c
c --- COMPARM.PUF variables used.
c             EPSAREA
c --- CURRENT.PUF variables used.
c             NSIDE, XVERT, YVERT, XV, YV
c
c --- OUTPUTS:
c
c              CCQB - real    - Coupling coefficient (s/m**3) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c              CCDQ - real    - Coupling coefficient (s/m**3) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c            CCIZQB - real    - Z-integrated coefficient (s/m**2) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c            CCIZDQ - real    - Z-integrated coefficient (s/m**2) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c
c --- AREAINT called by:  CALCSL
c --- AREAINT calls:      XY2UWCW, CWYVALS, VECMIN, VECMAX, EXTREME
c                         CPQROMB
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'comparm.puf'
      include 'current.puf'
c
      logical lwflux,ldbhr
      real xvord(mxvert)
      data sigcut/3.0/
      data zero/0.0/
c
c --- Zero out the return quantities.
      ccqb  = zero
      ccdq  = zero
      ccizqb  = zero
      ccizdq  = zero
c
c --- Transform vertex coordinates, (XVERT,YVERT), into upwind/crosswind
c --- frame as (XV,YV), relative to receptor (x,y); also compute upwind
c --- position of edge of line sources (if source-type is 5), and
c --- pass slug-length variables DXY12, RDXY12 to /SLGLIN/
      call xy2uwcw(x,y)
c
c --- Quit if receptor entirely upwind.
      xtest = vecmax(nside,xv)
      if(xtest.le.zero) then
         go to 500
      else
c ---    Quit if receptor excessively crosswind.
         call extreme(nside,yv,ymin,ymax)
c ---    Continue test if receptor is NOT directly downwind.
         if((ymin*ymax).gt.zero) then
c ---       Define smallest absolute crosswind distance.
            ymin = amin1(abs(ymin),abs(ymax))
c ---       Normalize by the largest sigma y possible
            ymin = ymin / sye1
            if(ymin.gt.sigcut) go to 500
         endif
      endif
c
c --- Order the XV vertex locations in ascending order in XVORD
c --- and determine the number of integration segments NISEG.
      xvord(  1  ) = vecmin(nside,xv)
      xlast        = vecmax(nside,xv)
      xvord(nside) = xlast
      niseg = 1
c
      do i=2,nside-1
         xbelow = xvord(i-1)
         xnext = xlast
         do j=1,nside
            xnow = xv(j)
            if(xnow.gt.xbelow) xnext = amin1(xnext,xnow)
         enddo
         xvord(i) = xnext
         if(xnext.lt.xlast) niseg = niseg + 1
      enddo
c
c --- Reduce the number of segments if intercept directly upwind.
c --- Reset NISEG to 2.
c --- Define alongwind X values
      call cwyvals(nside,yv,xv,zero,xmin,xmax,nhits)
      if(nhits.eq.2) then
         xvord(2) = amax1(xmin,zero)
         xvord(3) = xlast
         niseg = 2
      endif
c
c --- Begin loop over finite length integration segments.
c --- N.B. The maximum value of NISEG is NSIDE-1
c
      do 15 i=1,niseg
      xbelow = xvord(i)
      xnext = xvord(i+1)
c
c --- Zero out the return quantities from CPQROMB
      ss1 = zero
      ss2 = zero
      ss3 = zero
      ss4 = zero
c
c --- Quit if receptor entirely upwind of this segment.
      if(xnext.le.zero) go to 15
c
c --- Redefine segment to ignore downwind source portions.
      xbelow = amax1(xbelow,zero)
c --- Ignore integration paths smaller than 0.01 m long (arbitrary cut)
      if(xnext-xbelow.lt.0.01) go to 15
c
c === Quit if receptor excessively crosswind of all Y in this interval.
c
c --- Define crosswind Y values at start of integration segment.
      call cwyvals(nside,xv,yv,xbelow,ymin,ymax,nhits)
c --- Skip detailed test if receptor directly downwind.
      if((ymin*ymax).le.zero) go to 12
      y1 = ymin
      y2 = ymax
c --- Define crosswind Y values at end of integration segment.
      call cwyvals(nside,xv,yv,xnext,ymin,ymax,nhits)
c --- Skip detailed test if receptor directly downwind.
      if((ymin*ymax).le.zero) go to 12
c --- Define range of crosswind Y values throughout integration segment.
      ymin = amin1(ymin,y1)
      ymax = amax1(ymax,y2)
c --- Skip detailed test if receptor directly downwind.
      if((ymin*ymax).le.zero) go to 12
c --- Define smallest absolute crosswind distance.
      ymin = amin1(abs(ymin),abs(ymax))
c --- Normalize by the largest sigma y possible
      ymin = ymin / sye1
      if(ymin.gt.sigcut) go to 15
c
c --- Evaluate the integral for this portion of the regime.
   12 call cpqromb(xbelow,xnext,lwflux,z,hlid,
     x             zrterr,zstak,zbase,ppcf,epsarea,
     x             ss1,ss2,ss3,ss4)
      ccqb  = ccqb + ss1
      ccdq  = ccdq + ss2
      ccizqb  = ccizqb + ss3
      ccizdq  = ccizdq + ss4
c ***
      if(ldbhr) then
         write(io6,*)'AREAINT -- i = ',i
         write(io6,*)'  ccqb, ccdq = ',ccqb,ccdq
      endif
c ***
c
   15 continue
c
  500 return
      end
c----------------------------------------------------------------------
      subroutine xy2uwcw(x,y)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                XY2UWCW
c                R. Yamartino, D. Strimaitis, SRC
c
c --- PURPOSE:  Transform the NSIDE vertex coordinates, (XVERT,YVERT),
c               relative to the receptor coordinates (X,Y),
c               into upwind/crosswind frame vectors (XV,YV).
c               Also compute upwind distance from receptor to the
c               upwind corner of the block of line sources (if modeled)
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): add variable line source treatment
c
c
c --- INPUTS:
c
c              X    - real    - Receptor X coordinate (m).
c              Y    - real    - Receptor Y coordinate (m).
c
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1, SYB1, SZB1,
c        XE1, YE1, ZE1, SYE1, SZE1,
c        XB2, YB2, ZB2, SYB2, SZB2,
c        XE2, YE2, ZE2, SYE2, SZE2,
c        IAGE, SPEEDI, SRAT, TEMIS,
c        NSIDE, XVERT, YVERT, XSHIFT
c
c --- OUTPUTS:
c
c     Common Block /CURRENT/ variables:
c             XV    - real    - Receptor/vertex upwind distances (m)
c             YV    - real    - Receptor/vertex crosswind distances (m)
c        XUPEDGE    - real    - Distance from receptor to upwind edge
c                               of block of line sources (m)
c
c     Common Block /SLGLIN/ variables:
c          DXY12    - real    - Projection of fully-extended slug length
c                               on the x-y plane (m)
c         RDXY12    - real    - Reciprocal of DXY12
c
c --- XY2UWCW called by:  AREAINT
c --- XY2UWCW calls:       none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'current.puf'

      common /SLGLIN/ dxy12,rdxy12
c
c --- Determine the length and orientation of the final slug
c --- emitted from the center of the polygon area source.
c --- XE1,YE1 are the final coordinates of the slug end-point.
c --- XB2,YB2 are the initial coordinates of the slug end-point.
c --- Note that there is no change in (XB2,YB2) over time.
      X12 = XE1 - XB2
      Y12 = YE1 - YB2
c --- DXY12 is the projection of the slug length on the x-y plane.
      DXY12 = SQRT(X12*X12 + Y12*Y12)
      RDXY12 = 1.0 / DXY12
c --- Note that the angles are defined cw (clockwise) from North.
c --- Define the cos and sin of omega.
c --- note that omega = wind direction (met.) + pi in this case !
      COSOM = Y12 * RDXY12
      SINOM = X12 * RDXY12
c
c --- Begin loop over array vertices.
      do i=1,nside
c ---    Define the vertex-receptor relative position.
         xr = xvert(i) - x
         yr = yvert(i) - y
c ---    Convert to upwind (=-downwind) and crosswind distances.
         xv(i) = -(yr * cosom  +  xr * sinom)
         yv(i) =  -xr * cosom  +  yr * sinom
      enddo
c
c --- For line sources, determine distance from upwind edge of block
c --- of line sources to this receptor
      if(istype.EQ.5 .OR. istype.EQ.6) then
c ---    Source-receptor relative position
         xr = xb2 - x
         yr = yb2 - y
c ---    Convert to upwind (=-downwind) distance
         xline = -(yr * cosom  +  xr * sinom)
c ---    Add distance between upwind edge and source
         xupedge = xline + xshift
      endif
c
      return
      end
c----------------------------------------------------------------------
      real function vecmin(n,xv)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 931228                 VECMIN
c                R. Yamartino, SRC
c
c --- PURPOSE:  For an N element array of values, XV,
c               determine the minimum value.
c
c --- INPUTS:
c
c             N     - integer - Number of elements in XV
c             XV    - real    - Array of values.
c
c
c --- OUTPUTS:
c
c           VECMIN  - real    - Minimun value found.
c
c
c --- VECMIN called by:  AREAINT
c --- VECMIN calls:       none
c----------------------------------------------------------------------
c
      real xv(n)
      data big/1.0e+20/
c
      xmin =  big
c
c --- Loop over array elements.
      do i=1,n
         xmin = amin1(xmin,xv( i ))
      enddo
      vecmin = xmin
c
      return
      end
c----------------------------------------------------------------------
      real function vecmax(n,xv)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 931228                 VECMAX
c                R. Yamartino, SRC
c
c --- PURPOSE:  For an N element array of values, XV,
c               determine the maximum value.
c
c --- INPUTS:
c
c             N     - integer - Number of elements in XV
c             XV    - real    - Array of values.
c
c --- OUTPUTS:
c
c           VECMAX  - real    - Maximun value found.
c
c --- VECMAX called by:  AREAINT
c --- VECMAX calls:       none
c----------------------------------------------------------------------
c
      real xv(n)
      data big/1.0e+20/
c
      xmax = -big
c
c --- Loop over array elements.
      do i=1,n
         xmax = amax1(xmax,xv( i ))
      enddo
      vecmax = xmax
c
      return
      end
c----------------------------------------------------------------------
      subroutine extreme(n,xv,xmin,xmax)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 931228                EXTREME
c                R. Yamartino, SRC
c
c --- PURPOSE:  For an N element array of values, XV, determine the
c               min./max. values and return as XMIN, XMAX.
c
c --- INPUTS:
c
c             N     - integer - Number of elements in XV
c             XV    - real    - Array of values.
c
c --- OUTPUTS:
c
c             XMIN  - real    - Minimun value found.
c             XMAX  - real    - Maximun value found.
c
c --- EXTREME called by:  AREAINT
c --- EXTREME calls:       none
c----------------------------------------------------------------------
c
      real xv(n)
      data big/1.0e+20/
c
      xmin =  big
      xmax = -big
c
c --- Loop over array elements.
      do i=1,n
         xmin = amin1(xmin,xv( i ))
         xmax = amax1(xmax,xv( i ))
      enddo
c
      return
      end
c----------------------------------------------------------------------
      subroutine cwyvals(nside,xv,yv,x,ymin,ymax,nhits)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 931228                CWYVALS
c                R. Yamartino, SRC
c
c --- PURPOSE:  For an NSIDEd polygon area source with vertices at
c               (upwind,crosswind) coordinates (XY,YV), relative to the
c               receptor at (0,0), determine the CrossWind Y VALS of
c               the polygon boundary intercepted by the cwosswind
c               line at upwind distance X.  The min./max. values are
c               computed and returned in YMIN/YMAX and the number of
c               legitimate values returned in NHITS.  Three values of
c               NHITS are possible.
c
c --- INPUTS:
c
c             NSIDE - integer - Number of sides (>3) for the polygon.
c             XV    - real    - Upwind distances of polygon vertices.
c             YV    - real    - Crosswind coords. of polygon vertices.
c             X     - real    - Upwind distance for eval. of YMIN/YMAX
c
c --- OUTPUTS:
c
c             YMIN  - real    - Minimun value of crosswind intercept.
c             YMAX  - real    - Maximun value of crosswind intercept.
c             NHITS - integer - Number of valid crosswind intercepts.
c                               NHITS = 0 => No crosswind intercepts
c                                            (e.g., X outside polygon)
c                               NHITS = 1 => 1 intercepts at a vertex.
c                               NHITS = 2 => 2 side intercepts.
c
c --- CWYVALS called by:  AREAINT, LSSLINT
c --- CWYVALS calls:       none
c----------------------------------------------------------------------
c
c --- SUPPLEMENTAL NOTES
c
c --- This subroutine may also be called with interchanged (XV,YV)
c     arguments to determine intercepts XMIN,XMAX at a specific value
c     of the coordinate Y.
c----------------------------------------------------------------------
c
      real xv(nside),yv(nside)
      data zero/0.0/,big/1.0e+20/
c
      ymin =  big
      ymax = -big
      nhits = 0
c
c *** Begin loop over all polygon segments.
      do 10 i=1,nside
      if(i.eq.nside) then
         ip1 = 1
         else
         ip1 = i + 1
      endif
c
      xt1 = xv( i ) - x
      xt2 = xv(ip1) - x
c
c --- Quit if X lies outside of the two ends of the segment.
      if((xt1*xt2).gt.zero) go to 10
c
c --- Test if intercept occurs at endpoint (e.g., a vertex hit)
      if(xt1.eq.zero) then
         ymin = amin1(ymin,yv( i ))
         ymax = amax1(ymax,yv( i ))
         nhits = nhits + 1
      endif
c
      if(xt2.eq.zero) then
         ymin = amin1(ymin,yv(ip1))
         ymax = amax1(ymax,yv(ip1))
         nhits = nhits + 1
      endif
c
      xtot = xt1 - xt2
c --- Quit if zero x-length segment as could only be end-point hit.
      if(xtot.eq.zero) go to 10
c     Define frac in range zero to one.
      frac = xt1 / xtot
      ytot = yv(i) - yv(ip1)
      y = yv(i) - frac * ytot
c
      ymin = amin1(ymin,y)
      ymax = amax1(ymax,y)
      nhits = nhits + 1
c
   10 continue
c
c --- Quit if X lies outside of the two ends of the segment.
      ytot = ymax - ymin
      if(ytot.lt.zero) nhits = 0
      if(nhits.eq.0) go to 20
c
c --- Must be 2 hits (e.g., vertex hit) or more, so set NHITS = 1.
      nhits = 1
c --- If the hits are separated in space then there are NHITS = 2.
      if(ytot.gt.zero) nhits = 2
c
   20 continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine cpqromb(xlower,xupper,lwflux,z,hlid,
     x                   zrterr,zstak,zbase,ppc,eps,
     x                   ss1,ss2,ss3,ss4)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980430                CPQROMB
c                R. Yamartino, SRC
c
c --- PURPOSE:  Performs Romberg integration of the polygon segment
c               in the upwind distance domain (XLOWER,XUPPER) via
c               calls to the slug line source routine LSSLINT.
c
c               Adapted to integration of multiple quantities from
c               QROMB Module of ISC2 Short Term Model - ISCST2
c
c               which performs Romberg Integration of Function Using
c               Polynomial Extrapolation for h=0 With h1(i)=h1(i-1)/4
c               Modifed To Use Variable Order Extrapolation
c
c               (as programmed on July 7, 1993 by:
c                    Jeff Wang, Roger Brode  and
c                    Adapted From Codes By Richard Strelitz, CSC)
c
c --- UPDATE
c --- V5.0-V5.0     980430  (DGS): drop dt from argument list
c --- V4.0-V5.0     971107  (DGS): add eps variable to calling arguments
c
c --- INPUTS:
c
c            XLOWER - real    - Lower limit (m) for the integration.
c            XUPPER - real    - Upper limit (m) for the integration.
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c                 Z - real    - Z coord. of receptor.
c              HLID - real    - Relevant mixing depth (m) at receptor.
c            ZRTERR - real    - Terrain elevation (m MSL) at receptor
c             ZSTAK - real    - Stack height of source of puff (m)
c             ZBASE - real    - Stack base elevation MSL (m)
c               PPC - real    - Plume Path Coefficient
c               EPS - real    - Tolerance limit for integral convergence
c
c --- OUTPUTS:
c
c            SS1    - real    - Coupling coeff. (s/m**3) #1
c            SS2    - real    - Coupling coeff. (s/m**3) #2
c            SS3    - real    - Coupling coeff. (s/m**2) #3
c            SS4    - real    - Coupling coeff. (s/m**2) #4
c
c --- CPQROMB called by:  AREAINT
c --- CPQROMB calls:      CPTRAP, POLINT
c----------------------------------------------------------------------

c --- Declarations
      parameter(K1 = 5, JMAX1 =10, ITMAX =100, EPS2 = 1.0E-20)
c *** parameter(K1 = 5, JMAX1 =10, ITMAX =100, EPS = 1.0E-6,
c ***&          EPS2 = 1.0E-20)
C**   K1    = Order of Extrapolating Polynomial
C**   JMAX1 = Maximum Number of Iterations in Halving Interval
C**   ITMAX = Maximum Number of Integral Iterations
C**   EPS   = Tolerance Limit for Convergence of the Integral
C**   EPS2  = Lower Threshold Limit for the Value of the Integral
      real s1(21), h1(21)
      real s2(21), s3(21), s4(21)
      logical lwflux
      data zero/0.0/,one/1.0/

c --- Initialize
      do j=1,jmax1
         H1(j) = zero
         s1(j) = zero
         s2(j) = zero
         s3(j) = zero
         s4(j) = zero
      enddo
      H1(1) = one

      call cptrap(xlower,xupper,lwflux,z,hlid,
     x            zrterr,zstak,zbase,ppc,
     x            s1(1),s2(1),s3(1),s4(1),1)
      ss1 = s1(1)
      ss2 = s2(1)
      ss3 = s3(1)
      ss4 = s4(1)

      do j = 2, jmax1
         h1(j) = 0.25*h1(j-1)
c ---    Obtain samples for all four integrals at once.
         call cptrap(xlower,xupper,lwflux,z,hlid,
     x               zrterr,zstak,zbase,ppc,
     x               s1(j),s2(j),s3(j),s4(j),j)
         kp = MIN0(j,k1)-1
c ---    Estimate all four integrals at once.
         call polint(h1(J-kp),s1(j-kp),kp+1,ss1,dss1)
         call polint(h1(j-kp),s2(j-kp),kp+1,ss2,dss2)
         call polint(h1(j-kp),s3(j-kp),kp+1,ss3,dss3)
         call polint(h1(j-kp),s4(j-kp),kp+1,ss4,dss4)
C***********************************************************************
C        Check The Convergence Criteria:
C        EPS is tolerance level for convergence of the integral,
C          initially set = 1.0E-4 in a PARAMETER statement in MAIN1.INC;
C        EPS2 is lower threshold for the integral, initially set = 1.0E-10
C          in a PARAMETER statement in MAIN1.INC;
C        J is number of halving intervals and must be at least 3 for
C          convergence criteria to be met.  Maximum number of intervals
C          is set by JMAX1 (=10).
C***********************************************************************
c ---    Consider the convergence of only one of the four integrals
         if ((abs(dss3) .le. eps*abs(ss3) .or. abs(ss3*dss3)
     &                  .le. eps2) .and. j .ge. 3) goto 999
      enddo

 999  return
      end
c----------------------------------------------------------------------
      subroutine cptrap(xlower,xupper,lwflux,z,hlid,
     x                 zrterr,zstak,zbase,ppc,
     x                 val1,val2,val3,val4,n)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980430                 CPTRAP
c                R. Yamartino, SRC
c
c --- PURPOSE:  Performs Trapezoidal integration of polygon segment
c               in the upwind distance domain (XLOWER,XUPPER) via
c               calls to the slug line source routine LSSLINT.
c
c               Adapted to integration of multiple quantities from
c               TRAPZD Module of ISC2 Short Term Model - ISCST2
c               which performs standard trapezoidal integration for 2-d
c               integrals.
c               (as programmed on July 7, 1993 by:
c                    Jeff Wang, Roger Brode  and
c                    Adapted From Codes By Richard Strelitz, CSC)
c
c --- UPDATE
c --- V5.0-V5.0     980430  (DGS): drop dt from argument list
c
c --- INPUTS:
c
c            XLOWER - real    - Lower limit (m) for the integration.
c            XUPPER - real    - Upper limit (m) for the integration.
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c                 Z - real    - Z coord. of receptor (m).
c              HLID - real    - Relevant mixing depth (m) at receptor.
c            ZRTERR - real    - Terrain elevation (m MSL) at receptor
c             ZSTAK - real    - Stack height of source of puff (m)
c             ZBASE - real    - Stack base elevation MSL (m)
c               PPC - real    - Plume Path Coefficient
c
c --- OUTPUTS:
c
c           VAL1    - real    - Coupling coeff. (s/m**3) #1
c           VAL2    - real    - Coupling coeff. (s/m**3) #2
c           VAL3    - real    - Coupling coeff. (s/m**2) #3
c           VAL4    - real    - Coupling coeff. (s/m**2) #4
c
c --- CPTRAP called by:  CPQROMB
c --- CPTRAP calls:      RECSPEC0, LSSLINT
c----------------------------------------------------------------------

      real del, sum1, sum2, sum3, sum4, sval1, sval2, sval3, sval4
      save neval2, sval1, sval2, sval3, sval4
      logical lwflux
      data zero/0.0/

      if(n .EQ. 1) then
         call recspec0(xupper,zrterr,zstak,zbase,ppc,
     &                 syr,szr,zpr)
         call lsslint(xupper,lwflux,z,zpr,syr,szr,hlid,
     x                sum11,sum21,sum31,sum41)

         call recspec0(xlower,zrterr,zstak,zbase,ppc,
     &                 syr,szr,zpr)
         call lsslint(xlower,lwflux,z,zpr,syr,szr,hlid,
     x                sum12,sum22,sum32,sum42)

         sum1 = sum11 + sum12
         sum2 = sum21 + sum22
         sum3 = sum31 + sum32
         sum4 = sum41 + sum42
c
         del = xupper-xlower
         sval1 = zero
         sval2 = zero
         sval3 = zero
         sval4 = zero
         neval2 = 1
      else
         del = (xupper-xlower)/neval2
         x1 = xlower+del*0.5
         sum1 = zero
         sum2 = zero
         sum3 = zero
         sum4 = zero
         do i = 1,neval2
            call recspec0(x1,zrterr,zstak,zbase,ppc,
     &                    syr,szr,zpr)
            call lsslint(x1,lwflux,z,zpr,syr,szr,hlid,
     x                   sumc1,sumc2,sumc3,sumc4)
            sum1 = sum1 + sumc1
            sum2 = sum2 + sumc2
            sum3 = sum3 + sumc3
            sum4 = sum4 + sumc4
            x1 = x1+del
         enddo
         neval2 = neval2*2
      endif
c
      val1 = 0.5 * (sval1 + del*sum1)
      sval1 = val1
c
      val2 = 0.5 * (sval2 + del*sum2)
      sval2 = val2
c
      val3 = 0.5 * (sval3 + del*sum3)
      sval3 = val3
c
      val4 = 0.5 * (sval4 + del*sum4)
      sval4 = val4
c
      return
      end
c----------------------------------------------------------------------
      subroutine lsslint(rhoa,lwflux,z,zpr,syr,szr,hlid,
     &                   ccqb,ccdq,ccizqb,ccizdq)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                LSSLINT
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the time-average coupling coefficients (s/m**3)
c               at the downwind dist. RHOA for the time period T to T+DT
c               for a crosswind line source.
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): pass ICODE to VCOUP from /CURRENT/
c --- V4.0-V4.07    971107  (DGS): add PDF logic (call PDFPATH)
c
c --- INPUTS:
c
c              RHOA - real    - Downwind line/receptor distance (m).
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c                 Z - real    - Height (m) receptor above ground
c               ZPR - real    - Height (m) of the plume above receptor
c                               terrain height (allowing for terr adj)
c         (SYR,SZR) - real    - Sigmas at the receptor before T factor.
c              HLID - real    - Relevant mixing depth (m) at receptor.
c
c     Common Block /CURRENT/ variables:
c        SYB2, SPEEDI, SRAT, ICODE
c     Common Block /PDF/ variables:
c        LPDF, SWUPF, SWDNF, SZUPB, SZDNB, WTUP, WTDN, ZUP, ZDN, RFACSQ
c     Parameters:
c        MXVERT
c
c --- OUTPUTS:
c
c              CCQB - real    - Coupling coefficient (s/m**3) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c              CCDQ - real    - Coupling coefficient (s/m**3) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c            CCIZQB - real    - Z-integrated coefficient (s/m**2) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c            CCIZDQ - real    - Z-integrated coefficient (s/m**2) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c
c --- LSSLINT called by:  CPTRAP
c --- LSSLINT calls:      CWYVALS, VCOUP, XERFDIF, ERF, ERFDIF, PDFPATH
c----------------------------------------------------------------------
c
c --- Include common blocks
      include 'params.puf'
      include 'current.puf'
      include 'pdf.puf'

      common /SLGLIN/ dxy12,rdxy12
c
      logical lwflux
c
      data srthaf/0.7071/,half/0.5/,small/1.0e-10/
      data fourth/0.25/
      data erfcut/3.0/
c
      ccqb = 0.0
      ccdq = 0.0
      ccizqb = 0.0
      ccizdq = 0.0
c
      call cwyvals(nside,xv,yv,rhoa,rhoc1,rhoc2,nhits)
      if(nhits.lt.2) go to 100
c
c --- Note that for Z coordinates, we take receptor-specific value
      zp = zpr
c
c --- Use actual values of sigmas at receptor. T factor is 1 for IAGE=0
c --- 12/3/89 Protect against divide by sigma of zero.
      sy = amax1(syr,small)
      sz = amax1(szr,small)
c
c --- All coordinates ready ! now compute coupling coefficient for
c --- a unit source (Q = 1 ug/sec)
c
c --- Check if any vertical coupling.
c --- vert = vcoup(icode,z,zp,sz,hlid) includes the 1/sqrt(2*pi) and
c --- the sum over all reflection terms.
      if(LPDF) then
c ---    Find the travel time to the receptor
         trec=AMAX1(0.0,rhoa/speedi)
         call PDFPATH(zp,hlid,trec)
         szsq=sz**2
         szdn=SQRT(szsq*swdnf+szdnb*rfacsq)
         szup=SQRT(szsq*swupf+szupb*rfacsq)
         vert= wtdn*VCOUP(icode,z,zdn,szdn,hlid) +
     &         wtup*VCOUP(icode,z,zup,szup,hlid)
      else
         vert = vcoup(icode,z,zp,sz,hlid)
      endif
c
c --- No longer always skip if no vertical coupling !!  11/12/88
      IF(.not.lwflux .and. vert .LT. SMALL) GO TO 100
c
c --- Check if any cross-slug distance coupling.
      phic1 = srthaf * srat * rhoc1 / sy
      phic2 = srthaf * srat * rhoc2 / sy
      expy = half * erfdif(phic2,phic1)
      if(expy .LT. small) goto 100
c
c --- Check if any along-slug distance coupling.
c --- 12/3/89 Protect against divide by sigma of zero.
      phia2 = srthaf * rhoa / amax1(syb2,small)
      eta2 = srthaf * (rhoa - dxy12) / sy
c
c --- For ETA1, I need the slug length at the beginning of the
c --- time step.  this is usually zero but may not be if we allow
c --- for prolonged steady-state releases somehow. however, this
c --- would then require a mechanism for telling this routine
c --- that IAGE > 0 but all conditions (e.g., met., source strength)
c --- are unchanged. since this may never be implemented, assume zero
c --- slug length and set ETA1 = PHIA2
c --- Modify eta1 to use sigma y at receptor rather than at source
      eta1 = srthaf * rhoa / sy
c
c --- Eliminate cases beyond the causal frontier.
c --- IF(ETA1.GT.ERFCUT .AND. ETA2.GT.ERFCUT) GO TO 100 for downwind
c --- receptors, but in general (including upwind receptors)
c --- consider the following approach.
      prod = eta2 * eta1
      if(prod.GT.0.0 .AND. abs(eta1).GT.erfcut .AND.
     &                     abs(eta2).GT.erfcut) goto 100
c
c --- Compute the causality factors FCAUS0 AND FCAUS1.
c --- For this I need the VMWS = speedi * srat
c --- coeff = sy / ( vmws * dt )
      erfa2 = 1.0
      if(phia2.LT.0.0) erfa2 = -1.0
      if(abs(phia2) .LE. erfcut) erfa2 = erf(phia2)
      coeff = SRTHAF/(eta1-eta2)
      coeff2 = coeff * coeff
c
      call xerfdif(eta2,eta1,xint0,xint1)
c
      fcaus0 = half * erfa2  +  srthaf * coeff * xint0
c
      fcaus1 = fourth * erfa2  -  coeff2 * xint1  +
     x         srthaf * coeff2 * ( rhoa / sy ) * xint0
c
c --- Compute the time-average conc. terms for unit emission rate line!
      ccoup = expy  / speedi
      if(ccoup .lt. small) go to 100
c
      if(fcaus0 .gt. small) then
         ccizqb = ccoup * fcaus0
         ccqb = vert * ccizqb
      endif
c
      if(fcaus1 .gt. small) then
         ccizdq = ccoup * fcaus1
         ccdq = vert * ccizdq
      endif
c
c*****
c *** write(6,*)'LSSLINT -- New slug -- vert = ',vert,
c ***1 '  expy = ',expy,'  speedi = ',speedi,'  sy = ',sy,
c ***2 '  sz = ',sz
c*****
c
c*****
c *** write(6,*)'SUBR. LSSLINT -- CCQB = ',ccqb,' CCDQ = ',ccdq,
c ***1 ' CCIZQB = ',ccizqb,' CCIZDQ = ',ccizdq,' DSAMP = ',dsamp
c ****
c
  100 return
      end
c----------------------------------------------------------------------
      subroutine polint(xa,ya,n1,y1,dy1)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 931229                 POLINT
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes Y(X) as Interpolation of XA, YA
c
c               Except for altered COMMOMs this is a copy of the
c               POLINT Module of ISC2 Short Term Model - ISCST2
c
c               (as programmed on July 7, 1993 by:
c                    Jeff Wang, Roger Brode  and
c                    Adapted From Codes By Richard Strelitz, CSC)
c
c --- INPUTS:
c
c             XA    - real    - The edge pairs
c             YA    - real    - The dimension of the edge pairs.
c
c --- OUTPUTS:
c
c             Y1    - real    - Interpolated value of YA relative to XA
c
c --- POLINT called by:  CPQROMB
c --- POLINT calls:      none
c----------------------------------------------------------------------

C     Variable Declarations
c     INCLUDE 'MAIN1.INC'
c     INCLUDE 'MAIN2.INC'
c     INCLUDE 'MAIN3.INC'
      PARAMETER (K1 = 5, JMAX1 =10, ITMAX =100, EPS = 1.0E-6,
     &           EPS2 = 1.0E-20)
C**   K1    = Order of Extrapolating Polynomial
C**   JMAX1 = Maximum Number of Iterations in Halving Interval
C**   ITMAX = Maximum Number of Integral Iterations
C**   EPS   = Tolerance Limit for Convergence of the Integral
C**   EPS2  = Lower Threshold Limit for the Value of the Integral

      DIMENSION XA(N1),YA(N1),C1(JMAX1),D1(JMAX1)

C     Variable Initializations
c     MODNAM = 'POLINT'

      ns = n1
      y1 = ya(ns)
c     dIFt = abs(xa(n1))
C     Set Up Interpolation/Divided Differences
      do 11 i = 1,n1
         c1(i) = ya(i)
         d1(i) = ya(i)
  11  CONTINUE

C     Compute Table Entries
      ns = ns-1
      do 13 m1 = 1,n1-1
         do 12 i = 1,n1-m1
            ho = xa(i)
            hp = xa(i+m1)
            w = c1(i+1)-d1(i)
            den = w/(ho-hp)
            d1(i) = hp*den
            c1(i) = ho*den
  12     CONTINUE
         IF (2*ns .lt. n1-m1) THEN
            dy1 = c1(ns+1)
         else
            dy1 = d1(ns)
            ns = ns-1
         END IF
         y1 = y1+dy1
  13  CONTINUE

      RETURN
      END
c----------------------------------------------------------------------
      subroutine calcpf(xold,yold,xnew,ynew,ppc,istab,iru,sigv,sigw,
     1                  el,bvf,uavg,dpbl,qold,qnew,icode,hlid,puffr,
     2                  vdpvd,nspec,q01wet,q01dry,vd,fracwet,tsampi,
     3                  tfract,ldbhr,lcalm,lclip)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                 CALCPF
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  For a given puff, perform the loop over all receptors
c               for each species. Time-averaged coupling coefficients
c               are used to compute concentration and wet and dry
c               deposition fluxes.
c
c --- UPDATE
c --- V5.75-V6.22   070921  (DGS): Fix bug in wet flux calculation.
c                                  Horizontal sampling factors were
c                                  calculated only if mass diffused to
c                                  the surface, but are also needed for
c                                  washout.
c --- V5.7-V5.75    050225  (DGS): Add DPBL arg to pass on to PUFRECS
c                                  for SETCSIG and TAULY
c --- V5.4-V5.7     030402  (DGS): Drop impact at receptors in/near
c                                  cavity zone for PRIME downwash
c --- V5.0-V5.4     000602  (DGS): add temperature excess logic (FOG)
c                                  at discrete receptors
c --- V5.0-V5.0     990228b (DGS): add non-zero receptor height
c --- V5.0-V5.0     980918  (DGS): add factor to estimate non-Gaussian
c                                  horizontal distribution (area source)
c --- V4.0-V5.0     971107  (DGS): use effective "pole" height from
c                                  call to PUFRECS
c                   971107  (DGS): add ICODE to VCOUP calls
c --- V4.0-V4.07    971107  (DGS): add PDF logic (call PDFPATH)
c
c --- INPUTS:
c
c         XOLD,YOLD - real    - Starting position (m)
c         XNEW,YNEW - real    - Ending position (m)
c               PPC - real    - Plume Path Coefficient
c             ISTAB - integer - PGT stability class
c               IRU - integer - Rural(0) or urban(1) flag
c              SIGV - real    - Sigma-v velocity (m/s)
c              SIGW - real    - Sigma-w velocity (m/s)
c                EL - real    - Monin-Obukhov length (m)
c               BVF - real    - Brunt-Vaisala frequency (1/s)
c              UAVG - real    - Mean transport speed (m/s) over xtotm
c              DPBL - real    - Depth of PBL (m)
c       QOLD(nspec) - real    - Puff mass (g) at beginning of time step
c       QNEW(nspec) - real    - Puff mass (g) at end of time step
c             ICODE - integer - Code for vertical layering of puff
c              HLID - real    - Height of reflection lid (m)
c             PUFFR - real    - Puff radius in computational grid units
c      VDPVD(nspec) - real    - Conc. correction factor (vd'/vd) used
c                               to estimate effect of dry deposition and
c                               vertical mixing on near-surface concs.
c             NSPEC - real    - Number of species
c  Q01WET(mxspec,2) - real    - Puff mass before/after wet removal (g)
c  Q01DRY(mxspec,2) - real    - Puff mass before/after dry removal (g)
c         VD(nspec) - real    - Dry deposition velocity (m/s) for each
c                               species
c    FRACWET(nspec) - real    - Fraction of mass left in puff after wet
c                               removal
c            TSAMPI - real    - 1.0/(TSAMP)
c            TFRACT - real    - 1./(number of samples in averaging pd)
c             LDBHR - logical - Debug output (T,F)
c             LCALM - logical - .TRUE. if this puff is in a calm
c             LCLIP - logical - .TRUE. if receptor-specific sigmas are
c                               limited to range defined by values at
c                               the start/end of step
c
c     Common Block /FLAGS/ variables:
c        MCTADJ
c     Common Block /FOG/ variables:
c        LADTFOG, TXSMXFOG
c     Common Block /PDF/ variables:
c        LPDF, SWUPF, SWDNF, SWUPB, SWDNB, WTUP, WTDN, ZUP, ZDN, RFACSQ
c     Parameters:
c        MXNX, MXNY, NSPEC, MXNXG, MXNYG, MXREC, IO6
c
c --- OUTPUTS:
c
c     Common block /CHIFLX/ variables:
c        CHISAM(mxnxg,mxnyg,mxspec),DFSAM(mxnxg,mxnyg,mxspec),
c        WFSAM(mxnxg,mxnyg,mxspec),CHIREC(mxrec,mxspec),
c        DFREC(mxrec,mxspec),WFREC(mxrec,mxspec),
c        CHICT(mxrect,mxspec)
c
c --- CALCPF called by:  COMP
c --- CALCPF calls:      PFSCRN, PUFRECS, PFSAMP, VCOUP, PDFPATH,
c                        ASDF
c----------------------------------------------------------------------
c --- Adapted from:
c --- MESOPUFF II   VERSION 5.1   LEVEL 921025                   GRICN2
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'chiflx.puf'
      include 'ctsgdat.puf'
      include 'flags.puf'
      include 'fog.puf'
      include 'grid.puf'
      include 'nongrd.puf'
      include 'pdf.puf'
c
      real qold(nspec),qnew(nspec),vdpvd(nspec)
      real q01wet(mxspec,2),q01dry(mxspec,2),vd(nspec),fracwet(nspec)
      real xadj(mxspec)
      logical ldbhr,lwet,limpact,lcalm,lclip

c --- Set number of sigmas to reach "edge" of puff (check subr. COMP !)
      data nsigma/3/
c
c --- Determine if wet removal is active this step: set adjustment
      lwet=.FALSE.
      if(mwet.EQ.1) then
         do i=1,nspec
            if(fracwet(i).LT.1.0) lwet=.TRUE.
            wetavg=0.5*(q01wet(i,1)+q01wet(i,2))
            if(wetavg.NE.0.0) then
               xadj(i)=tfract*tsampi*q01wet(i,1)/wetavg
            else
               xadj(i)=0.0
            endif
         enddo
      endif
c
c --- Check for mass in lower layer of puff (in contact with ground)
      mass=0
      do is=1,nspec
         if(qold(is).GT.0.0 .OR. qnew(is).GT.0.0) mass=1
      enddo

c --- Skip this puff if no mass in lower layer, and if no wet removal
      if(mass.EQ.0. .AND. .NOT.lwet) return
c
c --- Calculate vertical distribution factor (uniform ONLY)
      if(icode.EQ.2 .OR. icode.EQ.6) then
c ---    ICODE=2,6:  within past/present mixed layer and uniform
         f1=1./hlid
      elseif(icode .EQ. 4) then
c ---    ICODE=4:  above mixed layer and uniform (no ground-level concs)
         f1=0.
      else
c ---    ICODE ODD: Gaussian,  set f1 to 1.0 for now
         f1=1.0
      endif

c --- Skip this puff if vertical factor is zero, and if no wet removal
      if(f1.EQ.0. .AND. .NOT.lwet) return
c
c -------------------------------------------------------------
c --- SAMPLING GRID RECEPTOR POINTS  (uses SAMPLING grid units)
c -------------------------------------------------------------
c
      if(.NOT.lsamp) goto 101
c --- Compute the start of the sampling grid in MET grid units
      xbsamp=float(ibsamp)-0.5
      ybsamp=float(jbsamp)-0.5
c --- Calculate puff center coordinates in SAMPLING grid units
      samxo=(xold-xbsamp)*meshdn+1.0
      samyo=(yold-ybsamp)*meshdn+1.0
      samxn=(xnew-xbsamp)*meshdn+1.0
      samyn=(ynew-ybsamp)*meshdn+1.0
c --- Convert puff radius to SAMPLING grid units
      samr=puffr*meshdn
      samrp1=samr+1.0
      samr2=samr*samr
c
c --- Determine section of grid affected by this puff
      il=amin1(samxo-samrp1,samxn-samrp1,float(nxsam))+0.001
      il=max0(1,il)
      ir=amax1(samxo+samrp1,samxn+samrp1,1.0)+0.001
      ir=min0(nxsam,ir)
      jb=amin1(samyo-samrp1,samyn-samrp1,float(nysam))+0.001
      jb=max0(1,jb)
      jt=amax1(samyo+samrp1,samyn+samrp1,1.0)+0.001
      jt=min0(nysam,jt)
c
c --- Loop over receptors
      do 100 isamp=il,ir
         xr=float(isamp)
         do 100 jsamp=jb,jt
            yr=float(jsamp)
c
c ---       Compute nearest approach of puff to receptor and screen out
c ---       receptors that are too far away
            call pfscrn(samxo,samyo,samxn,samyn,xr,yr,samr2,
     &                  samd2,limpact)
c
            if(.NOT.limpact) goto 100
c
c ---------------------------------------------------------------------
c ---       Obtain receptor-specific sigmas and puff height (gradual
c ---       rise) including any terrain adjustment to height
c ---------------------------------------------------------------------
c ---       Get location of the receptor (m) (on met. grid)
            xrec = xbsamp*dgrid+float(isamp-1)*delsam
            yrec = ybsamp*dgrid+float(jsamp-1)*delsam
            zrec = 0.0
            call pufrecs(lclip,xrec,yrec,zrec,istab,iru,sigv,sigw,el,
     &                   bvf,uavg,dpbl,elevg(isamp,jsamp),ppc,lcalm,
     &                   trec,frec,syrec,szrec,zgrise,zpr,zrpole,
     &                   rfacsq,idrop)
c ---       PRIME downwash:  skip 'dropped' receptors in cavity zone
            if(idrop.EQ.1) goto 100
c
c ---       Check impact based on receptor-specific sigma-y and skip
c ---       this receptor if no impact
c ---       Convert receptor specific sigma-y to SAMPLING grid units
            syrgu=syrec/delsam
c ---       Puff radius (squared) at receptor
            pr2=(nsigma*syrgu)**2
            if(samd2.GT.pr2) goto 100
c
c ***
      if(LDBHR) then
      write(io6,*) 'CALCPF: Grid rec x,y  = ',xrec,yrec
      write(io6,*) '        Trans. Rise   = ',zgrise
      write(io6,*) '        Adj. Puff Ht. = ',zpr
      write(io6,*) '    Adj. Rec Pole Ht. = ',zrpole
      write(io6,*) '       Sigma-y @ rec. = ',syrec
      write(io6,*) '       Sigma-z @ rec. = ',szrec
      write(io6,*) '   Reflecting Lid Ht. = ',hlid
      write(io6,*) '     Time to receptor = ',trec
      write(io6,*) ' G.Rise Adj to BID**2 = ',rfacsq
      endif
c ***
c
            if(mod(icode,2).EQ.1) then
c ---          Sample vertical distribution (GAUSSIAN)
               if(LPDF) then
                  call PDFPATH(zpr,hlid,trec)
                  szrecsq=szrec**2
                  argup=szrecsq*swupf+szupb*rfacsq
                  argdn=szrecsq*swdnf+szdnb*rfacsq
                  szdn=SQRT(argdn)
                  szup=SQRT(argup)
                  f1= wtdn*VCOUP(icode,zrpole,zdn,szdn,hlid) +
     &                wtup*VCOUP(icode,zrpole,zup,szup,hlid)
               else
                  f1=vcoup(icode,zrpole,zpr,szrec,hlid)
               endif
c ***
      if(LDBHR) then
      write(io6,*) '       zrpole, vcoup  = ',zrpole,f1
      endif
c ***
            endif
c
c ---       Sample horizontal distribution if puff impact reaches the
c ---       surface due to diffusion or washout
            if(f1.GT.0. .OR. mwet.EQ.1) then
               call pfsamp(samxo,samyo,samxn,samyn,xr,yr,syrgu,samd2,
     &                    xi1,xi2)
c ---          Normalize horizontal sampling result by 1/(2*pi*syrec^2)
c ---          and scale by the Area Source Distribution Factor
c ---          (nominally 1.0); syrec is in meters;
               samdm=SQRT(samd2)*delsam
               dinv=ASDF(ldbhr,samdm,syrec)/(6.2831853*syrec**2)
               t2=xi2*dinv
               t1=xi1*dinv-t2
c ---          (QOLD*T1+QNEW*T2 IS THE HORIZONTAL TERM * SOURCE TERM OF
c ---           THE GAUSSIAN EQN.)
            endif

c ---       Concentration and Dry Fluxes
            if(f1.GT.0.) then
               xtemp=f1*tfract
               do ipol=1,nspec
                  conc=vdpvd(ipol)*xtemp*(qold(ipol)*t1+qnew(ipol)*t2)
                  chisam(isamp,jsamp,ipol)=chisam(isamp,jsamp,ipol)+conc
                  if(mdry.EQ.1) then
                     dfsam(isamp,jsamp,ipol)=dfsam(isamp,jsamp,ipol)+
     &                    (q01dry(ipol,1)*t1+q01dry(ipol,2)*t2)*
     &                     vd(ipol)*vdpvd(ipol)*xtemp
                  endif
               enddo
            endif
c
c ---       Wet fluxes
            if(mwet.EQ.1) then
               do ipol=1,nspec
                  wfsam(isamp,jsamp,ipol)=wfsam(isamp,jsamp,ipol)+
     &                 (q01wet(ipol,1)*t1+q01wet(ipol,2)*t2)*
     &                 (1.0-fracwet(ipol))*xadj(ipol)
               enddo
            endif
100   continue
101   continue
c
c ----------------------------------------------------
c --- DISCRETE RECEPTOR POINTS  (using MET grid units)
c ----------------------------------------------------
c
      if(nrec.LE.0) goto 201
c
      puffr2=puffr*puffr
c
c --- Loop over receptors
      do i=1,nrec
c
c ---    Compute nearest approach of puff to receptor and screen out
c ---    receptors that are too far away
         call pfscrn(xold,yold,xnew,ynew,xng(i),yng(i),puffr2,
     &               d2,limpact)
c
         if(.NOT.limpact) goto 200
c
c ---------------------------------------------------------------
c ---    Obtain receptor-specific sigmas and puff height (gradual
c ---    rise) including any terrain adjustment to height
c ---------------------------------------------------------------
c ---    Get location of the receptor (m) (on met. grid)
         xrec = xng(i)*dgrid
         yrec = yng(i)*dgrid
         zrec = zng(i)
         call pufrecs(lclip,xrec,yrec,zrec,istab,iru,sigv,sigw,el,bvf,
     &                uavg,dpbl,elevng(i),ppc,lcalm,
     &                trec,frec,syrec,szrec,zgrise,zpr,zrpole,
     &                rfacsq,idrop)
c ---    PRIME downwash:  skip 'dropped' receptors in cavity zone
         if(idrop.EQ.1) goto 200
c
c ---    Check impact based on receptor-specific sigma-y and skip
c ---    this receptor if no impact
c ---    Convert receptor specific sigma-y to MET grid units
         syrgu=syrec*dgridi
c ---    Puff radius (squared) at receptor
         pr2=(nsigma*syrgu)**2
         if(d2.GT.pr2) goto 200
c
c ***
      if(LDBHR) then
      write(io6,*) 'CALCPF: Disc rec x,y,z= ',xrec,yrec,zrec
      write(io6,*) '        Trans. Rise   = ',zgrise
      write(io6,*) '        Adj. Puff Ht. = ',zpr
      write(io6,*) '    Adj. Rec Pole Ht. = ',zrpole
      write(io6,*) '       Sigma-y @ rec. = ',syrec
      write(io6,*) '       Sigma-z @ rec. = ',szrec
      write(io6,*) '   Reflecting Lid Ht. = ',hlid
      write(io6,*) '     Time to receptor = ',trec
      write(io6,*) ' G.Rise Adj to BID**2 = ',rfacsq
      endif
c ***
c
         if(mod(icode,2).EQ.1) then
c ---       Sample vertical distribution (GAUSSIAN)
            if(LPDF) then
               call PDFPATH(zpr,hlid,trec)
               szrecsq=szrec**2
               argup=szrecsq*swupf+szupb*rfacsq
               argdn=szrecsq*swdnf+szdnb*rfacsq
               szdn=SQRT(argdn)
               szup=SQRT(argup)
               f1= wtdn*VCOUP(icode,zrpole,zdn,szdn,hlid) +
     &             wtup*VCOUP(icode,zrpole,zup,szup,hlid)
            else
               f1=vcoup(icode,zrpole,zpr,szrec,hlid)
            endif
c ***
      if(LDBHR) then
      write(io6,*) '       zrpole, vcoup  = ',zrpole,f1
      endif
c ***
         endif
c
c ---    Sample horizontal distribution if puff impact reaches the
c ---    surface due to diffusion or washout
         if(f1.GT.0. .OR. mwet.EQ.1) then
            call pfsamp(xold,yold,xnew,ynew,xng(i),yng(i),syrgu,d2,
     &                  xi1,xi2)
c ---       Normalize horizontal sampling result by 1/(2*pi*syrec^2)
c ---       and scale by the Area Source Distribution Factor
c ---       (nominally 1.0); syrec is in meters;
            dm=SQRT(d2)*dgrid
            dinv=ASDF(ldbhr,dm,syrec)/(6.2831853*syrec**2)
            t2=xi2*dinv
            t1=xi1*dinv-t2
         endif

         if(f1.GT.0.) then
c ---       Compute concentration
            xtemp=f1*tfract
            do ipol=1,nspec
               conc=vdpvd(ipol)*xtemp*(qold(ipol)*t1+qnew(ipol)*t2)
               chirec(i,ipol)=chirec(i,ipol)+conc
               if(ipol.EQ.2 .AND. LADTFOG) then
c ---             FOG: SUM the T excess (ipol=2) at receptor but
c ---             do not allow sum to exceed excess at release
                  chirec(i,ipol)=AMIN1(txsmxfog,chirec(i,ipol))
               endif
            enddo
         endif
c
c ---    Wet fluxes
         if(mwet.EQ.1) then
            do ipol=1,nspec
               wfrec(i,ipol)=wfrec(i,ipol)+
     &              (q01wet(ipol,1)*t1+q01wet(ipol,2)*t2)*
     &              (1.0-fracwet(ipol))*xadj(ipol)
            enddo
         endif
c
c ---    Dry fluxes
         if(mdry.EQ.1 .AND. f1.GT.0.) then
            do ipol=1,nspec
               dfrec(i,ipol)=dfrec(i,ipol)+
     &              (q01dry(ipol,1)*t1+q01dry(ipol,2)*t2)*
     &               vd(ipol)*vdpvd(ipol)*xtemp
            enddo
         endif
c
c ---    End computation of impact at receptor
200      continue
c
c --- End loop over discrete receptors
      enddo
c
201      continue
c
c ----------------------------------------------------
c --- CTSG RECEPTOR POINTS  (using MET grid units)
c --- CALM conditions ONLY!
c ----------------------------------------------------
c
      if(nctrec.LE.0 .OR. .NOT.lcalm) return
c
      puffr2=puffr*puffr
c
c --- Loop over receptors
      do i=1,nctrec
c
c ---    Compute nearest approach of puff to receptor and screen out
c ---    receptors that are too far away
         call pfscrn(xold,yold,xnew,ynew,xrct(i),yrct(i),puffr2,
     &               d2,limpact)
c
         if(.NOT.limpact) goto 300
c
c ---------------------------------------------------------------
c ---    Obtain receptor-specific sigmas and puff height (gradual
c ---    rise) assuming no terrain adjustment to height
c ---------------------------------------------------------------
c ---    Get location of the receptor (m) (on met. grid)
         xrec = xrct(i)*dgrid
         yrec = yrct(i)*dgrid
         zrec = 0.0
         call pufrecs(lclip,xrec,yrec,zrec,istab,iru,sigv,sigw,el,bvf,
     &                uavg,dpbl,0.0,ppc,lcalm,
     &                trec,frec,syrec,szrec,zgrise,zpr,zrpole,
     &                rfacsq,idrop)
         zrpole=0.0
c ---    PRIME downwash:  skip 'dropped' receptors in cavity zone
         if(idrop.EQ.1) goto 300
c
c ---    Check impact based on receptor-specific sigma-y and skip
c ---    this receptor if no impact
c ---    Convert receptor specific sigma-y to MET grid units
         syrgu=syrec*dgridi
c ---    Puff radius (squared) at receptor
         pr2=(nsigma*syrgu)**2
         if(d2.GT.pr2) goto 300
c
c ***
      if(LDBHR) then
      write(io6,*) 'CALCPF: calm CTSG x,y  = ',xrec,yrec
      write(io6,*) '         Trans. Rise   = ',zgrise
      write(io6,*) '         Adj. Puff Ht. = ',zpr
      write(io6,*) '     Adj. Rec Pole Ht. = ',zrpole
      write(io6,*) '        Sigma-y @ rec. = ',syrec
      write(io6,*) '        Sigma-z @ rec. = ',szrec
      write(io6,*) '    Reflecting Lid Ht. = ',hlid
      write(io6,*) '     Time to receptor = ',trec
      write(io6,*) ' G.Rise Adj to BID**2 = ',rfacsq
      endif
c ***
c
         if(mod(icode,2).EQ.1) then
c ---       GAUSSIAN: sample vertical distribution at the surface if
c ---       non-stable class (dividing streamline is 0); sample at
c ---       receptor elevation above base of hill if stable (impingement
c ---       case)
            if(istab.GT.4) then
               zrpole=elrect(i)-hilldat(4,ihill(i))
               zrpole=amax1(0.0,zrpole)
            else
               zrpole=0.0
            endif
            if(LPDF) then
               call PDFPATH(zpr,hlid,trec)
               szrecsq=szrec**2
               argup=szrecsq*swupf+szupb*rfacsq
               argdn=szrecsq*swdnf+szdnb*rfacsq
               szdn=SQRT(argdn)
               szup=SQRT(argup)
               f1= wtdn*VCOUP(icode,zrpole,zdn,szdn,hlid) +
     &             wtup*VCOUP(icode,zrpole,zup,szup,hlid)
            else
               f1=vcoup(icode,zrpole,zpr,szrec,hlid)
            endif
c ***
      if(LDBHR) then
      write(io6,*) '        zrpole, vcoup  = ',zrpole,f1
      endif
c ***
         endif

c ---    Sample horizontal distribution if puff impact reaches the
c ---    surface due to diffusion (no Wet fluxes at CTSG receptors)
         if(f1.GT.0.) then
            call pfsamp(xold,yold,xnew,ynew,xrct(i),yrct(i),syrgu,d2,
     &                  xi1,xi2)
c ---       Normalize horizontal sampling result by 1/(2*pi*syrec^2)
c ---       and scale by the Area Source Distribution Factor
c ---       (nominally 1.0); syrec is in meters;
            dm=SQRT(d2)*dgrid
            dinv=ASDF(ldbhr,dm,syrec)/(6.2831853*syrec**2)
            t2=xi2*dinv
            t1=xi1*dinv-t2
         endif
         if(f1.GT.0.) then
c ---       Compute concentration
            xtemp=f1*tfract
            do ipol=1,nspec
               conc=vdpvd(ipol)*xtemp*(qold(ipol)*t1+qnew(ipol)*t2)
               chict(i,ipol)=chict(i,ipol)+conc
            enddo
         endif
c
c ---    No Wet or Dry fluxes at CTSG receptors!
c
c ---    End computation of impact at receptor
300      continue
c
c --- End loop over CTSG receptors during CALM conditions
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine pfscrn(xold,yold,xnew,ynew,xrec,yrec,puffr2,
     &                  dist2,limpact)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                 PFSCRN
c                J. Scire, D. Strimaitis,  SRC
c
c --- PURPOSE:  For a given puff and receptor, use the puff radius at
c               the end of the step and the trajectory to screen out
c               cases with zero contribution.
c
c --- INPUTS:   (*  Assumes all distance units are consistent)
c
c         XOLD,YOLD - real    - Starting position (*)
c         XNEW,YNEW - real    - Ending position (*)
c         XREC,YREC - real    - Receptor position (*)
c            PUFFR2 - real    - Square of puff radius at end of step (*)
c
c --- OUTPUTS:
c             DIST2 - real    - Square of distance of closest approach
c                               of puff to receptor (*)
c           LIMPACT - logical - Calculate impact? (TRUE/FALSE)
c
c
c --- PFSCRN called by:  CALCPF
c --- PFSCRN calls:      none
c----------------------------------------------------------------------

      logical limpact

      dx=xnew-xold
      dy=ynew-yold
      dx1=xold-xrec
      dy1=yold-yrec

c --- Length of trajectory
      c1=dx*dx+dy*dy
c
      a=c1/puffr2
c
c --- Calculate distance of closest approach of puff to receptor
      if(a.LT.1.e-4) then
c ---    Prevent numerical problems at very low wind speeds
         dist2=(xrec-(xold+0.5*dx))**2+(yrec-(yold+0.5*dy))**2
      else
         c2=dx*dx1+dy*dy1
         pc=-c2/c1
         pc=amax1(pc,0.0)
         pc=amin1(pc,1.0)
         xpc=xold+dx*pc
         ypc=yold+dy*pc
         dist2=(xrec-xpc)**2+(yrec-ypc)**2
      endif
c
c --- Compare distance to puff radius to determine impact
      if(dist2.GT.puffr2) then
         limpact=.FALSE.
      else
         limpact=.TRUE.
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine pfsamp(xold,yold,xnew,ynew,xrec,yrec,sygu,dist2,
     &                  xi1,xi2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                 PFSAMP
c                J. Scire,  SRC
c
c --- PURPOSE:  For a given puff and receptor, compute the time-
c               averaged coupling coefficients used to compute
c               concentration and wet and dry deposition fluxes.
c
c --- INPUTS:   (*  Assumes all distance units are consistent)
c
c         XOLD,YOLD - real    - Starting position (*)
c         XNEW,YNEW - real    - Ending position (*)
c         XREC,YREC - real    - Sampling position (*)
c              SYGU - real    - Sigma-y at receptor (*)
c             DIST2 - real    - Square of distance of closest approach
c                               of puff to receptor (*)
c
c --- OUTPUTS:  (unitless)
c               XI1 - real    - Integral I1 in sampling function
c               XI2 - real    - Integral I2 in sampling function
c
c
c --- PFSAMP called by:  CALCPF
c --- PFSAMP calls:      none
c----------------------------------------------------------------------
c --- Adapted from:
c --- MESOPUFF II   VERSION 5.1   LEVEL 920930                   SAMPLE
c----------------------------------------------------------------------

      data rt2/1.4142136/,rtpiby2/1.2533141/

      xi1=0.0
      xi2=0.0

      dx=xnew-xold
      dy=ynew-yold
      dx1=xold-xrec
      dy1=yold-yrec
c
      c1=dx*dx+dy*dy
      tsy=sygu*sygu
      a=c1/tsy
c
c --- Prevent numerical problems at very low wind speeds
      if(a.LT.1.e-4) then
c ---    Factor of 0.5 averages (qold+qnew)
         xi2=0.5*exp(-dist2/(2.*tsy))
         xi1=2.*xi2
         return
      endif
c
      sqrta=sqrt(a)
      sqrt2a=rt2*sqrta
      c2=dx*dx1+dy*dy1
      b=c2/tsy
      c=(dx1*dx1+dy1*dy1)/tsy
c
      xxexp=exp(0.5*(b*b/a-c))
c --- Use error function difference routine
c --- XI1=(rtpiby2/SQRTA)*XXEXP*(ERF((A+B)/SQRT2A)-ERF(B/SQRT2A))
      xi1=(rtpiby2/sqrta)*xxexp*(erfdif((a+b)/sqrt2a,b/sqrt2a))
      b2da=b*b/a
      xi2=-b*xi1/a+(xxexp/a)*(exp(-0.5*b2da)-exp(-0.5*(a+2.*b+b2da)))
      return

      end
c----------------------------------------------------------------------
      subroutine pufrecs(lclip,x,y,z,istab,iru,sigv,sigw,el,bvf,uavg,
     &                   dpbl,zrterr,ppcoef,lcalm,
     &                   trec,frac,syr,szr,hgr,zpr,zrpole,rfacsq,idrop)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                PUFRECS
c                D. Strimaitis
C
c --- PURPOSE:  Computes the receptor-specific sigmas y and z, and
c               finds receptor-specific puff height (gradual rise)
c               with terrain adjustments for PUFFS
c
c --- UPDATE
c --- V6.23-V6.261  080520  (DGS): Replace call to PRSS with GRISE
c --- V6.22-V6.23   080204  (DGS): Remove stack-tip downwash adjustment
c                                  to gradual rise because adjustment
c                                  is done within GRISE.
c --- V6.2-V6.22    070921  (DGS): Check for imet outside valid range
c                                  of 1 to MXMETSAV+1
c --- V6.1-V6.2     070629  (DGS): move CALM re-assignment of IDW0() to
c                                  SETPUF so that downwash effects are
c                                  turned off as soon as a puff reaches
c                                  a calm area (add QA here).
c --- V5.75-V6.1    050915  (DGS): Add IQSTEP arg in call to WAKE_TAB
c --- V5.725-V5.75  050225  (DGS): add platform ht to DWSIGS call for
c                                  ISC building downwash (MBDW=1)
c                   050225  (DGS): Add DPBL arg to pass on to SETCSIG
c                                  for TAULY
c --- V5.7-V5.725   050128  (DGS): fix bug that did not update the rise
c                                  factor when the PRIME wake tables are
c                                  used to obtain receptor-specific
c                                  sigmas
c --- V5.7-V5.73    040611  (DGS): add gravitational settling for one
c                                  particle size (plume tilt)
c --- V5.5-V5.7     030402  (DGS): add PRIME downwash gradual rise and
c                                  sigma tables, and add IDROP to skip
c                                  impact at receptors in/near the
c                                  cavity zone (contribution already
c                                  added)
c --- V5.4-V5.5     010730  (DGS): correct initial sigma used with
c                                  downwash sigma
c --- V5.3-V5.4     000602_2(DGS): add initial sigmas to downwash
c                                  sigmas in quadrature
c --- V5.0-V5.3     991222b (DGS): pass momentum flux to STKTIP
c --- V5.0-V5.0     990228a (JSS): screen for zero puff height in 
c                                  terrain adjustment (CTADJ=2)
c --- V5.0-V5.0     990228b (DGS): add receptor ht above ground
c --- V5.0-V5.0     980918  (DGS): use quadrature to include initial
c                                  area source size
c --- V5.0-V5.0     980615  (DGS): remove extra sigma-z virtual calls
c --- V5.0-V5.0     980304  (DGS): use SY0,SZ0 for minimum sigmas
c --- V4.0-V5.0     971107  (DGS): compute effective "pole" height
c                                  of receptor for option MCTADJ=2
c                   971107  (DGS): initialize gradual rise at final
c                                  rise for x < 10 "Hb"
c --- V4.0-V4.07    971107  (DGS): add time to receptor and rise factor
c                                  squared to arg list
c --- V4.0-V5.0     971107  (DGS): alter puff height at receptor
c                                  position for option MCTADJ=2
c                   971107  (DGS): use SLGFRAC to provide puff-step
c                                  geometry and relative receptor pos.
c                   971107  (DGS): extrapolate puff sigmas beyond step
c                                  when puff "passes" receptor, even if
c                                  LCLIP is .TRUE.;do not clip distance
c                                  to receptor
c
c --- INPUTS:
c
c             LCLIP - logical - .TRUE. : limit "receptor position" to
c                                        lie within puff trajectory for
c                                        local puff influence
c                               .FALSE.: always use actual receptor
c                                        positionto determine sigmas
c           (X,Y,Z) - real    - Coordinates of the receptor (m), where
c                               Z is above ground, not sea level
c                               NOTE: All Sigmas before any T factors.
c             ISTAB - integer - PGT stability class
c               IRU - integer - Rural(0) or urban(1) flag
c              SIGV - real    - Sigma-v velocity (m/s)
c              SIGW - real    - Sigma-w velocity (m/s)
c                EL - real    - Monin-Obukhov length (m)
c               BVF - real    - Brunt-Vaisala frequency (1/s)
c              UAVG - real    - Mean transport speed (m/s) over xtotm
c              DPBL - real    - Depth of PBL (m)
c            ZRTERR - real    - Terrain elevation (m MSL) at receptor
c            PPCOEF - real    - Plume path coefficient
c             LCALM - logical - .TRUE. if this puff is in a calm
c
c     Common Block /COMPARM/ variables:
c        SYMIN, SZMIN, TBD
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1, SYB1, SZB1,
c        XE1, YE1, ZE1, SYE1, SZE1,
c        xttb1,xtte1,tb1,te1,vsetl,
c        vtyb1,vtzb1,vtye1,vtze1,
c        vdyb1,vdzb1,vdye1,vdze1,
c        bidsq, sy0sq, IPNUM, ISTYPE, IQSTEP,
c        IDOPTY, IDOPTZ, ZPLAT
c     Common Block /FLAGS/ variables:
c        MTRANS, MTIP, MHFTSZ
c     Common Block /PUFF/ variables:
c        zfinal,xfinal,fb,fm,xbfin,xmfin,elbase,
c        idw0,ht0,exitw0,diam0,ws0,istab0,sqrts0,srat0,
c        hb0,hw0,heff20,iru0,sigv0,sigw0,el0,
c        plexp0,zly0,r0,xshift0,sy0,sz0,
c        sysrc0,szsrc0,
c        zimax
c
c     Parameters:
c        IO6
c
c --- OUTPUTS:
c
c              TREC - real    - Time from source to receptor for
c                               computing PDF path (s)
c              FRAC - real    - Interpolation factor for receptor pos.
c                                 (0: at puff at start of step)
c                                 (1: at puff at end of step  )
c               SYR - real    - Receptor sigma Y (m)
c               SZR - real    - Receptor sigma Z (m)
c               HGR - real    - Receptor-specific puff height due to
c                               gradual rise (m).
c               ZPR - real    - Receptor-specific puff height after any
c                               terrain adjustments (m)
c            ZRPOLE - real    - Pole height for receptor (m)
c            RFACSQ - real    - Square of gradual rise / final rise
c             IDROP - integer - Flag to skip impact at this receptor
c                               when it is in the PRIME cavity zone
c                                 (0: do not drop this receptor)
c                                 (1: drop this receptor)
c
c --- PUFRECS called by:  CALCPF, COMP, PLMFOG
c --- PUFRECS calls:      SETCSIG, SIGTY, SIGTZ, DWSIGS, GRISE,
c                         SLGFRAC, HEFTRAN, CTADJ, PUFFCT2
c                         WAKE_TAB
c----------------------------------------------------------------------
c
c --- Include parameter block
      include 'params.puf'

c --- Include common blocks
      include 'comparm.puf'
      include 'current.puf'
      include 'pt1.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'puff.puf'

      logical lcalm,lclip,lendpt,ldbg
      data dum0/0.0/

c --- Set list-file output switch for testing
      ldbg=.FALSE.

c --- Initialize PRIME IDROP flag (process this receptor)
      idrop=0

c --- Validate imet index
      if(imet.LT.1 .OR. imet.GT.mxmetsav+1) then
         write(io6,*)
         write(io6,*) 'FATAL ERROR in PUFRECS: bad met period index'
         write(io6,*) 'Expected IMET = 1 to MXMETSAV+1'
         write(io6,*) 'Found    IMET = ',imet
         write(io6,*) '     MXMETSAV = ',mxmetsav
         write(io6,*)
         write(*,*)
         stop 'Halted in PUFRECS -- See list file'
      endif

c -------------------------------------------------------------------
c --- Determine interpolation factor FRAC for interpolating
c --- virtual time/distance for sigmas
c -------------------------------------------------------------------
      call SLGFRAC(x,y,xe1,ye1,xb1,yb1,xr1,yr1,frac,xbe1,rxbe1)
c
c --- Does interpolation factor need to be clipped?
      if(LCLIP) then
c ---    Extend the 0,1 range by the puff sigma-y at start and end
c ---    of step, scaled by length of step, and limit FRAC to this
c ---    range
         frac=AMAX1(frac,-syb1*rxbe1)
         frac=AMIN1(frac,1.0+sye1*rxbe1)
c ---    Do not allow receptor-specific puff properties to be
c ---    extrapolated beyond the FRAC limit - change receptor "location"
         xr1=frac*xbe1
      endif

c --- Estimate total travel distance to receptor from source
      xtt1 = xttb1+xr1
      if(xtt1.LT.0.0) then
         xtt1 = 0.0
         frac = -xttb1*rxbe1
      endif

c --- Estimate total travel time to receptor from source for PDF
      trec = xtt1/uavg

c --- If CALM period encountered: reset dispersion option for this step
c --- ("calms" use time-based sigmas)
      if(lcalm) then
         idopty=1
         idoptz=1
         frac=0.5
         xfrise=0.0
c ---    Test:  Downwash should aready be off for a puff in a calm
         if(idw0(ipnum).GT.0) then
            write(io6,*)'PUFRECS: Puff with active downwash found in'
            write(io6,*)'   a calm environment.  This should have been'
            write(io6,*)'   trapped in SETPUF!'
            stop 'Halted in PUFRECS -- See list file'
         endif
      endif

      if(idw0(ipnum).EQ.3 .OR. idw0(ipnum).EQ.4) then
c -------------------------------------------------------------------
c ---    Special case of PRIME building downwash ---
c -------------------------------------------------------------------
c        Plume rise is tabulated, and the sigmas are tabulated from
c        the source to the point where the turbulence reaches ambient.
c        Use WAKE_TAB to interpolate rise and sigmas within the
c        tabulated range of the sigmas, using the appropriate source
c        arrays.  Beyond the range, do nothing here and allow the
c        normal processing to take place (idone=0).
c -------------------------------------------------------------------
c ---    Check location of receptor relative to cavity area
         if(xtt1.LE.xshift0(ipnum)) then
            idrop=1
            return
         else
c ---       Extract sigmas if this puff was emitted with current met
            if(imet.EQ.1) then
               call WAKE_TAB(istype,isnum,iqstep,idw0(ipnum),xtt1,
     &                       syr,szr,hgr,rise,xlast,idone)
c ---          Finish up and skip to terrain adjustments if sigmas
c ---          are extracted
               if(idone.EQ.1) then
                  rfacsq=0.0
                  if(rise.GT.0.0) then
c ---                Add BID contribution to sigmas
                     sigbidsq=(rise/3.5)**2
                     syr=sqrt(syr**2+sigbidsq)
                     szr=sqrt(szr**2+sigbidsq)
c ---                Compute the corresponding BIDSQ adjustment factor
                     rfacsq=sigbidsq/bidsq
                  endif
                  go to 500
               endif
            endif
         endif
      elseif((idw0(ipnum).EQ.1 .OR. idw0(ipnum).EQ.2)
     &                             .AND. istype.LE.2) then
c -------------------------------------------------------------------
c ---    Special case of HS/SS building downwash ---
c -------------------------------------------------------------------
c        Consider the details of effects of the Huber-Snyder downwash
c        formulation or the Schulman-Scire downwash formulation on the
c        sigmas within 10 HL of the source.  This applies only if this
c        puff experiences building downwash.
c        POINT SOURCES !
c -------------------------------------------------------------------
c ---    Check for receptors in downwash zone
         hl=amin1(hb0(ipnum),hw0(ipnum))
         if(xtt1.LT.(10.*hl)) then
c ---       Initialize ratio of (gradual/final)^2  (used for BID)
            rfacsq=1.0
            if(idw0(ipnum).EQ.2) rfacsq=0.0
            hgr=zfinal(ipnum)
c ---       Set selected data in /CSIGMA/ for sigma calls
            call setcsig(idopty,idoptz,iru0(ipnum),ws0(ipnum),
     &                   istab0(ipnum),el0(ipnum),sqrts0(ipnum),
     &                   sigv0(ipnum),sigw0(ipnum),symin,szmin,
     &                   zfinal(ipnum),dpbl)
c ---       Obtain sigmas in downwash zone
            call dwsigs(tbd,hw0(ipnum),hb0(ipnum),mhftsz,ws0(ipnum),
     &                  ht0(ipnum),heff20(ipnum),zplat,xtt1,sydw,szdw)
c ---       Add initial sigmas to downwash sigmas
            sydw=SQRT(sydw**2+sysrc0(ipnum)**2)
            szdw=SQRT(szdw**2+szsrc0(ipnum)**2)
c ---       Set a "floor" to the sigma values equal to SYMIN, SZMIN
            syr=amax1(sydw,symin)
            szr=amax1(szdw,szmin)
c ---       Assess gradual rise at all receptors in downwash zone
            if(xtt1.LT.xfrise) then
c ---          Compute gradual rise
               if(idw0(ipnum).EQ.2) then
c ---             Schulman-Scire building downwash
                  call grise(xtt1,hgr,risefac)
               elseif(idw0(ipnum).EQ.1) then
c ---             Huber-Snyder building downwash
                  call grise(xtt1,hgr,risefac)
                  rfacsq=risefac**2
               endif
            endif
c ---       Add BID contribution to sigmas
            if(bidsq.GT.0.0) then
               syr=sqrt(syr**2+bidsq*rfacsq)
               szr=sqrt(szr**2+bidsq*rfacsq)
            endif
c
c ---       Skip to terrain adjustments
            goto 500
         endif
      endif

c --- Continue on for receptors outside downwash zone

c --------------------------------------------------------------------
c --- Compute the gradual rise if appropriate ...............
c ---   Use ISC convention that gradual rise is used to compute
c ---   buoyancy enhancement to sigmas; and is used as the "plume"
c ---   height only if MTRANS=1
c --------------------------------------------------------------------
c
      if(xtt1.LT.xfrise .AND. xtt1.GT.0.0 .AND. .NOT.lcalm) then
c ---    Compute gradual rise
         if(idw0(ipnum).EQ.3 .OR. idw0(ipnum).EQ.4) then
c ---       PRIME building downwash
            call grise(xtt1,hgr,risefac)
            rfacsq=risefac**2
         elseif(idw0(ipnum).EQ.2) then
c ---       Schulman-Scire building downwash
            call grise(xtt1,hgr,risefac)
c ---       No BID here
            rfacsq=0.0
         elseif(idw0(ipnum).EQ.1) then
c ---       Huber-Snyder building downwash
            call grise(xtt1,hgr,risefac)
            rfacsq=risefac**2
         else
c ---       No building downwash
cc ---       Adjustment for stack-tip downwash (NOT for bldg downwash)
c            if(mtip.EQ.1 .AND. istype.LE.2) then
c               call stktip(ht0(ipnum),diam0(ipnum),fm(ipnum),
c     &                     exitw0(ipnum),ws0(ipnum),tipdw)
c            else
c               tipdw=0.0
c            endif
            call grise(xtt1,hgr,risefac)
c            hgr=amax1(0.0,hgr-tipdw)
            rfacsq=risefac**2
         endif
      elseif(xtt1.LE.0.0 .AND. xfrise.GT.0.0) then
c ---    Receptor upwind of source, and final rise does NOT occur at
c ---    source (wind for plume rise is not "calm")
         hgr=ht0(ipnum)
         rfacsq=0.0
      else
c ---    Final rise
         hgr=zfinal(ipnum)
         rfacsq=1.0
      endif
c
c --- Set BID adjustment to account for gradual rise
c --- ADD addbid to ambient sigmas**2 without BID
      addbid=bidsq*rfacsq
c --- SUBTRACT subbid from sigmas**2 with BID
      subbid=bidsq*(1.0-rfacsq)
c
c -------------------------------------------------------------------
c --- Find the receptor-specific sigmas, with BID
c -------------------------------------------------------------------
      lendpt=.FALSE.
      if(frac.EQ.0.0) then
c ---    Use sigmas at start of step
         lendpt=.TRUE.
         syr=syb1
         szr=szb1
      elseif(frac.EQ.1.0) then
c ---    Use sigmas at end of step
         lendpt=.TRUE.
         syr=sye1
         szr=sze1
      endif
      if(LENDPT) then
         if(subbid.GE.0.0) then
            argy=syr**2-subbid
            syr=symin
            if(argy.GT.0.) syr=sqrt(argy)
            if(MOD(icode,2).EQ.1) then
c ---          Gaussian
               argz=szr**2-subbid
               szr=szmin
               if(argz.GT.0.) szr=sqrt(argz)
            endif
         endif
      else
c ---    Compute sigmas from virtual times
c ---    Set selected data in /CSIGMA/ for sigma calls
         call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &                sigv,sigw,symin,szmin,ze1,dpbl)

c ---    SIGMA-Y:
c ---------------
c ---    Interpolate for virtual times/distances at receptor
         vty = AMAX1(0.0,(vtyb1 + frac * (vtye1 - vtyb1)))
         vdy = AMAX1(0.0,(vdyb1 + frac * (vdye1 - vdyb1)))
c
c ---    Compute the receptor-specific sigma (syar) via 'forward'
c ---    call to the sigma routine (without BID)
         call sigty(dum0,vdy,vty,syar,dum1,dum2)

c ---    Adjust sigma:  add contribution due to buoyancy enhancement
c ---    and initial area source size
         syr=syar
         if(addbid.GT.0.0 .OR.
     &       sy0sq.GT.0.0) syr=sqrt(syar**2+addbid+sy0sq)

c ---    SIGMA-Z:
c ---------------
         if(MOD(icode,2).EQ.0) then
            szr=szb1
         else
c ---       Interpolate for virtual times/distances at receptor
            vtz = AMAX1(0.0,(vtzb1 + frac * (vtze1 - vtzb1)))
            vdz = AMAX1(0.0,(vdzb1 + frac * (vdze1 - vdzb1)))
c
c ---       Reset Heffter transition for sigma-z for current slug
            if(mhftsz.EQ.1) call heftran(2,zb1,dum0,dum0,
     &                                   vtzb1,vtze1,vtyb1,vtye1)
c
c ---       Compute the receptor-specific sigma (szar) via 'forward'
c ---       call to the sigma routine (without BID)
            call sigtz(dum0,vdz,vtz,zb1,szar,dum1,dum2)

c ---       Adjust sigma: add contribution due to buoyancy enhancement
            szr=szar
            if(addbid.GT.0.0) szr=sqrt(szar**2+addbid)
         endif
      endif

c --- Set a "floor" to the sigma values equal to SY0, SZ0
c --- which represent minimum values at release
      if(syr .LT. sy0(ipnum)) syr=sy0(ipnum)
      if(szr .LT. sz0(ipnum)) szr=sz0(ipnum)

500   continue

c --- Estimate puff height at receptor with gravitational settling
c --- (Initial Implementation!)
      if(mtilt.EQ.1) then
c ---    Use full settling over puff age here (ht may be negative)
         dzprg=-(tb1+frac*(te1-tb1))*vsetl
         dzprg=AMIN1(0.0,dzprg)
      else
         dzprg=0.0
      endif

c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(LDBG) then
         write(io6,*)'PUFRECS --  plume tilt'
         write(io6,*)'zb1,ze1,frac     = ',zb1,ze1,frac
         write(io6,*)'tb1,te1          = ',tb1,te1
         write(io6,*)'dzprg            = ',dzprg
      endif
c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


c -------------------------------------------------------------------
c --- Section for terrain adjustments to puff or receptor height
c -------------------------------------------------------------------
c --- Use gradual rise height if requested, or if downwash is active
      if(mtrans.EQ.1 .OR. idw0(ipnum).GT.0) then
         zpr = hgr
      else
         zpr = zfinal(ipnum)
      endif

c --- Account for settling (may be negative)
      zpr=zpr+dzprg

      zrpole=z
      if(mctadj.eq.1 .OR. mctadj.eq.3) then
         call ctadj(zrterr,zpr,ht0(ipnum),elbase(ipnum),ppcoef,zpra)
         zpr=zpra

c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(LDBG) then
         write(io6,*)'zrterr,elbase    = ',zrterr,elbase(ipnum)
         write(io6,*)'ppcoef,zpra      = ',ppcoef,zpra
      endif
c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      elseif(mctadj.eq.2) then
c ---    Set receptor-specific puff height
         call PUFFCT2(frac,xr1,yr1,zpr)
         if(mtrans.EQ.1 .OR. idw0(ipnum).GT.0) then
            if(zfinal(ipnum).gt.0.0)then
c ---          Scale by ratio of gradual rise to final rise
               zpr = zpr*hgr/zfinal(ipnum)
            else
               zpr = 0.0
            endif
         endif
c ---    Set receptor elevation relative to dividing-streamline
         if(bvf.gt.0.0) then
c ---       Get elevation (m MSL) of hilltop for receptor
            ix=x*dgridi+1
            iy=y*dgridi+1
            eltop=relief(5,ix,iy)
c ---       Set elevation (m MSL) of dividing-streamline
            dsel=eltop-uavg/bvf
c ---       Set elevation (m MSL) beneath puff (receptor-specific)
            xr1met = xr1*dgridi
            yr1met = yr1*dgridi
            call GETELEV(xr1met,yr1met,ze)
c ---       Set dividing-streamline height above this elevation
            dsh=AMAX1(0.0,dsel-ze)
c ---       Set elevation difference from receptor location to
c ---       dividing-streamline elevation
            zdiff=zrterr-dsel
            zdiff=zrterr-dsel
c ---       Reset pole height if altered from "z"
            if(dsh.EQ.0.0) then
               if(zdiff.LT.0.0) zrpole=AMAX1(0.0,z+zdiff)
            else
               if(zdiff.LT.0.0) then
                  zrpole=AMAX1(0.0,z+zrterr-ze)
               else
                  zrpole=z+dsh
               endif
            endif
c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(LDBG) then
            write(io6,*)'PUFRECS --  mctadj=2'
            write(io6,*)'(x,y,z) @ puff = ',xr1,yr1,ze
            write(io6,*)'uavg, bvf        = ',uavg, bvf
            write(io6,*)'dsel, eltop (MSL)= ',dsel, eltop
            write(io6,*)'dsh, zrterr (MSL)= ',dsh,zrterr
      endif
c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         endif
      endif

c --- Condition final effective puff ht to be non-negative
      zpr=AMAX1(zpr,0.0)

      return
      end
c----------------------------------------------------------------------
      subroutine calcsl(tsamp,tfract,nspec,qb,qe,qw,zstak,zbase,
     1 ppc,istab,symin,szmin,iru,hlid,sigv,sigw,el,bvf,dpbl,xlam,
     2 vd,vdpvd,uavg,ldbhr,lcalm,lclip)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050225                 CALCSL
c                R. Yamartino, J. Scire, D. Strimaitis,  SRC
c
c --- PURPOSE:  For a given slug, perform the loop over all receptors
c               for each species. Time-averaged coupling coefficients
c               are computed for each slug-receptor pair via SLUGAVE.
c               Also computed wet and dry deposition fluxes.
c
c --- UPDATE
c --- V5.721-V5.75  050225  (DGS): Add DPBL arg to pass on to SLGRECS,
c                                  SETCSIG for TAULY
c --- V5.4-V5.721   040503  (DGS): Fix declaration of qw(MXSPEC,2) for
c                                  slug mass associated with wet fluxes
c                                  (was NSPEC,2)
c --- V5.1-V5.4     000602  (DGS): add temperature excess logic (FOG)
c                                  at discrete receptors
c --- V5.0-V5.1     990625a (DGS): fix coding error in SLGRECS call
c --- V5.0-V5.0     990228b (DGS): add non-zero receptor height
c --- V4.0-V5.0     971107  (DGS): use effective "pole" height from
c                                  call to SLGRECS
c                   971107  (DGS): add variable line source treatment
c                   971107  (DGS): ICODE obtained from /CURRENT/
c --- V4.0-V4.07    971107  (DGS): add PDF logic (call PDFPATH)
c
c --- INPUTS:
c
c             TSAMP - real    - Sampling time duration (s)
c            TFRACT - real    - 1./(number of samples in averaging pd)
c             NSPEC - real    - Number of species
c         QB(nspec) - real    - Slug 'mass' (g/s) (effective emission
c                               rate) at beginning of time step
c         QE(nspec) - real    - Slug 'mass' (g/s) (effective emission
c                               rate) at end of time step
c      QW(mxspec,1) - real    - Total slug 'mass' (g/s) (effective
c                               emission rate) before wet removal
c      QW(mxspec,2) - real    - Total slug 'mass' (g/s) (effective
c                               emission rate) after wet removal
c             ZSTAK - real    - Stack height of source of slug (m)
c             ZBASE - real    - Stack base elevation MSL (m)
c               PPC - real    - Plume Path Coefficient
c             ISTAB - integer - PGT stability class
c             SYMIN - real    - Minimum sigma-y (m)
c             SZMIN - real    - Minimum sigma-z (m)
c               IRU - integer - Rural(0) or urban(1) flag
c              HLID - real    - Height of reflection lid (m)
c              SIGV - real    - Sigma-v velocity (m/s)
c              SIGW - real    - Sigma-w velocity (m/s)
c                EL - real    - Monin-Obukhov length (m)
c               BVF - real    - Brunt Vaisala frequency (1/s)
c              DPBL - real    - Depth of PBL (m)
c       XLAM(nspec) - real    - Scavenging ratio (1/s) for each species
c         VD(nspec) - real    - Dry deposition velocity (m/s) for each
c                               species
c      VDPVD(nspec) - real    - Conc. correction factor (vd'/vd) used
c                               to estimate effect of dry deposition and
c                               vertical mixing on near-surface concs.
c              UAVG - real    - Mean transport speed (m/s) over life of
c                               slug
c             LDBHR - logical - Debug output (T,F)
c             LCALM - logical - .TRUE. if this puff is in a calm
c             LCLIP - logical - .TRUE. if receptor-specific sigmas are
c                               limited to range defined by values at
c                               the start/end of step
c
c     Common Block /FLAGS/ variables:
c        MCTADJ, MHFTSZ
c     Common Block /FOG/ variables:
c        LADTFOG, TXSMXFOG
c     Common Block /GRID/ variables:
c        ELEVG(mxnxg,mxnyg), DGRID, IBSAMP, JBSAMP, DELSAM
c     Common Block /CURRENT/ variables:
c        XB1, YB1, XE2, YE2, XB2, YB2, XE2, YE2
c        IAGE, SPEEDI, SRAT, TEMIS, AREAM2
c        IDOPTY, IDOPTZ, ICODE
c     Common Block /CTSGDAT/ variables:
c        NCTREC, XRCT, YRCT, IHILL, HILLDAT, ELRECT
c     Common Block /PDF/ variables:
c        LPDF
c     Parameters:
c        NSPEC, MXREC, MXSLUG, IO6
c
c
c --- OUTPUTS:
c
c     Common block /CHIFLX/ variables:
c        CHISAM(mxnxg,mxnyg,mxspec),DFSAM(mxnxg,mxnyg,mxspec),
c        WFSAM(mxnxg,mxnyg,mxspec),CHIREC(mxrec,mxspec),
c        DFREC(mxrec,mxspec),WFREC(mxrec,mxspec)
c     Common Block /PDF/ variables:
c        RFACSQ
c
c --- CALCSL called by:  COMP
c --- CALCSL calls:      SLGXLIM, SLGRECS, SLUGAVE, AREAINT, SETCSIG
c----------------------------------------------------------------------
c --- Note that ungridded receptor info in /slgbnd/ is used here.
c     common/slgbnd/ xreclo,xrechi,yreclo,yrechi
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'chiflx.puf'
      include 'ctsgdat.puf'
      include 'current.puf'
      include 'flags.puf'
      include 'fog.puf'
      include 'grid.puf'
      include 'nongrd.puf'
      include 'pdf.puf'
c
      common/slgbnd/ xreclo,xrechi,yreclo,yrechi
c
      real qb(nspec),qe(nspec),qw(mxspec,2)
      real qdiff(mxspec),qwdiff(mxspec)
      real xlam(nspec),vd(nspec),vdpvd(nspec)
      logical lwflux
      logical ldbhr,lcalm,lclip

c
c --- Slug types : "icode" differentiates the vertical structure
c ---    ICODE=11:  within mixed layer and Gaussian
c ---    ICODE=12:  within mixed layer and uniform
c ---    ICODE=13:  above mixed layer and Gaussian (ignore mixing ht)
c ---    ICODE=14:  above mixed layer and uniform (not allowed !!)
c ---    ICODE=15:  above (but previously below) mixed layer and Gaussian
c ---    ICODE=16:  above (but previously below) mixed layer and uniform
c ---    ICODE=99:  off grid
      if(icode.EQ.14 .OR. icode.EQ.99) then
c ---    No concs
         return
      endif
c
c --- Is wet flux to be computed for this slug ?
      lwflux=.FALSE.
      if(mwet.EQ.1) then
         xsum=0.0
         do i=1,nspec
            xsum=xsum+xlam(i)
         enddo
         if(xsum.GT.0.0) lwflux=.TRUE.
      endif
c
c --- Process emissions (mass) for each species in this slug
      mass=0
      massw=0
      do is=1,nspec
         qdiff(is) = 0.0
         if(qb(is).GT.0.0 .OR. qe(is).GT.0.0) then
c ---       There is mass in this slug (lower layer)
            mass=1
            qdiff(is) = qe(is)-qb(is)
         endif
         qwdiff(is) = 0.0
         if(lwflux .AND. (qw(is,1).GT.0.0 .OR. qw(is,2).GT.0.0)) then
c ---       There is wet removal of mass from this slug
            massw=1
            qwdiff(is) = qw(is,1)-qw(is,2)
         endif
      enddo
c
c --- Save calls to slug sampling routines if current slug has
c --- no mass of any species
      if(mass.EQ.0 .AND. massw.EQ.0) return
c
c --- Determine the T factors for the slug that are due to shear
c     induced stretching of the slug.  4/5/89
c --- First must define the average x-y plane length of slug over
c --- the sampling time interval.
      sluglen = srat * speedi * temis
      if(iage.gt.0) sluglen = 0.5*(sqrt( (xb1-xb2)**2 + (yb1-yb2)**2 )+
     1                             sqrt( (xe1-xe2)**2 + (ye1-ye2)**2 ))
c
c --- Now compute the T factors, tfaca and tfacc.
      tfaca = 1.0
c --- Slugs with low srat are essentially puffs and are not subjected
c     to shear growth of the axial length.
      if(iage.GT.0 .AND. srat.GT.0.01) tfaca = sluglen /
     1                                         (srat * speedi * temis)
c --- Assume that there is no z - compensation due to shear.
c --- i.e. tfacz = 1.0 is understood and not defined.
      tfacai = 1.0 / tfaca
      tfacc = tfacai
c
c --- Set bounds on receptors affected by the slug
c --- Corresponding coordinate bounds are placed in /SLGBND/
      call slgxlim(il,iu,jl,ju,tfacc)
c
c --- Set factor to obtain correct units from area-source integrator:
c --- Divide coupling coefficients by area of source
      if(iage.EQ.0 .AND.
     &   istype.GE.3 .AND. istype.LE.6) then
         factor=1./aream2
      else
         factor=1.0
      endif
c
c --- Set unadjusted slug height above ground for SETCSIG
      zht=ze1
c
c*****
      if(LDBHR) then
      write(io6,*)
      write(io6,*) ' CALCSL -- xlo, xhi = ',xreclo,xrechi
      write(io6,*) '           ylo, yhi = ',yreclo,yrechi
      write(io6,*) '        IL,IU,JL,JU = ',il,iu,jl,ju
      write(io6,*) '       tfaca, tfacc = ',tfaca,tfacc
      write(io6,*) '  area units factor = ',factor
      do is=1,nspec
         write(io6,*)' CALCSL --  ispec = ',is
         write(io6,*)'           qb, qe = ',qb(is),qe(is)
         write(io6,*)'          qw(1,2) = ',qw(is,1),qw(is,2)
         write(io6,*)'         vd, xlam = ',vd(is),xlam(is)
      enddo
      endif
c*****

      if(lsamp) then
c ---------------------------------------------------------------------
c --- Begin loop over grid receptors
c ---------------------------------------------------------------------
      do 200 i=il,iu
      do 200 j=jl,ju
c
c --- xrec,yrec is the location of the receptor (m) (on met. grid)
      xrec = (float(ibsamp)-0.5)*dgrid+float(i-1)*delsam
      yrec = (float(jbsamp)-0.5)*dgrid+float(j-1)*delsam
c --- zrec is the z height (m) of the receptor above local terrain.
      zrec = 0.0
c
c --- The local lid height is measured above terrain and is presently
c --- assumed to be a constant over the grid.
c
c --- Identify the local terrain elevation (m MSL) at the receptor
      zrterr=elevg(i,j)
c
c --- Special treatment for determination of impact due to a polygon
c --- area source for a slug attached to the source.
c --- The source type index for POLYGON areas is 3 or 4.  Initially,
c --- LINE sources (source type=5,6) are also modeled as polygon areas.
      if(iage.EQ.0 .AND.
     &   istype.GE.3 .AND. istype.LE.6) then
c ---    Set selected data in /CSIGMA/ for sigma calls
         call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &                sigv,sigw,symin,szmin,zht,dpbl)
         call areaint(xrec,yrec,lwflux,zrec,hlid,
     2                zrterr,zstak,zbase,ppc,ldbhr,
     3                ccqb,ccdq,ccizqb,ccizdq)
         ccqb=ccqb*factor
         ccdq=ccdq*factor
         ccizqb=ccizqb*factor
         ccizdq=ccizdq*factor
c
      else
c ---    Obtain receptor-specific sigmas and puff height (gradual rise),
c ---    including any terrain adjustment to height
         call slgrecs(lclip,xrec,yrec,zrec,istab,iru,sigv,sigw,el,bvf,
     &                uavg,dpbl,zrterr,ppc,lcalm,
     &                trec,syrb,syre,szrb,szre,zgrise,zpr,zrpole,rfacsq)
c
c ***
      if(LDBHR) then
      write(io6,*) 'CALCSL: Grid rec x,y  = ',xrec,yrec
      write(io6,*) '        Trans. Rise   = ',zgrise
      write(io6,*) '        Adj. Slug Ht. = ',zpr
      write(io6,*) '    Adj. Rec Pole Ht. = ',zrpole
      write(io6,*) '  Sigma-y @ rec. (b,e)= ',syrb,syre
      write(io6,*) '  Sigma-z @ rec. (b,e)= ',szrb,szre
      write(io6,*) '  Reflecting Lid Ht.  = ',hlid
      write(io6,*) '    Time to receptor  = ',trec
      write(io6,*) ' G.Rise Adj to BID**2 = ',rfacsq
      endif
c ***
c
c ---    Store PDF path data for this receptor
         if(LPDF) call PDFPATH(zpr,hlid,trec)

c ---    Perform SLUG calculations
         call slugave(ldbhr,lwflux,tsamp,xrec,yrec,zrpole,zpr,tfacc,
     &                syrb,szrb,syre,szre,hlid,
     &                ccqb,ccdq,ccizqb,ccizdq)
c
      endif
c
c --- All coupling coefficients are now available.
c
c ---------------------------------------------------------------------
c --- Begin the loop over species
c ---------------------------------------------------------------------
c
      do 100 is=1,nspec
c
      conc = 0.0
      dflux = 0.0
      wflux = 0.0
c
c --- Concentration and dry deposition flux
      if(mass.EQ.1) then
c ---    Compute concentration at receptor (include vd'/vd)
c ---    Introduce the along slug T factor correction (tfacai=1/tfaca)
         conc = vdpvd(is)*(qb(is)*ccqb + qdiff(is)*ccdq)*tfacai
         chisam(i,j,is) = chisam(i,j,is) + conc* tfract
c ---    Compute dry flux at receptor using local concentration and vd.
         dflux = vd(is) * conc
         dfsam(i,j,is) = dfsam(i,j,is) + dflux*tfract
      endif
c
c --- Wet deposition flux
      if(massw.EQ.1) then
c ---    Compute wet flux at receptor using z integrated quantities,
c ---    Introduce the along slug T factor correction (tfacai=1/tfaca)
         wflux = (qw(is,1)*ccizqb + qwdiff(is)*ccizdq)*xlam(is)*tfacai
         wfsam(i,j,is) = wfsam(i,j,is) + wflux*tfract
      endif
c
c ***
      if(LDBHR) then
      write(io6,*) ' CALCSL -- i,j,ispec = ',i,j,is
      write(io6,*) '  conc, wflux, dflux = ',conc,wflux,dflux
      write(io6,*) '        ccqb, ccizqb = ',ccqb,ccizqb
      write(io6,*) '        ccdq, ccizdq = ',ccdq,ccizdq
      endif
c ***
c
  100 continue
  200 continue
c ---------------------------------------------------------------------
c --- END loop over grid receptors
c ---------------------------------------------------------------------
      endif

c
c ---------------------------------------------------------------------
c --- Begin loop over discrete receptors
c ---------------------------------------------------------------------
c
      if(nrec.GT.0) then
      do 400 ing=1,nrec
c
c --- xrec is the X location of the receptor (m) (on met. grid)
c --- yrec is the Y location of the receptor (m) (on met. grid)
      xrec = xng(ing)*dgrid
      yrec = yng(ing)*dgrid
c --- zrec is the z height (m) of the receptor above local terrain.
      zrec = zng(ing)

c --- Test receptor location to see if it is affected by slug
c --- (loop to next receptor if outside slug boundary)
      if(xrec.lt.xreclo .OR. xrec.gt.xrechi) goto 400
      if(yrec.lt.yreclo .OR. yrec.gt.yrechi) goto 400
c
c --- Identify the local terrain elevation (m MSL) at the receptor
      zrterr=elevng(ing)
c
c --- Special treatment for determination of impact due to a polygon
c --- area source for a slug attached to the source.
c --- The source type index for POLYGON areas is 3 or 4.  Initially,
c --- LINE sources (source type=5,6) are also modeled as polygon areas.
      if(iage.EQ.0 .AND.
     &   istype.GE.3 .AND. istype.LE.6) then
c ---    Set selected data in /CSIGMA/ for sigma calls
         call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &                sigv,sigw,symin,szmin,zht,dpbl)
         call areaint(xrec,yrec,lwflux,zrec,hlid,
     2                zrterr,zstak,zbase,ppc,ldbhr,
     3                ccqb,ccdq,ccizqb,ccizdq)
         ccqb=ccqb*factor
         ccdq=ccdq*factor
         ccizqb=ccizqb*factor
         ccizdq=ccizdq*factor
c
      else
c ---    Obtain receptor-specific sigmas and puff height (gradual rise),
c ---    including any terrain adjustment to height
         call slgrecs(lclip,xrec,yrec,zrec,istab,iru,sigv,sigw,el,bvf,
     &                uavg,dpbl,zrterr,ppc,lcalm,
     &                trec,syrb,syre,szrb,szre,zgrise,zpr,zrpole,rfacsq)
c
c ***
      if(LDBHR) then
      write(io6,*) 'CALCSL: Disc rec x,y,z= ',xrec,yrec,zrec
      write(io6,*) '        Trans. Rise   = ',zgrise
      write(io6,*) '        Adj. Slug Ht. = ',zpr
      write(io6,*) '    Adj. Rec Pole Ht. = ',zrpole
      write(io6,*) '  Sigma-y @ rec. (b,e)= ',syrb,syre
      write(io6,*) '  Sigma-z @ rec. (b,e)= ',szrb,szre
      write(io6,*) '  Reflecting Lid Ht.  = ',hlid
      write(io6,*) '    Time to receptor  = ',trec
      write(io6,*) ' G.Rise Adj to BID**2 = ',rfacsq
      endif
c ***
c
c ---    Store PDF path data for this receptor
         if(LPDF) call PDFPATH(zpr,hlid,trec)

c ---    Perform SLUG calculations
         call slugave(ldbhr,lwflux,tsamp,xrec,yrec,zrpole,zpr,tfacc,
     &                syrb,szrb,syre,szre,hlid,
     &                ccqb,ccdq,ccizqb,ccizdq)
c
      endif
c
c --- All coupling coefficients are now available.
c
c ---------------------------------------------------------------------
c --- Begin the loop over species
c ---------------------------------------------------------------------
c
      do 300 is=1,nspec
c
      conc = 0.0
      dflux = 0.0
      wflux = 0.0
c
c --- Concentration and dry deposition flux
      if(mass.EQ.1) then
c ---    Compute concentration at receptor (include vd'/vd)
c ---    Introduce the along slug T factor correction (tfacai=1/tfaca)
         conc = vdpvd(is)*(qb(is)*ccqb + qdiff(is)*ccdq)*tfacai
         chirec(ing,is) = chirec(ing,is) + conc*tfract
         if(is.EQ.2 .AND. LADTFOG) then
c ---       FOG: SUM T excess (is=2) at receptor but do not exceed
c ---       excess at source
            chirec(ing,is) = AMIN1(txsmxfog,chirec(ing,is))
         endif
c ---    Compute dry flux at receptor using local concentration and vd.
         dflux = vd(is) * conc
         dfrec(ing,is) = dfrec(ing,is) + dflux*tfract
      endif
c
c --- Wet deposition flux
      if(massw.EQ.1) then
c ---    Compute wet flux at receptor using z integrated quantities,
c ---    Introduce the along slug T factor correction (tfacai=1/tfaca)
         wflux = (qw(is,1)*ccizqb + qwdiff(is)*ccizdq)*xlam(is)*tfacai
         wfrec(ing,is) = wfrec(ing,is) + wflux*tfract
      endif
c
c ***
      if(LDBHR) then
      write(io6,*) ' CALCSL -- ing,ispec = ',ing,is
      write(io6,*) '  conc, wflux, dflux = ',conc,wflux,dflux
      write(io6,*) '        ccqb, ccizqb = ',ccqb,ccizqb
      write(io6,*) '        ccdq, ccizdq = ',ccdq,ccizdq
      endif
c ***
c
  300 continue
  400 continue
c ---------------------------------------------------------------------
c --- END loop over discrete receptors
c ---------------------------------------------------------------------
      endif

c
c ---------------------------------------------------------------------
c --- Begin loop over CTSG receptors
c --- CALM conditions ONLY!
c ---------------------------------------------------------------------
c
      if(nctrec.GT.0 .AND. LCALM) then
      do 600 ict=1,nctrec
c
c --- xrec is the X location of the receptor (m) (on met. grid)
c --- yrec is the Y location of the receptor (m) (on met. grid)
      xrec = xrct(ict)*dgrid
      yrec = yrct(ict)*dgrid
c --- zrec is the z height (m) of the receptor above local terrain.
c --- Sample vertical distribution at the surface if non-stable class
c --- (dividing streamline is 0); sample at receptor elevation above
c --- base of hill if stable (impingement case)
      if(istab.GT.4) then
         zrec=elrect(ict)-hilldat(4,ihill(ict))
         zrec=amax1(0.0,zrec)
      else
         zrec=0.0
      endif

c --- Test receptor location to see if it is affected by slug
c --- (loop to next receptor if outside slug boundary)
      if(xrec.lt.xreclo .OR. xrec.gt.xrechi) goto 600
      if(yrec.lt.yreclo .OR. yrec.gt.yrechi) goto 600
c
c --- Identify the local terrain elevation (m MSL) at the receptor with
c --- the base of the source so that slug height is not modified by
c --- simple terrain adjustments (terrain influence is done via zrec)
      zrterr=zbase
c
c --- Special treatment for determination of impact due to a polygon
c --- area source for a slug attached to the source.
c --- The source type index for POLYGON areas is 3 or 4.  Initially,
c --- LINE sources (source type=5,6) are also modeled as polygon areas.
      if(iage.EQ.0 .AND.
     &   istype.GE.3 .AND. istype.LE.6) then
c ---    Set selected data in /CSIGMA/ for sigma calls
         call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &                sigv,sigw,symin,szmin,zht,dpbl)
         call areaint(xrec,yrec,lwflux,zrec,hlid,
     2                zrterr,zstak,zbase,ppc,ldbhr,
     3                ccqb,ccdq,ccizqb,ccizdq)
         ccqb=ccqb*factor
         ccdq=ccdq*factor
         ccizqb=ccizqb*factor
         ccizdq=ccizdq*factor
c
      else
c ---    Obtain receptor-specific sigmas and puff height (gradual rise),
c ---    including any terrain adjustment to height
         call slgrecs(lclip,xrec,yrec,zrec,istab,iru,sigv,sigw,el,bvf,
     &                uavg,dpbl,zrterr,ppc,lcalm,
     &                trec,syrb,syre,szrb,szre,zgrise,zpr,zrpole,rfacsq)
c ---    NOTE: zrpole is not used for these CTSG receptors!
c
c ***
      if(LDBHR) then
      write(io6,*) 'CALCSL: CTSG Calm x,y,z= ',xrec,yrec,zrec
      write(io6,*) '         Trans. Rise   = ',zgrise
      write(io6,*) '         Adj. Slug Ht. = ',zpr
      write(io6,*) '   Sigma-y @ rec. (b,e)= ',syrb,syre
      write(io6,*) '   Sigma-z @ rec. (b,e)= ',szrb,szre
      write(io6,*) '   Reflecting Lid Ht.  = ',hlid
      write(io6,*) '    Time to receptor  = ',trec
      write(io6,*) ' G.Rise Adj to BID**2 = ',rfacsq
      endif
c ***
c
c ---    Store PDF path data for this receptor
         if(LPDF) call PDFPATH(zpr,hlid,trec)

c ---    Perform SLUG calculations
         call slugave(ldbhr,lwflux,tsamp,xrec,yrec,zrec,zpr,tfacc,
     &                syrb,szrb,syre,szre,hlid,
     &                ccqb,ccdq,ccizqb,ccizdq)
c
      endif
c
c --- All coupling coefficients are now available.
c
c ---------------------------------------------------------------------
c --- Begin the loop over species
c ---------------------------------------------------------------------
c
      do 500 is=1,nspec
c
      conc = 0.0
c
c --- Concentration
      if(mass.EQ.1) then
c ---    Compute concentration at receptor (include vd'/vd)
c ---    Introduce the along slug T factor correction (tfacai=1/tfaca)
         conc = vdpvd(is)*(qb(is)*ccqb + qdiff(is)*ccdq)*tfacai
         chict(ict,is) = chict(ict,is) + conc*tfract
      endif
c
c --- Wet and Dry deposition flux not computed at CTSG receptors
c
c ***
      if(LDBHR) then
      write(io6,*) ' CALCSL -- ict,ispec = ',ict,is
      write(io6,*) '                conc = ',conc
      write(io6,*) '        ccqb, ccizqb = ',ccqb,ccizqb
      write(io6,*) '        ccdq, ccizdq = ',ccdq,ccizdq
      endif
c ***
c
  500 continue
  600 continue
c ---------------------------------------------------------------------
c --- END loop over CTSG receptors
c ---------------------------------------------------------------------
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine slgrecs(lclip0,x,y,z,istab,iru,sigv,sigw,el,bvf,uavg,
     &                   dpbl,zrterr,ppcoef,lcalm,
     &                   trec,syrb,syre,szrb,szre,hgr,zpr,zrpole,
     &                   rfacsq)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                SLGRECS
c                R. Yamartino, D. Strimaitis
c
c --- PURPOSE:  Computes the receptor-specific sigmas y and z,
c               and receptor-specific slug height (gradual rise)
c               with terrain adjustments for SLUGS
c
c --- UPDATE
c --- V6.23-V6.261  080520  (DGS): Replace call to PRSS with GRISE
c --- V6.2-V6.23    080204  (DGS): Remove stack-tip downwash adjustment
c                                  to gradual rise because adjustment
c                                  is done within GRISE.
c --- V5.75-V6.2    070629  (DGS): move CALM re-assignment of IDW0() to
c                                  SETSLG so that downwash effects are
c                                  turned off as soon as a puff reaches
c                                  a calm area (add QA here).
c --- V5.73-V5.75   050225  (DGS): add platform ht to DWSIGS call for
c                                  ISC building downwash (MBDW=1)
c                   050225  (DGS): Add DPBL arg to pass on to SETCSIG
c                                  for TAULY
c --- V5.5-V5.73    040611  (DGS): add gravitational settling for one
c                                  particle size (plume tilt)
c --- V5.4-V5.5     010730  (DGS): correct initial sigma used with
c                                  downwash sigma
c --- V5.3-V5.4     000602_2(DGS): add initial sigmas to downwash
c                                  sigmas in quadrature
c --- V5.0-V5.3     991222b (DGS): pass momentum flux to STKTIP
c --- V5.0-V5.0     990228b (DGS): screen for zero puff height in 
c                                  terrain adjustment (CTADJ=2)
c --- V5.0-V5.0     990228b (DGS): add receptor ht above ground
c --- V5.0-V5.0     980918  (DGS): use quadrature to include initial
c                                  area source size
c --- V5.0-V5.0     980615  (DGS): return initial sigz if well-mixed
c --- V5.0-V5.0     980304  (DGS): use hard clip in place of soft clip
c                                  along the axis of a slug if
c                                  dispersion changes, and use
c                                  sy0,sz0 for min values
c --- V4.0-V5.0     971107  (DGS): extrapolate slug sigmas beyond ends
c                                  when slug "passes" receptor, even if
c                                  LCLIP0 is .TRUE.
c                   971107  (DGS): compute effective "pole" height
c                                  of receptor for option MCTADJ=2
c --- V4.0-V4.07    971107  (DGS): add mean transport time and gradual
c                                  rise factor squared to output
c --- V4.0-v5.0     971107  (DGS): alter slug height for receptor
c                                  position for option MCTADJ=2
c                   971107  (DGS): package slug geometry in SLGFRAC
c
c --- INPUTS:
c
c            LCLIP0 - logical - .TRUE. : limit "receptor position" to
c                                        lie within slug end-points for
c                                        local slug influence
c                               .FALSE.: use actual receptor position
c                                        to determine sigmas
c           (X,Y,Z) - real    - Coordinates of the receptor (m), where
c                               Z is above ground, not sea level
c             ISTAB - integer - PGT stability class
c               IRU - integer - Rural(0) or urban(1) flag
c              SIGV - real    - Sigma-v velocity (m/s)
c              SIGW - real    - Sigma-w velocity (m/s)
c                EL - real    - Monin-Obukhov length (m)
c               BVF - real    - Brunt-Vaisala frequency (1/s)
c              UAVG - real    - Mean transport speed (m/s) over xtotm
c              DPBL - real    - Depth of PBL (m)
c            ZRTERR - real    - Terrain elevation (m MSL) at receptor
c            PPCOEF - real    - Plume path coefficient
c             LCALM - logical - .TRUE. if this puff is in a calm
c
c     Common Block /COMPARM/ variables:
c        SYMIN, SZMIN, TBD
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1, SYB1, SZB1,
c        XE1, YE1, ZE1, SYE1, SZE1,
c        XB2, YB2, ZB2, SYB2, SZB2,
c        XE2, YE2, ZE2, SYE2, SZE2,
c        xttb1,xtte1,tb1,te1,vsetl,
c        xttb2,xtte2,tb2,te2,
c        vtyb1,vtzb1,vtyb2,vtzb2,
c        vtye1,vtze1,vtye2,vtze2,
c        vdyb1,vdzb1,vdyb2,vdzb2,
c        vdye1,vdze1,vdye2,vdze2,
c        IAGE, SPEEDI, SRAT, TEMIS, bidsq, IPNUM, ISTYPE, sy0sq,
c        IDOPTY, IDOPTZ, rlfmax,
c        ZPLAT
c     Common Block /FLAGS/ variables:
c        MTRANS, MTIP, MHFTSZ, MCTADJ. MTILT
c     Common Block /PUFF/ variables:
c        zfinal,xfinal,fb,fm,xbfin,xmfin,elbase,
c        idw0,ht0,exitw0,diam0,ws0,istab0,sqrts0,srat0,
c        hb0,hw0,heff20,iru0,sigv0,sigw0,el0,
c        plexp0,zly0,r0,xshift0,sy0,sz0,
c        sysrc0,szsrc0
c
c     Parameters:
c        IO6
c
c --- OUTPUTS:
c
c              TREC - real    - Time from source to receptor (s)
c              SYRB - real    - Receptor sigma Y at start of time step.
c              SYRE - real    - Receptor sigma Y at end of time step.
c              SZRB - real    - Receptor sigma Z at start of time step.
c              SZRE - real    - Receptor sigma Z at end of time step.
c               HGR - real    - Receptor-specific slug height due to
c                               gradual rise (m).
c               ZPR - real    - Receptor-specific slug height after any
c                               terrain adjustments (m)
c            ZRPOLE - real    - Pole height for receptor (m)
c            RFACSQ - real    - Rise factor squared
c
c --- SLGRECS called by:  CALCSL
c --- SLGRECS calls:      SETCSIG, SIGTY, SIGTZ, DWSIGS, GRISE,
c                         STKTIP, HEFTRAN, CTADJ, SLUGCT2, SLGFRAC
c----------------------------------------------------------------------
c
c --- Include parameter block
      include 'params.puf'

c --- Include common blocks
      include 'comparm.puf'
      include 'pt1.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'puff.puf'
      include 'current.puf'

c --- Some variables passed to LSSLINT via SLGLIN common block
      COMMON /SLGLIN/ DXY12,RDXY12

      logical lcalm,lclip0,lclip, ldbg
      data zero/0.0/, one/1.0/
      data dum0/0.0/

c --- Set list-file output switch for testing
      ldbg=.FALSE.

c --- Initialize gradual rise height to full final rise
      hgr=zfinal(ipnum)
c
c --- If CALM period encountered: reset dispersion option for this step
c --- ("calms" use time-based sigmas)
      if(lcalm) then
         idopty=1
         idoptz=1
         xfrise=zero
         if(idw0(ipnum).GT.0) then
            write(io6,*)'SLGRECS: Puff with active downwash found in'
            write(io6,*)'   a calm environment.  This should have been'
            write(io6,*)'   trapped in SETSLG!'
            stop 'Halted in SLGRECS -- See list file'
         endif
      endif

c -------------------------------------------------------------------
c --- Determine the spatial interpolation factors for along-slug
c --- and along-step positions
c -------------------------------------------------------------------

c --- (1)  Along-slug at Final slug position  (FRACSF)
c
c --- Determine the length and orientation of the final slug,
c --- and the position of the receptor relative to slug end 2
c --- as a fraction of the along-slug length
c --- FRACSF = 0 corresponds to slug end 2 (new)
c --- FRACSF = 1 corresponds to slug end 1 (old)
      call SLGFRAC(x,y,xe1,ye1,xe2,ye2,rhoaf,rhocf,fracsf,d12f,rd12f)

c --- (2)  Along-slug at Initial slug position  (FRACSI)
c
      if(iage.EQ.1) then
         call SLGFRAC(x,y,xb1,yb1,xb2,yb2,rhoai,rhoci,fracsi,d12i,rd12i)
      else
         fracsi=fracsf
         rhoai=rhoaf
         rhoci=rhocf
      endif

c --- (3)  Along-step for Old slug-end  (FRACSO)
c
c --- Determine the length and orientation of the step taken by this
c --- slug-end, and the along-step position of the receptor
c --- as a fraction of this step length
      call SLGFRAC(x,y,xe1,ye1,xb1,yb1,rhoao,rhoco,fracso,d12o,rd12o)

c --- (4)  Along-step for Young slug-end  (FRACSY)
c
      if(iage.EQ.1) then
         call SLGFRAC(x,y,xe2,ye2,xb2,yb2,rhoay,rhocy,fracsy,d12y,rd12y)
      else
         fracsy = fracso
         rhoay = rhoao
         rhocy = rhoco
      endif

c --- (5)  Do interpolation factors need to be clipped near slug-ends?
c
      lclip=lclip0
      if(LCLIP0) then

c ---    Identify case where slug passes receptor during step (no clip)
         if(fracsi.GT.-syb2*rd12i .AND.
     &      fracsf.LT.one+sye1*rd12f) lclip=.FALSE.

c ---    Now clip interpolation range if needed
         if(LCLIP) then

c ---       (1) Along-step
c ---       Extend the 0,1 range by sigma-y at start and end of step,
c ---       scaled by length of step, and limit FRAC to this interval
            fracso=AMAX1(fracso,-syb1*rd12o)
            fracso=AMIN1(fracso,one+sye1*rd12o)
            fracsy=AMAX1(fracsy,-syb2*rd12y)
            fracsy=AMIN1(fracsy,one+sye2*rd12y)

c ---       (2) Along-slug
c ---       Extend the 0,1 range by sigma-y at young and old end of
c ---       slug, scaled by length of slug, and limit FRAC to this
c ---       interval
            fracsi=AMAX1(fracsi,-syb2*rd12i)
            fracsi=AMIN1(fracsi,one+syb1*rd12i)
            fracsf=AMAX1(fracsf,-sye2*rd12f)
            fracsf=AMIN1(fracsf,one+sye1*rd12f)

c ---       Note: along-slug/step distance (rhoa_) is not clipped here

         endif
      endif

c --- (6)  Define "hard" clipping factors for dispersion calcs
c
      hfracsi=fracsi
      hfracsf=fracsf
      if(LCLIP0) then
c ---    Set a hard clip Along-slug if end-point sigma-ys are not
c ---    consistent with real difference in age across slug (temis)
c ---    indicating slug has passed into new dispersion regime
         fclip=(vtye1-vtye2)/temis
         if(fclip.GT.1.1 .OR. fclip.LT.0.9) then
c ---       Reset hard FRACS[I,F] values within 0-1 range
            hfracsi=AMAX1(fracsi,zero)
            hfracsi=AMIN1(hfracsi,one)
            hfracsf=AMAX1(fracsf,zero)
            hfracsf=AMIN1(hfracsf,one)
         endif
      endif

c -------------------------------------------------------------------
c --- Approximate the (clipped) distance and time to receptor
c -------------------------------------------------------------------
c
c --- (1) Estimate total travel distance to receptor, using movement
c --- of OLDER end of slug from beginning to end of step
      xtt1 = xttb1+fracso*(xtte1-xttb1)
c
c --- (2) Estimate total travel distance to receptor, using movement
c --- of YOUNG end of slug from beginning to end of step
      if(iage.EQ.1) then
         xtt2 = xttb2+fracsy*(xtte2-xttb2)
      else
         xtt2=xtt1
      endif
c
c --- (3) Choose/interpolate between xtt1 and xtt2, giving priority
c --- to information obtained from the old (1) end of the slug
      if(fracso.LT.0.5) then
c ---    Focus on slug at the beginning of the step
         frac=fracsi
      else
c ---    Focus on slug at the end of the step
         frac=fracsf
      endif
      if(frac.LE.zero) then
         xttr=xtt2
      elseif(frac.GE.one) then
         xttr=xtt1
      else
c ---    Interpolate from new (xxt2) to old (xxt1) end distance
         xttr=xtt2+frac*(xtt1-xtt2)
      endif

c --- Total travel distance is positive!
      xrec=amax1(xttr,zero)

c --- Use xrec to estimate travel time to receptor
      trec=xrec/uavg

c -------------------------------------------------------------------
c --- Special case of building downwash ---
c -------------------------------------------------------------------
c     Point sources:
c     Consider the details of effects of the Huber-Snyder downwash
c     formulation or the Schulman-Scire downwash formulation on the
c     sigmas within 10 HL of the source.  This applies only if this
c     slug experiences building downwash, and if the youngest end of
c     the slug is attached to the source at the start of the step.
c     POINT SOURCES !
c -------------------------------------------------------------------

      if(idw0(ipnum).GT.0 .AND. istype.LE.2) then
c ---    Check for receptors in downwash zone
         hl=amin1(hb0(ipnum),hw0(ipnum))
         if(xrec.LT.(10.*hl)) then
c ---       Initialize ratio of (gradual/final)^2  (used for BID)
            rfacsq=one
            if(idw0(ipnum).EQ.2) rfacsq=zero
c ---       Set selected data in /CSIGMA/ for sigma calls
            call setcsig(idopty,idoptz,iru0(ipnum),ws0(ipnum),
     &                   istab0(ipnum),el0(ipnum),sqrts0(ipnum),
     &                   sigv0(ipnum),sigw0(ipnum),symin,szmin,
     &                   zfinal(ipnum),dpbl)
c ---       Obtain sigmas in downwash zone
            call dwsigs(tbd,hw0(ipnum),hb0(ipnum),mhftsz,ws0(ipnum),
     &                  ht0(ipnum),heff20(ipnum),zplat,xrec,sydw,szdw)
c ---       Add initial sigmas to downwash sigmas
            sydw=SQRT(sydw**2+sysrc0(ipnum)**2)
            szdw=SQRT(szdw**2+szsrc0(ipnum)**2)
c ---       Set a "floor" to the sigma values equal to SYMIN, SZMIN
            syre=amax1(sydw,symin)
            syrb=syre
            szre=amax1(szdw,szmin)
            szrb=szre
c ---       Assess gradual rise at all receptors in downwash zone
            if(xrec.LT.xfrise) then
c ---          Compute gradual rise
               if(idw0(ipnum).EQ.2) then
c ---             Schulman-Scire building downwash
                  call grise(xrec,hgr,risefac)
               elseif(idw0(ipnum).EQ.1) then
c ---             Huber-Snyder building downwash
                  call grise(xrec,hgr,risefac)
                  rfacsq=risefac**2
               endif
            endif
c ---       Add BID contribution to sigmas
            if(bidsq.GT.zero) then
               syre=sqrt(syre**2+bidsq*rfacsq)
               szre=sqrt(szre**2+bidsq*rfacsq)
               syrb=syre
               szrb=szre
            endif
c
c ---       Skip to terrain adjustments
            goto 500
         endif
      endif

c --- Continue on for receptors outside downwash zone
c
c --- Set selected data in /CSIGMA/ for sigma calls
      call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &             sigv,sigw,symin,szmin,ze1,dpbl)

c --- Set sigma-y squared for effective area source size for old slugs
      sysq=zero
      if(iage.EQ.1) sysq=sy0sq

c -------------------------------------------------------------------
c --- Find the receptor-specific sigmas for the FINAL slug position
c -------------------------------------------------------------------
c
c --- Avoid unrealistic interpolation during calm conditions by forcing
c --- sigmas to lie between those at the ends of the slug
      if(lcalm .AND. fracsf.LE.zero) then
         syre=sye2
         szre=sze2
      elseif(lcalm .AND. fracsf.GE.one) then
         syre=sye1
         szre=sze1
      else
c ---    Interpolate for virtual times/distances at receptor
c
c ---    SIGMA-Y
c --------------
c ---    Enforce hard-clipped interpolation factors for dispersion
         vty = vtye2 + hfracsf * (vtye1 - vtye2)
         vty = amax1(vty,zero)
         vdy = vdye2 + hfracsf * (vdye1 - vdye2)
         vdy = amax1(vdy,zero)
c
c ---    Compute the receptor-specific sigma (syare) via
c ---    'forward' call to the sigma routine (without BID)
         call sigty(dum0,vdy,vty,syare,dum1,dum2)

c ---    Add contribution due to BID at final rise and initial area
c ---    source size (after slug is emitted!)
         syre=syare
         if(bidsq.GT.zero .OR.
     &       sysq.GT.zero) syre=sqrt(syare**2+bidsq+sysq)

c ---    SIGMA-Z
c --------------
         if(MOD(icode,2).EQ.0) then
            szre=sze1
         else
c ---       Enforce hard-clipped interpolation factors for dispersion
            vtz = vtze2 + hfracsf * (vtze1 - vtze2)
            vtz = amax1(vtz,zero)
            vdz = vdze2 + hfracsf * (vdze1 - vdze2)
            vdz = amax1(vdz,zero)
c
c ---       Reset Heffter transition for sigma-z for current slug
            if(mhftsz.EQ.1) call heftran(2,zb1,dum0,dum0,
     &                                   vtze1,vtze2,vtye1,vtye2)
c
c ---       Compute the receptor-specific sigma (szare) via
c ---       'forward' call to the sigma routine (without BID)
            call sigtz(dum0,vdz,vtz,zb1,szare,dum1,dum2)

c ---       Add contribution due to BID at final rise
            szre=szare
            if(bidsq.GT.zero) szre=sqrt(szare**2+bidsq)
         endif
      endif

c -------------------------------------------------------------------
c --- Find the receptor-specific sigmas for the INITIAL slug position
c -------------------------------------------------------------------

c --- Consider the special case of the current period's emissions.

      if(iage.eq.0) then
c ---    Constrain the receptor-specific sigmas to be time independent.
c ---    Note that it may also be dangerous to compute them directly due
c ---    to zero length slug possibilities.
         syrb = syre
         szrb = szre

      else
c
c ---    Avoid unrealistic interpolation during calm conditions by
c ---    forcing sigmas to lie between those at the ends of the slug
         if(lcalm .AND. fracsi.LE.zero) then
            syrb=syb2
            szrb=szb2
         elseif(lcalm .AND. fracsi.GE.one) then
            syrb=syb1
            szrb=szb1
         else
c ---       Interpolate for virtual times/distances at receptor
c
c ---       SIGMA-Y
c -----------------
            vty = vtyb2 + hfracsi * (vtyb1 - vtyb2)
            vty = amax1(vty,zero)
            vdy = vdyb2 + hfracsi * (vdyb1 - vdyb2)
            vdy = amax1(vdy,zero)
c
c ---       Compute the receptor-specific sigma (syrb) via
c ---       'forward' call to the sigma routine (without BID)
            call sigty(dum0,vdy,vty,syarb,dum1,dum2)

c ---       Add contribution due to BID at final rise and initial area
c ---       source size
            syrb=syarb
            if(bidsq.GT.zero .OR.
     &          sysq.GT.zero) syrb=sqrt(syarb**2+bidsq+sysq)
c
c ---       SIGMA-Z
c -----------------
            if(MOD(icode,2).EQ.0) then
               szre=szb1
            else
               vtz = vtzb2 + hfracsi * (vtzb1 - vtzb2)
               vtz = amax1(vtz,zero)
               vdz = vdzb2 + hfracsi * (vdzb1 - vdzb2)
               vdz = amax1(vdz,zero)
c
c ---          Reset Heffter transition for sigma-z for current slug
               if(mhftsz.EQ.1) call heftran(2,zb1,dum0,dum0,
     &                                      vtzb1,vtzb2,vtyb1,vtyb2)
c
c ---          Compute the receptor-specific sigma (szrb) via
c ---          'forward' call to the sigma routine (without BID)
               call sigtz(dum0,vdz,vtz,zb1,szarb,dum1,dum2)
c
c ---          Add contribution due to BID at final rise
               szrb=szarb
               if(bidsq.GT.zero) szrb=sqrt(szarb**2+bidsq)
            endif
         endif

      endif

c
c --------------------------------------------------------------------
c --- Compute the gradual rise if appropriate ...............
c ---   Use ISC convention that gradual rise is used to compute
c ---   buoyancy enhancement to sigmas; and is used as the "plume"
c ---   height only if MTRANS=1
c --------------------------------------------------------------------
c
      if(xrec.LT.xfrise .AND. xrec.GT.zero) then
c ---    Compute gradual rise
         if(idw0(ipnum).EQ.2) then
c ---       Schulman-Scire building downwash
            call grise(xrec,hgr,risefac)
c ---       No BID here
            rfacsq=zero
         elseif(idw0(ipnum).EQ.1) then
c ---       Huber-Snyder building downwash
            call grise(xrec,hgr,risefac)
            rfacsq=risefac**2
         else
c ---       No building downwash
cc ---       Adjustment for stack-tip downwash (NOT for bldg downwash!)
c            if(mtip.EQ.1 .AND. istype.LE.2) then
c               call stktip(ht0(ipnum),diam0(ipnum),fm(ipnum),
c     &                     exitw0(ipnum),ws0(ipnum),tipdw)
c            else
c               tipdw=zero
c            endif
            call grise(xrec,hgr,risefac)
c            hgr=amax1(zero,hgr-tipdw)
            rfacsq=risefac**2
         endif
      elseif(xrec.LE.zero) then
c ---    Receptor upwind of source
         hgr=ht0(ipnum)
         rfacsq=zero
      else
c ---    Final rise height (before any terrain adjustment)
         hgr=zfinal(ipnum)
         rfacsq=one
      endif
c
c --- Reset BID adjustment to account for gradual rise
c --- SUBTRACT subbid from sigmas**2 with BID at final rise
      subbid=bidsq*(one-rfacsq)
      if(subbid.GT.zero) then
c
         argy=syrb**2-subbid
         syrb=symin
         if(argy.GT.zero) syrb=sqrt(argy)
c
         argy=syre**2-subbid
         syre=symin
         if(argy.GT.zero) syre=sqrt(argy)
c
         argz=szrb**2-subbid
         szrb=szmin
         if(argz.GT.zero) szrb=sqrt(argz)
c
         argz=szre**2-subbid
         szre=szmin
         if(argz.GT.zero) szre=sqrt(argz)
c
      endif

c --- Set a "floor" to all sigma values equal to SY0, SZ0
c --- which are the minimum values allowed at the time of release
      if(iage.EQ.0 .AND. (istype.EQ.3 .OR. istype.EQ.4)) then
         if(syrb .LT. symin) syrb=symin
         if(syre .LT. symin) syre=symin
      else
         if(syrb .LT. sy0(ipnum)) syrb=sy0(ipnum)
         if(syre .LT. sy0(ipnum)) syre=sy0(ipnum)
      endif
      if(szrb .LT. sz0(ipnum)) szrb=sz0(ipnum)
      if(szre .LT. sz0(ipnum)) szre=sz0(ipnum)

500   continue


c --- Estimate slug height at receptor with gravitational settling
c --- (Initial Implementation!)
      if(mtilt.EQ.1) then
c ---    Use full settling over slug ages here (ht may be negative)
c ---    Older end
         dzprg1=-(tb1+fracso*(te1-tb1))*vsetl
c ---    Younger end
         dzprg2=-(tb2+fracsy*(te2-tb2))*vsetl
c ---    Average along-slug factor between initial and final positions
         if(te2.GT.1.0) then
c ---       Slug detached from source
            fracavg=0.5*(hfracsi+hfracsf)
         else
c ---       Slug attached to source
            fracavg=1.0
         endif
c ---    Limit to 0-1 range
         fracavg=AMAX1(0.0,fracavg)
         fracavg=AMIN1(1.0,fracavg)
         dzprg=dzprg2+fracavg*(dzprg1-dzprg2)
         dzprg=AMIN1(0.0,dzprg)
      else
         dzprg=0.0
      endif

c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(LDBG) then
         write(io6,*)'SLGRECS --  plume tilt'
         write(io6,*)'zb1,ze1,fracso   = ',zb1,ze1,fracso
         write(io6,*)'tb1,te1,dzprg1   = ',tb1,te1,dzprg1
         write(io6,*)'zb2,ze2,fracsy   = ',zb2,ze2,fracsy
         write(io6,*)'tb2,te2,dzprg2   = ',tb2,te2,dzprg2
         write(io6,*)'fracsi,fracsf    = ',fracsi,fracsf
         write(io6,*)'fracavg,dzprg    = ',fracavg,dzprg
      endif
c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


c -------------------------------------------------------------------
c --- Section for terrain adjustments to slug or receptor height
c -------------------------------------------------------------------
c --- Use gradual rise height if requested, or if downwash is active
      if(mtrans.EQ.1 .OR. idw0(ipnum).GT.0) then
         zpr = hgr
      else
         zpr = zfinal(ipnum)
      endif

c --- Account for settling (may be negative)
      zpr=zpr+dzprg

      zrpole=z
      if(mctadj.eq.1 .OR. mctadj.eq.3) then
         call ctadj(zrterr,zpr,ht0(ipnum),elbase(ipnum),ppcoef,zpra)
         zpr=zpra
      elseif(mctadj.eq.2) then
c ---    Set receptor-specific slug height
         call SLUGCT2(x,y,lclip,rhoci,rhocf,fracsi,fracsy,fracso,
     &                xr1,yr1,xr2,yr2,zpr,fracsr)
         if(mtrans.EQ.1 .OR. idw0(ipnum).GT.0) then
            if(zfinal(ipnum).gt.0.0)then
c ---          Scale by ratio of gradual rise to final rise
               zpr = zpr*hgr/zfinal(ipnum)
            else
               zpr = 0.0
            endif
         endif
c ---    Set receptor elevation relative to dividing-streamline
         if(bvf.gt.0.0) then
c ---       Get elevation (m MSL) of hilltop for receptor
            ix=x*dgridi+1
            iy=y*dgridi+1
            eltop=relief(5,ix,iy)
c ---       Set elevation (m MSL) of dividing-streamline
            dsel=eltop-uavg/bvf
c ---       Set elevation (m MSL) beneath slug (receptor-specific)
c ---       OLD end of slug
            xr1met = xr1*dgridi
            yr1met = yr1*dgridi
            call GETELEV(xr1met,yr1met,zeo)
c ---       YOUNG end of slug
            xr2met = xr2*dgridi
            yr2met = yr2*dgridi
            call GETELEV(xr2met,yr2met,zey)
c ---       Interpolate elevation between ends
            ze=zey+fracsr*(zeo-zey)
c ---       Set dividing-streamline height above this elevation
            dsh=AMAX1(zero,dsel-ze)
c ---       Set elevation difference from receptor location to
c ---       dividing-streamline elevation
            zdiff=zrterr-dsel
c ---       Reset pole height if altered from "z"
            if(dsh.EQ.zero) then
               if(zdiff.LT.zero) zrpole=AMAX1(zero,z+zdiff)
            else
               if(zdiff.LT.0.0) then
                  zrpole=AMAX1(zero,z+zrterr-ze)
               else
                  zrpole=z+dsh
               endif
            endif
         endif
      endif

c --- Condition final effective puff ht to be non-negative
      zpr=AMAX1(zpr,0.0)

c --- Special DEBUG (normally inactive)
      if(LDBG) then
         write(io6,*)'SLGRECS:'
         write(io6,*)'fracs[i,f,y,o]= ',fracsi,fracsf,fracsy,fracso
         write(io6,*)'hfracs[i,f]   = ',hfracsi,hfracsf
         write(io6,*)'rhoa[i,f,y,o]= ',rhoai,rhoaf,rhoay,rhoao
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine plgrecs(lclip,pfac,x,y,istab,iru,sigv,sigw,el,bvf,
     &                   uavg,dpbl,frac,syr,szr,zpr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                PLGRECS
c                D. Strimaitis
c
c --- PURPOSE:  Computes the receptor-specific sigmas y and z, and
c               finds receptor-specific puff height (gradual rise)
c               with terrain adjustments for PLUGS
c               --- PLUGS are puff-like segments of a slug ---
c
c --- UPDATE
c --- V6.23-V6.261  080520  (DGS): Replace call to PRSS with GRISE
c --- V5.75-V6.23   080204  (DGS): Remove stack-tip downwash adjustment
c                                  to gradual rise because adjustment
c                                  is done within GRISE.
c --- V5.5-V5.75    050225  (DGS): add platform ht to DWSIGS call for
c                                  ISC building downwash (MBDW=1)
c                   050225  (DGS): Add DPBL arg to pass on to SETCSIG
c                                  for TAULY
c --- V5.4-V5.5     010730  (DGS): correct initial sigma used with
c                                  downwash sigma
c --- V5.3-V5.4     000602_2(DGS): add initial sigmas to downwash
c                                  sigmas in quadrature
c --- V5.0-V5.3     991222b (DGS): pass momentum flux to STKTIP
c --- V5.0-V5.0     980918  (DGS): use quadrature to include size of
c                                  area source
c --- V5.0-V5.0     980615  (DGS): return initial sigz if well-mixed
c --- V5.0-V5.0     980304  (DGS): use SY0,SZ0 as minimum sigmas
c --- V4.0-V5.0     971107  (DGS): initialize gradual rise at final
c                                  rise for x < 10 "Hb"
c --- V4.0-V5.0     971107  (DGS): package step interpolation in call
c                                  to SLGFRAC
c
c --- INPUTS:
c
c             LCLIP - logical - .TRUE. : limit "receptor position" to
c                                        lie within plug trajectory for
c                                        local plug influence
c                               .FALSE.: use actual receptor position
c                                        to determine sigmas
c              PFAC - real    - Factor denoting position of plug
c                               along slug (0: older end
c                                           1: newer end)
c            (X, Y) - real    - Coordinates of the receptor (m)
c                               NOTE: All Sigmas before any T factors.
c             ISTAB - integer - PGT stability class
c               IRU - integer - Rural(0) or urban(1) flag
c              SIGV - real    - Sigma-v velocity (m/s)
c              SIGW - real    - Sigma-w velocity (m/s)
c                EL - real    - Monin-Obukhov length (m)
c               BVF - real    - Brunt-Vaisala frequency (1/s)
c              UAVG - real    - Mean transport speed (m/s) over xtotm
c
c     Common Block /COMPARM/ variables:
c        SYMIN, SZMIN, TBD
c     Common Block /CURRENT/ variables: (for SLUGS)
c        XB1, YB1, ZB1, SYB1, SZB1,
c        XE1, YE1, ZE1, SYE1, SZE1,
c        XB2, YB2, ZB2, SYB2, SZB2,
c        XE2, YE2, ZE2, SYE2, SZE2,
c        xttb1,xttb2,xtte1,xtte2,
c        vtyb1,vtzb1,vtyb2,vtzb2,
c        vtye1,vtze1,vtye2,vtze2,
c        vdyb1,vdzb1,vdyb2,vdzb2,
c        vdye1,vdze1,vdye2,vdze2,
c        IAGE, SPEEDI, SRAT, TEMIS, bidsq, sy0sq, IPNUM, ISTYPE,
c        IDOPTY, IDOPTZ, ZPLAT
c     Common Block /FLAGS/ variables:
c        MTRANS, MTIP, MHFTSZ
c     Common Block /PUFF/ variables:
c        zfinal,xfinal,fb,fm,xbfin,xmfin,elbase,
c        idw0,ht0,exitw0,diam0,ws0,istab0,sqrts0,srat0,
c        hb0,hw0,heff20,iru0,sigv0,sigw0,el0,
c        plexp0,zly0,r0,xshift0,sy0,sz0,
c        sysrc0,szsrc0
c
c     Parameters:
c        IO6
c
c --- OUTPUTS:
c
c              FRAC - real    - Interpolation factor for receptor pos.
c                                 (0: at plug at start of step)
c                                 (1: at plug at end of step  )
c               SYR - real    - Receptor sigma Y (m)
c               SZR - real    - Receptor sigma Z (m)
c               ZPR - real    - Receptor-specific plug height (m)
c
c --- PLGRECS called by:  COMP
c --- PLGRECS calls:      SETCSIG, SIGTY, SIGTZ, DWSIGS, GRISE,
c                         HEFTRAN, SLGFRAC
c----------------------------------------------------------------------
c
c --- Include parameter block
      include 'params.puf'

c --- Include common blocks
      include 'comparm.puf'
      include 'current.puf'
      include 'pt1.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'puff.puf'

      logical lclip

      data dum0/0.0/

cc --- DEBUG Section ---
c      write(io6,*) 'PLGRECS: Selected values passed in argument list'
c      write(io6,*) 'pfac, rec(x,y)  : ',pfac,x,y
c      write(io6,*) 'PLGRECS: Selected values passed in /CURRENT/'
c      write(io6,*) 'Younger end of slug ---'
c      write(io6,*) 'xb2,xb1,yb2,yb1 : ',xb2,xb1,yb2,yb1
c      write(io6,*) 'xttb2,xttb1     : ',xttb2,xttb1
c      write(io6,*) 'Older end of slug ---'
c      write(io6,*) 'xe2,xe1,ye2,ye1 : ',xe2,xe1,ye2,ye1
c      write(io6,*) 'xtte2,xtte1     : ',xtte2,xtte1
cc --- DEBUG Section ---

c -------------------------------------------------------------------
c --- Define plug parameters by interpolating from older end (1) to
c --- younger end (2) of slug by the factor PFAC
c -------------------------------------------------------------------

c --- At START:
c --- Position
      pxb1=xb1+pfac*(xb2-xb1)
      pyb1=yb1+pfac*(yb2-yb1)
c --- Height above ground (linear approximation)
      pzb1=zb1+pfac*(zb2-zb1)
c --- Total distance traveled
      pxttb1=xttb1+pfac*(xttb2-xttb1)
c --- Sigma-y (linear approximation)
      psyb1=syb1+pfac*(syb2-syb1)
c --- Virtuals
      pvtyb1=vtyb1+pfac*(vtyb2-vtyb1)
      pvtzb1=vtzb1+pfac*(vtzb2-vtzb1)
      pvdyb1=vdyb1+pfac*(vdyb2-vdyb1)
      pvdzb1=vdzb1+pfac*(vdzb2-vdzb1)

c --- At END:
c --- Position
      pxe1=xe1+pfac*(xe2-xe1)
      pye1=ye1+pfac*(ye2-ye1)
c --- Height above ground (linear approximation)
      pze1=ze1+pfac*(ze2-ze1)
c --- Sigma-y (linear approximation)
      psye1=sye1+pfac*(sye2-sye1)
c --- Virtuals
      pvtye1=vtye1+pfac*(vtye2-vtye1)
      pvtze1=vtze1+pfac*(vtze2-vtze1)
      pvdye1=vdye1+pfac*(vdye2-vdye1)
      pvdze1=vdze1+pfac*(vdze2-vdze1)

c -------------------------------------------------------------------
c --- Determine factor FRAC for interpolating virtual time/distance
c --- from plug at start as a fraction of plug-step
c ---                         (0: at plug at start of step)
c ---                         (1: at plug at end of step  )
c -------------------------------------------------------------------
      call SLGFRAC(x,y,pxe1,pye1,pxb1,pyb1,xr1,rhoc,frac,
     &             xbe1,rxbe1)
c
c --- Does interpolation factor need to be clipped?
      if(LCLIP) then
c ---    Extend the 0,1 range by the plug sigma-y at start and end
c ---    of step, scaled by length of step, and limit FRAC to this
c ---    range
         frac=AMAX1(frac,-psyb1*rxbe1)
         frac=AMIN1(frac,1.0+psye1*rxbe1)
      endif

c --- Do not allow receptor-specific puff properties to be
c --- extrapolated beyond the FRAC limit - change receptor "location"
      xr1=frac*xbe1

c --- Estimate total travel distance to receptor from source
      xtt1 = pxttb1+xr1
      if(xtt1.LT.0.0) then
         xtt1 = 0.0
         frac = -pxttb1*rxbe1
      endif

c -------------------------------------------------------------------
c --- Special case of building downwash ---
c -------------------------------------------------------------------
c     Point sources:
c     Consider the details of effects of the Huber-Snyder downwash
c     formulation or the Schulman-Scire downwash formulation on the
c     sigmas within 10 HL of the source.  This applies only if this
c     puff experiences building downwash.
c     POINT SOURCES !
c -------------------------------------------------------------------
      if(idw0(ipnum).GT.0 .AND. istype.LE.2) then
c ---    Check for receptors in downwash zone
         hl=amin1(hb0(ipnum),hw0(ipnum))
         if(xtt1.LT.(10.*hl)) then
c ---       Initialize ratio of (gradual/final)^2  (used for BID)
            rfacsq=1.0
            if(idw0(ipnum).EQ.2) rfacsq=0.0
            hgr=zfinal(ipnum)
c ---       Set selected data in /CSIGMA/ for sigma calls
            call setcsig(idopty,idoptz,iru0(ipnum),ws0(ipnum),
     &                   istab0(ipnum),el0(ipnum),sqrts0(ipnum),
     &                   sigv0(ipnum),sigw0(ipnum),symin,szmin,
     &                   zfinal(ipnum),dpbl)
c ---       Obtain sigmas in downwash zone
            call dwsigs(tbd,hw0(ipnum),hb0(ipnum),mhftsz,ws0(ipnum),
     &                  ht0(ipnum),heff20(ipnum),zplat,xtt1,sydw,szdw)
c ---       Add initial sigmas to downwash sigmas
            sydw=SQRT(sydw**2+sysrc0(ipnum)**2)
            szdw=SQRT(szdw**2+szsrc0(ipnum)**2)
c ---       Set a "floor" to the sigma values equal to SYMIN, SZMIN
            syr=amax1(sydw,symin)
            szr=amax1(szdw,szmin)
c ---       Assess gradual rise at all receptors in downwash zone
            if(xtt1.LT.xfrise) then
c ---          Compute gradual rise
               if(idw0(ipnum).EQ.2) then
c ---             Schulman-Scire building downwash
                  call grise(xtt1,hgr,risefac)
               elseif(idw0(ipnum).EQ.1) then
c ---             Huber-Snyder building downwash
                  call grise(xtt1,hgr,risefac)
                  rfacsq=risefac**2
               endif
            endif
c ---       Add BID contribution to sigmas
            if(bidsq.GT.0.0) then
               syr=sqrt(syr**2+bidsq*rfacsq)
               szr=sqrt(szr**2+bidsq*rfacsq)
            endif
c
c ---       Skip to puff height section
            goto 500
         endif
      endif

c --- Continue on for receptors outside downwash zone

c --------------------------------------------------------------------
c --- Compute the gradual rise if appropriate ...............
c ---   Use ISC convention that gradual rise is used to compute
c ---   buoyancy enhancement to sigmas; and is used as the "plume"
c ---   height only if MTRANS=1
c --------------------------------------------------------------------
c
      if(xtt1.LT.xfrise .AND. xtt1.GT.0.0) then
c ---    Compute gradual rise
         if(idw0(ipnum).EQ.2) then
c ---       Schulman-Scire building downwash
            call grise(xtt1,hgr,risefac)
c ---       No BID here
            rfacsq=0.0
         elseif(idw0(ipnum).EQ.1) then
c ---       Huber-Snyder building downwash
            call grise(xtt1,hgr,risefac)
            rfacsq=risefac**2
         else
c ---       No building downwash
cc ---       Adjustment for stack-tip downwash (NOT for bldg downwash)
c            if(mtip.EQ.1 .AND. istype.LE.2) then
c               call stktip(ht0(ipnum),diam0(ipnum),fm(ipnum),
c     &                     exitw0(ipnum),ws0(ipnum),tipdw)
c            else
c               tipdw=0.0
c            endif
            call grise(xtt1,hgr,risefac)
c            hgr=amax1(0.0,hgr-tipdw)
            rfacsq=risefac**2
         endif
      elseif(xtt1.LE.0.0 .AND. xfrise.GT.0.0) then
c ---    Receptor upwind of source, and final rise does NOT occur at
c ---    source (wind for plume rise is not "calm")
         hgr=ht0(ipnum)
         rfacsq=0.0
      else
c ---    Final rise
         hgr=zfinal(ipnum)
         rfacsq=1.0
      endif
c
c --- Set BID adjustment to account for gradual rise
c --- ADD addbid to ambient sigmas**2 without BID
      addbid=bidsq*rfacsq
c
c -------------------------------------------------------------------
c --- Find the receptor-specific sigmas, with BID
c -------------------------------------------------------------------
c
c --- Set selected data in /CSIGMA/ for sigma calls
      call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &             sigv,sigw,symin,szmin,pze1,dpbl)
c
c ---    SIGMA-Y:
c ---------------
c --- Interpolate for virtual times/distances at receptor
      vty = AMAX1(0.0,(pvtyb1 + frac * (pvtye1 - pvtyb1)))
      vdy = AMAX1(0.0,(pvdyb1 + frac * (pvdye1 - pvdyb1)))
c
c --- Compute the receptor-specific sigma (syar) via 'forward'
c --- call to the sigma routine (without BID)
      call sigty(dum0,vdy,vty,syar,dum1,dum2)

c --- Adjust sigma:  add contribution due to buoyancy enhancement
      syr=syar
      if(addbid.GT.0.0 .OR.
     &    sy0sq.GT.0.0) syr=sqrt(syar**2+addbid+sy0sq)

c ---    SIGMA-Z:
c ---------------
      if(MOD(icode,2).EQ.0) then
         szr=szb1
      else
c
c ---    Interpolate for virtual times/distances at receptor
         vtz = AMAX1(0.0,(pvtzb1 + frac * (pvtze1 - pvtzb1)))
         vdz = AMAX1(0.0,(pvdzb1 + frac * (pvdze1 - pvdzb1)))
c
c ---    Reset Heffter transition for sigma-z for current slug
         if(mhftsz.EQ.1) call heftran(2,zfinal(ipnum),dum0,dum0,
     &                                vtzb1,vtze1,vtyb1,vtye1)
c
c ---    Compute the receptor-specific sigma (szar) via 'forward'
c ---    call to the sigma routine (without BID)
         call sigtz(dum0,vdz,vtz,zfinal(ipnum),szar,dum1,dum2)
      endif

c --- Adjust sigma:  add contribution due to buoyancy enhancement
      szr=szar
      if(addbid.GT.0.0) szr=sqrt(szar**2+addbid)

c --- Set a "floor" to the sigma values equal to SY0, SZ0
c --- which represent minimum values at release
      if(syr .LT. sy0(ipnum)) syr=sy0(ipnum)
      if(szr .LT. sz0(ipnum)) szr=sz0(ipnum)

500   continue
c -------------------------------------------------------------------
c --- Section for puff height at receptor
c -------------------------------------------------------------------
c --- Use gradual rise height if requested, or if downwash is active
      if(mtrans.EQ.1 .OR. idw0(ipnum).GT.0) then
         zpr = hgr
      else
         zpr = zfinal(ipnum)
      endif

c --- Height must not be greater than interpolated height from slug data
c --- Condition FRAC to fully clipped range
      fracz=AMAX1(0.0,frac)
      fracz=AMIN1(fracz,1.0)
c --- Interpolate height
      zslug=pzb1+fracz*(pze1-pzb1)
      zpr=AMIN1(zpr,zslug)

      return
      end
c----------------------------------------------------------------------
      subroutine slgfrac(x,y,x1,y1,x2,y2,rhoa,rhoc,fracs,dxy12,rdxy12)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                SLGFRAC
c                R. Yamartino, D. Strimaitis, SRC
c
c --- PURPOSE:  Computes along-slug and cross-slug distances from
c               the younger end (x2,y2) to a reference point (x,y),
c               the spatial interpolation factor for the scaled
c               along-slug position, and the slug length.
c
c --- INPUTS:
c
c            (X, Y) - real    - Coordinates of the reference point (m)
c          (X1, Y1) - real    - Coordinates of the old end of slug (m)
c          (X2, Y2) - real    - Coordinates of the new end of slug (m)
c
c
c --- OUTPUTS:
c
c              RHOA - real    - Distance along slug from end 2 to ref
c                               point (m)
c              RHOC - real    - Distance across slug from end 2 to ref
c                               point (m)
c             FRACS - real    - Distance along slug from end 2 to ref
c                               point, expressed as fraction of slug
c                               length
c             DXY12 - real    - Slug length in x-y plane (m)
c            RDXY12 - real    - Reciprocal of DXY12
c
c --- SLGFRAC called by:  PUFRECS, SLGRECS, SLUGAVE, SLUGSNP, SLUGINT,
c                         SLUGCT2, PLGRECS
c --- SLGFRAC calls:      none
c----------------------------------------------------------------------
      data one/1.0/, zero/0.0/

c --- Determine the length of the slug
      x12 = x1 - x2
      y12 = y1 - y2
c --- DXY12 is the projection of the slug length on the x-y plane
      dxy12 = SQRT(x12*x12 + y12*y12)

      if(dxy12.GE.one) then

c ---    Determine the orientation of the slug
c ---    Note that slug angles are defined cw (clockwise) from North
c ---    Define the cos and sin of omega.
c ---    note that omega = wind direction (met.) + pi for IAGE=0 slugs
         rdxy12 = one / dxy12
         cosom = y12 * rdxy12
         sinom = x12 * rdxy12

c ---    Define position of reference point relative to slug end 2
         xr = x - x2
         yr = y - y2

c ---    Convert reference position to along-slug and cross-slug axis
c        coordinates RHOA and RHOC respectively
         rhoa =  yr * cosom  +  xr * sinom
         rhoc = -xr * cosom  +  yr * sinom

c ---    FRACS is the fraction RHOA/DXY12 for this slug position
c ---    FRACS = 0 corresponds to the point (X2,Y2).
c ---    FRACS = 1 corresponds to the point (X1,Y1).
         fracs = rhoa * rdxy12

      else

c ---    SPECIAL CASE of small slug length (1 meter or less)
c ---    Just use scale factor of unity (this should not happen often)
c ---    and place reference point "across" this slug
         dxy12 = one
         rdxy12 = one
         xr = x - x2
         yr = y - y2
         rhoc = SQRT(xr*xr + yr*yr)
         rhoa = zero
         fracs = zero

      endif

      return
      end
c----------------------------------------------------------------------
      subroutine chem(nspec,mchem,maqchem,nhrind,tsamp,jsup,qsw,tempk,
     1 irh,rhoair,istab,hlid,chioz,chih2o2,cloud,zcoef,zmsl,ldbhr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_3                 CHEM
c                J. Scire, SRC
c
c --- PURPOSE:  Compute chemical transformation rates for each species
c               using the MESOPUFF II or RIVAD algorithm, or user-
c               specified diurnally varying values.  Adjust the mass
c               in each layer to account for chemical transformation
c               effects.
c
c --- UPDATE
c --- V5.4-V5.4
c          000602 - 000602_3(DGS): Add aqueous chemistry data
c --- V5.3-V5.4
c          991222 - 000602  (DGS): Add message to "stop"
c --- V5.2-V5.3
c          980918 - 991222  (DGS): Fix bug in assigning puff volume for
c                                  computing CON array for CHEMTF call
c                                  for mass above mixed layer
c --- V5.0-V5.0
c          980304 - 980918  (DGS): Add SOA module (MCHEM=4)
c          960521 - 980304  (DGS): include well-mixed limit on mean C
c                                : Store NO and NO2 for RIVAD option,
c                                  but keep NOx for the other options
c
c --- INPUTS:
c
c             NSPEC - integer - Number of chemical species
c             MCHEM - integer - Chemical transformation mechanism
c                               flag (0 = no transformation,
c                               1 = MESOPUFF II scheme,
c                               2 = user-specified rates, except
c                                   HNO3 <--> NO3 based on equilibrium
c                                   equation
c                               3 = RIVAD scheme with HNO3 <--> NO3 
c                                   equilibrium)
c                               4 = Form SOA from VOC emissions
c           MAQCHEM - integer - Aqueous phase transformation flag
c                               0 = aqueous phase transformation
c                                   not modeled
c                               1 = transformation rates adjusted
c                                   for aqueous phase reactions
c            NHRIND - integer - Current hour (01-24)
c             TSAMP - real    - Sampling step (s)
c              JSUP - integer - effective stability class above the
c                               mixed layer
c               QSW - real    - Short-wave solar radiation (W/m**2)
c             TEMPK - real    - Air temperature (deg. K)
c               IRH - integer - Relative humidity (percent)
c            RHOAIR - real    - Air density (kg/m**3)
c             ISTAB - integer - PGT stability class
c              HLID - real    - Height of reflecting lid (m)
c             CHIOZ - real    - Ozone concentration (ppb) to use in
c                               chemistry calculations
c           CHIH2O2 - real    - background H2O2 concentration (ppb)
c             CLOUD - real    - Cloud cover (tenths)
c             ZCOEF - real    - Cosine of solar zenith angle
c              ZMSL - real    - Height of puff above sea level (m)
c             LDBHR - logical - Variable controlling debug write
c                               statements
c
c     Common Block /CHEMDAT/ variables:
c        MOZ, BCKNH3, RNITE1, RNITE2, RNITE3, CHEMT(24,3),
c        NOZSTA
c     Common Block /CURRENT/ variables:
c        SYB1,SZB1,SYE1,SZE1,
c        SPEEDI,TEMIS,IPNUM,ICODE
c     Common Block /DATE/ variables:
c        NDATHR
c     Common Block /PUFF/ variables:
c        QM(mxspec,mxpuff), QU(mxspec,mxpuff)
c     Parameters:
c        MXPUFF, MXSPEC, MXOZ, MXNX, MXNY, IO6, IO22
c
c --- OUTPUT:
c     Common Block /PUFF/ variables:
c        QM(mxspec,mxpuff), QU(mxspec,mxpuff)
c
c --- CHEM called by:  COMP
c --- CHEM calls:      CHEMTF, CHEMRIV, CHEMSOA
c----------------------------------------------------------------------
c
c --- Include PARAMETERS
      include 'params.puf'
c
c --- Include common blocks
      include 'chemdat.puf'
      include 'current.puf'
      include 'puff.puf'
c
      real rmid(3),rup(3),ruser(3)
      real rmid3(4),rup3(4)
      real rmid4(4),rup4(4)
      real qmid(mxspec),qup(mxspec)
      real con(mxspec)
      integer noreact5(5),noreact6(6)
      logical ldbhr,ldb,lentrain
c
      data rmid/3*0.0/,rup/3*0.0/,ruser/3*0.0/
      data rmid3/4*0.0/,rup3/4*0.0/
      data rmid4/4*0.0/,rup4/4*0.0/
      data qmid/mxspec*0.0/,qup/mxspec*0.0/
      data con/mxspec*0.0/
      data imiss/9999/,xmiss/9999./
      data noreact5/1,1,2,3,3/
      data noreact6/1,1,3,3,4,4/
      data xscale/0.984127/

c --- Set local debug switch here
      ldb=ldbhr
c --- ldb=.TRUE.

c --- Do not consider entrained volume
      lentrain=.FALSE.

c --- Check that required data are not missing
      if(qsw.ge.xmiss.or.tempk.ge.xmiss.or.irh.ge.imiss.or.
     1 rhoair.ge.xmiss)then
         write(io6,*)'ERROR in SUBR. CHEM -- Required data are',
     1   ' missing -- QSW = ',qsw,' TEMPK = ',tempk,' IRH = ',irh,
     2   ' RHOAIR = ',rhoair
         write(*,*)
         stop 'Halted in CHEM -- see list file.'
      endif

c --- Set local puff index to value in /CURRENT/
      jp=ipnum

c --- Identify position of TNO3 in the species list (NT)
c --- MCHEM=0,1,2:  SO2,SO4,NOX,TNO3,NO3       - NT=4
c --- MCHEM=3    :  SO2,SO4,NO ,NO2 ,TNO3,NO3  - NT=5
c --- and set IREACT, the number of reaction rates required
      if(mchem.LT.3) then
         nt=4
         ireact=noreact5(MIN0(nspec,5))
      elseif(mchem.EQ.3) then
         nt=5
         ireact=noreact6(MIN0(nspec,6))
      elseif(mchem.EQ.4) then
c ---    Set nt>nspec to disable since TNO3 not modeled in CHEMSOA
         nt=nspec+1
      endif
      nt1=nt+1

c --- Compute chemical conversion rates
      if(mchem.eq.0)then
c ---    No chemical conversion
         do i=1,ireact
            rmid(i)=0.0
            rup(i)=0.0
         enddo
         go to 100
      elseif(mchem.eq.2)then
c ---    User-specified chemical conversion rates
         do i=1,ireact
            ruser(i)=chemt(nhrind,i)
         enddo
      endif
c
c --- Compute and apply modeled (MESOPUFF II or RIVAD, or SOA)
c --- conversion rates or apply user-specified conversion rates
c
      rhum=irh
      delt=tsamp/3600.
c
c --- Clear working arrays and assign mass in each layer
      do i=1,mxspec
         qup(i)=0.0
         qmid(i)=0.0
      enddo
      do i=1,nspec
         qup(i)=qu(i,jp)
         qmid(i)=qm(i,jp)
      enddo
c
c --- NOTE: TNO3 = HNO3 + NO3 is required by the chemical module
c --- (does not apply to mchem=4)
      if(nspec.ge.nt)then
c ---    XSCALE is 0.984127 = 62./63. = (mol. wt. NO3)/(mol. wt. HNO3)
         qup(nt)=qu(nt,jp)*xscale+qu(nt1,jp)
         qmid(nt)=qm(nt,jp)*xscale+qm(nt1,jp)
      endif

c --- Puff volume computation (for mean concentration) follows MESOPUFF
c --- approach.  Length scale is SQRT(2pi)*sigma/0.723 = sigma*3.467
c --- Use puff or old end of slug for length scales (end of step)
      if(mchem.NE.4) then
         ylenb=syb1*3.467
         zlenb=szb1*3.467
         ylene=sye1*3.467
         zlene=sze1*3.467
         pareab=ylenb**2
         pareae=ylene**2
         if(icode.LT.10) then
c ---       Puff
            icd=icode
         else
c ---       Slug
            icd=icode-10
         endif
c ---    Set vertical length scales for upper and main layer
         if(icd.EQ.2 .OR. icd.EQ.4 .OR. icd.EQ.6) then
c ---       Uniformly mixed in the vertical
            zlenue=zimax(jp)-hlid
            zlenme=hlid
            zlenub=zlenue
            zlenmb=zlenme
         elseif(icd.eq.1) then
            zlenue=0.0
            zlenme=AMIN1(zlene,hlid)
            zlenub=0.0
            zlenmb=AMIN1(zlenb,hlid)
         elseif(icd.eq.3) then
            zlenue=zlene
            zlenme=zlene
            zlenub=zlenb
            zlenmb=zlenb
         elseif(icd.eq.5) then
            zlenue=zimax(jp)-hlid
            zlenme=AMIN1(zlene,hlid)
            zlenub=zlenue
            zlenmb=AMIN1(zlenb,hlid)
         endif
c ---    Compute entrained volume during step
         ventm=AMAX1(0.0,pareae*zlenme-pareab*zlenmb)
         ventu=AMAX1(0.0,pareae*zlenue-pareab*zlenub)
c ---    Compute 1/volume at end of step
         pivolu=pareae*zlenue
         if(pivolu.GT.0.0) pivolu=1./pivolu
         pivolm=pareae*zlenme
         if(pivolm.GT.0.0) pivolm=1./pivolm
      endif


c --- Transformation in the mixed layer
c
c --- If non-zero mass in mixed layer, compute transformation rates
c --- NOTE: (qmid(nt) = q(TNO3))
      qtot=0.0
      do i=1,nt
         qtot=qtot+qmid(i)
      enddo
      if(qtot.gt.0.0)then
         if(mchem.NE.4 .AND. pivolm.LE.0.0) then
            write(io6,*)'CHEM:  No Puff volume below lid!'
            write(io6,*)'       Puff ID = ',ipnum
            write(*,*)
            stop 'Halted in CHEM -- see list file.'
         endif
         if(mchem.LE.2) then
            do i=1,nt1
               con(i)=qmid(i)*pivolm
            enddo
            call CHEMTF(delt,con,qmid,chioz,bcknh3,chih2o2,qsw,tempk,
     1                  rhum,rhoair,istab,rnite1,rnite2,rnite3,mchem,
     2                  maqchem,ruser,nspec,ldb,io6,rmid)
         elseif(mchem.EQ.3) then
            o3ent=chioz
            if(lentrain) o3ent=chioz*ventm*pivolm
            call CHEMRIV(delt,qmid,o3ent,bcknh3,chih2o2,maqchem,tempk,
     1                   rhum,rhoair,pivolm,zmsl,cloud,zcoef,nspec,
     2                   ldb,io6,rmid3)
         elseif(mchem.EQ.4) then
            call CHEMSOA(ldb,io6,delt,qmid,istab,qsw,tempk,chioz,rmid4)
         endif
      endif

c
c --- Transformation above the mixed layer
c
c --- If non-zero mass in upper layer, compute transformation rates
c --- NOTE: (qup(nt) = q(TNO3))
      qtot=0.0
      do i=1,nt
         qtot=qtot+qup(i)
      enddo
      if(qtot.gt.0.0)then
         jdstab=jsup
         if(jdstab.eq.0)jdstab=istab
         if(mchem.NE.4 .AND. pivolu.LE.0.0) then
            write(io6,*)'CHEM:  No Puff volume above lid!'
            write(io6,*)'       Puff ID = ',ipnum
            write(*,*)
            stop 'Halted in CHEM -- see list file.'
         endif
         if(mchem.LE.2) then
            do i=1,nt1
               con(i)=qup(i)*pivolu
            enddo
            call CHEMTF(delt,con,qup,chioz,bcknh3,chih2o2,qsw,tempk,
     1                  rhum,rhoair,jdstab,rnite1,rnite2,rnite3,mchem,
     2                  maqchem,ruser,nspec,ldb,io6,rup)
         elseif(mchem.EQ.3) then
            o3ent=chioz
            if(lentrain) o3ent=chioz*ventu*pivolu
            call CHEMRIV(delt,qup,chioz,bcknh3,chih2o2,maqchem,tempk,
     1                   rhum,rhoair,pivolu,zmsl,cloud,zcoef,nspec,
     2                   ldb,io6,rup3)
         elseif(mchem.EQ.4) then
            call CHEMSOA(ldb,io6,delt,qup,jdstab,qsw,tempk,chioz,rup4)
         endif
      endif
C
      do i=1,nspec
         qm(i,jp)=qmid(i)
         qu(i,jp)=qup(i)
      enddo
c
c --- XSCALE is 0.984127 = 62./63. = (mol. wt. NO3)/(mol. wt. HNO3)
c --- (does not apply to mchem=4)
      if(nspec.ge.nt)then
         qm(nt,jp)=(qmid(nt)-qmid(nt1))/xscale
         qu(nt,jp)=(qup(nt)-qup(nt1))/xscale
         qm(nt1,jp)=qmid(nt1)
         qu(nt1,jp)=qup(nt1)
      endif
c
100   continue
c*****
      if(ldb)then
         write(io6,*)'CHEMICAL CONVERSION over step (s): ',tsamp
         if(mchem.EQ.3) then
            write(io6,103) rup3
            write(io6,105) rmid3
         elseif(mchem.EQ.4) then
            write(io6,103) rup4
            write(io6,105) rmid4
         else
            write(io6,103) (rup(n),n=1,ireact)
            write(io6,105) (rmid(n),n=1,ireact)
         endif
103      format(5x,'UPPER LAYER',2x,'rup =',4F12.2)
105      format(5x,'MIXED LAYER',2x,'rmid=',4F12.2)
      endif
c*****
      return
      end
c----------------------------------------------------------------------
      subroutine chemtf(delt,con,q,coz,ctnh3,ch2o2,qsw,temp,
     1 rhum,rhoair,istab,rnite1,rnite2,rnite3,mchem,maqchem,ruser,
     2 nspec,ldb1,io6,r)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_3               CHEMTF
c                J. Scire
c --- Adapted from MESOPUFF II Subr. CHEMTF written by F. Lurmann
c     MESOPUFF II   VERSION 4.41  LEVEL 821201   CHEMTF     ERT
c
c --- PURPOSE:  This routine adjusts the pollutant mass values
c               to account for chemical transformations
c
c --- UPDATE
c --- V5.4-V5.4
c          000602 - 000602_3(DGS): add aqueous chemistry module
c --- V5.0-V5.4
c          980615 - 000602  (DGS): add message to "stop"
c --- V5.0-V5.0
c          960612 - 980615  (DGS): fix NSPEC loop (limit = 5)
c
c --- INPUTS:
c         DELT - real    - integration time interval (hours)
c       CON(5) - real    - Concentrations current time (g/m**3)
c                            CON(1) = SO2  (not used within CHEMTF)
c                            CON(2) = SO4
c                            CON(3) = NOx  (NO + NO2 weighed as NO2)
c                            CON(4) = TNO3 (HNO3 + NO3)
c                            CON(5) = NH4NO3  (not used within CHEMTF)
c         Q(5) - real    - Pollutant mass (g) in the puff
c                            Q(1) = SO2
c                            Q(2) = SO4
c                            Q(3) = NOx
c                            Q(4) = TNO3 (HNO3 + NO3)
c                            Q(5) = NH4NO3
c          COZ - real    - background ozone concentration (ppb)
c        CTNH3 - real    - background ammonia concentration (ppb)
c        CH2O2 - real    - background H2O2 concentration (ppb)
c          QSW - real    - total solar radiation (W/m**2)
c         CNOX - real    - NOx concentration current time (ppb)
c         TEMP - real    - temperature (deg. K)
c         RHUM - real    - relative humidity (percent)
c       RHOAIR - real    - surface air density (kg/m**3)
c        ISTAB - integer - PGT stability class (1-6)
c       RNITE1 - real    - nighttime SO2 loss rate (percent/hour)
c       RNITE2 - real    - nighttime NOx loss rate (percent/hour)
c       RNITE3 - real    - nighttime HNO3 formation rate (percent/hour)
c        MCHEM - integer - Chemical transformation mechanism
c                          flag (0 = no transformation,
c                            1 = MESOPUFF II scheme,
c                            2 = user-specified rates, except
c                                HNO3 <--> NO3 based on equilibrium
c                                equation)
c      MAQCHEM - integer - Aqueous phase transformation flag
c                            0 = aqueous phase transformation
c                                not modeled
c                            1 = transformation rates adjusted
c                                for aqueous phase reactions
c     RUSER(3) - real    - User-specified conversion rates (percent/hr)
c        NSPEC - real    - number of species
c         LDB1 - logical - Control variable for printing of debug
c                          information
c          IO6 - integer - Fortran unit number of printed output
c
c --- OUTPUT:
c         R(3) - real    - Transformation rates (percent/hour)
c                            R(1) -- SO2 loss rate
c                            R(2) -- NOx loss rate
c                            R(3) -- HNO3 formation rate
c
c --- CHEMTF called by: CHEM
c --- CHEMTF calls:     CHEMII, CHEMEQ, AQTEST
c----------------------------------------------------------------------
c
      real con(5),ppb(5),q(5),r(3),ruser(3)
      real rmwt(5)
      logical ldb1
c
c --- Note: HNO3 is weighed as NO3
      data rmwt/64.,96.,46.,62.,62./

c --- Define default fraction of mass available for aqueous phase chem
c --- as a fraction/hour
      data faqmass0/0.02/
c
c --- Define local NSPEC to be no greater than 5
      nspec5=MIN0(nspec,5) 
c
c --- Convert units of solar radiation from W/m**2 to KW/m**2
      tsr=0.001*qsw
c
c --- Combine %-conversion with time-step
      dt=0.01*delt
c
c --- Convert concentrations from g/m**3 to ppb
c --- Note: constant 28.97e6 is based on rho in kg/m**3, not g/m**3
      f=28.97e6/rhoair
      do 10 i=1,nspec5
      ppb(I)=con(i)*f/rmwt(i)
10    continue

c --- Initialize parameters for aqueous phase chem
c --- Available SO2 mass fraction
      faqmass=0.0
c --- Fraction of available SO2 lost
      faqloss=0.0
c
c --- Compute transformation rates
c
      if(mchem.eq.1)then
c
c ---    Using MESOPUFF II scheme to compute transformation rates
         call chemii(ppb(3),coz,tsr,rhum,istab,rnite1,rnite2,
     1   rnite3,r)
c ---    SO2 loss rate if using aqueous phase module
         if(maqchem.EQ.1) then
            call AQTEST(delt,con,coz,ctnh3,ch2o2,temp,
     1                  rhoair,ldb1,io6,raq)
c ---       Factor for SO2 loss rate from Aqueous Chem Module
            faqloss=(1.-exp(-raq*dt))
            faqmass=faqmass0*delt
         endif
      else if(mchem.eq.2)then
c
c ---    Using user-specified conversion rates
         r(1)=ruser(1)
         r(2)=ruser(2)
         r(3)=ruser(3)
      else
         write(io6,*)'ERROR in SUBR. CHEMTF -- Invalid value of ',
     1   'MCHEM passed to routine -- MCHEM = ',mchem
         write(*,*)
         stop 'Halted in CHEMTF -- see list file.'
      endif
c
c --- Perform transformation/integration
c
c------------- SOX --------------------
c
c --- Factor for SO2 loss rate from Chem Module
      floss=(1.-exp(-r(1)*dt))
c
      dc1=q(1)*((1.-faqmass)*floss+faqmass*faqloss)
      q(1)=q(1)-dc1
      q(2)=q(2)+rmwt(2)*dc1/rmwt(1)
c
c------------- NOX --------------------
c
      if(nspec5.ge.3)then
         dc1=q(3)*(1.-exp(-r(2)*dt))
         dc2=q(3)*(1.-exp(-r(3)*dt))
         q(3)=q(3)-dc1
         q(4)=q(4)+rmwt(4)*dc2/rmwt(3)
         q(5)=0.0
         if(q(4).gt.0.0)then
c
c ---       Adjust total ammonia for that absorbed by SO4 in the puff
            canh3=ctnh3-2.*ppb(2)
            if(canh3.gt.0.0)then
c
c ---          Compute NH4NO3 concentration from chemical equilibrium
               call chemeq(canh3,ppb(4),rhum,temp,ppb(5),ehno3,ehn3,io6)
c
c ------------ HNO3, NH4NO3 --------------
               pfrac=0.0
               if(ppb(4).gt.0.0)pfrac=ppb(5)/ppb(4)
c ---          Prevent round-off problem; PFRAC must be 0.0-1.0
               pfrac=amax1(pfrac,0.0)
               pfrac=amin1(pfrac,1.0)
               q(5)=q(4)*pfrac
c*****
               if(ldb1)write(io6,2028)pfrac,ppb(4),ehno3,ppb(5),ehn3,
     1          rhum,temp
2028           format(24x,'PFRAC=',f4.2,1x,'TNO3(ppb)=',f6.2,1x,
     1          'HNO3(ppb)=',f6.2,1x,'NO3(ppb)=',f6.2,1x,'NH3(ppb)=',
     2          f6.2,1x,'RHUM=',f4.0,1x,'TEMP=',f5.1)
c*****
            endif
         endif
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine chemii(cnox,coz,tsr,rhum,istab,rnite1,rnite2,
     1 rnite3,r)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                   CHEM
c                J. Scire
c --- Adapted from MESOPUFF II Subr. CHEMTR written by F. Lurmann
c
c --- Purpose: Calculate the chemical tranformation rates for loss
c              of SO2 & NOx and formation of SO4 & HNO3
c
c --- INPUTS:
c         CNOX - real    - NOx concentration current time (ppb)
c          TSR - real    - total solar radiation (KW/M**2)
c        ISTAB - integer - PGT stability class (1-6)
c         RHUM - real    - relative humidity (percent)
c          COZ - real    - background ozone concentration (ppb)
c       RNITE1 - real    - nighttime SO2 loss rate (percent/hour)
c       RNITE2 - real    - nighttime NOx loss rate (percent/hour)
c       RNITE3 - real    - nighttime HNO3 formation rate (percent/hour)
c
c --- OUTPUT:
c         R(3) - real    - Transformation rates (percent/hour)
c                            R(1) -- SO2 loss rate
c                            R(2) -- NOx loss rate
c                            R(3) -- HNO3 formation rate
c
c --- CHEMII called by: CHEM
c --- CHEMII calls:     none
c----------------------------------------------------------------------
      real r(3)
c
c --- Initialize conversion rates
      do 10 i=1,3
      r(i)=0.0
10    continue
c
      co3ppm=0.001*coz
      st=amax0(istab,2)
c
c ---------------------------
c --- SOx transformation rate
c ---------------------------
      if(tsr.le.0.)then
c
c ---    Use nighttime transformation rate
         r(1)=rnite1
      else
c
c ---    Compute daytime transformation rate
         r(1)=36.*(tsr**.55)*(co3ppm**.71)/(st**1.29)
c ---    Add heterogeneous component
         rshet=3.E-8*(rhum**4)
         rshet=amax1(rshet,0.2)
         r(1)=r(1)+rshet
      endif
c
c ----------------------------
c --- NOx transformation rates
c ----------------------------
      if(tsr.le.0.)then
c
c ---    Use nighttime transformation rates
         r(2)=rnite2
         r(3)=rnite3
      else
c
c ---    Compute daytime transformation rates
         cnppm=0.001*cnox
         cnppm=amax1(cnppm,1.e-4)
         r(2)=1206.*(co3ppm**1.50)/(cnppm**.329)/(st**1.41)
         r(3)=1262.*(co3ppm**1.45)/(cnppm**.122)/(st**1.34)
         r(3)=amin1(r(2),r(3))
      endif
c
      return
      end
c----------------------------------------------------------------------
      SUBROUTINE CHEMEQ(CANH3,CTNO3,RHUM,TEMP,CPNO3,EHNO3,ENH3,io6)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960612                 CHEMEQ
c --- Adapted from MESOPUFF II Subr. CHEMEQ
c     MESOPUFF II   VERSION 4.41  LEVEL 821201   CHEMEQ     ERT
C
C      THIS ROUTINE DETERMINES AMMONIUM NITRATE CONCENTRATION
C      FROM TOTAL NITRATE CONCENTRATION.
C
C INPUTS:  CANH3 = TOTAL AMMONIA AVAILIABLE FOR NH4NO3 FORMATION (PPB)
C                  (IE. TOTAL AMMONIA - SULFATE)
C          CTNO3 = PUFF TOTAL NITRATE CONCENTRATION (PPB)
C           RHUM = RELATIVE HUMIDITY (PERCENT)
C           TEMP = TEMP (DEG K)
C           io6 = LOGICAL UNIT OF PRINTED OUTPUT FILE
C
C OUTPUTS: CPNO3 = EQUILIBRIUM NH4NO3 AEROSOL CONCENTRATION (PPB)
C          EHNO3 = EQUILIBRIUM GASEOUS HNO3 CONCENTRATION (PPB)
C          ENH3  = EQUILIBRIUM GASEOUS NH3 CONCENTRATION (PPB)
C
C METHOD:  WE ASSUME HNO3, NH3, AND NH4NO3 ARE IN EQUILIBRIUM.
C
C          HNO3 + NH3 <---> NH4NO3
C
C          K = (NH3)*(HNO3)/(NH4NO3)
C
C          K HAS BEEN SHOWN TO BE A NONLINEAR FUNCTION OF
C          RELATIVE HUMIDITY AND TEMPERATURE.
C
C          WE USE DOUBLE LINEAR INTERPOLATION ON TABULATED DATA
C          TO DETERMINE K FROM RHUM AND TEMP.
C
C          EQUILIBRIUM CONSTANT DATA OBTAINED FROM:
C
C          STELSON,A.W. AND J.H.SEINFELD 1982.  RELATIVE HUMIDITY
C          AND TEMPERATURE DEPENDENCE OF AMMONIUM NITRATE
C          DISSOCIATION CONSTANT. ATMOSPHERIC ENVIRONMENT.
C          VOL.16,NO.5,PP 983-992.
C
C          GIVEN CTNO3, CANH3, AND K, NH4NO3 IS DETERMINED
C          FROM THE FOLLOWING EQUATION:
C
C          NH4NO3 = 0.5 * (B - SQRT(B**2 -4*CTNO3*CANH3) )
C          WHERE B = K + CTNO3 + CANH3
C
      DIMENSION EQKD(10,5), RHUMD(10), TEMPD(5)
      double precision b,r
C
C------ RELATIVE HUMIDITY VECTOR    (DATA IN PERCENT)
      DATA RHUMD /0.,50.,60.,70.,75.,80.,85.,90.,95.,100./
      DATA NRHUMD /10/
C------ TEMPERATURE VECTOR     (DATA IN DEGREES KELVIN)
      DATA TEMPD /273.,283.,293.,303.,313./
      DATA NTEMPD /5/
C------ EQUILIBRIUM CONSTANT ARRAY   (DATA IN PPB)
      DATA EQKD /        5*.029,  .02,  .012,  .008,  .003,  .0001,
     1              4*.535,.400,  .30,   .24,   .15,   .04,   .001,
     2         3*8.0,   7.,  6.,   4.,    3.,   1.5,    .4,    .01,
     3   2*99.6, 98.,  75., 60.,  40.,   28.,   13.,    4.,    .02,
     4  2*1047.,1000.,700.,500., 400.,  250.,  120.,   20.,    .05/
C
C------- FIND THE INDICES IN TEMPD WHICH BRACKET TEMP
C
      TEMPX = TEMP
      TEMPX = AMAX1(TEMPX,TEMPD(1))
      TEMPX = AMIN1(TEMPX,TEMPD(NTEMPD))
      N = NTEMPD - 1
c *** NOTE: If tempx=tempd(1) i.e., temp < tempd(1) won't satisfy the
c ***       following if therefore changing .GT. to .GE. -- 5/30/93
      DO 100 K=1,N
c***  IF( (TEMPX.GT.TEMPD(K)) .AND. (TEMPX.LE.TEMPD(K+1)) )  GO TO 110
      IF( (TEMPX.ge.TEMPD(K)) .AND. (TEMPX.LE.TEMPD(K+1)) )  GO TO 110
100   CONTINUE
110   K1 = K
      K2 = K + 1
C------- INTERPOLATION ON RELATIVE HUMIDITY AT
C        THE UPPER AND LOWER TEMPERATURES.
      EQK1 = TRPF(RHUM,RHUMD,EQKD(1,K1),NRHUMD)
      EQK2 = TRPF(RHUM,RHUMD,EQKD(1,K2),NRHUMD)
C------- INTERPOLATE ON TEMPERATURE TO FIND K
      EQK = EQK1 + ((TEMPX-TEMPD(K1))/(TEMPD(K2)-TEMPD(K1)))*(EQK2-EQK1)
C------- SOLVE THE QUADRATIC EQN FOR NH4NO3 CONCENTRATION
      B = EQK + CANH3 + CTNO3
      R = B**2 - 4.*CANH3*CTNO3
      IF(R.LT.0.)  GO TO 120
c *** Change to double precision to avoid precision problems
c *** as recommended by J. Vimont (NPS) - 6/96
c *** CPNO3 = (B -SQRT(R))/2.
      CPNO3 = 0.5d0*(B-DSQRT(R))
      if((ctno3-cpno3).lt.0.0)then
        cpno3=ctno3
      endif
c --- Add checks to avoid problems when b**2 = r
      cpno3 = amax1(cpno3,0.0)
      EHNO3 = CTNO3 - CPNO3
      ehno3 = amax1(ehno3,0.0)
      ENH3 = CANH3 - CPNO3
      enh3 = amax1(enh3,0.0)
      RETURN
120   WRITE(io6,130) CANH3,CTNO3,TEMP,rhum,EQK
130   FORMAT(56H1JOB ABORTED IN CHEMEQ -- QUADRATIC EQN NOT SOLVABLE
     1,//, 30H NH3, TNO3, TEMP, RHUM, EQK =         ,5E12.4)
      write(*,*)
      stop 'Halted in CHEMEQ -- see list file.'
      END
c----------------------------------------------------------------------
      FUNCTION TRPF(X,XS,FS,NXF)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                   TRPF
c --- Adapted from MESOPUFF II Subr. CHEM
c     MESOPUFF II   VERSION 4.41  LEVEL 821201   TRPF     ERT
c
C--------- TRPF IS A LINEAR INTERPOLATOR
      DIMENSION XS(NXF),FS(NXF)
      IF(XS(NXF)-XS(1))  100,120,120
100   DO 110 K =1,NXF
      IF(X-XS(K))  110,110,140
110   CONTINUE
      K=NXF + 1
      GO TO 140
120   DO 130 K=1,NXF
      IF(XS(K)-X)  130,130,140
130   CONTINUE
      K=NXF + 1
140   KL=K-1
      IF(K-2) 160,170,150
150   IF(K-NXF) 170,170,180
160   TRPF = FS(1)
      RETURN
170   DX = XS(K) - XS(KL)
      IF(DX.NE.0.0000)  GO TO 175
      TRPF = FS(KL)
      RETURN
175   TRPF =FS(KL)+(X-XS(KL))*(FS(K)-FS(KL))/DX
      RETURN
180   TRPF = FS(NXF)
      RETURN
      END
c----------------------------------------------------------------------
      subroutine chemi(mchem,maqchem,ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070629                  CHEMI
c                J. Scire
c
c --- PURPOSE:  Setup functions for the chemistry module
c                 -- Read user-specified conversion rates from CHEM.DAT
c                 -- Read header & time-invariant records of the
c                    hourly ozone data file (OZONE.DAT) and the
c                    hourly H2O2 data file (H2O2.DAT)
c                 -- Perform conversion of station coordinates and
c                    compute nearest ozone station to each grid point
c
c --- UPDATE
c --- 6.102-V6.2
c          051130 - 070629  (DGS): LPRT in call to RDHDAQ should be LDB
c
c --- 6.1-V6.102
c          050915 - 051130  (DGS): pass map projection of AQ data to
c                                  RDTIAQ in place of LLORDER
c --- V5.727-V6.1
c          050309 - 050915  (DGS): convert AQ station locations to
c                                  model map projection and datum
c                           (DGS): remove UTM zone check for OZONE.DAT
c                           (DGS): replace RDHDOZ with RDHDAQ, and
c                                  RDTIOZ with RDTIAQ
c --- V5.7-V5.727
c          030402 - 050309  (DGS): revise UTM zone check for OZONE.DAT
c --- V5.4-V5.7
c          000602_3- 030402 (DGS): add /MAP/
c --- V5.4-V5.4
c          000602 - 000602_3(DGS): add H2O2.DAT for aqueous chemistry
c --- V5.0-V5.4
c          990130 - 000602  (DGS): add message to "stop"
c --- V5.0-V5.0
c          980918 - 990130  (JSS): fixed logic for NSPEC=2 and 3
c          980304 - 980918  (DGS): add MCHEM=4 logic and species QA
c                                  fix SOA species name checking
c          941215 - 980304  (DGS): add MCHEM=3 logic and species QA
c
c --- INPUTS:
c             MCHEM - integer - Chemical transformation mechanism
c                               flag (0 = no transformation,
c                               1 = MESOPUFF II scheme,
c                               2 = user-specified rates, except
c                                   HNO3 <--> NO3 based on equilibrium
c                                   equation)
c                               3 = RIVAD scheme with HNO3 <--> NO3 
c                                   equilibrium)
c                               4 = Form SOA from VOC emissions
c           MAQCHEM - integer - Aqueous phase transformation flag
c                               (Used only if MCHEM = 1 or 3)
c                               0 = aqueous phase transformation
c                                   not modeled
c                               1 = transformation rates adjusted
c                                   for aqueous phase reactions
c              LDB - logical  - Flag controlling printing of header
c                               record data (F=suppress, T=print)
c
c     Common block /CHEMDAT/ variables
c           MOZ, MH2O2
c     common block /DATASET/ variables
c           veroz,verh2o2
c     Common block /GEN/ variables
c           NSPEC, CSPEC(mxspec), METFM
c     Common block /GRID/ variables
c           NX, NY, DGRID, XORIG, YORIG
c     Common block /MAP/ variables
c           IUTMZN, PMAP, UTMHEM, DATUM
c     common block /MAP/ variables
c           iutmzn,feast,fnorth,
c           rnlat0,relon0,rlat0,rlon0,xlat1,xlat2,
c           pmap,utmhem,datum
c
c        Parameters:
c           IO6, MXSPEC, MXOZ, MXNX, MXNY, MXNZP1
c
c --- OUTPUT:
c     Common block /CHEMDAT/ variables
c           CHEMT(24,3) --->  (if MCHEM=2)
c           NOZSTA,IUTMOZ,IBDATO,IBTIMO,IEDATO,IETIMO,VRSOZ,LABOZ, and
c           NEAROZ      --->  (if MCHEM=1,3,4 and MOZ=1)
c           NH2O2STA,IUTMH2O2,IBDATH,IBTIMH,IEDATH,IETIMH,VRSH2O2,
c           LABH2O2, and NEAROZ
c                       --->  (if MAQCHEM=1 and MH2O2=1)
c     Common block /SOA/ variables (if MCHEM=4)
c           LAROM, LBIOG
c
c --- CHEMI called by: SETUP
c --- CHEMI calls:     RDCHEM, OUT, SSLATLON,
c                      RDHDAQ, RDTIAQ
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'chemdat.puf'
      include 'dataset.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'map.puf'
      include 'soa.puf'
c
      logical ldb,ldate,problem
      character*70 messag
      character*12 cspec1(5),cspec3(6),cspec4(5)

      character*12 dtype

c --- For coordinate transformations
      character*8 cmapi,cmapo
      character*12 caction
      character*4 c4hem
      real*8 vecti(9),vecto(9)

      data cspec1/ 'SO2', 'SO4', 'NOX', 'HNO3',   'NO3'/
      data cspec3/ 'SO2', 'SO4', 'NO', 'NO2', 'HNO3', 'NO3'/
      data cspec4/ 'TOLUENE', 'XYLENE', 'B-PINENE', 'A-PINENE',
     &             'SOA'/
      data rmax/1.e37/

      problem=.FALSE.

c --- Set up for coordinate transformations
c --- Scale factor for Tangential TM projection
      tmsone=1.00000
c --- Output of coord transform is to CALPUFF (x,y) - /MAP/
      iutmo=iutmzn
      if(utmhem.EQ.'S   ' .AND. iutmo.LT.900) iutmo=-iutmo
      cmapo=pmap
      if(cmapo.EQ.'TTM     ') cmapo='TM      '

c --- Perform QA check on species library;  Species must be entered
c --- in the correct order
      if(mchem.LT.3) then
c ---    Check for MESOPUFF species
         if(nspec.LT.5) then
c ********* if(nspec.NE.2 .OR. nspec.NE.3) problem=.TRUE.
c ---       Allowed values of NSPEC are 2,3,5 with MCHEM=1 or 2
            if(nspec.eq.1.or.nspec.eq.4) problem=.true.
         endif
         is=MIN0(nspec,5)
         do i=1,is
            if(cspec(i).NE.cspec1(i)) then
               problem=.TRUE.
            endif
         enddo
      elseif(mchem.EQ.3) then
c ---    Check for RIVAD species
         if(nspec.LT.6) then
c ********* if(nspec.NE.2 .OR. nspec.NE.4) problem=.TRUE.
c ---       Allowed values of NSPEC are 2,4,6 with MCHEM=3
            if(nspec.eq.1.or.nspec.eq.3.or.nspec.eq.5) problem=.true.
         endif
         is=MIN0(nspec,6)
         do i=1,is
            if(cspec(i).NE.cspec3(i)) then
               problem=.TRUE.
            endif
         enddo
      elseif(mchem.EQ.4) then
c ---    Check for VOC and SOA species
         larom=.FALSE.
         lbiog=.FALSE.
         if(nspec.LT.3) then
            problem=.TRUE.
         elseif(cspec(1).EQ.cspec4(1)) then
            larom=.TRUE.
            if(cspec(3).EQ.cspec4(3)) lbiog=.TRUE.
         elseif(cspec(1).EQ.cspec4(3)) then
            lbiog=.TRUE.
         endif
         is=MIN0(nspec,5)
         if(LAROM .AND. LBIOG) then
c ---       First 5 species should match expected order
            if(is.NE.5) then
               problem=.TRUE.
            else
               do i=1,is
                  if(cspec(i).NE.cspec4(i)) problem=.TRUE.
               enddo
            endif
         elseif(LAROM) then
c ---       First 2 species should be aromatics; 3rd is SOA
            if(is.GE.3) then
               if(cspec(3).NE.cspec4(5)) problem=.TRUE.
               do i=1,2
                  if(cspec(i).NE.cspec4(i)) problem=.TRUE.
               enddo
            endif
         elseif(LBIOG) then
c ---       First 2 species should be biogenics; 3rd is SOA
            if(is.GE.3) then
               do i=1,3
                  if(cspec(i).NE.cspec4(i+2)) problem=.TRUE.
               enddo
            endif
         else
c ---       Initial species name is not consistent with SOA CHEM
            problem=.TRUE.
         endif
      else
         problem=.TRUE.
      endif
      if(problem) then
         if(mchem.EQ.3) then
            write(io6,*)'CHEMI: FATAL error with species'
            write(io6,*)'RIVAD chemistry selected, MCHEM= ',mchem
            write(io6,*)'Species number must be 2,4,6 or greater'
            write(io6,*)'And ordered as:'
            do i=1,6
               write(io6,*) cspec3(i)
            enddo
            write(io6,*)'Species found:'
            do i=1,is
               write(io6,*) cspec(i)
            enddo
         elseif(mchem.LT.3) then
            write(io6,*)'CHEMI: FATAL error with species'
            write(io6,*)'User or MESOPUFF chemistry, MCHEM= ',mchem
            write(io6,*)'Species number must be 2,3,5 or greater'
            write(io6,*)'And ordered as:'
            do i=1,5
               write(io6,*) cspec1(i)
            enddo
            write(io6,*)'Species found:'
            do i=1,is
               write(io6,*) cspec(i)
            enddo
         elseif(mchem.EQ.4) then
            write(io6,*)'CHEMI: FATAL error with species'
            write(io6,*)'SOA chemistry selected, MCHEM= ',mchem
            write(io6,*)'Species order must be either'
            do i=1,5
               write(io6,*) cspec4(i)
            enddo
            write(io6,*)'for AROMATIC and BIOGENIC VOCs, or'
            do i=1,2
               write(io6,*) cspec4(i)
            enddo
            write(io6,*) cspec4(5)
            write(io6,*)'for just AROMATIC VOCs, or'
            do i=1,3
               write(io6,*) cspec4(i+2)
            enddo
            write(io6,*)'for just BIOGENIC VOCs.'
            write(io6,*)
            write(io6,*)'Species found:'
            do i=1,is
               write(io6,*) cspec(i)
            enddo
         else
            write(io6,*)'CHEMI: FATAL error with chemistry selection'
            write(io6,*)'Undefined MCHEM= ',mchem
            write(*,*)
            stop 'Halted in CHEMI -- see list file.'
         endif
         write(*,*)
         stop 'Halted in CHEMI -- see list file.'
      endif
c
c -------------------------------------------------------------------
c --- Read user-specified chemical transformation rates from CHEM.DAT
c -------------------------------------------------------------------
      if(mchem.eq.2)call rdchem(nspec)
c
c ----------------------------------------------------------------------
c --- Read and process header & time-invariant ozone data from OZONE.DAT
c ----------------------------------------------------------------------
      if((mchem.EQ.1 .OR. mchem.EQ.3 .OR. mchem.EQ.4) .AND. moz.EQ.1)
     &   then
         dtype='OZONE       '
c
c ---    Read the header record
         call RDHDAQ(dtype,io22,veroz,ldb,nozsta,ibdathro,ibseco,
     &               iedathro,ieseco,t2btzoz,iutmoz,pmapoz,utmhemoz,
     &               datumoz,datenoz,xyunitoz,feastoz,fnorthoz,
     &               rnlat0oz,relon0oz,rnlat1oz,rnlat2oz)
c
c ---    Read the time-invariant records
         call RDTIAQ(dtype,io22,nozsta,pmapoz,ldb,cidoz,xozm,yozm)
c
c ---    Set up map projection conversion to CALPUFF coordinates
         iutmi=iutmoz
         if(utmhemoz.EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
         cmapi=pmapoz
         if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---    Set conversion vectors
         call GLOBE1(cmapi,iutmi,tmsone,rnlat1oz,rnlat2oz,
     &               rnlat0oz,relon0oz,feastoz,fnorthoz,
     &               cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &               feast,fnorth,
     &               caction,vecti,vecto)
c
c ---    Convert station coordinates to model map projection and datm,
c ---    and then from (km) to meters relative to origin of met. grid
         do i=1,nozsta
            call GLOBE(io6,caction,datumoz,vecti,datum,vecto,
     &                 xozm(i),yozm(i),xdum,ydum,izone,c4hem)
            xozm(i)=1000.*xdum-xorig
            yozm(i)=1000.*ydum-yorig
         enddo
c
c ---    Compute the station number of the closest ozone station to
c ---    each grid point
         if(nozsta.eq.1)then
            do 30 i=1,nx
            do 30 j=1,ny
            nearoz(i,j)=1
30          continue
         else if(nozsta.ge.2)then
            do 40 i=1,nx
            xgdpt=(float(i)-0.5)*dgrid
            do 40 j=1,ny
            ygdpt=(float(j)-0.5)*dgrid
            dmin2=rmax
            ksv=0
c
c ---       Loop over ozone stations to find the closest one to
c ---       grid point (i,j)
            do 35 k=1,nozsta
            dist2=(xozm(k)-xgdpt)**2 + (yozm(k)-ygdpt)**2
            if(dist2.lt.dmin2)then
               dmin2=dist2
               ksv=k
            endif
35          continue
c
            if(ksv.gt.0)then
               nearoz(i,j)=ksv
            else
               write(io6,*)'ERROR in subr. CHEMI -- Invalid value ',
     1         'of KSV --  KSV = ',ksv,' I = ',i,' J = ',j
               write(*,*)
               stop 'Halted in CHEMI -- see list file.'
            endif
40          continue
c
         else
            write(io6,*)'ERROR in subr. CHEMI -- Invalid value ',
     1      'of NOZSTA with MOZ=2 option -- NOZSTA = ',nozsta
            write(*,*)
            stop 'Halted in CHEMI -- see list file.'
         endif
c
c ---    Write NEAROZ data
         if(ldb)then
            ldate=.false.
            messag='Nearest ozone station number to each grid point'
            call out(xdum,nearoz,2,5,ldate,messag,nx,ny)
         endif
      endif
c
c ----------------------------------------------------------------------
c --- Read and process header & time-invariant H2O2 data from H2O2.DAT
c ----------------------------------------------------------------------
      if(maqchem.EQ.1 .AND. mh2o2.EQ.1) then
         dtype='H2O2        '
c
c ---    Read the header record
         call RDHDAQ(dtype,io23,verh2o2,ldb,nh2o2sta,ibdathrh,ibsech,
     &               iedathrh,iesech,t2btzhp,iutmhp,pmaphp,utmhemhp,
     &               datumhp,datenhp,xyunithp,feasthp,fnorthhp,
     &               rnlat0hp,relon0hp,rnlat1hp,rnlat2hp)
c
c ---    Read the time-invariant records
         call RDTIAQ(dtype,io23,nh2o2sta,pmaphp,ldb,
     &               cidhp,xh2o2m,yh2o2m)
c
c ---    Set up map projection conversion to CALPUFF coordinates
c ---    Input is from H2O2.DAT header - /CHEMDAT/
         iutmi=iutmhp
         if(utmhemhp.EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
         cmapi=pmaphp
         if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---    Set conversion vectors
         call GLOBE1(cmapi,iutmi,tmsone,rnlat1hp,rnlat2hp,
     &               rnlat0hp,relon0hp,feasthp,fnorthhp,
     &               cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &               feast,fnorth,
     &               caction,vecti,vecto)
c
c ---    Convert station coordinates to model map projection and datm,
c ---    and then from (km) to meters relative to origin of met. grid
         do i=1,nh2o2sta
            call GLOBE(io6,caction,datumhp,vecti,datum,vecto,
     &                 xh2o2m(i),yh2o2m,xdum,ydum,izone,c4hem)
            xh2o2m(i)=1000.*xdum-xorig
            yh2o2m(i)=1000.*ydum-yorig
         enddo
c
c ---    Compute the station number of the closest H2O2 station to
c ---    each grid point
         if(nh2o2sta.eq.1)then
            do i=1,nx
               do j=1,ny
                  nearh2o2(i,j)=1
               enddo
            enddo
         else if(nh2o2sta.ge.2)then
            do 140 i=1,nx
            xgdpt=(float(i)-0.5)*dgrid
            do 140 j=1,ny
            ygdpt=(float(j)-0.5)*dgrid
            dmin2=rmax
            ksv=0
c
c ---       Loop over H2O2 stations to find the closest one to
c ---       grid point (i,j)
            do k=1,nh2o2sta
               dist2=(xh2o2m(k)-xgdpt)**2 + (yh2o2m(k)-ygdpt)**2
               if(dist2.lt.dmin2)then
                  dmin2=dist2
                  ksv=k
               endif
            enddo
c
            if(ksv.gt.0)then
               nearh2o2(i,j)=ksv
            else
               write(io6,*)'ERROR in subr. CHEMI -- Invalid value ',
     1         'of KSV --  KSV = ',ksv,' I = ',i,' J = ',j
               write(*,*)
               stop 'Halted in CHEMI -- see list file.'
            endif
140         continue
c
         else
            write(io6,*)'ERROR in subr. CHEMI -- Invalid value ',
     1      'of NH2O2STA with MH2O2=2 option -- NH2O2STA = ',nh2o2sta
            write(*,*)
            stop 'Halted in CHEMI -- see list file.'
         endif
c
c ---    Write NEARH2O2 data
         if(ldb)then
            ldate=.false.
            messag='Nearest H2O2 station number to each grid point'
            call out(xdum,nearh2o2,2,5,ldate,messag,nx,ny)
         endif
      endif
c
c ----------------------------------------------------------------------
c --- Compute Lat/Lon for CALMET surface met stations for MCHEM=3
c ----------------------------------------------------------------------
      if(mchem.EQ.3 .AND. metfm.EQ.1) call SSLATLON(ldb)
c
c
      return
      end
c----------------------------------------------------------------------
      subroutine rdchem(nspec)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                 RDCHEM
c                J. Scire, SRC
c
c --- PURPOSE:  Read a file containing a diurnal cycle of 24 hourly
c               chemical transformation rates (in percent/hour)
c
c --- UPDATE
c --- V5.4-V5.7
c          000602 - 030402  (DGS): MXVAR relocated to PARAMS.CAL
c --- V5.3-V5.4
c          950122 - 000602  (DGS): add message to "stop"
c
c --- INPUTS:
c        NSPEC - integer - Number of species being modeled
c     Parameters: IO6, IO24
c
c --- OUTPUT:
c     Common block /CHEMDAT/ variables
c           CHEMT(24,3)
c
c --- RDCHEM called by: CHEMI
c --- RDCHEM calls:     READIN
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
      include 'params.cal'
c
      integer ivleng(mxvar),ivtype(mxvar)
      character*12 cvdic(mxvar)
      logical lecho
c
      include 'chemdat.puf'
c
      data cvdic/'k1','k2','k3','K1','K2','K3',54*' '/
      data ivleng/6*24,54*0/
      data ivtype/6*1, 54*0/
      data lecho/.true./
c
c --- Initialize user-specified vd array with missing value
c --- indicators
      do 10 j=1,3
      do 10 i=1,24
      chemt(i,j)=-9999.
10    continue
c
c --- read the formatted file
      write(io6,32)
32    format(///1x,13('----------')//5x,'USER-SPECIFIED CHEMICAL ',
     1 'TRANSFORMATION RATE FILE (CHEM.DAT)'//)
c
      call readin(cvdic,ivleng,ivtype,io24,io6,lecho,
     1 chemt(1,1),chemt(1,2),chemt(1,3),chemt(1,1),chemt(1,2),
     2 chemt(1,3),
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum,idum)
c
c --- check that values for every required species have been read
      ierr=0
      if(nspec.ge.1)then
         do 45 i=1,24
         if(chemt(i,1).le.-9999.)ierr=1
45       continue
      endif
c
      if(nspec.ge.3)then
         do 47 i=1,24
         if(chemt(i,2).le.-9999.)ierr=1
47       continue
      endif
c
      if(nspec.ge.4)then
         do 49 i=1,24
         if(chemt(i,3).le.-9999.)ierr=1
49       continue
      endif
c
c --- Error if any hour for this deposited species is missing
      if(ierr.eq.1)then
         write(io6,57)
57       format(/1x,'ERROR in subr. RDCHEM -- required values not ',
     1   'found in CHEM.DAT file')
         if(nspec.ge.1)write(io6,59)'k1',(chemt(n,1),n=1,24)
         if(nspec.ge.3)write(io6,59)'k2',(chemt(n,2),n=1,24)
         if(nspec.ge.4)write(io6,59)'k2',(chemt(n,3),n=1,24)
59       format(/1x,a2,' = ',12(f10.4,1x)/6x,12(f10.4,1x))
         write(*,*)
         stop 'Halted in RDCHEM -- see list file.'
      endif
c
999   continue
      return
      end
c----------------------------------------------------------------------
      subroutine getoz(ixs,iys,dgrid,ldb,chioz)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                  GETOZ
c                J. Scire, SRC
c
c --- PURPOSE:  Determine the appropriate value of ozone concentration
c               to use in the MESOPUFF II chemical routine
c                -- Use monthly background value if MOZ = 0
c                -- Read hourly values if MOZ = 1
c
c --- UPDATE
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c              IXS - integer - X index of the closest met. grid point
c                              to the puff/slug center
c              IYS - integer - Y index of the closest met. grid point
c                              to the puff/slug center
c            DGRID - real    - Grid spacing (m)
c              LDB - logical - Control variable determining if debug
c                              information is printed
c
c     Common block /CHEMDAT/ variables:
c           MOZ, BCKO3, NOZSTA, OZCONC(mxoz), XOZM(mxoz),
c           YOZM(mxoz), NEAROZ(mxnx,mxny)
c     Parameters:
c           MXNX, MXNY, MXOZ, IO6, IO22
c
c --- OUTPUT:
c            CHIOZ - real    - Ozone concentration (ppb)
c
c --- GETOZ called by:  CHEM
c --- GETOZ calls:      FINDR
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      logical ldb
c
      include 'chemdat.puf'
c
c --- Missing value indicator
      data xmiss/9999./
c
      if(moz.eq.0)then
         chioz=bcko3
      else if(moz.eq.1)then
c
c ---    ISTA is the ozone station closest to grid point (IXS,IYS)
         istaoz=nearoz(ixs,iys)
c
c ---    Determine ozone concentration (ppb) at the closest station
         chioz=ozconc(istaoz)
         if(chioz.ge.xmiss)then
c
c ---       Compute grid point coordinates (m) relative to met.
c ---       grid origin
            xgrd=(float(ixs)-0.5)*dgrid
            ygrd=(float(iys)-0.5)*dgrid
c
c ---       Find closest ozone station with non-missing data
            call findr(xozm,yozm,nozsta,ozconc,xgrd,ygrd,
     1      istaoz,chioz,ierr)
c
c ---       If all station data is missing, use default background conc.
            if(ierr.eq.1)chioz=bcko3
         endif
      else
         write(io6,*)'ERROR in subr. GETOZ -- Invalid value of MOZ',
     1   ' -- MOZ = ',moz
         write(*,*)
         stop 'Halted in GETOZ -- see list file.'
      endif
c
c*****
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. GETOZ -- ixs = ',ixs,' iys = ',iys,
     1   ' dgrid = ',dgrid,' istaoz = ',istaoz
         write(io6,*)'ozconc = ',(ozconc(n),n=1,nozsta)
         write(io6,*)'chioz  = ',chioz
      endif
c*****
      return
      end
c----------------------------------------------------------------------
      subroutine chembk(ndathr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                 CHEMBK
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Select the background Ozone, Ammonia, and H2O2
c               concentration for the current month
c --- UPDATE
c --- V5.5-V5.7     030402  (DGS): Add list file unit to GRDAY
c
c --- INPUTS:
c            NDATHR - integer    - YYYYJJJHH date-time for hour
c
c     Common Block /CHEMDAT/ variables:
c        BCKO3M(12),BCKNH3M(12),BCKH2O2M(12)
c
c --- OUTPUT:
c
c     Common block /CHEMDAT/ variables:
c        BCKO3, BCKNH3, BCKH2O2
c
c --- CHEMBK called by:  COMP
c --- CHEMBK calls:      GRDAY
c----------------------------------------------------------------------
      include 'params.puf'
      include 'chemdat.puf'

c --- Extract month from date-time
      iyr=ndathr/100000
      ijul=ndathr/100 - 1000*iyr
      call GRDAY(io6,iyr,ijul,imo,iday)

c --- Set background data for this month
      bcko3=bcko3m(imo)
      bcknh3=bcknh3m(imo)
      bckh2o2=bckh2o2m(imo)

      return
      end
c----------------------------------------------------------------------
      subroutine comp
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                   COMP
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Computational phase of modeling -- Contains
c               main time loop
c
c --- UPDATE
c --- V6.25-V6.261  080520  (DGS): Add call to SRCTABIN to read current
c                                  tabulated rise properties in the puff
c                                  loop, and assign IMET=1 so that the
c                                  /SRCTAB/ tables are always used
c --- V6.24-V6.25   080227  (DGS): Replace MXSAM with MXNEW in VARSAM
c                                  call, and use a variable starting
c                                  sampling step (NSSTR)
c                                  Revise test for sampling substeps
c                                  (LSUBSAM) from nsam.EQ.mxsam to 
c                                  nsam.GE.mxsam
c --- V6.22-V6.24   080208  (DGS): Compute wind speed used in calls to
c                                  VARSAM as done in POINTS2, AREAS2,
c                                  LINES2, and VOLS
c --- V6.21-V6.22   070921  (DGS): Check for imet outside valid range
c                                  of 1 to MXMETSAV+1
c                   070921  (DGS): Add MXSAM to VARSAM call
c --- V6.2-V6.21    070801  (DGS): Add cap to sigma-z to protect against
c                                  floating-point error in virtuals
c --- V6.11-V6.2    070629  (DGS): Add LCALM to SETPUF/SETSLG calls
c                   070629  (DGS): Process the total chiflx receptor
c                                  arrays even when the individual
c                                  source output option is not used
c                                  because they may contain PRIME cavity
c                                  impacts
c                   070629  (DGS): recast SMXI2 calculation to match v5
c --- V6.1-V6.11    060309  (DGS): Heat flux at start of step is used
c                                  to screen TIBLGRO call
c                           (DGS): Add overwater SVMIN,SWMIN
c --- V5.751-V6.1   050915  (DGS): Add begin-time/end-time structures
c                                  for sub-hour timesteps
c                           (DGS): Replace RDOZ with RDAQ
c                           (DGS): Stop run if primary met data update
c                                  period is less than model timestep
c --- V5.75-V5.751  050805  (DGS): TIBLGRO arguments updated
c --- V5.741-V5.75  050225  (DGS): Place platform (downwash) ht into
c                                  /CURRENT/
c                   050225  (DGS): Add UATZI for TURBSET's AERSWV call
c                   050225  (DGS): Add DPBL arg to PUFRECS, PLGRECS,
c                                  SETPUF, SETSLG, CALCPF, CALCSL, and
c                                  PLMFOG to pass on to SETCSIG and 
c                                  TAULY
c --- V5.74-V5.741  040913  (DGS): Add puff-age cutoff
c --- V5.72-V5.74   040715  (DGS): Add AERMET version of SURFACE and
c                                  PROFILE met data files
c                                  (METFM=5 or MPRFFM=2)
c --- V5.71-V5.72   031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c                   031017  (DGS): Source contribution option added;
c                                  update array space for volemarb
c --- V5.7-V5.71    030528  (DGS): Get search radius for BC puffs from
c                                  user input stored in /BCS/
c --- V5.5-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c                   030402  (DGS): Add list file unit to JULDAY, GRDAY,
c                                  INCR
c                   030402  (DGS): add PRIME downwash changes
c                   030402  (DGS): compute IMET for /CURRENT/
c
c --- V5.4-V5.4     000602_4(DGS): Assign ZFRISE the rise rather than
c                                  the effective plume ht at final rise
c                                  before call to RISEWIND
c --- V5.4-V5.4     000602_4(DGS): BCKO3M, BCKH2O2M monthly arrays
c --- V5.4-V5.4     000602_3(DGS): add H2O2 processing for aqueous chem
c --- V5.4-V5.4     000602_2(DGS): add FOGWIND call for PLUME mode
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c                   000602  (DGS): update SPLIT arguments (horizontal)
c                   000602  (DGS): add IMESG=2 option
c                   000602  (DGS): FOG processing added
c --- V5.3-V5.3     991222a (DGS): move supplementary PROFILE.DAT read
c                                  ahead of reads from primary met file
c                                  and update profile hts here if turbs
c                                  are obtained from PLMMET.DAT
c --- V5.0-V5.3     991222  (DGS): add Boundary Condition puffs and
c                                  remove redundant IPUFID decoding
c --- V5.0-V5.0     981228e (DGS): use IFREE flag for fresh puffs as
c                                  well as attached slugs
c                   981228e (DGS): move initial coastline screen into
c                                  TIBLON
c --- V5.0-V5.0     981228d (DGS): add mass flux balance option
c                   981228d (DGS): debug puff range changed from
c                                  (1,NPFDEB) to (IPFDEB1,IPFDEB2) 
c --- V5.0-V5.0     981228c (DGS): add mass flux output option
c --- V5.0-V5.0     981228  (DGS): shift last hour processed back 1
c                                  when EOF is found
c                   980918  (DGS): use substeps for all sampling steps
c                                  except those with attached slug
c                   980918  (DGS): add SOA module branch (MCHEM=4)
c                   980821  (DGS): allow transitional plume rise hts to
c                                  define advection wind for steps
c                   980821  (DGS): allow sampling sub-steps for wind
c                                  speed increase over timestep
c                   980807  (DGS): read restart data only if NPUFFS>0
c                   980807  (DGS): update ICODE when slug is converted
c                                  to a puff
c                   980807  (DGS): add METFM to INITPUF call
c                   980731  (DGS): refine criteria for JSUP
c                   980722  (DGS): SVMIN & SWMIN by stability class
c                   980515  (DGS): compute steps and mixing ht for TIBL
c                                  module
c                   980430  (DGS): use stability JSUP at heights above
c                                  HLID, which is unlimited for stable
c                                  periods
c                   980304  (DGS): add restart option calls
c --- V4.0-V5.0     971107  (DGS): add EOF recovery to met file call
c                   971107  (DGS): NYR=NYR-1 changed to NPYR=NYR-1
c                   971107  (DGS): screen CTSG receptors hill-by-hill
c                   971107  (DGS): re-order vertex array elements
c                   971107  (DGS): add LNEMARB (variable line source)
c                   971107  (DGS): remove DPBL limit on ZTOP for stable
c                                  and neutral
c                   971107  (DGS): Place ZTOP/ZBOT logic into PUFFDZ,
c                                  and use to find advection speed
c                                  when computing sampling steps
c                   971107  (DGS): compute vertical divergence dwdz of
c                                  CALMET winds and modify sigma-z
c                   971107  (DGS): move record-skip logic into "RD..."
c                   971107  (DGS): move current value of puff code into
c                                  /CURRENT/ as icode
c --- V4.0-V4.07    971107  (DGS): add PDFVARS for CBL
c --- V4.0-V5.0     971107  (DGS): replace ZFINAL puff/slug height array
c                                  with ZPB,ZPE arrays
c                   971107  (DGS): CTSG not called for puffs above CBL
c                   971107  (DGS): RDSIG replaced with RDPROF
c
c --- Parameters: MXNX, MXNY, MXSPEC, MXP4, MXP6, MXP14,
c                 MXPT2, MXAREA, MXLINES, MXLNGRP, MXVOL, MXHILL, IO6
c
c --- COMP called by: MAIN
c --- COMP calls:     JULDAY, RDMET, RDISC, RDPLM, RDMET4, RDPROF,
c                     SPLIT,INITR2D,GETPRFM,GETPRFP,HDUN,INITPUF,ZFIND,
c                     ADVECT, WINDSET, TURBSET, EXMET, PTLAPS, GETOZ,
c                     VMASS, SETPUF, SETSLG, CHEM, WET, DRY, PUFRECS,
c                     CALCPF, PLGRECS, CALCSL, SLG2PUF, CTSG,
c                     OUTPUT, GRDAY, INCR, INITI2D, PDFVARS,
c                     RESTARTI, RESTARTO, TIBLON, TIBLGRO, RISEWIND,
c                     MFLXINI, MFLXCMP, MBALINI, MBALSUM, MBALOUT,
c                     SETSOA, CALCBC, SUMBC, PLMFOG, FOGWIND, ZTRACE,
c                     FOGREC, RDAQ, GETH2O2, CHEMBK, TCHIFLX,
c                     VARSAM, TPERIOD, TIMEUP, SRCTABIN
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'ar1.puf'
      include 'ar2.puf'
      include 'bcs.puf'
      include 'chemdat.puf'
      include 'chiflx.puf'
      include 'comparm.puf'
      include 'ctsgdat.puf'
      include 'current.puf'
      include 'dataset.puf'
      include 'datehr.puf'
      include 'dispdat.puf'
      include 'flags.puf'
      include 'fog.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'nongrd.puf'
      include 'outpt.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'puff.puf'
      include 'slug.puf'
      include 'tibl.puf'
      include 'vol1.puf'
      include 'vol2.puf'
      include 'wrkspc.puf'
c
      real hillr2(mxhill)
      real fracwet(mxspec),fracdry(mxspec)
      real xlam(mxspec),vd(mxspec),vdpvd(mxspec)
      real qold(mxspec),qnew(mxspec),qavg(mxspec),qavgt(mxspec)
      real qbrate(mxspec),qerate(mxspec)
      real q01wet(mxspec,2),q01dry(mxspec,2),qratew(mxspec,2)
      real em2dat(mxp4,mxpt2),em4dat(mxp6,mxvol)
      real em3dat(mxp14,mxarea)
      real em5dat(mxp6,mxlines),em5grp(7,mxlngrp)
      real wdivs(mxnz),wdive(mxnz)
      real q1sfc(mxspec),q1upr(mxspec)
      logical ldb2,ldb,ldb0,ldbmet,lpuff,lslug,lskip,lresplit
      logical lcalm,lclip,ldohill(mxhill)
      logical leof,ldiv,lctsg,lprof,ltibl
      logical lsubsam
      logical ltest
      logical lszcap
      logical lvar,lrdmet,lrdprf,lrdozn,lrdh2o2,lozn,lh2o2
      integer nsource(9)
      character*12 dtype
c
c --- Special treatment for puffs from boundary conditions
      logical lbcpuf
      character*3 cbal
c
      data zero/0.0/
      data fracwet/mxspec*1.0/,fracdry/mxspec*1.0/
      data vd/mxspec*0.0/,vdpvd/mxspec*1.0/
      data qold/mxspec*0.0/,qnew/mxspec*0.0/
      data qbrate/mxspec*0.0/,qerate/mxspec*0.0/
      data qunit/1.0/,rad/57.295778/
      data nsigma/3/
c --- Set value of transport wind speed for "calm"
      data ucalm/0.001/
c --- Set minimum value on computed potential temperature gradients
      data ptgrad0/0.005/
c --- Set initial values for 'last' date-times for met/AQ data files
      data ndhrmetb/-000100100/,ndhrmete/-000100100/
      data nsecmetb/0/,nsecmete/0/
      data ndhrprfb/-000100100/,ndhrprfe/-000100100/
      data nsecprfb/0/,nsecprfe/0/
      data ndhroznb/-000100100/,ndhrozne/-000100100/
      data nsecoznb/0/,nsecozne/0/
      data ndhrh2o2b/-000100100/,ndhrh2o2e/-000100100/
      data nsech2o2b/0/,nsech2o2e/0/
c
c ***
      write(iomesg,*)'COMPUTATIONAL PHASE'
c ***
c
c----------------------------------------------------------
c --- INITIALIZATIONS
c----------------------------------------------------------

c --- Set search radius (grid cells) for boundary condition puffs
c --- to impact a receptor
      rbc0=rsampbc*1000.*dgridi

      chioz=bcko3m(nmob)
      chih2o2=bckh2o2m(nmob)
      rconst=nsigma*dgridi

c --- Length of period is NSECDT in seconds
      secdt=FLOAT(nsecdt)

c --- Reciprocal of speed required to travel max allowed distance in 1
c --- timestep in s/m (XMXLEN is maximum slug length, or maximum puff
c --- step during emission, in grid units; XSAMLEN is maximum advection
c --- step of an existing puff/slug in grid units)
      xsamleni=1.0/xsamlen
      smxi1=secdt/(xmxlen*dgrid)
c --- Recast smxi2 calculation to match how it was done in v5
c --- smxi2=secdt/(xsamlen*dgrid)
      smxi2=secdt*xsamleni*dgridi

c
c --- Set boundary of computational grid in MET-GRID units
      xb=ibcomp-1.0
      xe=iecomp
      yb=jbcomp-1.0
      ye=jecomp
c
c --- Set factor used to distinguish "puff codes" for puffs vs. slugs
      mfact=10*mslug
c
c --- Pass default potential temperature gradient from control file
c --- variable PTG0 to hourly met variable PTG (hourly PTG is provided
c --- by RDISC and RDPLM, but not by RDMET, RDMET4)
      ptg(1)=ptg0(1)
      ptg(2)=ptg0(2)
c
c --- Set value of LCLIP:  this is passed to PUFRECS, SLGRECS, and
c --- PLGRECS to limit receptor-specific sigmas to range defined by
c --- values at the start/end of the step, when true.
c     lclip=.FALSE.
      lclip=.TRUE.
c
c --- Set End-Of-File logical to .FALSE. (met & chem files)
      leof=.FALSE.
c
c --- PROFILE heights are determined hourly, but initialize to model
c --- layers for cases where PROFILE.DAT file is not used
      nzprf=nz
      do iz=1,nz
         zprf(iz)=zgpt(iz)
      enddo

c --- Set square of maximum "radius" of hills for CTSG option
      if(MCTSG.EQ.1) then
         do ih=1,nhill
            hillr2(ih)=(dgridi*AMAX1(hilldat(10,ih),hilldat(11,ih)))**2
         enddo
      endif

c --- Set logical for incorporating vertical divergence in puff growth
      if(lcalgrd .AND. metfm.EQ.1) then
         ldiv=.TRUE.
      else
         ldiv=.FALSE.
      endif

c --- Set logical for applying cap to sigma-z to protect virtuals
      if(szcap_m.GT.0.0) then
         lszcap=.TRUE.
      else
         lszcap=.FALSE.
      endif

c --- Set logical for reading PROFILE.DAT as a secondary met file
c --- (e.g. for turbulence data or inversion strength)
      if(metfm.EQ.4 .OR. metfm.EQ.5) then
         lprof=.FALSE.
      elseif(mtinv.EQ.1) then
         lprof=.TRUE.
      elseif(mdisp.EQ.1 .OR. mdisp.EQ.5) then
         if(mturbvw.LT.4) then
            lprof=.TRUE.
         else
            lprof=.FALSE.
         endif
      else
         lprof=.FALSE.
      endif

c --- Set logical for using external file for ozone or H2O2
      lozn=.FALSE.
      if((mchem.EQ.1 .OR. mchem.EQ.3 .OR. mchem.EQ.4)
     &                               .AND.  moz.EQ.1) lozn=.TRUE.
      lh2o2=.FALSE.
      if(maqchem.EQ.1 .AND.  mh2o2.EQ.1) lh2o2=.TRUE.

c --- Initialize model fields with restart file if this is
c --- a "continuation" run, and if NPUFFS>0 was found in header
      if(npuffs.GT.0 .AND.
     &  (mrestart.EQ.1 .OR. mrestart.EQ.3)) call RESTARTI

c --- Set puff ID range for debug output
      ipfdeb1=ipfdeb
      ipfdeb2=ipfdeb1+npfdeb-1

c----------------------------------------------------------
c --- BASIC TIME LOOP (nsecdt per step)
c----------------------------------------------------------
      if(imesg.eq.1)then
         write(iomesg,*)'  ---   Advection Step Length (sec)',nsecdt
         write(iomesg,*)'  ---   Puff #      Advection Step'
         write(iomesg,*)
      elseif(imesg.eq.2)then
        if(msplit.GT.0) then
          write(iomesg,*)'  --- Advection Step Starting:'
          write(iomesg,*)
     &          '  --- YYYYJJJHH SSSS   # Old  # Split  # Emitted'
        else
          write(iomesg,*)'  --- Advection Step Starting:'
          write(iomesg,*)'  --- YYYYJJJHH SSSS   # Old  # Emitted'
        endif
        write(iomesg,*)
      endif
c
      iarlg=IABS(irlg)
      do 1000 nn=1,iarlg
c
c --- Determine if debug data are written this period
      if(nn.ge.nn1.and.nn.le.nn2)then
         ldb=ldebug
      else
         ldb=.false.
      endif
      ldb0=ldb
c     ldbmet=ldb
      ldbmet=.FALSE.

c --- Determine which external data should be read for this step by
c --- comparing the time at the mid-point of the step with the
c --- period for the current data
c --- Met data
      lrdmet=.FALSE.
      call TPERIOD(0,ndathrm,nsecm,ndhrmetb,nsecmetb,ndhrmete,nsecmete,
     1             ilocate)
      if(ilocate.EQ.1) lrdmet=.TRUE.
c --- Supplementary data from PROFILE file
      lrdprf=.FALSE.
      if(lprof) then
         call TPERIOD(0,ndathrm,nsecm,ndhrprfb,nsecprfb,ndhrprfe,
     1                nsecprfe,ilocate)
         if(ilocate.EQ.1) lrdprf=.TRUE.
      endif
c --- Ozone data
      lrdozn=.FALSE.
      if(lozn) then
         call TPERIOD(0,ndathrm,nsecm,ndhroznb,nsecoznb,ndhrozne,
     1                nsecozne,ilocate)
         if(ilocate.EQ.1) lrdozn=.TRUE.
      endif
c --- H2O2 data
      lrdh2o2=.FALSE.
      if(lh2o2) then
         call TPERIOD(0,ndathrm,nsecm,ndhrh2o2b,nsech2o2b,ndhrh2o2e,
     1                nsech2o2e,ilocate)
         if(ilocate.EQ.1) lrdh2o2=.TRUE.
      endif
c
c --- Echo progress message to screen (conditional)
      if((lrdmet.OR.lrdprf.OR.lrdozn) .AND. imesg.EQ.1) print 5,nn
5     format('+',' Reading Data         ',i6)

c --- Read meteorological data
c
c --- Read data from PROFILE file for current period if needed and if
c --- not already done (LPROF=T if PROFILE.DAT must be read)
      if(lrdprf) then
         if(mprffm.EQ.1) then
            call RDPROF(ndathrm,nsecm,ldbmet,nzprf,wsprf,wdprf,
     &                  tprf,zprf,ssprf,swprf,svprf,dptinvo,
     &                  ndhrprfe,nsecprfe,ndhrprfb,nsecprfb,leof)
         elseif(mprffm.EQ.2) then
            call RDPROF5(ndathrm,nsecm,ldbmet,nzprf,wsprf,wdprf,
     &                  tprf,zprf,ssprf,swprf,svprf,dptinvo,
     &                  ndhrprfe,nsecprfe,ndhrprfb,nsecprfb,leof)
         else
            write(io6,*)
            write(io6,*) 'COMP:  Bad MPRFFM found = ',mprffm
            write(io6,*) 'Expected 1 or 2'
            write(io6,*)
            write(*,*)
            write(*,*) 'COMP:  Bad MPRFFM found = ',mprffm
            write(*,*) 'Expected 1 or 2'
            write(*,*)
            stop
         endif
c
c ---    Reset PROFILE heights to model layers if turbulence data will
c ---    be read from PLMMET.DAT
         if(mturbvw.EQ.4) then
            nzprf=nz
            do iz=1,nz
               zprf(iz)=zgpt(iz)
            enddo
         endif
      endif

c --- Read data from primary met file for current period
      if(lrdmet) then
         if(metfm.EQ.1) then
            call RDMET(ndathrm,nsecm,tmp1,nw1,ldbmet,umet,vmet,tmet,
     1                 ipgt,htmix,ustar,xmonin,wstar,rmm,tempss,rhoss,
     2                 qswss,irhss,ipcode,temp2d,rho2d,qsw2d,irh2d,
     3                 ipcode2d,ndhrmete,nsecmete,ndhrmetb,nsecmetb,
     4                 wdiv)
c
c ---       Compute vertical divergence fields for CALMET data
            if(LDIV) then
               do k=nz,1,-1
                  delzi=1./(zface(k+1)-zface(k))
                  do i=1,nx
                  do j=1,ny
                     if(k.GT.1) then
                        wdiv(i,j,k)=delzi*(wdiv(i,j,k)-wdiv(i,j,k-1))
                     else
                        wdiv(i,j,k)=delzi*wdiv(i,j,k)
                     endif
                  enddo
                  enddo
               enddo
            endif
         elseif(metfm.EQ.2) then
            call RDISC(ndathrm,nsecm,ldbmet,umet,vmet,ipgt,htmix,ustar,
     1                 xmonin,wstar,rmm,tempss,rhoss,qswss,irhss,
     2                 ipcode,ptg,plexp,leof,ndhrmete,nsecmete,
     3                 ndhrmetb,nsecmetb)
         elseif(metfm.EQ.3) then
            call RDPLM(ndathrm,nsecm,ldbmet,umet,vmet,svprf,ipgt,htmix,
     1                 ustar,xmonin,wstar,rmm,tempss,rhoss,qswss,irhss,
     2                 ipcode,ptg,plexp,leof,ndhrmete,nsecmete,
     3                 ndhrmetb,nsecmetb)
         elseif(metfm.EQ.4) then
            call RDMET4(ndathrm,nsecm,ldbmet,ptg,nzprf,wsprf,wdprf,
     1                 tprf,zprf,ssprf,swprf,svprf,ipgt,htmix,ustar,
     2                 xmonin,wstar,rmm,tempss,rhoss,qswss,irhss,
     3                 ipcode,dptinvo,leof,ndhrmete,nsecmete,
     4                 ndhrmetb,nsecmetb)
         elseif(metfm.EQ.5) then
            call RDMET5(ndathrm,nsecm,ldbmet,ptg,nzprf,wsprf,wdprf,
     1                 tprf,zprf,ssprf,swprf,svprf,ipgt,htmix,ustar,
     2                 xmonin,wstar,rmm,tempss,rhoss,qswss,irhss,
     3                 ipcode,dptinvo,leof,ndhrmete,nsecmete,
     4                 ndhrmetb,nsecmetb)
         endif

c ---    Require primary met timstep to be GE model timestep
         call DELTSEC(ndhrmetb,nsecmetb,ndhrmete,nsecmete,nsecmet)
         if(nsecmet.LT.nsecdt) then
            write(io6,*)
            write(io6,*) 'Primary MET data timestep    : ',nsecmet
            write(io6,*) 'is LESS than CALPUFF timestep: ',nsecdt
            write(io6,*) 'Set CALPUFF timestep to this MET timestep'
            write(io6,*)
            write(*,*)
            write(*,*) 'Primary MET data timestep    : ',nsecmet
            write(*,*) 'is LESS than CALPUFF timestep: ',nsecdt
            write(*,*) 'Set CALPUFF timestep to this MET timestep'
            write(*,*)
            stop 'Halted in COMP'
         endif

      endif
c
c --- Disregard any DPTINVO values read from PROFILE.DAT when MTINV=0
      if(mtinv.EQ.0) dptinvo=-999.
c
c --- Read ozone data for current period (nsecozn[b,e] remain zero)
      if(lrdozn) then
         dtype='OZONE       '
         call RDAQ(io22,dtype,veroz,ndathrm,nsecm,t2btzoz,nozsta,
     &             ldbmet,ndhroznb,nsecoznb,ndhrozne,nsecozne,
     &             ozconc,leof)
      endif
c
c --- Read H2O2 data for current period
      if(lrdh2o2) then
         dtype='H2O2        '
         call RDAQ(io23,dtype,verh2o2,ndathrm,nsecm,t2btzhp,nh2o2sta,
     &             ldbmet,ndhrh2o2b,nsech2o2b,ndhrh2o2e,nsech2o2e,
     &             h2o2conc,leof)
      endif
c
c --- Compute cloud and zenith data at surface met stations
      call SUNDATA(ldbmet)
c
c --- Set background data for SOA option this hour
      if(mchem.EQ.4) call SETSOA(ndathrm)
c
c --- Update current monthly background data
      if(mchem.GT.0) call CHEMBK(ndathrm)
c
      if(lrdmet.OR.lrdprf.OR.lrdozn.OR.lrdh2o2) then
         if(LEOF) then
            irlg=nn-1
            write(io6,*)
            write(io6,*) 'EOF reached in MET or CHEM data file'
            write(io6,*) 'Last period processed IRLG =',irlg
            write(io6,*)
            write(*,*)
            write(*,*) 'EOF reached in MET or CHEM data file'
            write(*,*) 'Last period processed IRLG =',irlg
            write(*,*)
c ---       Roll back date-time to report last period processed
            call TIMEUP(-1)
            return
         endif
      endif

c --- Initialize concentrations and dry/wet fluxes at beginning
c --- of each averaging output period (TOTAL and BC arrays)
      if(iavg.eq.1.or.mod(nn,iavg).eq.1)then
c
c ---    Set beginning time for averaging period
         nyrab =nyrb
         nmoab =nmob
         ndayab=ndayb
         njulab=njulb
         nhrab =nhrb
         nsecab=nsecb
c
c ---    Gridded receptors
         if(lsamp)then
            do i=1,nspec
               call INITR2D(zero,mxnxg,mxnyg,nxsam,nysam,tchisam(1,1,i))
               if(mdry.eq.1)call INITR2D(zero,mxnxg,mxnyg,
     1                      nxsam,nysam,tdfsam(1,1,i))
               if(mwet.eq.1)call INITR2D(zero,mxnxg,mxnyg,
     1                      nxsam,nysam,twfsam(1,1,i))
            enddo
         endif
         if(lsamp .AND. nbc.GT.0)then
            call INITR2D(rbc0,mxnxg,mxnyg,nxsam,nysam,rbcsam)
            do i=1,nspec
               call INITR2D(zero,mxnxg,mxnyg,nxsam,nysam,cbcsam(1,1,i))
               if(mdry.eq.1)call INITR2D(zero,mxnxg,mxnyg,
     1                      nxsam,nysam,dbcsam(1,1,i))
               if(mwet.eq.1)call INITR2D(zero,mxnxg,mxnyg,
     1                      nxsam,nysam,wbcsam(1,1,i))
            enddo
         endif
c
c ---    Non-gridded receptors
         if(nrec.gt.0)then
            call INITR2D(zero,mxrec,mxspec,nrec,nspec,tchirec)
            if(mdry.eq.1)call INITR2D(zero,mxrec,mxspec,nrec,nspec,
     1                   tdfrec)
            if(mwet.eq.1)call INITR2D(zero,mxrec,mxspec,nrec,nspec,
     1                   twfrec)
         endif
         if(nrec.gt.0 .AND. nbc.GT.0)then
            call INITAR(rbc0,nrec,rbcrec)
            call INITR2D(zero,mxrec,mxspec,nrec,nspec,cbcrec)
            if(mdry.eq.1)call INITR2D(zero,mxrec,mxspec,nrec,nspec,
     1                   dbcrec)
            if(mwet.eq.1)call INITR2D(zero,mxrec,mxspec,nrec,nspec,
     1                   wbcrec)
         endif
c
c ---    Complex-terrain (CTSG) receptors
         if(nctrec.gt.0)then
            call INITR2D(zero,mxrect,mxspec,nctrec,nspec,tchict)
            if(nbc.GT.0) then
               call INITAR(rbc0,nctrec,rbcct)
               call INITR2D(zero,mxrect,mxspec,nctrec,nspec,cbcct)
            endif
         endif
      endif
c
c --- Initialize mass flux arrays at beginning of each time step
      if(imflx.EQ.1) call MFLXINI
c
c --- Initialize mass balance arrays at beginning of each time step
      if(imbal.EQ.1) call MBALINI
c
c --- Compute hill-specific flow parameters (Hd, U/N) for CTSG
c --- terrain option
      if(nhill.gt.0)then
         if(metfm.EQ.4 .OR. metfm.EQ.5) then
c ---       Use 1-D PROFILE.DAT arrays
c ---       Set surface layer data (use cell 1,1)
            istab=ipgt(1,1)
            istab=MIN0(istab,6)
            dpbl=AMAX1(htmix(1,1),xminzi)
            dpbl=AMIN1(dpbl,xmaxzi)
            el=xmonin(1,1)
            z0m=z0(1,1)
            call GETPRFP(ssprf,tprf,zprf,nears,tempss,lcalgrd,
     &                   istab,dpbl,el,z0m,ptg,nzprf)
            do ih=1,nhill
               call HDUN(ih)
            enddo
         else
c ---       Use 3-D MET arrays
            do ih=1,nhill
c frr (09/01) - CALMET noobs mode temp2d instead of tempss
c               call GETPRFM(ih,umet,vmet,tmet,zgpt,nears,tempss,lcalgrd,
c     &                      ipgt,ptg,nx,ny,nz,xorig,yorig,dgrid)
               call GETPRFM(ih,umet,vmet,tmet,zgpt,nears,tempss,lcalgrd,
     &                      ipgt,ptg,nx,ny,nz,xorig,yorig,dgrid,
     &                      i2dmet,temp2d)
               call HDUN(ih)
            enddo
         endif
      endif

c --- Initialize puff numbers to report to screen this step (imesg=2)
      numold=npuffs
      numsplty=0
      numspltz=0
c
c --- Split certain puffs/slugs to respond to wind shear
      ldb2=ldb
c     ldb2=.TRUE.
c     ldb2=.FALSE.
      if(msplit.EQ.1) then
         if(iresplit(nhrind).EQ.1) then
            lresplit=.TRUE.
         else
            lresplit=.FALSE.
         endif
         call SPLIT(ldb2,lresplit,nspec,xb,yb,xe,ye,imbal,
     &              numsplty,numspltz)
         numsplit=numsplty+numspltz
      endif
c
c --- Release new puffs/slugs for this time step
c --- NOTE: when using PRIME downwash, in/near-cavity concentrations
c ---       will be computed here within source-loop
      ldb2=ldb
c     ldb2=.TRUE.
c     ldb2=.FALSE.
      call INITPUF(ndathrb,nsecb,ndathre,nsece,nspec,secdt,smxi1,ldb2,
     &             em2dat,em4dat,em3dat,em5dat,em5grp,metfm,newpuf)
      noldp=npuffs
      npuffs=npuffs+newpuf
c
c --- Identify puffs for computing FOG output in plume mode, and
c --- set up puff centerline trace and receptors for each
c --- Process just the first new puff released this step from each
c --- point source
      if(LPMODE) then
         ldb2=ldb
c        ldb2=.TRUE.
c        ldb2=.FALSE.
         nipfog=0
c ---    ZTRACE operates on current met period tables
         imet=1
         do i=1,newpuf
            ip=noldp+i
            if(irlsnum(ip).EQ.1 .AND.
     &        (isrctyp(ip).EQ.1 .OR. isrctyp(ip).EQ.2)) then
c ---          Keep this puff
               nipfog=nipfog+1
               ipfog(nipfog)=ip
c ---          Compute puff height at each distance in fog arrays
               call ZTRACE(ldb2,ip,mxrfog,xrfog,zrfog(1,nipfog))
            else
c ---          Drop this puff
               ipufcd(ip)=99
            endif
         enddo
c ---    Generate discrete receptors for this hour
         call FOGREC(ldb2)
      endif

c --- Tracking message for this timestep
      if(imesg.EQ.2) then
         if(msplit.GT.0) then
            print 7,ndathrb,nsecb,numold,numsplit,newpuf
         else
            print 7,ndathrb,nsecb,numold,newpuf
         endif
      endif
7     format('+',6x,i9,i5,3i9)
c
c --- Echo splitting information to list file
      ldb2=ldb
c     ldb2=.TRUE.
c     ldb2=.FALSE.
      if(LDB2) then
         write(io6,'(a,6i9)')'#Old,split-y,split-z,emitted: ',
     &           ndathrb,nsecb,numold,numsplty,numspltz,newpuf
      endif
c
c
c*****
      if(ldb)then
         write(io6,202)nn,noldp,newpuf,npuffs
202      format(/1x,'Advection step (NN) = ',i5,2x,
     1   'No. old puffs (NOLDP) = ',i6,2x,'No. new puffs (NEWPUF) = ',
     3   i6,2x,'Total puffs (NPUFFS) = ',i6)
         write(io6,*)'Start of Step (YYYYJJJHH,SSSS) ',ndathrb,nsecb
         write(io6,*)'End of Step   (YYYYJJJHH,SSSS) ',ndathre,nsece
      endif
c*****
c
c----------------------------------------------------------
c --- LOOP OVER PUFFS
c----------------------------------------------------------

c --- MSOURCE Option
c ---------------------
c --- The source contribution option requires output of computed
c --- fields for EACH source as well as all sources combined.
c --- Process impacts for EACH source in turn by just using puffs
c --- emitted from that source.  This is implemented by placing a
c --- screen for the source ID into the puff loop, and executing
c --- the puff loop multiple times, once for each source.  If the
c --- source contribution option is OFF (MSOURCE=0), the puff
c --- loop is executed once, and no source screen is applied.
c --- Source Types are:
c            1 = Point         Constant Emissions
c            2 = Point         Variable Emissions
c            3 = Poly. Area    Constant Emissions
c            4 = Poly. Area    Variable Emissions
c            5 = Line          Constant Emissions
c            6 = Line          Variable Emissions
c            7 = Volume        Constant Emissions
c            8 = Grid Volume   Variable Emissions
c            9 = Boundary Condition
C --- Set range for loops over source types and sources
      if(msource.EQ.0) then
c ---    Set loop ranges so that puff loop is executed once
         nstype=1
         nsource(1)=1
         do kk=2,9
            nsource(kk)=0
         enddo
      elseif(msource.EQ.1) then
         nstype=9
         nsource(1)=npt1
         nsource(2)=npt2
         nsource(3)=nar1
         nsource(4)=nar2
         nsource(5)=nlines
         nsource(6)=nln2
         nsource(7)=nvl1
         nsource(8)=nvl2
         nsource(9)=nbc
      endif

c --- Loop over source types
      do 1200 ktype=1,nstype

c ---  Loop over sources of the current type
       do 1100 ksource=1,nsource(ktype)
c
c ---    Initialize concentrations and dry/wet fluxes (SOURCE
c ---    contribution arrays)
c ---    Gridded receptors
         if(lsamp .AND. ktype.NE.9)then
            do i=1,nspec
               call INITR2D(zero,mxnxg,mxnyg,nxsam,nysam,chisam(1,1,i))
               if(mdry.eq.1)call INITR2D(zero,mxnxg,mxnyg,
     1                      nxsam,nysam,dfsam(1,1,i))
               if(mwet.eq.1)call INITR2D(zero,mxnxg,mxnyg,
     1                      nxsam,nysam,wfsam(1,1,i))
            enddo
         endif
c
c ---    Non-gridded receptors
         if(nrec.gt.0 .AND. ktype.NE.9)then
            call INITR2D(zero,mxrec,mxspec,nrec,nspec,chirec)
            if(mdry.eq.1)call INITR2D(zero,mxrec,mxspec,nrec,nspec,
     1                   dfrec)
            if(mwet.eq.1)call INITR2D(zero,mxrec,mxspec,nrec,nspec,
     1                   wfrec)
         endif
c
c ---    Complex-terrain (CTSG) receptors
         if(nctrec.gt.0 .AND. ktype.NE.9)then
            call INITR2D(zero,mxrect,mxspec,nctrec,nspec,chict)
         endif


         DO 900 II=1,NPUFFS
c
c ---    Skip puffs/slugs off the computational grid
         if(ipufcd(ii).ge.99)go to 900

         if(LAGE) then
c ---       Drop puffs older than age cutoff
            if(tmtotb(ii).GE.tsecmax) then
               ipufcd(ii)=99
               goto 900
            endif
         endif
c
c ---    Process just first new puff released this step from each
c ---    point source if modeling visible plume length (this should
c ---    be redundant)
         if(LPMODE) then
            ltest=.FALSE.
            do jfog=1,nipfog
               if(ii.EQ.ipfog(jfog)) ltest=.TRUE.
            enddo
            if(.NOT.LTEST) then
               ipufcd(ii)=99
               goto 900
            endif
         endif

         if(msource.EQ.1) then
c ---       Skip this puff if it is not from the current source type
            if(ktype.NE.isrctyp(ii)) goto 900
c ---       Skip this puff if it is not from the current source
            if(ktype.EQ.5 .OR. ktype.EQ.6) then
c ---          Line source may be isrcnum=1000+isrcnum (isrcnum<1000)
               ksource2=ksource+1000
               if(isrcnum(ii).NE.ksource .AND.
     &            isrcnum(ii).NE.ksource2) goto 900
            else
               if(isrcnum(ii).NE.ksource) goto 900
            endif
         endif
c
c ---    Using area-source approach for modeling NEW emissions from
c ---    LINE sources requires skipping the sampling step for slugs
c ---    released from all but the first "segment" of a line.  This
c ---    will be controlled by LSKIP.  Initialize it here.
         lskip=.FALSE.
c
c ---    Initialize flag for variable source parameters
         lvar=.FALSE.
c
c ---    Use puff position (or younger end of slug) to obtain initial
c ---    met grid cell index - make sure that index is in bounds!
         ixs=1.0+xpb(ii)
         iys=1.0+ypb(ii)
         if(ixs.LT.1) then
            ixs=1
         elseif(ixs.GT.nx) then
            ixs=nx
         endif
         if(iys.LT.1) then
            iys=1
         elseif(iys.GT.ny) then
            iys=ny
         endif
c ***
         if(imesg.eq.1)print 8,ii,nn
8        format('+',6x,i6,10x,i6)
c ***
c
c ---    Track puffs in DEBUG mode, starting with puff IPFDEB1 and
c ---    ending with puff IPFDEB2
         if(ii.GE.ipfdeb1 .AND. ii.LE.ipfdeb2) then
            ldb=ldb0
         else
            ldb=.FALSE.
         endif
c
c ---    Retrieve puff/slug identification factor for this "puff"
c ---    (MFACT equal 0 indicates all are puffs, but some slugs are
c ---    really puffs if the slug indexing factor has been removed
c ---    from the puff code)
         if(mfact.EQ.0 .OR. ipufcd(ii).LT.mfact) then
c ---       This is a PUFF
            mfact0=0
            lpuff=.TRUE.
            lslug=.FALSE.
            zpmean=zpb(ii)
         else
c ---       This is a SLUG
            mfact0=mfact
            lslug=.TRUE.
            lpuff=.FALSE.
            zpmean=0.5*(zpb(ii)+zpe(ii))
         endif
c
c ---    Assign puff code for this puff
         icode=ipufcd(ii)
c
c ---    Move puff identification into local and /CURRENT/ variables:
c ---       IPNO,   the puff number released from the source for the
c ---               current time step (local);
c ---       ISTYPE, the type of source (/CURRENT/); and
c ---       ISNUM,  the source number from which the puff was released
c                   (/CURRENT/)
         ipno=irlsnum(ii)
         istype=isrctyp(ii)
         isnum=isrcnum(ii)

c --- Retain IMET for roll-back capability to earlier versions, but set
c --- equal to 1 here so that /SRCTAB/ tables are always used
         imet=1
cc
cc ---    Compute met period index for source tabulations for this puff
cc ---    (stored in /CURRENT/, capped at MXMETSAV+1)
c         imet=1+(ipno-1+NINT(tmtotb(ii)/temit0(ii)))/
c     &           NINT(secdt/temit0(ii))
c         imet=MIN(imet,mxmetsav+1)
c         if(imet.LT.1) then
c            write(io6,*)
c            write(io6,*) 'FATAL ERROR in COMP: bad met period index'
c            write(io6,*) 'Expected IMET = 1 to MXMETSAV+1'
c            write(io6,*) 'Found    IMET = ',imet
c            write(io6,*) '     MXMETSAV = ',mxmetsav
c            write(io6,*)
c            write(*,*)
c            stop 'Halted in COMP -- See list file'
c         endif

c ---    Place source tabulations that apply to this puff into /SRCTAB/
         call SRCTABIN(ii,isrctyp(ii),isrcnum(ii),irlsnum(ii))

c ---    Assign emissions step index
         iqstep=iemstep(ii)

c ---    Place the platform height (downwash) into /CURRENT/ if this
c ---    puff is from a point source
         zplat=0.0
         if(istype.EQ.1) then
            zplat=zplatpt1(isnum)
         elseif(istype.EQ.2) then
            zplat=zplatpt2(isnum)
         endif

c ---    Set logical for treating boundary condition (BC) puffs
         lbcpuf=.FALSE.
         if(istype.EQ.9) lbcpuf=.TRUE.
c
c ---    Find the layer containing the puff before rise
         call ZFIND(ht0(ii),zface,nzp1,ilayer0)
c ---    Find the layer containing the puff after rise
         call ZFIND(zpmean,zface,nzp1,ilayer1)
c
c ---    Assign met parameters from cell
         istab=ipgt(ixs,iys)
         istab=MIN0(istab,6)
         dpbl=AMAX1(htmix(ixs,iys),xminzi)
         dpbl=AMIN1(dpbl,xmaxzi)
         el=xmonin(ixs,iys)
         z0m=z0(ixs,iys)
c
c ---    Get wind speed for puff at final rise for metfm=1,4,5
         ilayer=ilayer1
         htmet=zpmean
c ---    Use power law from wind at stacktop for metfm=2,3
         if(metfm.EQ.2 .OR. metfm.EQ.3) then
            htmet=ht0(ii)
            ztop=htmet
            zbot=htmet
         else
            call PUFFDZ(ii,icode,lpuff,istab,ilayer,htmet,dpbl,
     &                  ztop,zbot)
         endif
         call ADVECT(ldb,ixs,iys,z0m,el,dpbl,istab,ht0(ii),
     &               zbot,ztop,uadv,vadv)
         ws=SQRT(uadv**2+vadv**2)
         if(ws.LT.wscalm) ws=AMAX1(ws,ucalm)
c
c ---    Select wind speed for VARSAM as MAX of stack-top and Heff
c ---    computed as in the variable emissions subroutines
         call ADVECT(ldb,ixs,iys,z0m,el,dpbl,istab,ht0(ii),
     &               htmet,htmet,uvar,vvar)
         wsvar=SQRT(uvar**2+vvar**2)
         wsvar=AMAX1(ws0(ii),wsvar)
c
c ---    Determine the number & length of the sampling steps
         if(ii.le.noldp)then
c
c ---       OLD PUFF/SLUG
            iold=1
c
c ---       Distance that would be traveled during the time step
c           (in grid units)
            nsam=nint(ws*smxi2+1)
            nsam=min0(nsam,mxsam)
            xsami=1.0/float(nsam)
            nsstr=1
            tsamp=secdt*xsami
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'OLD PUFF'
         write(io6,*)'ii = ',ii,' nsam = ',nsam,' nsstr = ',nsstr
         write(io6,*)'tsamp = ',tsamp,' ws = ',ws
      endif
c ***
         ELSE
c
c ---       NEW PUFF/SLUG
            iold=0
c
c ---       Set starting sampling step number for this puff (constant
c ---       control-file emissions)
            nsstr=ipno
c
c ---       Select wind speed for VARSAM as MAX of stack-top and Heff
c ---       wind computed as in the variable emissions subroutines
            call ADVECT(ldb,ixs,iys,z0m,el,dpbl,istab,ht0(ii),
     &               htmet,htmet,uvar,vvar)
            wsvar=SQRT(uvar**2+vvar**2)
            wsvar=AMAX1(ws0(ii),wsvar)
c
            if(istype.EQ.1) then
c ---          Revise nsam to allow PRIME module to create a dual
c ---          release (primary source and cavity source);  
c ---          nsam=newpt1(isnum) can be too large by factor of 2
               nsam=NINT(secdt/temit0(ii))
            elseif(istype.EQ.2) then
               lvar=.TRUE.
               call VARSAM(ldb,temit0(ii),tmtotb(ii),secdt,smxi1,
     &                     mxnew,wsvar,nsstr,nsam,tsamp2,tsampf)
c ---          (Note: VARSAM resets tmtotb=0.0 after use)
            elseif(istype.EQ.3) then
               nsam=newar1(isnum)
               if(lslug) then
c ---             Transfer vertex information and area of source to
c ---             /current/ arrays (new slug from POLYGON area)
                  nside=nvert1(isnum)
                  aream2=area1(isnum)
                  do iv=1,nside
                     xvert(iv)=xar1grd(iv,isnum)*dgrid
                     yvert(iv)=yar1grd(iv,isnum)*dgrid
                  enddo
               endif
            elseif(istype.EQ.4) then
               lvar=.TRUE.
               call VARSAM(ldb,temit0(ii),tmtotb(ii),secdt,smxi1,
     &                     mxnew,wsvar,nsstr,nsam,tsamp2,tsampf)
c ---          (Note: VARSAM resets tmtotb=0.0 after use)
               if(lslug) then
c ---             Transfer vertex information and area of source to
c ---             /current/ arrays (new slug from POLYGON area)
                  nside=nvert2(isnum)
                  aream2=area2(iqstep,isnum)
                  do iv=1,nside
                     xvert(iv)=xar2grd(iv,iqstep,isnum)*dgrid
                     yvert(iv)=yar2grd(iv,iqstep,isnum)*dgrid
                  enddo
               endif
            elseif(istype.EQ.5) then
               if(lslug) then
                  if(isnum.LT.1000) then
c ---                This puff is a NEW release from segment 1 of LINE
c ---                so polygon area source method for slugs is used
c ---                for entire line during the first sampling step.
c ---                Transfer "vertex" information and "area" of source
c ---                to /CURRENT/ arrays.
                     nside=4
c ---                Note: pass area of one segment
                     aream2=arline(isnum)/nseg(isnum)
                     do iv=1,nside
                        xvert(iv)=xvertl(iv,isnum)*dgrid
                        yvert(iv)=yvertl(iv,isnum)*dgrid
                     enddo
                  else
c ---                This slug is a NEW release from segment 2+ of LINE
c ---                so skip call to CALCSL for 1st sampling step
                     lskip=.TRUE.
c ---                Reset puff ID information
                     isnum=isnum-1000
                     isrcnum(ii)=isnum
                  endif
               endif
               nsam=newln1(isnum)
            elseif(istype.EQ.6) then
               lvar=.TRUE.
               call VARSAM(ldb,temit0(ii),tmtotb(ii),secdt,smxi1,
     &                     mxnew,wsvar,nsstr,nsam,tsamp2,tsampf)
c ---          (Note: VARSAM resets tmtotb=0.0 after use)
               if(lslug) then
                  if(isnum.LT.1000) then
c ---                This puff is a NEW release from segment 1 of LINE
c ---                so polygon area source method for slugs is used
c ---                for entire line during the first sampling step.
c ---                Transfer "vertex" information and "area" of source
c ---                to /CURRENT/ arrays.
                     nside=4
c ---                Note: pass area of one segment
                     aream2=arline2(iqstep,isnum)/nseg2(iqstep,isnum)
                     do iv=1,nside
                        xvert(iv)=xvertl2(iv,iqstep,isnum)*dgrid
                        yvert(iv)=yvertl2(iv,iqstep,isnum)*dgrid
                     enddo
                  else
c ---                This slug is a NEW release from segment 2+ of LINE
c ---                so skip call to CALCSL for 1st sampling step
                     lskip=.TRUE.
c ---                Reset puff ID information
                     isnum=isnum-1000
                     isrcnum(ii)=isnum
                  endif
               endif
            elseif(istype.EQ.7) then
               nsam=newvl1(isnum)
            elseif(istype.EQ.8) then
               lvar=.TRUE.
               call VARSAM(ldb,temit0(ii),tmtotb(ii),secdt,smxi1,
     &                     mxnew,wsvar,nsstr,nsam,tsamp2,tsampf)
c ---          (Note: VARSAM resets tmtotb=0.0 after use)
            elseif(istype.EQ.9) then
               nsam=newbc(isnum)
            else
               write(io6,*)
               write(io6,*) 'FATAL:  Source type invalid! - ',istype
               write(io6,*)
               write(*,*)
               stop 'Halted in COMP -- see list file.'
            endif
c
            tsamp=temit0(ii)
c
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'NEW PUFF'
         write(io6,*)'ii = ',ii,' nsam = ',nsam,' nsstr = ',nsstr
         write(io6,*)'tsamp = ',tsamp,' IPNO = ',ipno
         write(io6,*)'ISNUM = ',isnum,' ISTYPE = ',istype
         if(LVAR) write(io6,*)' tsamp2,tsampf  = ',tsamp2,tsampf
      endif
c ***
         ENDIF

c ---    Reciprocal of number of seconds in averaging period
         tavgi=1./(float(iavg*nsecdt))
c ---    Reciprocal of number of seconds in puff emission period
         temiti=1.0/temit0(ii)
c ---    Reciprocal of number of seconds in a sampling step
         tsampi=1.0/tsamp
c ---    Reciprocal of number of sampling steps in averaging period
         tfract=tsamp*tavgi

c ---    Sampling step may need to be adjusted as puff travels among
c ---    grid cells if speeds change sufficiently.  Assign the initial
c ---    sampling step interval to a reference variable.
         reftsamp=tsamp
         tleft=0.0
c ---    Do not use substeps if the number of sampling steps has already
c ---    reached the maximum imposed
         lsubsam=.TRUE.
         if(nsam.GE.mxsam) lsubsam=.FALSE.

c*****
      if(ldb)then
         write(io6,212)ii,iold,irlsnum(ii),isrcnum(ii),isrctyp(ii),
     &                 ipufcd(ii)
         write(io6,214)xpb(ii),ypb(ii),sigyb(ii),sigzb(ii),xtotb(ii),
     1    tmtotb(ii)
         if(ipufcd(ii).gt.10)write(io6,216)xpe(ii),ype(ii),
     1    sigye(ii),sigze(ii),xtote(ii),tmtote(ii)
         write(io6,218)zimax(ii),ziold(ii),zpmean,xfinal(ii),
     1    elbase(ii),ws0(ii),srat0(ii),temit0(ii)
         write(io6,220)'QU',(qu(n,ii),n=1,nspec)
         write(io6,220)'QM',(qm(n,ii),n=1,nspec)
212      format(5x,'Puff no.=',i7,2x,'IOLD=',i1,' (0=new,1=old)',
     1   2x,'IRLSNUM=',i8,2x,'ISRCNUM=',i8,2x,'ISRCTYP=',i8,
     2   2x,'IPUFCD=',i3)
214      format(5x,'XPB=',f8.3,2x,'YPB=',f8.3,2x,'SIGYB=',f8.1,2x,
     1    'SIGZB=',f8.1,2x,'XTOTB=',f8.1,2x,'TMTOTB=',f10.1)
216      format(5x,'XPE=',f8.3,2x,'YPE=',f8.3,2x,'SIGYE=',f8.1,2x,
     1    'SIGZE=',f8.1,2x,'XTOTE=',f8.1,2x,'TMTOTE=',f10.1)
218      format(5x,'ZIMAX=',f6.0,2x,'ZIOLD=',f6.0,2x,'ZPMEAN=',f7.2,
     1    2x,'XFINAL=',f7.1,2x,'ELBASE=',f6.1,2x,'WS0=',f6.2,2x,
     2    'SRAT0=',f6.3,2x,'TEMIT0=',f7.1)
220      format(5x,a2,'=',8(f12.2,2x))
         write(io6,*)'TEMITI= ',temiti,' TFRACT=',tfract,' TSAMPI=',
     1    tsampi,' TAVGI=',tavgi
      endif
c*****

c ---    Add mass of fresh emissions to total emissions this period
         if(imbal.EQ.1 .AND. iold.EQ.0) then
            if(LBCPUF) then
               cbal='IBC'
            else
               cbal='INP'
            endif
            call MBALSUM(cbal,qm(1,ii),qu(1,ii),qm(1,ii),qu(1,ii))
         endif

c
c----------------------------------------------------------
c ---    LOOP OVER SAMPLING STEPS
c----------------------------------------------------------
         DO 800 KSAM=NSSTR,NSAM
c
c ---    Special case for variable releases: reset the reference
c ---    timestep to tsamp2 after the first sampling step for fresh
c ---    emissions to allow larger sampling steps after a short
c ---    emission period
         if(LVAR) then
            if(ksam.EQ.(nsstr+1) .AND. iold.EQ.0) reftsamp=tsamp2
            if(ksam.EQ.nsam      .AND. iold.EQ.0) reftsamp=tsampf
         endif
c
c ---    Initialize sampling step variables
         tsamp=reftsamp+tleft
c ---    Time left in current sampling step
         tleft=tsamp
c
c ---    Identify slugs that are attached to source and puffs that are
c ---    at the source at the start of the step: if puff/slug was
c ---    generated this time-step (IOLD=0), and if this is the first 
c ---    sampling step, then a slug is attached to the source for the 
c ---    sampling step, and a puff touches the source at the start
c ---    (ifree=0).
         ifree=1
         if(ksam .EQ. nsstr) ifree=iold
c
c ---    Re-entry for possible substep
500      continue
         tsampi=1.0/tsamp
         tfract=tsamp*tavgi

c ---    Transfer met. variables at start of step needed to compute
c ---    trajectory.  Use the puff position at the end of the previous
c ---    step, or the average slug position at the end of previous step.
         if(lpuff) then
c ---       Set last position of PUFF
            xold=xpb(ii)
            yold=ypb(ii)
            zold=zpb(ii)
         else
c ---       Set last position of SLUG center
            xold=0.5*(xpb(ii)+xpe(ii))
            yold=0.5*(ypb(ii)+ype(ii))
            zold=0.5*(zpb(ii)+zpe(ii))
         endif
c
         ixs=1.0+xold
         iys=1.0+yold
         if(ixs.LT.1) then
            ixs=1
         elseif(ixs.GT.nx) then
            ixs=nx
         endif
         if(iys.LT.1) then
            iys=1
         elseif(iys.GT.ny) then
            iys=ny
         endif
c
c ------------------------------------
c ---    Determine the advective winds
c ------------------------------------
         istab=ipgt(ixs,iys)
         istab=MIN0(istab,6)
         dpbl=AMAX1(htmix(ixs,iys),xminzi)
         dpbl=AMIN1(dpbl,xmaxzi)
         el=xmonin(ixs,iys)
         z0m=z0(ixs,iys)
c
         htmet=zold
         ilayer=ilayer1
c
c ---    Compute the height of the bottom and top of the puff/slug
c ---    at the end of previous step
         call PUFFDZ(ii,icode,lpuff,istab,ilayer,htmet,dpbl,
     &               ztop,zbot)
c
c ---    Compute the wind components for advection
         call ADVECT(ldb,ixs,iys,z0m,el,dpbl,istab,ht0(ii),zbot,ztop,
     &               uadv,vadv)
c ---    Compute corresponding speed and direction
         ws=SQRT(uadv**2+vadv**2)
c
c ---    Account for wind profile on transport during rise
c ---    (applies to CALMET or PROFILE winds only)
         if(xtotb(ii).LT.xfinal(ii)) then
            if(metfm.EQ.1 .OR. metfm.EQ.4 .OR. metfm.EQ.5) then
c ---          Fill /CURRENT/ variables needed in GRISE
               ipnum=ii
               zfrise=zfinal(ii)-(ht0(ii)-stipdw(ii))
               xfrise=xfinal(ii)
               xshift=xshift0(ii)
c ---          Vertical spread from centerline ht at start of step
               dzb=ztop-htmet
c ---          Obtain average wind for step
               call RISEWIND(ldb,lpuff,ncount,dzb,ii,ixs,iys,z0m,
     &                       el,dpbl,istab,tsamp,uadv,vadv,ws)
            endif
         endif
c
c ---    Treat calm conditions by imposing a minimum on vadv
         if(ws.LT.wscalm) then
            lcalm=.TRUE.
            if(ABS(vadv).LT.ucalm) vadv=ucalm
            ws=AMAX1(ws,ucalm)
         else
            lcalm=.FALSE.
         endif
c
c ---    FOG analysis in PLUME mode requires advection to be shifted
c ---    to align with receptor directions
         if(LPMODE) call FOGWIND(io6,ldb,ws,uadv,vadv)
c
c ---    Compute final advection wind direction (not flow vector)
         wd=270.-rad*atan2(vadv,uadv)
         wd=amod(wd,360.)

c ---    Apply constraint on step-size:  Slugs that are being emitted
c ---    during the first sampling step are not altered (they are NOT
c ---    free of the source)
         fstep=1.0
         if((LPUFF .OR. (LSLUG .AND. ifree.EQ.1)) .AND. LSUBSAM) then
c ---       Step distance in grid units should not exceed XSAMLEN
            fstep=ws*tsamp*dgridi*xsamleni
            if(fstep.GT.1.0) then
c ---          Substep with shorter sampling time is needed
               if(fstep.GE.2.0 .OR. ksam.LT.nsam) then
c ---             Take a full XSAMLEN this sub-step
                  tsamp=tsamp/fstep
                  tsampi=1.0/tsamp
                  tfract=tsamp*tavgi
               else
c ---             This is the last step and 1<fstep<2, so divide it
c ---             into two equal timesteps
                  tsamp=0.5*tsamp
                  tsampi=1.0/tsamp
                  tfract=tsamp*tavgi
               endif
c ---          Shorter TSAMP could change mean transport wind if puff
c ---          is still rising! (revisit RISEWIND)
               if(xtotb(ii).LT.xfinal(ii)) then
                  if(metfm.EQ.1 .OR. metfm.EQ.4 .OR. metfm.EQ.5) then
                     call RISEWIND(ldb,lpuff,ncount,dzb,ii,ixs,iys,
     &                            z0m,el,dpbl,istab,tsamp,uadv,vadv,ws)
                  endif
               endif
            endif
         endif
         tleft=tleft-tsamp

c*****
      if(ldb)then
         write(io6,240)ksam,nsam
         write(io6,242)'BEGINNING Qs',(qu(n1,ii),n1=1,nspec)
         write(io6,244)(qm(n2,ii),n2=1,nspec)
         write(io6,245)xold,yold,ixs,iys,ilayer
         write(io6,246)ws,wd,dpbl
         write(io6,*)' REFTSAMP      TSAMP      TLEFT    (for substep)'
         write(io6,'(3f10.2)') reftsamp,tsamp,tleft
240      format(/10x,'Sampling step: ',i4,' of ',i4)
242      format(10x,a11,1x,'QU=  ',5(f11.1,1x))
244      format(22x,'QM=  ',5(f11.1,1x))
245      format(10x,'XOLD=',f7.3,' YOLD=',f7.3,' IXS=',i4,' IYS=',i4,
     1    ' ILAYER=',i3)
246      format(10x,'WS=',f7.3,' WD=',f7.3,' DPBL=',f7.1)
      endif
c*****
c
c ---    Compute the DX, DY and new coordinates of the puff (in
c ---    met. grid units).  Note that when slugs are modeled, the
c ---    new and old DX,DY refer to the distance traveled by the
c ---    newer and older ends of the slug during the step.  Furthermore,
c ---    the new X,Y represents the new position of the slug center.
c ---    First, in meters.
         dxoldm=uadv*tsamp
         dyoldm=vadv*tsamp
         dxnewm=dxoldm
         dynewm=dyoldm
         distm=ws*tsamp
c ---    Now, in met. grid units
         dxmold=dxoldm*dgridi
         dymold=dyoldm*dgridi
         xnew=xold+dxmold
         ynew=yold+dymold

c ---    Set cell index for the mid-point of the step
         ixmid=0.5*(xold+xnew)+1.0
         if(ixmid.LT.1) then
            ixmid=1
         elseif(ixmid.GT.nx) then
            ixmid=nx
         endif
         iymid=0.5*(yold+ynew)+1.0
         if(iymid.LT.1) then
            iymid=1
         elseif(iymid.GT.ny) then
            iymid=ny
         endif

c ---    Set cell index for the end of the step
         ixend=xnew+1.0
         if(ixend.LT.1) then
            ixend=1
         elseif(ixend.GT.nx) then
            ixend=nx
         endif
         iyend=ynew+1.0
         if(iyend.LT.1) then
            iyend=1
         elseif(iyend.GT.ny) then
            iyend=ny
         endif
c
c ---    Add contribution of vertical divergence to sigma-z if
c ---    Gaussian puff/slug enters a cell with acute vertical
c ---    divergence during step
         if(LDIV .AND. mod(icode,2).EQ.1) then
c ---       Find average w-divergence across puff using "wind" sub.
            do kz=1,nz
               wdivs(kz)=wdiv(ixs,iys,kz)
               wdive(kz)=wdiv(ixend,iyend,kz)
            enddo
            call ADVWND(wdivs,wdive,zface,nzp1,zbot,ztop,divs,dive)
            wdivmx=AMAX1(divs,dive)
            if(wdivmx.GT.cdiv(1)) then
               ftrans=1.0
               if(wdivmx.LT.cdiv(2)) ftrans=(wdivmx-cdiv(1))/
     &                                      (cdiv(2)-cdiv(1))
               szdivfac=1.+ftrans*wdivmx*tsamp
               sigzb(ii)=sigzb(ii)*szdivfac
               sigze(ii)=sigze(ii)*szdivfac
            else
               szdivfac=0.0
            endif
         else
            szdivfac=0.0
         endif
c*****
         if(ldb .AND. szdivfac.GT.0.0) then
            write(io6,*) ' -----  Div triggered; szdivfac=',szdivfac
            write(io6,*) ' -----  Dw/Dz averaged over puff'
            write(io6,*) '           ixs,iys,ixend,iyend =',ixs,iys,
     &                                                  ixend,iyend
            do kz=1,nz
               write(io6,*)' iz,wdiv(start),wdiv(end) =',kz,wdivs(kz),
     &                                                      wdive(kz)
            enddo
            write(io6,*) '              ftrans,wdivmx =',ftrans,wdivmx

         endif
c*****

c ---    CAP
c ---    Place a cap on the size of the sigma-z at the start of the step
c ---    to keep it from growing (much) beyond a very large value
c ---    This keeps sigma within the range of the host curves
         if(lszcap) then
            sigzb(ii)=AMIN1(sigzb(ii),szcap_m)
            sigze(ii)=AMIN1(sigze(ii),szcap_m)
            if(ldb) then
               write(io6,*) ' -----  SIGMA-Z CAP (m): ',szcap_m
               write(io6,*) ' -----  sigzb,sigze = ',
     &                               sigzb(ii),sigze(ii)
            endif
         endif
c
c ---    Transfer ozone concentration for chemistry
         ldb2=.false.
         if(mchem.EQ.1 .OR. mchem.EQ.3 .OR. mchem.EQ.4)
     &      call GETOZ(ixmid,iymid,dgrid,ldb2,chioz)
c
c ---    Transfer H2O2 concentration for aqueous chemistry
         ldb2=.false.
         if(maqchem.EQ.1)
     &      call GETH2O2(ixmid,iymid,dgrid,ldb2,chih2o2)

c ---    Set met/dispersion data for the mid-point of the step
         istab=ipgt(ixmid,iymid)
         istab=min0(istab,6)
         dpbl=amax1(htmix(ixmid,iymid),xminzi)
         dpbl=amin1(dpbl,xmaxzi)
         el=xmonin(ixmid,iymid)
         ustr=ustar(ixmid,iymid)
         wstr=wstar(ixmid,iymid)
         z0m=z0(ixmid,iymid)
c ---    Assign Plume Path Coefficient (even if not used)
         ppcoef=ppc(istab)
c
c ---    Extract IRU value (rural=0, urban=1) at mid-point
         iru=0
         if(ilandu(ixmid,iymid) .GE. iurb1 .AND.
     &      ilandu(ixmid,iymid) .LE. iurb2) iru=1

c ---    Set met cell index for subsequent use (TIBL may change index)
         ixmet=ixmid
         iymet=iymid

c ---    Test for sub-grid TIBL treatment
c ---------------------------------------
         ltibl=.FALSE.
         if(MSGTIBL.EQ.1) then
c ---       Store current sampling time into MASTER variable since
c ---       sub-grid TIBL module may alter it
            tsamp0=tsamp
            itibl=0
            if(zitibl(ii).LE.0.) then
c ---          Puff not currently interacting with TIBL
c ---          Check for Positive Radiation at start of step
c frr (09/01 ) 2D QSW in CALMET
               if(i2dmet.EQ.1) then
                  qsws=qsw2d(ixs,iys)
               elseif(i2dmet.EQ.0) then
                  qsws=qswss(nears(ixs,iys))
               else
                  write(*,*)'Subr. COMP:  Invalid I2DMET = ',i2dmet
                  stop
               endif
               if(qsws.GT.0.0) then
                  ltibl=.TRUE.
c ---             Complete the check for initiating TIBL this step
c ---             and set parameters if TIBL is needed
                  if(LTIBL) call TIBLON(ldb,ifree,xold,yold,xnew,
     &                                  ynew,ixs,iys,ixend,iyend,
     &                                  htmet,ltibl)
               endif
               if(LTIBL) then
c ---             Store TIBL ht for next sampling step for this puff
                  if(ilandu(ixend,iyend).GE.iwat1 .AND.
     &               ilandu(ixend,iyend).LE.iwat2) then
c ---                Still in a water cell (must re-enter this section)
                     zitibl(ii)=-1.
                  else
                     zitibl(ii)=htibl(ntibl)
                  endif
               endif
            else
c ---          Puff currently interacting with TIBL (ZITIBL>0)
c ---          Do not override current land use cell index (TIBLGRO)
               ixr=-1
               iyr=-1
c ---          Current heat flux must exceed 5 W/m**2 for further TIBL
c frr (09/01 ) 2D QSW in CALMET
               if(i2dmet.EQ.1) then
                  temps=temp2d(ixs,iys)
               elseif(i2dmet.EQ.0) then
                  temps=tempss(nears(ixs,iys))
               else
                  write(*,*)'Subr. COMP:  Invalid I2DMET = ',i2dmet
                  stop
               endif

c ---          Test for heat flux using met data at start of step, 
c ---          and form based on u-star and M-O length
c ---          to conform to what is done within TIBLGRO
               ustars=AMAX1(0.0,ustar(ixs,iys))
               hbyrcp=-ustars**3*temps/(9.8*0.4*xmonin(ixs,iys))

               if(hbyrcp.LE.0.004) then
c ---             Turn off TIBL calculations due to small heat flux
                  ltibl=.FALSE.
                  zitibl(ii)=-1.
               elseif(zitibl(ii).GE.dpbl) then
c ---             Turn off TIBL calculations if TIBL exceeds current ZI
                  ltibl=.FALSE.
                  zitibl(ii)=-1.
               else
c ---             Compute TIBL arrays for this step
                  ltibl=.TRUE.
                  call TIBLGRO(ldb,xold,yold,xnew,ynew,ixr,iyr,
     &                         zitibl(ii),-.001,-1.)
c ---             Store TIBL ht for next sampling step for this puff
                  if(ilandu(ixend,iyend).GE.iwat1 .AND.
     &               ilandu(ixend,iyend).LE.iwat2) then
c ---                Enters a water cell next step
                     zitibl(ii)=-1.
                  else
                     zitibl(ii)=htibl(ntibl)
                  endif
               endif
            endif
         endif

c ---    Sub-grid TIBL Sub-step
c ---    Set up data for current substep within this sampling step
600      if(LTIBL) then
            itibl=itibl+1
c ---       Set sampling time for this sub-step
            tsamp=tstibl(itibl)*tsamp0
            tsampi=1.0/tsamp
            tfract=tsamp*tavgi
c ---       Redefine step
            distm=ws*tsamp
            dxoldm=uadv*tsamp
            dyoldm=vadv*tsamp
            dxnewm=dxoldm
            dynewm=dyoldm
            dxmold=dxoldm*dgridi
            dymold=dyoldm*dgridi
            xnew=xold+dxmold
            ynew=yold+dymold
c ---       Replace surface layer properties with those
c ---       consistent with TIBL computation
            ixmet=ixtibl(itibl)
            iymet=iytibl(itibl)
            istab=ipgt(ixmet,iymet)
            istab=min0(istab,6)
            el=xmonin(ixmet,iymet)
            ustr=ustar(ixmet,iymet)
            wstr=wstar(ixmet,iymet)
            z0m=z0(ixmet,iymet)
            iru=0
            if(ilandu(ixmet,iymet) .GE. iurb1 .AND.
     &         ilandu(ixmet,iymet) .LE. iurb2) iru=1
c ---       Assign Plume Path Coefficient (even if not used)
            ppcoef=ppc(istab)
c ---       Use actual TIBL height for dpbl
            dpbl=amax1(htibl(itibl),xminzi)
            dpbl=amin1(dpbl,xmaxzi)
         endif
c
c ---    Transfer surface station met. variables (flag=2)
         call EXMET(2,ixmet,iymet,dgrid,tempk,qsw,irh,rhoair,
     &              cldcov,coszen)
c ---    Set land (1) water (2) index for SVMIN,SWMIN
         ilw=1
         if(ilandu(ixmet,iymet).GE.iwat1 .AND.
     &      ilandu(ixmet,iymet).LE.iwat2) ilw=2
c
c ---    Set vertical mass distribution for this step
c ---    The reflecting lid returned (HLID) is used for subsequent calc
c ---    of the vertical distribution of mass; the original height
c ---    (DPBL) is retained for all other uses
         call VMASS(ii,mfact0,nspec,istab,dpbl,hlid,icode)
c
c ---    For puffs above mixed layer, use stability class "JSUP" to
c ---    calculate SIGMA Y and SIGMA Z growth (if JSUP=0, or if ISTAB
c ---    is 5 or 6, use the mixed-layer stability class ISTAB)
         jdstab=istab
         if(jsup.GT.0 .AND. istab.LT.5 .AND. htmet.GT.dpbl) jdstab=jsup
c
c ---    Set turbulence velocities and activate dispersion options
c ---    (Note: idopty and idoptz will be carried in /CURRENT/)
         if(mdisp.EQ.1 .OR. mdisp.EQ.2 .OR. mdisp.EQ.5) then
c ---       Extract wind speed (m/s) at Zi
            call ZFIND(dpbl,zface,nzp1,ilayerzi)
            call WINDSET(dpbl,ilayerzi,ixmet,iymet,z0m,el,dpbl,istab,
     &                   uatzi,wdzi)
            call TURBSET(ldb,ustr,el,wstr,jdstab,dpbl,z0m,htmet,
     &                   uatzi,ws,wd,ixmet,iymet,ilw,
     &                   tsigv,tsigw,idopty,idoptz)
         else
            idopty=mdisp
            idoptz=mdisp
            tsigv=svmin(jdstab,ilw)
            tsigw=swmin(jdstab,ilw)
         endif

c ---    Set PDF variables
         if(mpdf.EQ.1) call PDFVARS(ldb,io6,mdisp,icode,tsigw,wstr,
     &                         ustr,bidfnl(ii),fb(ii),dpbl,ht0(ii),ws)
c
c ---    Set local Brunt-Vaisala frequency
         if(LCALGRD) then
c ---       Use temperature (K) gradient across puff depth (DELZ)
c ---       Minimum pot. temp. gradient is 0.005 K/m
            delz=amax1((ztop-zbot),10.)
            call PTLAPS(ixmet,iymet,zbot,ptgrad0,delz,ptgrad,t0)
            bvf=sqrt(9.80665*ptgrad/t0)
         else
c ---       Use default potential temperature lapse rate with the
c ---       surface temperature from the nearest station
            if(istab.LE.4) then
               ptgrad=0.0
            elseif(istab.EQ.5) then
               ptgrad=amax1(ptg(1),ptgrad0)
            else
               ptgrad=amax1(ptg(2),ptgrad0)
            endif
            bvf=sqrt(9.80665*ptgrad/tempk)
         endif
c
c*****
      if(ldb)then
         write(io6,*)
         write(io6,242)'AFTER VMASS ',(qu(n1,ii),n1=1,nspec)
         write(io6,244)(qm(n2,ii),n2=1,nspec)
         write(io6,*)'old,new Puff/Slug Code = ',ipufcd(ii),icode
         write(io6,*)'             zbot,ztop = ',zbot,ztop
         write(io6,*)'             uadv,vadv = ',uadv,vadv
         write(io6,*)'       xnew,ynew,distm = ',xnew,ynew,distm
         write(io6,*)'       ixmet,iymet,iru = ',ixmet,iymet,iru
         write(io6,*)'dpbl,hlid,istab,jdstab = ',dpbl,hlid,istab,jdstab
         write(io6,*)'            bvf,ppcoef = ',bvf,ppcoef
      endif
c*****
c
c ---    Store current puff code into array (may change in VMASS)
         ipufcd(ii)=icode
c
c -----------------------------------------------------
c ---    Finish Setting Puff/Slug parameters
c -----------------------------------------------------
         if(LBCPUF) then
c ---       Boundary Condition (BC) PUFFS FIRST
            call SETBCPUF(ii,tsamp,distm,ws,xnew,ynew,ldb,uavg)

         elseif(lpuff) then
c
c ---       NOW PUFFS
c ---       Compute puff position and sigmas, and update stored data.
            call SETPUF(ii,tsamp,distm,jdstab,el,tsigv,tsigw,bvf,ws,
     &                  dpbl,xnew,ynew,iru,ldb,uavg,lcalm)
c
         else
c
c ---       NOW SLUGS
c ---       Compute position of slug-ends at start and end of step,
c ---       compute sigmas at these points, and update stored data.
            call SETSLG(ii,ifree,tsamp,iru,jdstab,el,tsigv,tsigw,bvf,
     &                  ws,dpbl,dxoldm,dyoldm,dxnewm,dynewm,ldb,
     &                  uavg,lcalm)
         endif
c
c
c --------------------------------------------------------
c ---    Account for Removal and/or Conversion Processes
c --------------------------------------------------------
c
c ---    Define mass at START of sampling step (after vertical
c ---    redistribution but before any removal or conversion)
         do ipl=1,nspec
c ---       Set initial pollutant mass (g) below mixing height (PUFF)
            qold(ipl)=qm(ipl,ii)
c ---       Set starting emissions (g/s) for each pollutant (SLUG)
            qbrate(ipl)=qm(ipl,ii)*temiti
c ---       Set contribution to total average mass over step
            qavgt(ipl)=0.5*(qm(ipl,ii)+qu(ipl,ii))
c ---       Store initial masses for mass balance option
            q1sfc(ipl)=qm(ipl,ii)
            q1upr(ipl)=qu(ipl,ii)
         enddo
c
c ---    Chemical Transformation
c ------------------------------
         if(mchem.ge.1)then
            zmsl=zpb(ii)+elev(ixmid,iymid)
            call CHEM(nspec,mchem,maqchem,nhrind,tsamp,jsup,qsw,tempk,
     &                irh,rhoair,istab,hlid,chioz,chih2o2,cldcov,
     &                coszen,zmsl,ldb)
            if(imbal.EQ.1) then
               cbal='TRN'
               if(LBCPUF) cbal='TBC'
               call MBALSUM(cbal,q1sfc,q1upr,qm(1,ii),qu(1,ii))
            endif
         endif
c*****
      if(ldb)then
         write(io6,242)'AFTER CHEM  ',(qu(n1,ii),n1=1,nspec)
         write(io6,244)(qm(n2,ii),n2=1,nspec)
      endif
c*****
c
c ---    Wet deposition
c ---------------------
         if(mwet.eq.1)then
            do ispec=1,nspec
               q01wet(ispec,1)=qm(ispec,ii)+qu(ispec,ii)
               qratew(ispec,1)=q01wet(ispec,1)*temiti
c ---          Store initial masses for mass balance option
               q1sfc(ispec)=qm(ispec,ii)
               q1upr(ispec)=qu(ispec,ii)
            enddo
c
            call WET(ixs,iys,nspec,tsamp,ii,tempk,ldb,xlam,fracwet)
c
            do ispec=1,nspec
               q01wet(ispec,2)=qm(ispec,ii)+qu(ispec,ii)
               qratew(ispec,2)=q01wet(ispec,2)*temiti
            enddo
c
            if(imbal.EQ.1) then
               cbal='WET'
               if(LBCPUF) cbal='WBC'
               call MBALSUM(cbal,q1sfc,q1upr,qm(1,ii),qu(1,ii))
            endif
         endif
c*****
      if(ldb)then
         write(io6,242)'AFTER WET   ',(qu(n1,ii),n1=1,nspec)
         write(io6,244)(qm(n2,ii),n2=1,nspec)
      endif
c*****
c
c ---    Dry deposition
c ---------------------
         if(mdry.eq.1)then
            do ispec=1,nspec
               q01dry(ispec,1)=qm(ispec,ii)
c ---          Store initial masses for mass balance option
               q1sfc(ispec)=qm(ispec,ii)
               q1upr(ispec)=qu(ispec,ii)
            enddo
c
            call DRY(icode,ixs,iys,nhrind,tsamp,ii,dpbl,hlid,
     &               tempk,qsw,ppcoef,ldb,
     &               vd,vdpvd,fracdry)
c
            do ispec=1,nspec
               q01dry(ispec,2)=qm(ispec,ii)
            enddo
c
            if(imbal.EQ.1) then
               cbal='DRY'
               if(LBCPUF) cbal='DBC'
               call MBALSUM(cbal,q1sfc,q1upr,qm(1,ii),qu(1,ii))
            endif
         endif
c*****
      if(ldb)then
         write(io6,242)'AFTER DRY   ',(qu(n1,ii),n1=1,nspec)
         write(io6,244)(qm(n2,ii),n2=1,nspec)
      endif
c*****
c
c ---    Define mass at END of sampling step (after removal & chemistry)
         do ipl=1,nspec
c ---       Set "new" pollutant mass (g) below mixing height (PUFF)
            qnew(ipl)=qm(ipl,ii)
c ---       Set ending emissions (g/s) for each pollutant (SLUG)
            qerate(ipl)=qm(ipl,ii)*temiti
c ---       Add contribution to total average mass over step
            qavgt(ipl)=qavgt(ipl)+0.5*(qm(ipl,ii)+qu(ipl,ii))
         enddo
c
c ---    Write puff/slug data at sampling step to TRACKING file
         if(ldb) call TRACK(ii,ndathre,nsece,dpbl,jdstab)
c
c ---    Update mass flux totals
         if(imflx.EQ.1) call MFLXCMP(ldb,lslug,nspec,qavgt)
c
c ----------------------------
c ---    Sampling of puff/slug
c ----------------------------
c
c ---    Reset LSKIP if a new slug is now free of the source
         if(lskip .AND. ifree.EQ.1) lskip=.FALSE.
c
c ---    Call appropriate sampling function (BC, PUFF, or SLUG)
c
         if(LPMODE) then
c ---       Process plume data for FOG Model PLUME Mode output
            call PLMFOG(xold,yold,jdstab,
     1                  iru,tsigv,tsigw,el,bvf,ws,wd,dpbl,nspec,
     2                  qm(1,ii),qu(1,ii),icode,hlid,temiti,
     3                  ldb,lcalm)
c ---       Drop this puff (sampled 1 time as a plume)
            ipufcd(ii)=99
c ---       Log mass dropped
            if(imbal.EQ.1) then
               cbal='OUT'
               call MBALSUM(cbal,qm(1,ii),
     &                      qu(1,ii),qm(1,ii),qu(1,ii))
            endif
            go to 801
            

         elseif(LBCPUF) then
c ---       Nearest BC puff sampling function
            call CALCBC(xold,yold,xnew,ynew,qold,qnew,icode,hlid,
     1                  diam0(ii),vdpvd,nspec,q01wet,q01dry,vd,fracwet,
     2                  tsampi,rbc0,ldb)

         elseif(lpuff) then
c ---       Integrated puff sampling function
c ---       PUFFR is the puff radius in computational grid units at
c ---       the END of the step
            puffr=rconst*sye1
            call CALCPF(xold,yold,xnew,ynew,ppcoef,jdstab,iru,
     1                  tsigv,tsigw,el,bvf,uavg,dpbl,qold,qnew,icode,
     2                  hlid,puffr,vdpvd,nspec,q01wet,q01dry,vd,fracwet,
     3                  tsampi,tfract,ldb,lcalm,lclip)
c
         elseif(.not.LSKIP) then
c ---       Slug sampling function
            call CALCSL(tsamp,tfract,nspec,qbrate,qerate,qratew,
     1                  ht0(ii),elbase(ii),ppcoef,jdstab,symin,szmin,
     2                  iru,hlid,tsigv,tsigw,el,bvf,dpbl,xlam,vd,
     3                  vdpvd,uavg,ldb,lcalm,lclip)
         endif

c -----------------------------
c ---    CTSG sampling function
c -----------------------------
c ---  NOTE 1: Deposition fluxes are not computed at CTSG receptors,
c ---          but any change in the mass in a puff/slug during the
c ---          step is reflected in the concentrations at these
c ---          receptors insofar as the average mass is used here.
c ---  NOTE 2: CTSG algorithm is not designed for CALM conditions.  A
c ---          treatment for CTSG receptors has been added to CALCPF
c ---          and CALCSL for CALM conditions, so skip call to CTSG.
c ---  NOTE 3: CTSG does not interpret puff codes;  screen out codes
c ---          3 & 13 at the start (all material above CBL)

         lctsg=.FALSE.
         if(nctrec.GT.0 .AND. .not.LCALM .AND. .not.LBCPUF) then
            if(mod(icode,10).NE.3) lctsg=.TRUE.
         endif
         if(LCTSG) then
c
c ---       Define AVERAGE mass during sampling step for each pollutant
c ---       but do not incorporate the near-surface correction factor
c ---       (vd'/vd) because center of puff may impinge on terrain
            do ipl=1,nspec
c ---          Set the average pollutant mass (g) below mixing height
               qavg(ipl)=0.5*(qold(ipl)+qnew(ipl))
            enddo
c
            if(lpuff) then
c ---          PUFFS:
c
c ---          Set puff radius (squared) at end of step to identify
c ---          receptors that can be affected (met grid units)
               puffr2=(rconst*sye1)**2
c
c ---          Identify hills that may be affected by puff this step
               do ih=1,nhill
                  scanr2=puffr2+hillr2(ih)
                  call PFSCRN(xold,yold,xnew,ynew,hilldat(1,ih),
     &                        hilldat(2,ih),scanr2,d2,ldohill(ih))
               enddo
c
               ipin=ii
               qin=qunit
c ---          (Note: ttb is age at START step, but tmtotb has already
c ---           been reset to the age at the start of the NEXT step)
               ttb=tmtotb(ii)-tsamp
c
c ---          Set receptor elevation to stack-base to assure no CTADJ
c ---          modifications in call to PUFRECS here
               recht=elbase(ii)
c
c ---          Loop over complex terrain receptors
               do irin=1,nctrec
c
                  if(ldohill(ihill(irin))) then
c ---                Get receptor-specific puff information
                     xrm=xrct(irin)*dgrid
                     yrm=yrct(irin)*dgrid
                     zrm=0.0
                     call PUFRECS(lclip,xrm,yrm,zrm,jdstab,iru,
     &                            tsigv,tsigw,el,bvf,uavg,dpbl,
     &                            recht,ppcoef,lcalm,trec,frac,
     &                            syr,szr,zgrise,zpr,zrpole,
     &                            rfacsq,idrop)
c ---                PRIME downwash:  skip 'dropped' receptors in
c ---                                 cavity zone
                     if(idrop.EQ.0) then
c
c ---                Use receptor-specific puff ht in CTSG call
                     call CTSG(ldb,irin,ipin,qin,ws,wd,hlid,xb1,yb1,
     &                         zgrise,jdstab,elrect(irin),ihill(irin),
     &                         tsamp,ttb,szb1,sze1,syb1,sye1,szr,syr,
     &                         szmin,symin,frac,concct,cflat)
c
c ---                Scale concentrations for each species
                     ctemp=concct*tfract
                     do js=1,nspec
                        chict(irin,js)=chict(irin,js)+qavg(js)*ctemp
                     enddo
                     endif
                  endif
               enddo
c
            else
c ---          SLUGS:
c ---          Determine the number of plugs needed to simulate slug
c ---          (a plug is a puff-like segment of a slug)
               if(iage.EQ.0) then
c ---             Use slug information at end of step for fresh release
                  call SLG2PUF(xe1,xe2,ye1,ye2,sye1,sye2,
     &                         numpuff,qfac,xfac)
               else
c ---             Use slug information at beginning of step
                  call SLG2PUF(xb1,xb2,yb1,yb2,syb1,syb2,
     &                         numpuff,qfac,xfac)
               endif

c ---  Debug Writes
       if(ldb) then
          write(io6,*)
          write(io6,*)'SLG2PUF results...........'
          write(io6,*)'Slug #, numpuff     = ',ii,numpuff
          write(io6,*)'qfac,xfac           = ',qfac,xfac
          write(io6,*)
       endif

c
c ---          Loop over plugs from younger end to older end of slug
               qin=qfac*qunit
c ---          Skip first plug of a fresh slug since it has no timestep
               nfirst=1
               if(iage.EQ.0) nfirst=2
               do np=nfirst,numpuff
c
c ---             Assign slug properties to the plug
                  ipin=ii+np
                  fac=1.0-xfac*(np-1)
c ---             Set age at START of step, and duration of the step
c ---             (Note: tmtotb and tmtote are ages of the young[2] and
c ---              old[1] ends of the slug at the END of the step)
                  ttb=tmtote(ii)+fac*(tmtotb(ii)-tmtote(ii))-tsamp
                  if(ttb.LT.0.0) then
c ---                Must be a freshly released slug!
                     stepin=ttb+tsamp
                     ttb=0.0
                     tadj=stepin/tsamp
                  else
                     stepin=tsamp
                     tadj=1.0
                  endif
c ---             Set coordinates at start and end of step (meters)
                  xpbm=xb1+fac*(xb2-xb1)
                  ypbm=yb1+fac*(yb2-yb1)
                  xpem=xe1+fac*(xe2-xe1)
                  ypem=ye1+fac*(ye2-ye1)
c ---             Set coordinates at start and end of step (met grid)
                  xbmg=xpbm*dgridi
                  ybmg=ypbm*dgridi
                  xemg=xpem*dgridi
                  yemg=ypem*dgridi
c ---             Compute sigmas at start of step (meters)
                  call PLGRECS(lclip,fac,xpbm,ypbm,jdstab,iru,
     &                         tsigv,tsigw,el,bvf,uavg,dpbl,
     &                         frac,sy1in,sz1in,zgrise)
c ---             Compute sigmas at end of step (meters)
                  call PLGRECS(lclip,fac,xpem,ypem,jdstab,iru,
     &                         tsigv,tsigw,el,bvf,uavg,dpbl,
     &                         frac,sy2in,sz2in,zgrise)
c
c ---             Set plug radius (squared) at end of step to identify
c ---             receptors that are affected (met grid units)
                  puffr2=(rconst*sy2in)**2
c
c ---             Identify hills that may be affected by plug this step
                  do ih=1,nhill
                     scanr2=puffr2+hillr2(ih)
                     call PFSCRN(xbmg,ybmg,xemg,yemg,hilldat(1,ih),
     &                           hilldat(2,ih),scanr2,d2,ldohill(ih))
                  enddo
c
c ---  Debug Writes ---
       if(ldb) then
          write(io6,*)
          write(io6,*)'Plug Loop.................'
          write(io6,*)'Slug #, Plug #, Q   = ',ii,np,qin
          write(io6,*)'fac, tstart, tstep  = ',fac,ttb,stepin
       endif
c ---  Debug Writes ---
c
c ---             Loop over complex terrain receptors
                  do irin=1,nctrec
c ---                Screen out receptors that are too far away
                     if(ldohill(ihill(irin))) then
c ---                   Get receptor-specific plug information
                        xrm=xrct(irin)*dgrid
                        yrm=yrct(irin)*dgrid
                        call PLGRECS(lclip,fac,xrm,yrm,jdstab,iru,
     &                               tsigv,tsigw,el,bvf,uavg,dpbl,
     &                               frac,syr,szr,zgrise)
c
c ---                   Use receptor-specific puff ht in CTSG call
                        call CTSG(ldb,irin,ipin,qin,ws,wd,hlid,xpbm,
     &                            ypbm,zgrise,jdstab,elrect(irin),
     &                            ihill(irin),stepin,ttb,sz1in,sz2in,
     &                            sy1in,sy2in,szr,syr,szmin,symin,frac,
     &                            concct,cflat)
c
c ---                   Scale concentrations for each species
                        ctemp=concct*tfract*tadj
                        do js=1,nspec
                           chict(irin,js)=chict(irin,js)+qavg(js)*ctemp
                        enddo
                     endif
                  enddo
               enddo
            endif
         endif

c -----------------------------
c ---    Clean up for next step
c -----------------------------

c ---    Update puff code (may change in sampling routines)
         ipufcd(ii)=icode
c
c ---    Reset ZIMAX for next step (used for uniform distribution)
         zimax(ii)=amax1(zimax(ii),hlid)

c ---    Update the reflecting lid height from "last" step
         ziold(ii)=hlid

c ---    Check if new position is off computational grid (reset code)
         if(lpuff) then
c ---       Test center of PUFF:
            if(xnew.lt.xb.or.xnew.gt.xe.or.
     1         ynew.lt.yb.or.ynew.gt.ye)then
               ipufcd(ii)=99
c ---          Log mass dropped
               if(imbal.EQ.1) then
                  cbal='OUT'
                  if(LBCPUF) cbal='OBC'
                  call MBALSUM(cbal,qm(1,ii),
     &                         qu(1,ii),qm(1,ii),qu(1,ii))
               endif
               go to 801
            endif
         else
c ---       Test both ends of SLUG:
            if(xpe(ii).lt.xb.or.xpe(ii).gt.xe.or.
     1         ype(ii).lt.yb.or.ype(ii).gt.ye) then
c ---          Older end of slug is off the grid!
               if(xpb(ii).lt.xb.or.xpb(ii).gt.xe.or.
     1            ypb(ii).lt.yb.or.ypb(ii).gt.ye) then
c ---             Younger end is also off grid!
                  ipufcd(ii)=99
c ---             Log mass dropped
                  if(imbal.EQ.1) call MBALSUM('OUT',qm(1,ii),
     &                                     qu(1,ii),qm(1,ii),qu(1,ii))
                  go to 801
               endif
            endif
         endif

c ---    Check if a slug should be converted to a puff
         if(lslug) then
c ---       This is a SLUG!
            testsy=amin1(sye2,sye1)
            testd=sl2pf*sqrt((xe1-xe2)**2+(ye1-ye2)**2)
            if(testsy.GE.testd) then
c ---          Convert to PUFF!
               ipufcd(ii)=ipufcd(ii)-mfact0
               mfact0=0
               icode=ipufcd(ii)
               lpuff=.TRUE.
               lslug=.FALSE.
               zpb(ii)=0.5*(zpb(ii)+zpe(ii))
               sigyb(ii)=0.5*(sigyb(ii)+sigye(ii))
               sigzb(ii)=0.5*(sigzb(ii)+sigze(ii))
               xtotb(ii)=0.5*(xtotb(ii)+xtote(ii))
               tmtotb(ii)=0.5*(tmtotb(ii)+tmtote(ii))
               xpb(ii)=xnew
               ypb(ii)=ynew
c*****
      if(ldb)then
         write(io6,*)'SLUG converted to PUFF at end of KSAM= ',ksam
         write(io6,*)'     SIGYB, SIGZB        = ',sigyb(ii),sigzb(ii)
         write(io6,*)'     Slug Length * SL2PF = ',testd
      endif
c*****
            endif
         endif 

c ---    End of TIBL sub-step loop
         if(LTIBL) then
            if(itibl.LT.ntibl) then
               xold=xnew
               yold=ynew
               goto 600
            else
c ---          Restore sampling step variables
               tsamp=tsamp0
               tsampi=1.0/tsamp
               tfract=tsamp*tavgi
            endif
         endif

         if(LSUBSAM) then
c ---       Check for incomplete sampling step
            if(tleft.GE.1.0 .AND. ksam.EQ.nsam) then
c ---          Last sampling step, so use up remaining sampling time
c ---          by taking another substep
               tsamp=tleft
               goto 500
            elseif(tleft.GT.tsamp) then          
c ---          Time remaining in this step exceeds the time used in
c ---          the current sub-step, so take another substep.
               tsamp=tleft
               goto 500
            endif
c ---       Otherwise, continue on to the next sampling step, and add
c ---       whatever time is left to the reference sampling step time
         endif

800      continue

c ---    Puff (ii) has been sampled, and is still in domain
c ---    Add mass to total for end of period
         if(imbal.EQ.1) then
            cbal='TOT'
            if(LBCPUF) cbal='SBC'
            call MBALSUM(cbal,qm(1,ii),qu(1,ii),qm(1,ii),qu(1,ii))
         endif

801      continue

c ---    Close puff loop
900      CONTINUE

c ---  All puffs for this source have been sampled
c ---  Add contribution to Total CHIFLX arrays (mode 1)
       ichiflx=1
       if(ktype.NE.9) call TCHIFLX(ichiflx)
       if(msource.EQ.1) then
c ---     Perform source contribution output
cc ---     Add contribution to Total CHIFLX arrays (mode 1)
c          ichiflx=1
c          if(ktype.NE.9) call TCHIFLX(ichiflx)
c ---     Print results and/or store source contribution records on disk
          isrcmode=1
          if(ktype.NE.9 .AND. MOD(nn,iavg).EQ.0)
     &                   call OUTPUT(nn,isrcmode,ktype,ksource)
       endif

c ---  Close source loop
1100   continue

c --- Close source-type loop
1200  continue

c --- Swap Total CHIFLX arrays into standard CHIFLX arrays (mode 2)
      ichiflx=2
c      if(msource.EQ.1) call TCHIFLX(ichiflx)
      call TCHIFLX(ichiflx)

c --- Sum contribution from the boundary condition puff that passes
c --- nearest each receptor this sampling step
      if(LBCPUF) call SUMBC

c --- Do Fog-related processing on concentration and temperature excess
c --- fields and report results
      if(MFOG.GT.0 .AND. MOD(nn,iavg).EQ.0) call FOGOUT     
c
c --- Print results and/or store results on disk
      ktype=0
      ksource=1
      isrcmode=0
      if(MOD(nn,iavg).EQ.0) call OUTPUT(nn,isrcmode,ktype,ksource)

c --- Write model run data for this period to restart file if selected
      if(mrestart.GE.2) then
         if(nn.EQ.iarlg) then
c ---       Restart data are written at close of run
            call RESTARTO
         elseif(nrespd.GT.0) then
c ---       Restart data are written every NRESPD periods
            if(MOD(nn,nrespd).EQ.0)call RESTARTO
         endif
      endif

c --- Increment date and time (except on last hour of run)
      if(nn.lt.iarlg) call TIMEUP(1)
c
1000  continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine vmass(ii,mfact0,nspec,istab,dpbl,hlid,icode)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040913                  VMASS
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Assigns vertical distribution of puff/slug for current
c               sampling step (puff code, mass)
c
c --- UPDATE
c --- V5.4-V5.741   040913  (DGS): MTILT option only: increase test for
c                                  well-mixed limit 
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.0     980731  (DGS): recast 2-layer logic for Gaussian to
c                                  allow gradual fumigation
c --- V4.0-V5.0     971107  (DGS): replace ZFINAL puff/slug height array
c                                  with ZPB,ZPE arrays
c
c --- INPUTS:
c            II - integer - Current puff/slug index
c        MFACT0 - integer - ICODE offset between puffs and slugs
c                           (0 = PUFF;  10 = SLUG)
c         NSPEC - integer - Number of active species in run
c         ISTAB - integer - Stability class in surface layer
c          DPBL - real    - Depth of planetary boundary layer (current
c                           mixing height, m)
c         ICODE - integer - Code for vertical distribution
c                                1 = Puff within DPBL & Gaussian
c                                2 = Puff within DPBL & uniform
c                                3 = Puff above DPBL & Gaussian
c                                4 = Puff above DPBL & uniform
c                                5 = Puff currently above DPBL
c                                    (but previously below) & Gaussian
c                                6 = Puff currently DPBL layer
c                                    (but previously below) & uniform
c                               11 = Slug within DPBL & Gaussian
c                               12 = Slug within DPBL & uniform
c                               13 = Slug above DPBL & Gaussian
c                               14 = Slug above DPBL & uniform
c                               15 = Slug currently above DPBL
c                                    (but previously below) & Gaussian
c                               16 = Slug currently above DPBL
c                                    (but previously below) & uniform
c
c     Common block /FLAGS/ variables:
c            MTILT
c     Common block /PUFF/ variables:
c            ZIMAX(mxpuff), ZIOLD(mxpuff), SIGYB(mxpuff), SIGZB(mxpuff),
c            ZPB(mxpuff), QU(mxspec,mxpuff), QM(mxspec,mxpuff)
c     Common block /SLUG/ variables:
c            ZPE(mxpuff), SIGYE(mxpuff), SIGZE(mxpuff)
c
c     Parameters:
c            MXPUFF, MXSPEC, IO6
c
c --- OUTPUT:
c          HLID - real    - Modified mixing height: reflecting lid
c                           for vertical mass distribution (m)
c         ICODE - integer - Code for vertical distribution
c     Common block /PUFF/ variables:
c            QU(mxspec,mxpuff), QM(mxspec,mxpuff)
c
c
c --- VMASS called by: COMP
c --- VMASS calls:     none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'flags.puf'
      include 'puff.puf'
      include 'slug.puf'
c
      logical lfatal
c
c --- Set unlimited mixing height (m)
      data ziunlm/1.0e04/
      data rtpiby2/1.2533141/, one/1.0/, half/0.5/, zero/0.0/

c --- Ratio of sigma-z to zi for well-mixed limit
      data szbyzi0/1.6/

c --- Factor to increase sz/zi0 for MTILT option
      data ftiltmix/2.0/

c --- Trap invalid puff codes here
      lfatal=.FALSE.
      if(icode.EQ.0) lfatal=.TRUE.
      if(icode.GE.7 .AND. icode.LE.10) lfatal=.TRUE.
      if(icode.GE.17 .AND. icode.LT.99) lfatal=.TRUE.
      if(LFATAL) then
         write(io6,*)'VMASS:  Invalid puff code = ',icode
         write(*,*)
         stop 'Halted in VMASS -- see list file.'
      endif

c --- Condition old mixing heights from last step
      qumass=zero
      do ipl=1,nspec
         qumass=qumass+qu(ipl,ii)
      enddo
      if(qumass.EQ.zero) then
c ---    No upper layer, so assign last lid height to max height to be
c ---    consistent with 1-layer structure
         zimax(ii)=ziold(ii)
      endif

c --- Set mean height of puff/slug
      if(mfact0.EQ.0) then
c ---    Puff
         zmean=zpb(ii)
      else
c ---    Slug
         zmean=half*(zpb(ii)+zpe(ii))
      endif

c --- Initialize lid height to PBL height
      hlid=dpbl

c --- If Gaussian, determine the top of equivalent uniform profile
c --- Ignore BID contribution to sigma-z
      if(mod(icode,2).EQ.1) then
         if(mfact0.EQ.0) then
c ---       Puff
            szmax=sigzb(ii)
            szmin=sigzb(ii)
            zmean=zpb(ii)
         else
c ---       Slug
            szmax=amax1(sigzb(ii),sigze(ii))
            szmin=amin1(sigzb(ii),sigze(ii))
            zmean=half*(zpb(ii)+zpe(ii))
         endif
c ---    Equivalent top of puff without influence of lid
         ptop0=zmean+rtpiby2*szmax
      endif

c --- Set the ratio of sigma-z to zi for well-mixed limit
      szbyzi=szbyzi0
      if(mtilt.GT.0) szbyzi=szbyzi0*ftiltmix
c
c ---------------------------------------------------
c --- Set vertical distribution for mixed puffs first
c ---------------------------------------------------
c
c --- CODE 4:  puff/slug above mixed layer since release, & Uniform
      if(mod(icode,10).EQ.4) then
c ---    Keep current icode until mixed layer reaches center of puff
c ---    then switch to icode=2,12 with no change to hlid, and shift
c ---    all mass to main layer
         if(hlid.GE.zmean) then
            icode=2+mfact0
            do ipl=1,nspec
               qm(ipl,ii)=qu(ipl,ii)+qm(ipl,ii)
               qu(ipl,ii)=zero
            enddo
         endif

c --- CODE 2,6:  puff/slug Uniform & within present/past mixed layer
      elseif(mod(icode,2).EQ.0) then
         if(hlid.GE.zimax(ii)) then
c ---       Current mixing height has exceeded ZIMAX, so there is a
c ---       1-layer structure:  transfer mass
            do ipl=1,nspec
               qm(ipl,ii)=qu(ipl,ii)+qm(ipl,ii)
               qu(ipl,ii)=zero
            enddo
            zimax(ii)=hlid
            ziold(ii)=hlid
            icode=2+mfact0
         else
c ---       Puff/slug mass is both above and below current mixed
c ---       layer. Calculate any transfer of mass between layers
c ---       Sign of the transfer is (+) if lower layer gains mass
c ---       from the upper layer, and (-) if upper layer gains mass.
            if(hlid.GE.ziold(ii)) then
c ---          1: lower layer growing into upper layer --
               dqfac=(hlid-ziold(ii))/(zimax(ii)-ziold(ii))
               if(dqfac.GT.one) dqfac=one
               do ipl=1,nspec
                  dq=qu(ipl,ii)*dqfac
                  qu(ipl,ii)=qu(ipl,ii)-dq
                  qm(ipl,ii)=qm(ipl,ii)+dq
               enddo
            else
c ---          2: upper layer growing into lower layer --
               qmtotal=zero
               do ipl=1,nspec
                  qmtotal=qmtotal+qm(ipl,ii)
               enddo
               if(qmtotal.EQ.zero) then
c ---             Special case of qm=0 (reset hlid to ziold)
                  hlid=ziold(ii)
               else
c ---             Mass in surface layer decreases as layer shrinks
                  dqfac=(hlid-ziold(ii))/ziold(ii)
                  if(dqfac.LT.-one) dqfac=-one
                  do ipl=1,nspec
                     dq=qm(ipl,ii)*dqfac
                     qu(ipl,ii)=qu(ipl,ii)-dq
                     qm(ipl,ii)=qm(ipl,ii)+dq
                  enddo
               endif
            endif
            ziold(ii)=hlid
            icode=6+mfact0
         endif
c
c -------------------------------------------------
c --- Set vertical distribution for Gaussian puffs
c -------------------------------------------------
c
c --- Treat STABLE surface layer case first
c
      elseif(istab.GE.5) then
c ---    Adjust puff code 3 case to code 1
         if(mod(icode,10).EQ.3) then
c ---       Place puff within unlimited stable layer
            icode=1+mfact0
            hlid=ziunlm
            zimax(ii)=ziunlm
            ziold(ii)=ziunlm
            do ipl=1,nspec
               qm(ipl,ii)=qu(ipl,ii)+qm(ipl,ii)
               qu(ipl,ii)=zero
            enddo           
         else
c ---       Make the old mixing height current to either preserve
c ---       unlimited mixing, or to retain structure from last hour
            hlid=ziold(ii)
         endif
c ---    Test for well-mixed limit and reset if found
         if((szmin/hlid).GT.szbyzi) then
c ---       Puff is mixed: change code
            icode=icode+1
         endif

c --- Now treat cases with a non-stable surface layer
c
c --- CODE 1:  puff/slug Gaussian & within current mixed layer
      elseif(mod(icode,10).EQ.1) then
c ---    Determine reflecting lid height for Gaussian distribution.
         if(hlid.LT.zmean) then
c ---       Puff above surface layer, so persist last structure and
c ---       reset code to 5
            hlid=ziold(ii)
            icode=5+mfact0
         elseif(hlid.LT.ziold(ii)) then
c ---       Mixing lid is decreasing, but puff remains within surface
c ---       layer, so do not allow reflecting lid to decrease below 
c ---       level at which puff first interacts strongly with the lid.
c ---       Test based on top-hat distribution
            ptop=AMIN1(ptop0,ziold(ii))
            hlid=AMAX1(hlid,ptop)
         endif
c ---    Reset zimax and ziold to the new lid height
         zimax(ii)=hlid
         ziold(ii)=hlid
c ---    Test for well-mixed limit
         if((szmin/hlid).GT.szbyzi) then
c ---       Puff is MIXED
            if(hlid.GT.dpbl) then
c ---          Create 2 layers: restore current mixing ht and
c ---          distribute mass above/below current mixing height
               icode=6+mfact0
               dqfac=(dpbl-hlid)/hlid
               if(dqfac.LT.-one) dqfac=-one
               do ipl=1,nspec
                  dq=qm(ipl,ii)*dqfac
                  qu(ipl,ii)=qu(ipl,ii)-dq
                  qm(ipl,ii)=qm(ipl,ii)+dq
               enddo
               ziold(ii)=dpbl
               hlid=dpbl
            else
c ---          There is only one layer
               icode=2+mfact0
            endif
         endif

c --- CODE 3:  puff/slug above mixed layer since release, & Gaussian
      elseif(mod(icode,10).EQ.3) then
c ---    Keep current values until mixed layer reaches centerline ht,
c ---    then pass mass below lid to qm, with reflections from hlid
         if(hlid.GE.zmean) then
c ---       Fraction of mass above lid is  0 < fup < 0.5
            if(hlid.GE.ptop0) then
c ---          All mass is in surface layer now --- One layer
               fup=zero
               icode=1+mfact0
               zimax(ii)=hlid
               ziold(ii)=hlid
            else
c ---          Two layers
               fup=0.5*(ptop0-hlid)/(ptop0-zmean)
               icode=5+mfact0
               zimax(ii)=ptop0
               ziold(ii)=hlid
            endif
c ---       Transfer mass from upper layer to surface layer
            do ipl=1,nspec
               qtot=qu(ipl,ii)+qm(ipl,ii)
               qu(ipl,ii)=fup*qtot
               qm(ipl,ii)=qtot-qu(ipl,ii)
            enddo
c ---       Test for well-mixed limit
            if((szmin/hlid).GT.szbyzi) icode=icode+1
         endif

c --- CODE 5:  puff/slug Gaussian with mass above & below mixing ht
      elseif(mod(icode,10).EQ.5) then
         if(hlid.GE.zimax(ii)) then
c ---       Current mixing height has exceeded ZIMAX, so there is a
c ---       1-layer structure again:  transfer mass
            do ipl=1,nspec
               qm(ipl,ii)=qu(ipl,ii)+qm(ipl,ii)
               qu(ipl,ii)=zero
            enddo
            icode=1+mfact0
            zimax(ii)=hlid
            ziold(ii)=hlid
c ---       Test for well-mixed limit
            if((szmin/hlid).GT.szbyzi) icode=icode+1
         elseif(hlid.LT.zmean) then
c ---       Surface layer is below the center of the puff; retain
c ---       old vertical structure
            hlid=ziold(ii)
c ---       Test for well-mixed limit in lower layer
            if((szmin/hlid).GT.szbyzi) icode=icode+1
         elseif(hlid.LT.ziold(ii)) then
c ---       Mixing lid is decreasing, but puff remains in surface layer;
c ---       do not allow reflecting lid to decrease in height below
c ---       level at which puff first interacts strongly with the lid.
c ---       Test based on top-hat distribution
            ptop=AMIN1(ptop0,ziold(ii))
            hlid=AMAX1(hlid,ptop)
c ---       Reset ziold to the new lid height, retain zimax (2 layers)
            ziold(ii)=hlid
c ---       Test for well-mixed limit in lower layer
            if((szmin/hlid).GT.szbyzi) icode=icode+1
         else
c ---       Mixing lid is rising, but remains less than ZIMAX
c ---       Allow growing layer to entrain mass that had partially
c ---       penetrated the top of the layer.
c ---       Sign of the transfer is (+) as lower layer gains mass
            dqfac=(hlid-ziold(ii))/(zimax(ii)-ziold(ii))
            if(dqfac.GT.one) dqfac=one
            do ipl=1,nspec
               if(qu(ipl,ii).GT.zero) then
                  dq=qu(ipl,ii)*dqfac
                  qu(ipl,ii)=qu(ipl,ii)-dq
                  qm(ipl,ii)=qm(ipl,ii)+dq
               endif
            enddo
c ---       Reset ZIOLD
            ziold(ii)=hlid
c ---       Test for well-mixed limit in lower layer
            if((szmin/hlid).GT.szbyzi) icode=icode+1
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine split(ldbhr,lresplit,nspec,xb,yb,xe,ye,imbal,
     &                 numsplty,numspltz)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 031017                  SPLIT
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Create "new" puffs/slugs by splitting old puffs/slugs
c               in the vertical and old puffs in the horizontal when
c               appropriate for tracking effects of wind shear
c
c --- UPDATE
c --- V5.4-V5.72    031017  (DGS): ISRCTYP replaces IPUFID
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c                   000602  (DGS): add horizontal splitting
c
c --- INPUTS:
c         LDBHR - logical - Debug output produced (T/F)
c      LRESPLIT - logical - Reset ISPLIT to 1 to allow further splits
c                           in the vertical (T = Yes, F = No)
c         NSPEC - integer - Number of species
c         XB,YB - real    - SW corner of computational grid 
c                           (met. grid units)
c         XE,YE - real    - NE corner of computational grid 
c                           (met. grid units)
c         IMBAL - integer - Flag for tracking mass balance (1=tracked)
c
c     Common block /COMPARM/ variables:
c           NSPLIT, ROLDMAX, ZISPLIT,
c           NSPLITH, SYSPLITH, CNSPLITH(mxspec), SHSPLITH
c     Common Block /GRID/ variables:
c           DGRIDI, NZ, NZP1, ZFACE(mxnzp1)
c    Common block /METHR/ variables:
c           UMET(mxnx,mxny,mxnz), VMET(mxnx,mxny,mxnz)
c     Common block /PUFF/ variables:
c           NPUFFS, ZIOLD, ZIMAX, SIGYB
c           ISRCTYP, IPUFCD, XPB, YPB, QM, QU
c     Parameters:
c           MXPUFF, MXSPEC, MXNX, MXNY, MXNZ, MXNZP1, IO6
c
c --- OUTPUT:
c      NUMSPLTY - integer - Number of old puffs that are split in the
c                           horizontal 
c                           (initial value set to 0 before call)
c      NUMSPLTZ - integer - Number of puffs that are split in the
c                           vertical 
c                           (initial value set to 0 before call)
c
c --- SPLIT called by:  COMP
c --- SPLIT calls:      ROLLDN, SWAP, PUFFDZ, ADVWND, MBALSUM
c----------------------------------------------------------------------
c ---       Conditions for splitting a puff in the horizontal:
c               1)  Must be a puff (not slug)
c               2)  Must NOT be a 'boundary puff'
c               3)  Sigma-y (without BID) must exceed SYSPLITH
c               4)  Average concentration of at least one species must
c                   exceed the corresponding CNSPLITH
c ---       Conditions for splitting a puff in the vertical:
c               1)  Puff/Slug code 6/16
c               2)  ISPLIT=1 (puff/slug has not been split this cycle)
c               3)  Mix. ht last step is at least a min. value ZISPLIT
c               4)  Mix. ht last step is a "small" fraction of ZIMAX,
c                   no larger than ROLDMAX
c               5)  Puff has finite mass in surface layer (qm)
c ---------------------------------------------------------------------
c
      include 'params.puf'
      include 'comparm.puf'
      include 'grid.puf'
      include 'methr.puf'
      include 'puff.puf'

      logical ldbhr,lresplit,lpuff
      logical lconc, lshear
      real qqu(mxspec),qqm(mxspec)
      real u(mxnz),v(mxnz)
      real sin45(8),cos45(8)
      character*3 cbal

c --- Set puff logical to true (horizontal splitting)
      data lpuff/.TRUE./

c --- Set the center-puff mass augmentation factor Fc/n
c --- for a radial spread factor of fd=2.4 (scales new sigma-y)
c ---     expval=EXP(-0.5*fd*fd)
c ---     fcbyn=(0.25-expval)/(1.0-expval)
      data fd/2.4/, fcbyn/0.205395/

      data twopi/6.2831853/
      data cbal/'OUT'/

c --- Set array of sines and cosines in 45 degree steps for the
c --- shear calculations
      data sin45/ 0.0,  0.707107,  1.0,  0.707107,
     &            0.0, -0.707107, -1.0, -0.707107/
      data cos45/ 1.0,  0.707107,  0.0, -0.707107,
     &           -1.0, -0.707107,  0.0,  0.707107/

c --- Set angle and mass weight for radial array of split puffs
      rnm1=FLOAT(nsplith-1)
      angle=twopi/rnm1
      weight=(1.-fcbyn)/rnm1

c ------------------------------------------
c --- Address HORIZONTAL splitting first
c ------------------------------------------
c --- Make room for split puffs: If too many puffs are needed,
c --- remove puffs that are off the grid and "roll down" arrays
c --- (this also applies to the DA file of tabulated arrays)
      np0=npuffs
      np=npuffs*(nsplith)
      if(np.GT.mxpuff) then
         call ROLLDN(np0)
c ---    Reset current number of puffs after roll-down
         np0=npuffs
      endif

c --- Loop over all existing puffs/slugs
c --------------------------------------
      do ii=1,np0
c ---  Must be an active PUFF (no slugs)
       if(ipufcd(ii).LT.11) then
c
c ---    Process only puffs released from explicit sources
c ---    (not boundary)
         if(isrctyp(ii).NE.9) then
c
c ---      Puff-size filter
           if(sigyb(ii).GT.sysplith) then
              lconc=.FALSE.
              if(ipufcd(ii).NE.4)then
c ---            (Code 4 is above mixed layer since release, and
c ---             uniform: do not split it)
c ---            Approximate puff concentration
c ---            Use 'neutral' form of PUFFDZ for puff top/bottom 
c ---            (ilayer is a dummy here)
                 iistab=4
                 iilayer=3
                 call PUFFDZ(ii,ipufcd(ii),lpuff,iistab,iilayer,
     &                       zpb(ii),ziold(ii),ztop,zbot)
                 volinv=1.0/((ztop-zbot)*twopi*sigyb(ii)*sigyb(ii))
                 do is=1,nspec
                    if(((qm(is,ii)+qu(is,ii))*volinv).GT.
     &                                     cnsplith(is)) then
                       lconc=.TRUE.
                       goto 101
                    endif
                 enddo
              endif
c
c ---         Minimum concentration filter
101           if(lconc) then
c ---           Set ring radius for obtaining shear (met. grid units)
c ---           [Use the distance based on the split-puff sigmas]
c ---           Set sigma-y for the new puffs
                synew=0.5*sigyb(ii)
c ---           Set radial distance for puffs about original location
                rmet=fd*synew*dgridi
c ---           Get advection components at center
                ix=1.0+AMAX1(0.,xpb(ii))
                iy=1.0+AMAX1(0.,ypb(ii))
                ix=MIN(ix,nx)
                iy=MIN(iy,ny)
c ---           Transfer U,V to 1-D arrays
                do iz=1,nz
                   u(iz)=umet(ix,iy,iz)
                   v(iz)=vmet(ix,iy,iz)
                enddo
                call ADVWND(u,v,zface,nzp1,zbot,ztop,u0,v0)
c ---           Check enlargement rate against shear criterion
                lshear=.FALSE.
c ---           Search at 45-deg intervals starting at 0 (North)
                do iang=1,8
                   x=xpb(ii)+rmet*sin45(iang)
                   y=ypb(ii)+rmet*cos45(iang)
                   ix=1.0+AMAX1(0.,x)
                   iy=1.0+AMAX1(0.,y)
                   ix=MIN(ix,nx)
                   iy=MIN(iy,ny)
c ---              Transfer U,V to 1-D arrays
                   do iz=1,nz
                      u(iz)=umet(ix,iy,iz)
                      v(iz)=vmet(ix,iy,iz)
                   enddo
                   call ADVWND(u,v,zface,nzp1,zbot,ztop,ui,vi)
                   erate=sin45(iang)*(ui-u0)+cos45(iang)*(vi-v0)
                   if(erate.GT.shsplith) then
                      lshear=.TRUE.
                      goto 201
                   endif
                enddo
c
c ---           Minimum wind shear filter
201             if(lshear) then

c                 --------------------
c ---               Split this PUFF
c                 --------------------

c *******
      if(ldbhr) then
         write(io6,*)
         write(io6,*) 'SPLIT --- initial values for puff ',ii
         write(io6,*) ' sigyb,ipufcd,ziold,zimax = '
         write(io6,*) sigyb(ii),ipufcd(ii),ziold(ii),zimax(ii)
         write(io6,*) 'ztop,zbot (m) = ',ztop,zbot
         write(io6,*) '1/Volume (1/m^3) = ',volinv
         write(io6,*) 'q-upper = ',(qu(is,ii),is=1,nspec)
         write(io6,*) 'q-lower = ',(qm(is,ii),is=1,nspec)
         write(io6,*)
         write(io6,*) 'Split criteria: shear'
         write(io6,*) '   iang,ix,iy = ',iang,ix,iy
         write(io6,*) 'xpb,ypb,u0,v0 = ',xpb(ii),ypb(ii),u0,v0
         write(io6,*) ' xi, yi,ui,vi = ',x,y,ui,vi
         write(io6,*) '   erate(m/s) = ',erate
         write(io6,*)
      endif
c ********
c
c ---             Check to see if roll-down was adequate
                  if(npuffs+nsplith.gt.mxpuff)then
                     write(io6,*) 'FATAL ERROR in subr. SPLIT'
                     write(io6,*)'Too many puffs on grid ---'
                     write(io6,*)' NPUFFS (old puffs) = ',npuffs
                     write(io6,*)' NSPLITH = ',nsplith
                     write(io6,*)' MXPUFF = ',mxpuff
                     write(*,*)
                     stop 'Halted in SPLIT -- see list file.'
                  endif
c
c ---             Swap puff data from original puff to splits
                  do i=1,nsplith-1
                     j=npuffs+i
                     call SWAP(j,ii)
                  enddo

c ---             Loop over split puffs (first puff is at old location)
c ---             and alter the sigma-y, location, and masses
c ---             Center puff:
                  sigyb(ii)=synew
                  do is=1,nspec
                     qm(is,ii)=fcbyn*qm(is,ii)
                     qu(is,ii)=fcbyn*qu(is,ii)
                  enddo
c ---             Ring puffs:
                  do i=2,nsplith
c ---                Set puff index (jj)
                     jj=npuffs+i-1
c ---                Revise puff attributes
                     sigyb(jj)=synew
                     xpb(jj)=xpb(ii)+rmet*SIN(angle*(i-2))
                     ypb(jj)=ypb(ii)+rmet*COS(angle*(i-2))
                     do is=1,nspec
                        qm(is,jj)=weight*qm(is,jj)
                        qu(is,jj)=weight*qu(is,jj)
                     enddo
c ---                Check if new position is off computational
c ---                grid (reset code)
                     if(xpb(jj).lt.xb.or.xpb(jj).gt.xe.or.
     &                  ypb(jj).lt.yb.or.ypb(jj).gt.ye)then
                        ipufcd(jj)=99
c ---                   Log mass dropped
                        if(imbal.EQ.1) then
                           call MBALSUM(cbal,qm(1,jj),qu(1,jj),
     &                                  qm(1,jj),qu(1,jj))
                        endif
                     endif
                  enddo
c *******
      if(ldbhr) then
         do i=1,nsplith
            jj=npuffs+i-1
            if(jj.EQ.npuffs) jj=ii
         write(io6,*) 'SPLIT --- changed values for puff ',jj
         write(io6,*) 'xpb,ypb,sigyb = ',xpb(jj),ypb(jj),sigyb(jj)
         write(io6,*) 'q-upper = ',(qu(is,jj),is=1,nspec)
         write(io6,*) 'q-lower = ',(qm(is,jj),is=1,nspec)
         write(io6,*)
         enddo
      endif
c *******

c
c ---             Update total number of puffs
                  npuffs=npuffs+nsplith-1
c ---             Update number of old puffs that are split
                  numsplty=numsplty+1
c
                endif
              endif
            endif
         endif
       endif
      enddo

c ------------------------------------------
c --- Address VERTICAL splitting next
c ------------------------------------------
c --- Make room for split puffs: If too many puffs are needed,
c --- remove puffs that are off the grid and "roll down" arrays
c --- (this also applies to the DA file of tabulated arrays)
      np0=npuffs
      np=npuffs*(nsplit)
      if(np.GT.mxpuff) then
         call ROLLDN(np0)
c ---    Reset current number of puffs after roll-down
         np0=npuffs
      endif

c --- Loop over all existing puffs/slugs
c --------------------------------------
      do ii=1,np0
       if(ipufcd(ii).LT.90) then
c
c ---    Reset ISPLIT flag to 1 if it is time to split all puffs again
         if(lresplit) isplit(ii)=1
c
c ---    Process only those puffs that are uniform in the vertical, and
c ---    above the mixing layer (but were once below)
         if(ipufcd(ii).EQ.6 .OR. ipufcd(ii).EQ.16) then
c
c ---       Check to see if roll-down was adequate
            if(npuffs+nsplit.gt.mxpuff)then
               write(io6,*) 'FATAL ERROR in subr. SPLIT'
               write(io6,*)'Too many puffs on grid for puff array -- ',
     1         'NPUFFS (old puffs) = ',npuffs,' NSPLIT = ',nsplit,
     2         ' MXPUFF = ',mxpuff
               write(*,*)
               stop 'Halted in SPLIT -- see list file.'
            endif
c
            if(isplit(ii).EQ.1 .AND. ziold(ii).GE.zisplit) then
               ratio=ziold(ii)/zimax(ii)
               qmtotal=0.0
               do is=1,nspec
                  qmtotal=qmtotal+qm(is,ii)
               enddo
               if(ratio.LE.roldmax .AND. qmtotal.GT.0.0) then
c                 ------------------------
c ---               Split this PUFF/SLUG
c                 ------------------------

c *******
      if(ldbhr) then
         write(io6,*)
         write(io6,*) 'SPLIT --- initial values for puff ',ii
         write(io6,*) ' isplit,ipufcd,ziold,zimax = '
         write(io6,*) isplit(ii),ipufcd(ii),ziold(ii),zimax(ii)
         write(io6,*) 'q-upper = ',(qu(is,ii),is=1,nspec)
         write(io6,*) 'q-lower = ',(qm(is,ii),is=1,nspec)
      endif
c ********
c
c ---             Reset split flag to indicate that a split has occurred
                  isplit(ii)=0
c
c ---             Swap puff/slug data from original puff to splits
                  do i=1,nsplit-1
                     j=npuffs+i
                     call SWAP(j,ii)
                  enddo
c
c ---             Set working variables
                  zlidu=zimax(ii)
                  zlidm=ziold(ii)
                  do is=1,nspec
                     qqu(is)=qu(is,ii)
                     qqm(is)=qm(is,ii)
                  enddo
                  dzui=1.0/(zlidu-zlidm)
                  dzmi=1.0/zlidm
                  zlo=zlidu
c
c ---             Loop over split puffs/slugs
                  do i=1,nsplit
c
c ---                Set puff/slug index (jj)
                     jj=npuffs+i-1
                     if(jj.EQ.npuffs) jj=ii
c
c ---                Set top and bottom of puff/slug slice
                     zhi=zlo
                     zlo=0.0
                     if(i.LT.nsplit) zlo=zhi*0.5
c
c --------------------------------------------
c ---                Set/revise puff/slug data
c --------------------------------------------
c
                     if(zlo.GE.zlidm) then
c ---                   Slice is from upper layer of original puff
                        dqfac=(zhi-zlo)*dzui
                        do is=1,nspec
                           qu(is,jj)=qqu(is)*dqfac
                           qm(is,jj)=0.0
                        enddo
                        zimax(jj)=zhi
                        ziold(jj)=zlo
c
                     elseif(zhi.LE.zlidm) then
c ---                   Slice is from lower layer of original puff
                        dqfac=(zhi-zlo)*dzmi
                        if(zlo.GT.0.0) then
                           do is=1,nspec
                              qu(is,jj)=qqm(is)*dqfac
                              qm(is,jj)=0.0
                           enddo
                           zimax(jj)=zhi
                           ziold(jj)=zlo
                        else
                           do is=1,nspec
                              qu(is,jj)=0.0
                              qm(is,jj)=qqm(is)*dqfac
                           enddo
c ---                      Change code from 6(16) to 2(12)
                           ipufcd(jj)=ipufcd(jj)-4
                           zimax(jj)=zhi
                           ziold(jj)=zhi
                        endif
c
                     elseif(zlo.EQ.0.0) then
c ---                   Lower layer is identical to lower layer of
c ---                   original puff, and upper layer is drawn from
c ---                   slice of upper layer of original puff
                        dqfac=(zhi-zlidm)*dzui
                        do is=1,nspec
                           qu(is,jj)=qqu(is)*dqfac
                        enddo
                        zimax(jj)=zhi
                        ziold(jj)=zlidm
c
                     else
c ---                   Slice straddles upper and lower layers of
c ---                   original puff
                        dqfacu=(zhi-zlidm)*dzui
                        dqfacm=(zlidm-zlo)*dzmi
                        do is=1,nspec
                           qu(is,jj)=qqu(is)*dqfacu+qqm(is)*dqfacm
                           qm(is,jj)=0.0
                        enddo
                        zimax(jj)=zhi
                        ziold(jj)=zlo
                     endif
c *******
      if(ldbhr) then
         write(io6,*) 'SPLIT --- changed values for puff ',jj
         write(io6,*) ' isplit,ipufcd,ziold,zimax = '
         write(io6,*) isplit(jj),ipufcd(jj),ziold(jj),zimax(jj)
         write(io6,*) 'q-upper = ',(qu(is,jj),is=1,nspec)
         write(io6,*) 'q-lower = ',(qm(is,jj),is=1,nspec)
      endif
c *******
                  enddo
c
c ---             Update total number of puffs
                  npuffs=npuffs+nsplit-1
c ---             Update number of old puffs that are split
                  numspltz=numspltz+1
c
               endif
            endif
         endif
       endif
      enddo
c
      return
      end
c----------------------------------------------------------------------
      subroutine initpuf(ndhrb,nsecb,ndhre,nsece,nspec,dt,smxi,ldb,
     &                   em2dat,em4dat,em3dat,em5dat,em5grp,
     &                   metfm,newpuf)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                INITPUF
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Invoke routines that initialize newly released
c               puff/slug variables from each source
c
c --- UPDATE
c --- V6.22-V6.26   080430  (DGS): Add time period to POINTS1 call for
c                                  RISE.DAT numerical rise output option
c --- V6.101-V6.22  070921  (DGS): Enforce MXMETSAV=2 (line source
c                                  tables are currently available only
c                                  for current and previous met period)
c                   070921  (DGS): Fix bug in LN2SWAP argument list
c                                  that reversed the input and output
c                                  index pointers (created problem only
c                                  for variable line sources with more
c                                  than 1 emission step per model step)
c                   070921  (DGS): Fix bug in RDEM2 argument list that
c                                  used the undefined variable NSRC2
c                                  instead of NPT2.
c --- V6.1-V6.101   051020  (DGS): Assign LNEMARB times to arrays
c --- V5.71-V6.1    050915  (DGS): Use begin-time/end-time (seconds)
c                                  for variable emissions files
c                                  and allow coordinate projection
c                                  transformations
c                   050915  (DGS): Trap EOF in emissions files
c --- V5.4-V5.71    030528  (DGS): Add MBCON=2 option for BCON file
c                   030528  (DGS): Require non-negative emissions from
c                                  variable emissions files
c --- V5.4-V5.4     000602_6(DGS): Fix call to RDEM3 (data records for
c                                  BAEMARB.DAT files) to use the file
c                                  unit number 'io' instead of 'io17',
c                                  which was removed in CALPUFF 5.4,
c                                  Level 000602.  File unit io17
c                                  (which is zero because it is not
c                                  defined) is not open so the call to
c                                  RDEM3 generates a runtime error
c                                  which halts the run.  This affects
c                                  previous CALPUFF versions starting
c                                  with version 5.4.
c --- V5.3-V5.4     000602  (DGS): relace VOLEM.DAT with VOLEMARB.DAT
c                   000602  (DGS): allow multiple PTEMARB, BAEMARB, and
c                                  VOLEMARB files
c                   000602  (DGS): add message to "stop"
c --- V5.2-V5.3     991222  (DGS): add Boundary Condition (BC) sources
c --- V5.0-V5.0     980807  (DGS): generalize VOLEM.DAT format
c                   980807  (DGS): pass METFM to subs
c                   980430  (DGS): correct BAEMARB emissions
c --- V4.0-V5.0     971107  (DGS): add LNEMARB.DAT data and subroutines
c                   971107  (DGS): remove volume flux from PT2 input
c                                  processing
c                   971107  (DGS): replace heat flux with effective rise
c                                  velocity and diameter in AR2 input
c                   971107  (DGS): add surface elevation to AR2 input
c                   971107  (DGS): add initial sigma-z to AR2 input
c                   971107  (DGS): re-order vertex array elements
c
c --- INPUTS:
c         NDHRB - integer - Julian day, hour beginning current step
c         NSECB - integer - Seconds at beginning of current step
c         NDHRE - integer - Julian day, hour at end of current step
c         NSECE - integer - Seconds at end of current step
c         NSPEC - integer - Number of species modeled
c          SMXI - real    - Reciprocal of speed required to travel
c                           max allowed distance in 1 timestep (s/m)
c            DT - real    - Length (seconds) of a basic time step
c           LDB - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c    EM2DAT(nse2+4,npt2) - real array - Time-varying PTEMARB source
c                                        data
c    EM4DAT(nse4+6,nvl2) - real array - Time-varying VOLEMARB source
c                                        data
c   EM3DAT(nse3+14,nar2) - real array - Time-varying BAEMARB source
c                                        data
c    EM5DAT(nse5+6,nln2) - real array - Time-varying LNEMARB source
c                                        data for lines
c      EM5GRP(7,mxlngrp) - real array - Time-varying LNEMARB source
c                                        data for groups of lines
c         METFM - integer - Meteorological data format
c
c     Common block /AR1/ variables:
c           NAR1
c     Common block /AR2/ variables:
c           NAR2, NSE3, IBSRC3(mxemdat), IESRC3(mxemdat),
c           pmapar2(mxemdat),utmhemar2(mxemdat),datumar2(mxemdat),
c           lutmar2(mxemdat),llccar2(mxemdat),lpsar2(mxemdat),
c           lemar2(mxemdat),llazaar2(mxemdat),lttmar2(mxemdat),
c           iutmznar2(mxemdat),feastar2(mxemdat),fnorthar2(mxemdat),
c           rnlat0ar2(mxemdat),relon0ar2(mxemdat),
c           rnlat1ar2(mxemdat),rnlat2ar2(mxemdat),
c           NSTEP3(mxemdat),T2BTZ3(mxemdat)
c     Common block /BCS/ variables:
c           NBC
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW
c     Common block /DATASET/ variables:
c           verparb(mxemdat),veraarb(mxemdat),
c           verlarb,vervarb(mxemdat),
c           verbcon
c     Common block /FILNAM/ variables:
c           NPTDAT, NARDAT, NVOLDAT,
c           PTDAT, ARDAT, VOLDAT
c     Common block /FLAGS/ variables:
c           MSLUG, MBCON
c     Common block /GRID/ variables:
c           DGRID, DGRIDI, XORIG
c     Common block /LN1/ variables:
c           NLINES
c     Common block /LN2/ variables:
c           NLN2, NSE5, IBEG5, IEND5
c     Common block /PUFF/ variables:
c           NPUFFS
c     Common block /PT1/ variables:
c           NPT1
c     Common block /PT2/ variables:
c           MFPT2, NPT2, NSE2, IBEG2, IEND2
c     Common block /VOL1/ variables:
c           NVL1
c     Common block /VOL2/ variables:
c           NVL2, NSE4, IBEG4, IEND4, MFVL2
c     Parameters:
c           MXPT1, MXPT2, MXLINES, MXLNGRP, MXMETSAV,
c           MXAREA, MXVOL, MXEMDAT, MXVERT, MXQSTEP,
c           IO6, IOPT2, IOAR2, IOVOL
c
c --- OUTPUT:
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c     Common block /AR2/ variables:
c            xar2grd(mxvertp1,mxarea),yar2grd(mxvertp1,mxarea),
c            area2(mxarea),refar2(mxarea),htar2(mxarea),tkar2(mxarea),
c            qhfar2(mxarea),qar2(mxspec,mxarea),
c            NSTEP3(mxemdat),
c            NDHRQB3(mxqstep,mxemdat),NSECQB3(mxqstep,mxemdat),
c            NDHRQE3(mxqstep,mxemdat),NSECQE3(mxqstep,mxemdat)
c
c
c --- INITPUF called by:  COMP
c --- INITPUF calls:      POINTS1,  RDEM2, POINTS2,
c                         LINES1 ,  RDEM5, LN2FILL, LN2SWAP, LINES2,
c                         AREAS1 ,  RDEM3,  AREAS2,
c                         VOLS   ,  RDEM4, 
c                         BCS1   , RDEMBC, RDEMBC2,
c                         TPERIOD, GLOBE1,   GLOBE
c----------------------------------------------------------------------
c
      include 'params.puf'

c --- Set number of variables before emissions in 'EMARB' arrays
c --- as parameters
      parameter(nvarpt=4, nvarba=14, nvarln=6, nvarvl=6)
c
      include 'ar1.puf'
      include 'ar2.puf'
      include 'bcs.puf'
      include 'comparm.puf'
      include 'dataset.puf'
      include 'filnam.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'map.puf'
      include 'puff.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'vol1.puf'
      include 'vol2.puf'
c
      logical ldb,problem,lqneg
c
c --- Time-variable emission arrays (declare full dimensions here and
c --- pass as argument to subr. so that dimensions can be adjusted)
      real em2dat(nse2+nvarpt,npt2)
      real em3dat(nse3+nvarba,nar2)
      real em4dat(nse4+nvarvl,nvl2)
      real em5dat(nse5+nvarln,nln2),em5grp(7,mxlngrp)
      integer idmap(mxlines),igrp(mxlngrp)
c
c --- Fix the number of vertices (sides) of area sources at 4
      real xvert(4),yvert(4)

c --- For coordinate transformations
      character*8 cmapi,cmapo
      character*12 caction
      character*4 c4hem
      real*8 vecti(9),vecto(9)

c --- Scale factor for Tangential TM projection
      tmsone=1.00000

c --- Output of coord transform is to CALPUFF (x,y) - /MAP/
      iutmo=iutmzn
      if(utmhem.EQ.'S   ' .AND. iutmo.LT.900) iutmo=-iutmo
      cmapo=pmap
      if(cmapo.EQ.'TTM     ') cmapo='TM      '

c --- Initialize current number of puffs equal to the number of
c --- old puffs, and set the number of new puffs to zero;
c --- both of these will be updated within subsequent calls
      np=npuffs
      newpuf=0
c
c --- MFACT is 0 (puffs released) or 10 (slugs released)
      mfact=10*mslug
c
c --- Set logical for detecting problem with sources
      problem=.FALSE.
c
c*****
      if(ldb)then
         write(io6,11)mfact,smxi
11       format(/1x,'LDB output from SUBR. INITPUF'/5x,'MFACT: ',i2,
     1   2x,'SMXI: ',f10.5)
      endif
c*****

c --- Enforce MXMETSAV=2 (set in parameter file) regardless of source
c --- types in current run
      if(mxmetsav.NE.2) then
        write(io6,*)
        write(io6,*)'ERROR -- MXMETSAV must be set to 2 in PARAMS.PUF'
        write(io6,*)
        stop 'Halted in INITPUF -- See list file'
      endif
c
c ---------------------------------------------------
c --- Loop over point sources with CONSTANT emissions
c ---------------------------------------------------
      if(npt1.gt.0) then
         do i=1,npt1
            call POINTS1(i,nspec,ndhrb,nsecb,ndhre,nsece,
     &                   dt,smxi,ldb,mfact,metfm,np,
     &                   newpuf,problem)
         enddo
      endif
c
c ---------------------------------------------------
c --- Loop over point sources with VARIABLE emissions
c ---------------------------------------------------
      if(npt2.gt.0) then
c ---    Update variable emissions from PTEMARB files
c ---    Loop over files to check/update all sources
         do ip=1,nptdat

c ---      File unit number
           io=iopt2+ip-1

c ---      Check if last emission period used in previous step extends
c ---      into current timestep (beginning of step < end of q-period)
           iq=nstep2(ip)
           call TPERIOD(-1,ndhrb,nsecb,ndhrqb2(iq,ip),nsecqb2(iq,ip),
     1                  ndhrqe2(iq,ip),nsecqe2(iq,ip),ilocate)
           if(ilocate.EQ.0) then
c ---         Reset emissions data arrays so that last emission period
c ---         of previous step is first period of current step
              if(iq.GT.1) then
                 ndhrqb2(1,ip)=ndhrqb2(iq,ip)
                 nsecqb2(1,ip)=nsecqb2(iq,ip)
                 ndhrqe2(1,ip)=ndhrqe2(iq,ip)
                 nsecqe2(1,ip)=nsecqe2(iq,ip)
                 do i=ibsrc2(ip),iesrc2(ip)
                    tstak2(1,i)=tstak2(iq,i)
                    exitw2(1,i)=exitw2(iq,i)
                    do is=1,nse2
                       qstak2(ixrem2(is),1,i)=qstak2(ixrem2(is),iq,i)
                    enddo
                 enddo
                 nstep2(ip)=1
              endif
           elseif(ilocate.EQ.1) then
c ---         First set of emissions data this step must be read in
              nstep2(ip)=0
           else
              write(io6,*)
              write(io6,*)'ERROR -- PTEMARB begin time exceeds current',
     1                    ' start time'
              write(io6,*)'      -- current begin time :',ndhrb,nsecb
              write(io6,*)'      -- PTEMARB begin time :',
     1                                   ndhrqb2(iq,ip),nsecqb2(iq,ip)
              stop
           endif

c ---      Are new emissions data needed?
           if(nstep2(ip).EQ.0) then
              ilocate=1
           else
              call TPERIOD(1,ndhre,nsece,ndhrqb2(1,ip),nsecqb2(1,ip),
     1                     ndhrqe2(1,ip),nsecqe2(1,ip),ilocate)
           endif

c ---      Read new emissions data if needed
           if(ilocate.EQ.1) then
211           continue
              call RDEM2(io,mfpt2,npt2,nse2,cid2,ibsrc2(ip),
     &                   iesrc2(ip),verparb(ip),t2btz2(ip),ldb,
     &                   io6,ibegh,ibegs,iendh,iends,em2dat,ieof)
              if(ieof.EQ.1) then
                 write(io6,*)
                 write(io6,*)'EOF in PTEMARB.DAT file ',ip
                 write(io6,*)'Halted at current end time :',ndhre,nsece
                 write(*,*)'EOF in PTEMARB.DAT file ',ip
                 write(*,*)'Halted at current end time :',ndhre,nsece
                 stop
              endif
c ---         Test emissions period relative to beginning of timestep
              call TPERIOD(-1,ndhrb,nsecb,ibegh,ibegs,iendh,iends,iloc)
c ---         Keep reading if emission period ends before start of step
              if(iloc.EQ.1) goto 211
c ---         Test period relative to end of timestep
              call TPERIOD(1,ndhre,nsece,ibegh,ibegs,iendh,iends,iloc)
              if(iloc.EQ.-1)then
                 write(io6,*)
                 write(io6,*)'ERROR: PTEMARB begin time later than ',
     1                       'end of timestep'
                 write(io6,*)'   -- current end time   :',ndhre,nsece
                 write(io6,*)'   -- PTEMARB start time :',ibegh,ibegs
                 stop 'Halted in INITPUF -- see list file'
              endif
c ---         Swap variable emissions data (em2dat) into /PT2/ arrays
              nstep2(ip)=nstep2(ip)+1
              iq=nstep2(ip)
              if(iq.GT.mxqstep) then
                 write(io6,*)'ERROR: PTEMARB has too many periods ',
     1                       'in the current timestep'
                 write(io6,*)'   -- current end time   :',ndhre,nsece
                 write(io6,*)'   -- PTEMARB start time :',ibegh,ibegs
                 write(io6,*)'   -- Max allowed (MXQSTEP) ',mxqstep
                 stop 'Halted in INITPUF -- see list file'
              endif
              ndhrqb2(iq,ip)=ibegh
              nsecqb2(iq,ip)=ibegs
              ndhrqe2(iq,ip)=iendh
              nsecqe2(iq,ip)=iends
c ---         Loop over sources
              do i=ibsrc2(ip),iesrc2(ip)
                 tstak2(iq,i)=em2dat(1,i)
                 exitw2(iq,i)=em2dat(2,i)
                 syipt2(iq,i)=em2dat(3,i)
                 szipt2(iq,i)=em2dat(4,i)
                 lqneg=.FALSE.
                 do is=1,nse2
                    k=is+nvarpt
                    qstak2(ixrem2(is),iq,i)=em2dat(k,i)
                    if(qstak2(ixrem2(is),iq,i).LT.0.0) lqneg=.TRUE.
                 enddo
c ---            Report problem if any emissions are negative
                 if(lqneg) then
                    write(io6,*)
                    write(io6,*)'*********  FATAL  ***********'
                    write(io6,*)'ERROR in subr. INITPUF -- Invalid ',
     1              'emission rate  (must NOT be negative)'
                    write(io6,*)' -- PTEMARB Source = ',i
                    problem=.TRUE.
                 endif
              enddo

c ---         Get another period of emissions data if the end of the
c ---         timestep is not within the period just read
              if(iloc.EQ.1) goto 211
           endif

           do i=ibsrc2(ip),iesrc2(ip)
              call POINTS2(ip,i,nspec,ndhrb,nsecb,ndhre,nsece,dt,
     &                     smxi,ldb,mfact,metfm,np,newpuf,problem)
           enddo

         enddo
      endif
c
c
c ------------------------------------------------------------
c --- Loop over polygon area sources with CONSTANT emissions
c ------------------------------------------------------------
      if(nar1.gt.0) then
         do i=1,nar1
            call AREAS1(i,nspec,dt,smxi,ldb,mfact,np,
     &                  newpuf,problem)
         enddo
      endif
c ----------------------------------------------------------
c --- Loop over polygon area sources with VARIABLE emissions
c ----------------------------------------------------------
      if(nar2.gt.0) then
c ---    Update variable emissions from BAEMARB files
c ---    Loop over files to check/update all sources
         do ia=1,nardat

c ---      File unit number
           io=ioar2+ia-1

c ---      Set up map projection conversion to CALPUFF coordinates
c ---      Input is from BAEMARB.DAT header - /AR2/
           iutmi=iutmznar2(ia)
           if(utmhemar2(ia).EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
           cmapi=pmapar2(ia)
           if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---      Set conversion vectors
           call GLOBE1(cmapi,iutmi,tmsone,rnlat1ar2(ia),rnlat2ar2(ia),
     &            rnlat0ar2(ia),relon0ar2(ia),
     &            feastar2(ia),fnorthar2(ia),
     &            cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &            feast,fnorth,
     &            caction,vecti,vecto)

c ---      Check if last emission period used in previous step extends
c ---      into current timestep (beginning of step < end of q-period)
           iq=nstep3(ia)
           call TPERIOD(-1,ndhrb,nsecb,ndhrqb3(iq,ia),nsecqb3(iq,ia),
     1                  ndhrqe3(iq,ia),nsecqe3(iq,ia),ilocate)
           if(ilocate.EQ.0) then
c ---         Reset location & emissions data arrays so that last emiss
c ---         period of previous step is first period of current step
              if(iq.GT.1) then
                 ndhrqb3(1,ia)=ndhrqb3(iq,ia)
                 nsecqb3(1,ia)=nsecqb3(iq,ia)
                 ndhrqe3(1,ia)=ndhrqe3(iq,ia)
                 nsecqe3(1,ia)=nsecqe3(iq,ia)
                 do i=ibsrc3(ia),iesrc3(ia)
                    do iv=1,nvert2(i)+1
                       xar2grd(iv,1,i)=xar2grd(iv,iq,i)
                       yar2grd(iv,1,i)=yar2grd(iv,iq,i)
                    enddo
                    area2(1,i)=area2(iq,i)
                    htar2(1,i)=htar2(iq,i)
                    elar2(1,i)=elar2(iq,i)
                    tkar2(1,i)=tkar2(iq,i)
                    wefar2(1,i)=wefar2(iq,i)
                    refar2(1,i)=refar2(iq,i)
                    sz0ar2(1,i)=sz0ar2(iq,i)
                    do is=1,nse3
                       qar2(ixrem3(is),1,i)=qar2(ixrem3(is),iq,i)
                    enddo
                 enddo
                 nstep3(ia)=1
              endif
           elseif(ilocate.EQ.1) then
c ---         First set of emissions data this step must be read in
              nstep3(ia)=0
           else
              write(io6,*)
              write(io6,*)'ERROR: BAEMARB begin time exceeds current',
     1                    ' start time'
              write(io6,*)'    -- current begin time :',ndhrb,nsecb
              write(io6,*)'    -- BAEMARB begin time :',ndhrqb3(iq,ia),
     1                     nsecqb3(iq,ia)
              stop 'Halted in INITPUF -- see list file'
           endif

c ---      Are new emissions data needed?
           if(nstep3(ia).EQ.0) then
              ilocate=1
           else
              call TPERIOD(1,ndhre,nsece,ndhrqb3(1,ia),nsecqb3(1,ia),
     1                     ndhrqe3(1,ia),nsecqe3(1,ia),ilocate)
           endif

c ---      Read new emissions data if needed
           if(ilocate.EQ.1) then
311           continue
              call RDEM3(io,nar2,nse3,cid3,ibsrc3(ia),iesrc3(ia),
     &                   veraarb(ia),t2btz3(ia),ldb,io6,ibegh,
     &                   ibegs,iendh,iends,em3dat,ieof)
              if(ieof.EQ.1) then
                 write(io6,*)
                 write(io6,*)'EOF in BAEMARB.DAT file ',ia
                 write(io6,*)'Halted at current end time :',ndhre,nsece
                 write(*,*)'EOF in BAEMARB.DAT file ',ia
                 write(*,*)'Halted at current end time :',ndhre,nsece
                 stop
              endif
c ---         Test emissions period relative to beginning of timestep
              call TPERIOD(-1,ndhrb,nsecb,ibegh,ibegs,iendh,iends,iloc)
c ---         Keep reading if emission period ends before start of step
              if(iloc.EQ.1) goto 311
c ---         Test period relative to end of timestep
              call TPERIOD(1,ndhre,nsece,ibegh,ibegs,iendh,iends,iloc)
              if(iloc.EQ.-1)then
                 write(io6,*)
                 write(io6,*)'ERROR: BAEMARB begin time later than ',
     1                       'end of timestep'
                 write(io6,*)'   -- current end time   :',ndhre,nsece
                 write(io6,*)'   -- BAEMARB start time :',ibegh,ibegs
                 stop 'Halted in INITPUF -- see list file'
              endif
c ---         Swap variable emissions data (em3dat) into /ar2/ arrays
              nstep3(ia)=nstep3(ia)+1
              iq=nstep3(ia)
              if(iq.GT.mxqstep) then
                 write(io6,*)'ERROR: BAEMARB has too many periods ',
     1                       'in the current timestep'
                 write(io6,*)'   -- current end time   :',ndhre,nsece
                 write(io6,*)'   -- BAEMARB start time :',ibegh,ibegs
                 write(io6,*)'   -- Max allowed (MXQSTEP) ',mxqstep
                 stop 'Halted in INITPUF -- see list file'
              endif
              ndhrqb3(iq,ia)=ibegh
              nsecqb3(iq,ia)=ibegs
              ndhrqe3(iq,ia)=iendh
              nsecqe3(iq,ia)=iends
c ---         Loop over sources
              do i=ibsrc3(ia),iesrc3(ia)
c
c ---            Compute & store relative vertex coordinates; accumulate
c ---            sums for computing the mean location of the area source
                 sumx=0.
                 sumy=0.
c ---            Explicitly allow ONLY 4-sided shapes!
                 nvert2(i)=4
                 do iv=1,nvert2(i)
                    xvert3=em3dat(iv,i)
                    yvert3=em3dat(iv+nvert2(i),i)
                    call GLOBE(io6,caction,datumar2(ia),vecti,datum,
     &                         vecto,xvert3,yvert3,xvert(iv),yvert(iv),
     &                         izone,c4hem)
                    xar2grd(iv,iq,i)=(1000.*xvert(iv)-xorig)*dgridi
                    yar2grd(iv,iq,i)=(1000.*yvert(iv)-yorig)*dgridi
                    sumx=sumx+xar2grd(iv,iq,i)
                    sumy=sumy+yar2grd(iv,iq,i)
                 enddo
c ---            Mean location of source
                 xar2grd(nvert2(i)+1,iq,i)=sumx/FLOAT(nvert2(i))
                 yar2grd(nvert2(i)+1,iq,i)=sumy/FLOAT(nvert2(i))
 
c ---            Area of 4-sided area source in m^2
                 call quadarea(xvert,yvert,area2(iq,i))
c
c ---            Height, surface elevation (m)
                 htar2(iq,i)=em3dat(9,i)
                 elar2(iq,i)=em3dat(10,i)

c ---            Effective temperature (K), velocity (m/s) and radius (m)
c ---            for rise calculation
                 tkar2(iq,i)=em3dat(11,i)
                 wefar2(iq,i)=em3dat(12,i)
                 refar2(iq,i)=em3dat(13,i)

c ---            Initial sigma-z (m)
                 sz0ar2(iq,i)=em3dat(14,i)

c ---            Emissions (g/s)
                 if(baemunit(i).EQ.'g/s') then
                    fqunit=1.00
                 elseif(baemunit(i).EQ.'g/m2/s') then
                    fqunit=area2(iq,i)
                 else
                    write(io6,*)
                    write(io6,*)
     &                    'ERROR -- Invalid units in BAEMARB.DAT'
                    write(io6,*)'      -- Expected g/s or g/m2/s'
                    write(io6,*)'      -- Found: ',baemunit(i)
                    write(*,*)
                    stop 'Halted in INITPUF -- see list file.'
                 endif
                 lqneg=.FALSE.
                 do is=1,nse3
                    k=is+nvarba
                    qar2(ixrem3(is),iq,i)=em3dat(k,i)*fqunit
                    if(qar2(ixrem3(is),iq,i).LT.0.0) lqneg=.TRUE.
                 enddo
c ---            Report problem if any emissions are negative
                 if(lqneg) then
                    write(io6,*)
                    write(io6,*)'ERROR in subr. INITPUF -- Invalid ',
     1              'emission rate  (must NOT be negative)'
                    write(io6,*)' -- BAEMARB Source = ',i
                    problem=.TRUE.
                 endif
              enddo

c ---         Get another period of emissions data if the end of the
c ---         timestep is not within the period just read
              if(iloc.EQ.1) goto 311
           endif

           do i=ibsrc3(ia),iesrc3(ia)
              call AREAS2(ia,i,nspec,ndhrb,nsecb,ndhre,nsece,dt,smxi,
     &                    ldb,mfact,metfm,np,newpuf,problem)
           enddo

         enddo

      endif
c
c ------------------------------------------------------------
c --- Loop over volume sources with CONSTANT emissions
c ------------------------------------------------------------
      if(nvl1.gt.0) then
         mvolume=1
         iv=1
         do i=1,nvl1
            call VOLS(mvolume,iv,i,nspec,ndhrb,nsecb,ndhre,nsece,
     &                dt,smxi,ldb,mfact,np,newpuf,problem)
         enddo
      endif
c
c ------------------------------------------------------------
c --- Loop over volume sources with VARIABLE emissions
c ------------------------------------------------------------
c
      if(nvl2.gt.0) then
         mvolume=2
c ---    Update variable emissions from VOLEMARB files
c ---    Loop over files to check/update all sources
         do iv=1,nvoldat

c ---      File unit number
           io=iovol+iv-1

c ---      Set up map projection conversion to CALPUFF coordinates
c ---      Input is from VOLEMARB.DAT header - /VOL2/
           iutmi=iutmznvl2(iv)
           if(utmhemvl2(iv).EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
           cmapi=pmapvl2(iv)
           if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---      Set conversion vectors
           call GLOBE1(cmapi,iutmi,tmsone,rnlat1vl2(iv),rnlat2vl2(iv),
     &            rnlat0vl2(iv),relon0vl2(iv),
     &            feastvl2(iv),fnorthvl2(iv),
     &            cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &            feast,fnorth,
     &            caction,vecti,vecto)

c ---      Check if last emission period used in previous step extends
c ---      into current timestep (beginning of step < end of q-period)
           iq=nstep4(iv)
           call TPERIOD(-1,ndhrb,nsecb,ndhrqb4(iq,iv),nsecqb4(iq,iv),
     1                  ndhrqe4(iq,iv),nsecqe4(iq,iv),ilocate)
           if(ilocate.EQ.0) then
c ---         Reset location & emissions data arrays so that last emiss
c ---         period of previous step is first period of current step
              if(iq.GT.1) then
                 ndhrqb4(1,iv)=ndhrqb4(iq,iv)
                 nsecqb4(1,iv)=nsecqb4(iq,iv)
                 ndhrqe4(1,iv)=ndhrqe4(iq,iv)
                 nsecqe4(1,iv)=nsecqe4(iq,iv)
                 do i=ibsrc4(iv),iesrc4(iv)
                    xvl2grd(1,i)=xvl2grd(iq,i)
                    yvl2grd(1,i)=yvl2grd(iq,i)
                    htvl2(1,i)=htvl2(iq,i)
                    elvl2(1,i)=elvl2(iq,i)
                    sy0vl2(1,i)=sy0vl2(iq,i)
                    sz0vl2(1,i)=sz0vl2(iq,i)
                    do is=1,nse4
                      qvl2(ixrem4(is),1,i)=qvl2(ixrem4(is),iq,i)
                    enddo
                 enddo
                 nstep4(iv)=1
              endif
           elseif(ilocate.EQ.1) then
c ---         First set of emissions data this step must be read in
              nstep4(iv)=0
           else
              write(io6,*)
              write(io6,*)'ERROR: VOLEMARB begin time exceeds current',
     1                    ' start time'
              write(io6,*)'   -- current begin time  :',ndhrb,nsecb
              write(io6,*)'   -- VOLEMARB begin time :',ndhrqb4(iq,iv),
     1                     nsecqb4(iq,iv)
              stop 'Halted in INITPUF -- see list file'
           endif

c ---      Are new emissions data needed?
           if(nstep4(iv).EQ.0) then
              ilocate=1
           else
              call TPERIOD(1,ndhre,nsece,ndhrqb4(1,iv),nsecqb4(1,iv),
     1                     ndhrqe4(1,iv),nsecqe4(1,iv),ilocate)
           endif

c ---      Read new emissions data if needed
           if(ilocate.EQ.1) then
411           continue
              call RDEM4(io,nvl2,nse4,cid4,ibsrc4(iv),iesrc4(iv),
     &                   vervarb(iv),t2btz4(iv),ldb,io6,ibegh,
     &                   ibegs,iendh,iends,em4dat,ieof)
              if(ieof.EQ.1) then
                 write(io6,*)
                 write(io6,*)'EOF in VOLEMARB.DAT file ',iv
                 write(io6,*)'Halted at current end time :',ndhre,nsece
                 write(*,*)'EOF in VOLEMARB.DAT file ',iv
                 write(*,*)'Halted at current end time :',ndhre,nsece
                 stop
              endif
c ---         Test emissions period relative to beginning of timestep
              call TPERIOD(-1,ndhrb,nsecb,ibegh,ibegs,iendh,iends,iloc)
c ---         Keep reading if emission period ends before start of step
              if(iloc.EQ.1) goto 411
c ---         Test period relative to end of timestep
              call TPERIOD(1,ndhre,nsece,ibegh,ibegs,iendh,iends,iloc)
              if(iloc.EQ.-1)then
                 write(io6,*)
                 write(io6,*)'ERROR: VOLEMARB begin time later than ',
     1                       'end of timestep'
                 write(io6,*)'   -- current end time   :',ndhre,nsece
                 write(io6,*)'   -- VOLEMARB start time :',ibegh,ibegs
                 stop 'Halted in INITPUF -- see list file'
              endif
c ---         Swap variable emissions data (em4dat) into /VOL2/ arrays
              nstep4(iv)=nstep4(iv)+1
              iq=nstep4(iv)
              if(iq.GT.mxqstep) then
                 write(io6,*)'ERROR: VOLEMARB has too many periods ',
     1                       'in the current timestep'
                 write(io6,*)'   -- current end time    :',ndhre,nsece
                 write(io6,*)'   -- VOLEMARB start time :',ibegh,ibegs
                 write(io6,*)'   -- Max allowed (MXQSTEP) ',mxqstep
                 stop 'Halted in INITPUF -- see list file'
              endif
              ndhrqb4(iq,iv)=ibegh
              nsecqb4(iq,iv)=ibegs
              ndhrqe4(iq,iv)=iendh
              nsecqe4(iq,iv)=iends
c ---         Loop over sources
              do i=ibsrc4(iv),iesrc4(iv)
c---             Apply projection/datum translation to position
                 call GLOBE(io6,caction,datumvl2(iv),vecti,datum,
     &                      vecto,em4dat(1,i),em4dat(2,i),xvl2,yvl2,
     &                      izone,c4hem)
c ---            Compute relative grid coordinates
                 xvl2grd(iq,i)=(1000.*xvl2-xorig)*dgridi
                 yvl2grd(iq,i)=(1000.*yvl2-yorig)*dgridi
                 htvl2(iq,i)=em4dat(3,i)
                 elvl2(iq,i)=em4dat(4,i)
                 sy0vl2(iq,i)=em4dat(5,i)
                 sz0vl2(iq,i)=em4dat(6,i)
                 lqneg=.FALSE.
                 do is=1,nse4
                    k=is+nvarvl
                    qvl2(ixrem4(is),iq,i)=em4dat(k,i)
                    if(qvl2(ixrem4(is),iq,i).LT.0.0) lqneg=.TRUE.
                 enddo
c ---            Report problem if any emissions are negative
                 if(lqneg) then
                    write(io6,*)
                    write(io6,*)'ERROR in subr. INITPUF -- Invalid ',
     1              'emission rate  (must NOT be negative)'
                    write(io6,*)' -- VOLEMARB Source = ',i
                    problem=.TRUE.
                 endif
              enddo

c ---         Get another period of emissions data if the end of the
c ---         timestep is not within the period just read
              if(iloc.EQ.1) goto 411
            endif

            do i=ibsrc4(iv),iesrc4(iv)
               call VOLS(mvolume,iv,i,nspec,ndhrb,nsecb,ndhre,nsece,
     &                   dt,smxi,ldb,mfact,np,newpuf,problem)
            enddo

         enddo
      endif
c
c --------------------------------------------------------------
c --- Process 1 group of line sources with CONSTANT emissions
c --------------------------------------------------------------
      if(nlines.gt.0) then
         call LINES1(nspec,dt,smxi,ldb,mfact,metfm,np,
     &               newpuf,problem)
      endif
c
c --------------------------------------------------------------------
c --- Process multiple groups of line sources with VARIABLE parameters
c --------------------------------------------------------------------
c
      if(nln2.gt.0) then

c ---    Set up map projection conversion to CALPUFF coordinates
c ---    Input is from LNEMARB.DAT header - /LN2/
         iutmi=iutmznln2
         if(utmhemln2.EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
         cmapi=pmapln2
         if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---    Set conversion vectors
         call GLOBE1(cmapi,iutmi,tmsone,rnlat1ln2,rnlat2ln2,
     &          rnlat0ln2,relon0ln2,
     &          feastln2,fnorthln2,
     &          cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &          feast,fnorth,
     &          caction,vecti,vecto)

c ---    Check if last emission period used in previous step extends
c ---    into current timestep (beginning of step < end of q-period)
         iq=nstep5
         call TPERIOD(-1,ndhrb,nsecb,ndhrqb5(iq),nsecqb5(iq),
     1                ndhrqe5(iq),nsecqe5(iq),ilocate)
         if(ilocate.EQ.0) then
c ---       Reset location & emissions data arrays so that last emiss
c ---       period of previous step is first period of current step
            if(iq.GT.1) then
               call LN2SWAP(nspec,iq,1)
               nstep5=1
            endif
         elseif(ilocate.EQ.1) then
c ---       First set of emissions data this step must be read in
            nstep5=0
         else
            write(io6,*)
            write(io6,*)'ERROR: LNEMARB begin time exceeds current',
     1                  ' start time'
            write(io6,*)'   -- current begin time :',ndhrb,nsecb
            write(io6,*)'   -- LNEMARB begin time :',ndhrqb5(iq),
     1                   nsecqb5(iq)
            stop 'Halted in INITPUF -- see list file'
         endif

c ---    Are new emissions data needed?
         if(nstep5.EQ.0) then
            ilocate=1
         else
            call TPERIOD(1,ndhre,nsece,ndhrqb5(1),nsecqb5(1),
     1                   ndhrqe5(1),nsecqe5(1),ilocate)
         endif

c ---    Read new emissions data if needed
         if(ilocate.EQ.1) then
511         continue
            call RDEM5(io19,mxlngrp,nln2,nse5,cid5,verlarb,t2btz5,
     &                 ldb,io6,ibegh,ibegs,iendh,iends,lngrp,idmap,
     &                 em5dat,em5grp,ieof)
            if(ieof.EQ.1) then
               write(io6,*)
               write(io6,*)'EOF in LNEMARB.DAT file '
               write(io6,*)'Halted at current end time :',ndhre,nsece
               write(*,*)'EOF in LNEMARB.DAT file '
               write(*,*)'Halted at current end time :',ndhre,nsece
               stop
            endif
c ---       Test emissions period relative to beginning of timestep
            call TPERIOD(-1,ndhrb,nsecb,ibegh,ibegs,iendh,iends,iloc)
c ---       Keep reading if emission period ends before start of step
            if(iloc.EQ.1) goto 511
c ---       Test period relative to end of timestep
            call TPERIOD(1,ndhre,nsece,ibegh,ibegs,iendh,iends,iloc)
            if(iloc.EQ.-1)then
               write(io6,*)
               write(io6,*)'ERROR: LNEMARB begin time later than ',
     1                     'end of timestep'
               write(io6,*)'   -- current end time   :',ndhre,nsece
               write(io6,*)'   -- LNEMARB start time :',ibegh,ibegs
               stop 'Halted in INITPUF -- see list file'
            endif

c---        Apply projection/datum translation to positions
            iline=0
            do ig=1,lngrp
               do il=1,em5grp(1,ig)
                  iline=iline+1
                  x1=em5dat(1,iline)
                  y1=em5dat(2,iline)
                  x2=em5dat(3,iline)
                  y2=em5dat(4,iline)
                  call GLOBE(io6,caction,datumln2,vecti,datum,
     &                 vecto,x1,y1,em5dat(1,iline),em5dat(2,iline),
     &                 izone,c4hem)
                  call GLOBE(io6,caction,datumln2,vecti,datum,
     &                 vecto,x2,y2,em5dat(3,iline),em5dat(4,iline),
     &                 izone,c4hem)
               enddo
            enddo

c ---       Swap variable emissions data (em5grp,em5dat) into /ln2/
            nstep5=nstep5+1
            iq=nstep5
            if(iq.GT.mxqstep) then
               write(io6,*)'ERROR: LNEMARB has too many periods ',
     1                     'in the current timestep'
               write(io6,*)'   -- current end time   :',ndhre,nsece
               write(io6,*)'   -- LNEMARB start time :',ibegh,ibegs
               write(io6,*)'   -- Max allowed (MXQSTEP) ',mxqstep
               stop 'Halted in INITPUF -- see list file'
            endif
            call LN2FILL(iq,lngrp,nln2,idmap,em5grp,em5dat,nvarln,
     &                   problem)
c ---       Assign start/end times for this step
            ndhrqb5(iq)=ibegh
            nsecqb5(iq)=ibegs
            ndhrqe5(iq)=iendh
            nsecqe5(iq)=iends

c ---       Get another period of emissions data if the end of the
c ---       timestep is not within the period just read
            if(iloc.EQ.1) goto 511
         endif

c ---    Initialize number of new puffs from line sources this timestep
         do i=1,nln2
            newln2(i)=0
         enddo

c ---    Identify current line source groups
c ---    Initialize marker for groups to 0
         do k=1,mxlngrp
            igrp(k)=0
         enddo
c ---    Loop over emission periods within this timestep
         do it=1,nstep5
c ---       Loop over lines to identify groups used
            do i=1,nlines2(it)
               k=ilngrp(idline(it,i))
               igrp(k)=1
            enddo
         enddo
c ---    Process active groups
         do ig=1,mxlngrp
            if(igrp(ig).EQ.1) call LINES2(ig,nspec,ndhrb,nsecb,
     &                  ndhre,nsece,dt,smxi,ldb,mfact,metfm,
     &                  np,newpuf,problem)
         enddo
      endif
c
c ----------------------------------------------------------------
c --- Loop over all boundary condition sources (1-hour steps)
c ----------------------------------------------------------------
      if(nbc.gt.0) then
         if(ntypebc2.GT.0) then
c ---       Check if it is time to update variable concentrations
            if(ndhre.lt.ibegbc)then
               write(io6,*)
               write(io6,*)'ERROR -- BCON date/time exceeds current'
               write(io6,*)'      -- current date/time :',ndhre
               write(io6,*)'      -- BCON date/time    :',ibegbc
               write(*,*)
               problem=.true.
            else if(ndhre.gt.iendbc)then
c ---          Obtain BCON data for current model date/time
               if(mbcon.EQ.1) then
                  call RDEMBC(ldb,ndhre)
               elseif(mbcon.EQ.2) then
                  call RDEMBC2(ldb,ndhre)
               else
                 write(io6,*)
                 write(io6,*)'ERROR -- BCON option is invalid'
                 write(io6,*)'      -- expected : 1 or 2'
                 write(io6,*)'      -- MBCON    :',mbcon
                 write(*,*)
                 problem=.true.
               endif
            endif
         endif
c ---    Loop over all boundary segments and define new puffs
         do i=1,nbc
            call BCS1(i,nspec,dt,ldb,np,newpuf,problem)
         enddo
      endif
c
c
      if(PROBLEM) then
         write(*,*)
         stop 'Halted in INITPUF -- see list file.'
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine areas1(i,nspec,dthr,xtmp1,ldbhr,mfact,np,
     &                  newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                 AREAS1
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff/slug variables for
c               polygon AREA SOURCES with constant emissions.
c
c --- UPDATE
c --- V6.22-V6.261  080520  (DGS): Place rise tables in DA file
c --- V5.72-V6.22   070921  (DGS): Change J to I in debug output
c --- V5.7-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.4-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.1-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.1     990729  (DGS): enforce minimum sigma-y at source
c --- V5.0-V5.0     980918  (DGS): initial sigma-y is zero
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V5.0-V5.0     980304  (DGS): drop any new puffs if emissions = 0 
c --- V5.0-V5.0     980304  (DGS): place source sigmas in SY0,SZ0
c --- V4.0-V5.0     971107  (DGS): add variable emissions factor call
c                                  to function VEMFAC
c                   971107  (DGS): reverse arguments of vertex arrays
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c
c --- INPUTS:
c             I - integer - Area source index
c         NSPEC - real    - Number of species modeled
c          DTHR - real    - Length (seconds) of a basic time step
c         XTMP1 - real    - Reciprocal of speed required to travel max
c                           allowed distance in 1 timestep
c         LDBHR - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW, SYMIN, SZMIN, WSCALM
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MHFTSZ
c     Common block /GRID/ variables:
c           DGRID, IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /METHR/ variables:
c           PLEXP
c     Common block /METHD/ variables:
c           I2DMET
c     Common block /PUFF/ variables:
c           NPUFFS
c     Common block /AR1/ variables:
c           XAR1GRD(mxvertp1,mxarea),YAR1GRD(mxvertp1,mxarea),
c           HTAR1(mxarea),ELAR1(mxarea),SZ0AR1(mxarea),NVERT1(mxarea),
c           QAR1(mxspec,mxarea),NEWAR1(mxarea),
c           ivar1(mxspec,mxarea),iq12ar1(mxspec,mxarea)
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXSPEC, MXAREA, IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /AR1/ variables:
c           NEWAR1(mxarea)
c     Common block /PUFF/ variables:
c           all variables in common block
c     Common block /SLUG/ variables:
c           all variables in common block
c
c --- AREAS1 called by:  INITPUF
c --- AREAS1 calls:      RLSMET, ROLLDN, SYAREA, SWAP, INJECT, VEMFAC,
c                        ZEROTAB, SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'comparm.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methr.puf'
      include 'ar1.puf'
      include 'puff.puf'
      include 'slug.puf'
c frr (09/01)
      include 'methd.puf'
c
      real q(mxspec)
      logical ldbhr,problem
c
c ***
      if(ldbhr) then
         write(io6,*)
         write(io6,*) 'AREAS1:  Source Number    ',i
      endif
c ***
c
c --- Determine the met. grid point closest to the source
      ixs=1.0+xar1grd(nvert1(i)+1,i)
      iys=1.0+yar1grd(nvert1(i)+1,i)
c
c --- Source off the computational grid -- write a FATAL message
      if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.iys.lt.jbcomp.or.iys.gt.
     1   jecomp)then
         write(io6,20)i,ixs,iys
20       format(/1x,'FATAL -- an area source with constant emissions ',
     1   'is off the computational grid'/1x,'source no. (i) = ',i6,2x,
     2   'nearest grid point (ixs,iys) = (',i5,',',i5,')')
         problem=.TRUE.
         return
      endif
c
c --- Extract release height wind speed & other met. variables
      htrel=htar1(i)
      call rlsmet(ldbhr,ixs,iys,htrel,mfact,
     &            mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &            ustr,wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)
c
c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
         temp=temp2d(ixs,iys)
      elseif(i2dmet.EQ.0) then
         temp=tempss(issta)
      else
         write(*,*)'Subr. AREAS1:  Invalid I2DMET = ',i2dmet
         stop
      endif

c --- Swap emission rate for source 'i' into 1D array and scale
      qtot=0.0
      do is=1,nspec
         q(is)=qar1(is,i)*VEMFAC(ldbhr,ivar1(is,i),iq12ar1(is,i),
     &                           temp,ws,istab)
         qtot=qtot+q(is)
      enddo
c --- Return without generating new puffs if all species have zero
c --- mass in puff
      if(qtot.EQ.0.0) then
c ***
         if(ldbhr) then
            write(io6,*)
            write(io6,*) 'No emissions this step from Source ',i
            write(io6,*)
         endif
c ***
         return
      endif

c --- Initialize source tabulation specifications to zero
      call ZEROTAB
c
c --- Compute the number of puffs/slugs released this hour
c --- from this source
      npnew=ws*xtmp1+1
      npnew=max0(npnew,1)
      npnew=min0(npnew,mxnew)
      newar1(i)=npnew
      newpuf=newpuf+npnew
c --- If puff arrays are full, remove puffs that are off the grid
c --- and "roll down" arrays to make room for new puffs
c --- (this also applies to the DA file of tabulated arrays)
      if(npuffs+newpuf.gt.mxpuff) call rolldn(np)
c --- Check to see if roll-down was adequate
      if(npuffs+newpuf.gt.mxpuff)then
         write(io6,*) ' ERROR in subr. AREAS1'
         write(io6,*)'Too many puffs on grid for array dimensions -- ',
     1   'NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2   ' MXPUFF = ',mxpuff
         write(*,*)
         stop 'Halted in AREAS1 -- see list file.'
      endif
c
c --- DT is the time (sec) over which each puff is emitted
      dt=dthr/float(npnew)
c
c --- Set variance associated with buoyancy-enhanced growth @ final rise
      xf=0.0
      rise=0.0
      bidsq=0.0
c --- Set downwash flag to zero (no building downwash)
      idw=0
c --- Set final plume height
      heff=htar1(i)
c --- Set sigma y, sigma z at the source
      szsrc=amax1(szmin,sz0ar1(i))
      call SYAREA(xar1grd(1,i),yar1grd(1,i),nvert1(i),dgrid,flow,ldbhr,
     &            sysrc)
      sysrc=amax1(symin,sysrc)

c******
      if(ldbhr)then
         write(io6,204)i,ilayer,ixs,iys,ws,istab,dpbl,issta,npnew,
     1    newpuf,dt
204      format(5x,'IS: ',i5,2x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'NPNEW: ',i4,2x,'NEWPUF: ',i5/
     3    5x,'DT: ',f7.2)
c
         write(io6,210)idw,heff,rise,xf,sysrc,szsrc
210      format(5x,'IDW: ',i5,2x,'HEFF: ',f8.2,2x,'RISE : ',f8.2,2x,
     1    'XF : ',f8.2,2x,'SYSRC: ',f8.2,2x,'SZSRC: ',f8.2)
c
         write(io6,208)i,np,iru,dt,sqrts
208      format(5x,'I: ',i5,2x,'NP: ',i5,2x,
     1    'IRU: ',i2,2x,'DT: ',f7.2,2x,'SQRTS: ',f7.3)
      endif
c*****
c ----------------------------------------------------------
c ---    Initialize current hour's new puffs for this source
c ----------------------------------------------------------
         do 50 j=1,npnew
         np=np+1
c
c ---    Use SWAP to start with all puff/slug variables equal to zero
         call swap(np,0)
c
c ---    Fill non-zero values
         xpb(np)=xar1grd(nvert1(i)+1,i)
         ypb(np)=yar1grd(nvert1(i)+1,i)
         zitibl(np)=-1.0
         elbase(np)=elar1(i)
         sigyb(np)=symin
         sigzb(np)=szsrc
c ---    Final plume rise results
         zfinal(np)=heff
         zpb(np)=heff
         zpe(np)=heff
         xfinal(np)=xf
         bidfnl(np)=bidsq
         isplit(np)=1
c ---    Time-of-release data
         ht0(np)=htar1(i)
         temit0(np)=dt
         ws0(np)=ws
         istab0(np)=istab
         sqrts0(np)=sqrts
         iru0(np)=iru
         sigv0(np)=tsigv
         sigw0(np)=tsigw
         el0(np)=el
         plexp0(np)=plexp
c ---    Set vector/scalar ws ratio to 1.0
         srat0(np)=1.0
c ---    Additional time-of-release parameters needed for
c ---    receptor-specific calculations
         idw0(np)=idw
         heff20(np)=heff
         sy0(np)=sysrc
         sz0(np)=szsrc

c ---    Emission period index for this puff
         iemstep(np)=1

c ---    Set puff identity where IRLSNUM is the puff number released
c ---    from this source this time step, ISRCNUM is the source number
c ---    of type ISRCTYP from which the puff was released.
c ---    (Type =3 for const. area sources)
         irlsnum(np)=j
         isrcnum(np)=i
         isrctyp(np)=3
c
c ----------------------------------------------------------
c ---    Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---    Note that "oldest" end of slug is at the source, as is the
c ---    "newest end; oldest end moves away and grows during the step,
c ---    while newest end remains fixed in size at the source.
c
         if(mslug.EQ.1 .AND. mfact0.GT.0) then
c ---       Set coordinates of oldest end of slug (in met. grid units)
            xpe(np)=xpb(np)
            ype(np)=ypb(np)
            xtote(np)=xtotb(np)
            tmtote(np)=tmtotb(np)
c ---       Set sigmas for oldest end of slug
            sigye(np)=sigyb(np)
            sigze(np)=sigzb(np)
         endif
c
c -------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c -------------------------------------------------------------------
c ---    Set partial penetration variables to null values
         fmix=1.0
         hmax=dpbl
         call INJECT(np,nspec,dt,mfact0,q,heff,hmax,dpbl,fmix,istab)

c ------------------------------------------------------------------
c ---    Transfer NULL tabulated arrays record to DA file
c ------------------------------------------------------------------
         call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

50       continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine areas2(ia,i,nspec,ndhrb,nsecb,ndhre,nsece,dtsec,smxi1,
     &                  ldb,mfact,metfm,np,newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                 AREAS2
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff/slug variables for
c               BUOYANT polygon AREA SOURCES.
c
c --- UPDATE
c --- V6.26-V6.261  080520  (DGS): Place rise tables in DA file
c --- V6.251-V6.26  080430  (DGS): Add RISE.DAT output calls
c --- V6.25-V6.251  080421  (DGS): Make MPARTLBA an explicit switch for
c                                  the partial penetration option
c                                  (MPARTL is not used here)
c --- V6.24-V6.25   080227  (DGS): Halt run if any source is not on the
c                                  computational grid (replaces a
c                                  warning)
c --- V6.22-V6.24   080208  (DGS): Use MPARTLBA to toggle partial
c                                  penetration feature
c                   080208  (DGS): Skip getting met data at mean of 
c                                  release ht and MIN(pbl,zfinal)
c                                  when partial penetration is OFF
c                   080208  (DGS): Move SYAREA call up so that it
c                                  uses the flow at the source height
c --- V6.1-V6.22    070921  (DGS): Change J to I in debug output
c                   070921  (DGS): Replace intrinsic function AMIN0()
c                                  with MIN() when both result and
c                                  arguments are integers
c --- V5.74-V6.1    050915  (DGS): generalize treatment of time for
c                                  variable emissions files --
c                                  resolve time to seconds, and
c                                  allow variable emissions timesteps
c                           (DGS): adopt partial penetration adjustment
c --- V5.72-V5.74   040715  (DGS): add METFM=5 (AERMET)
c --- V5.7-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.4-V5.7     030402  (DGS): add MPRIME, SYSRC, SZSRC, HTR to
c                                  NUMRISE call (not used here)
c --- V5.1-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.1     990729  (DGS): enforce minimum sigma-y at source
c --- V5.0-V5.0     980918  (DGS): initial sigma-y is zero
c --- V5.0-V5.0     980807  (DGS): use final rise CALMET/PROFILE winds 
c                                  to set release step
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V5.0-V5.0     980430  (DGS): assign PROBLEM (compiler warning)
c --- V5.0-V5.0     980304  (DGS): place source sigmas in SY0,SZ0
c --- V4.0-V5.0     971107  (DGS): remove heat flux from AR2 input
c                                  processing
c                   971107  (DGS): add ground elevation and initial
c                                  sigma-z to AR2 input
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c
c --- INPUTS:
c            IA - integer - BAEMARB.DAT file index
c             I - integer - Area source index
c         NSPEC - real    - Number of species modeled
c         NDHRB - integer - Julian day, hour beginning current step
c         NSECB - integer - Seconds at beginning of current step
c         NDHRE - integer - Julian day, hour at end of current step
c         NSECE - integer - Seconds at end of current step
c         DTSEC - real    - Length (seconds) of a basic time step
c         SMXI1 - real    - Reciprocal of speed required to travel max
c                           allowed distance in 1 timestep
c           LDB - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c         METFM - integer - Meteorological data format
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /AR2/ variables:
c           NTR0
c           NSTEP3(mxemdat),NDHRQB3(mxqstep,mxemdat),
c           NSECQB3(mxqstep,mxemdat),NDHRQE3(mxqstep,mxemdat),
c           NSECQE3(mxqstep,mxemdat),XAR2GRD(mxvertp1,mxqstep,mxarea),
c           YAR2GRD(mxvertp1,mxqstep,mxarea),HTAR2(mxqstep,mxarea),
c           ELAR2(mxqstep,mxarea),TKAR2(mxqstep,mxarea),
c           REFAR2(mxqstep,mxarea),WEFAR2(mxqstep,mxarea),
c           SZ0AR2(mxqstep,mxarea),
c           QAR2(mxspec,mxqstep,mxarea),AREA2(mxqstep,mxarea),
c           NVERT2(mxarea),NEWAR2(mxarea)
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW, SYMIN, SZMIN, WSCALM
c     Common block /DISPDAT/ variables:
c           JSUP
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MHFTSZ, MPARTLBA
c     Common block /GRID/ variables:
c           DGRID, IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /METHD/ variables:
c           ELEV(mxnx,mxny), I2DMET
c     Common block /METHR/ variables:
c           PLEXP, PTG(2), DPTINVO, TEMPSS, TEMP2D(mxnx,mxny)
c     Common block /PUFF/ variables:
c           NPUFFS
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXSPEC, MXAREA, MXQSTEP, MXEMDAT,
c           MXRISE, IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /AR2/ variables:
c           NEWAR2(mxarea)
c     Common block /PUFF/ variables:
c           all variables in common block
c     Common block /SLUG/ variables:
c           all variables in common block
c     Common block /SRCTAB/ variables:
c           NTR,XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise)
c
c --- AREAS2 called by:  INITPUF
c --- AREAS2 calls:      RLSMET, ROLLDN, NUMMET, NUMRISE, NUMCLIP,
c                        DELTSEC, SYAREA, SWAP, INJECT, PTLAPS, PRFPP,
c                        NRISEHD, ZEROTAB, SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'ar2.puf'
      include 'comparm.puf'
      include 'dispdat.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'puff.puf'
      include 'slug.puf'
      include 'srctab.puf'
c
      real q(mxspec)
      logical ldb,problem
      data twobypi/0.63662/
c --- Set minimum allowed potential temperature gradient PTGRAD0,
      data ptgrad0/.005/

c --- Set source type (4 for buoyant areas)
      data itype4/4/

c --- No PRIME downwash for NUMRISE call
      data mprime/0/
c --- Set dummy initial sigmas for NUMRISE call (used only with PRIME)
      data sydum/1.0/, szdum/1.0/
c
c ***
      if(ldb) then
         write(io6,*)
         write(io6,*) 'AREAS2:  Source Number    ',i
      endif
c ***
c
c --- Initialize number of new puffs from this source, this timestep
      newar2(i)=0

c --- Loop over emission periods within this timestep
      do 100 it=1,nstep3(ia)
c
c --------------------------------------------------------------------
c ---    Do not generate puff for this step if all emissions are ZERO!
c --------------------------------------------------------------------
         qsum=0.0
         do is=1,nspec
            qsum=qsum+qar2(is,it,i)
         enddo
         if(qsum.EQ.0.0) goto 100

c ---    Initialize source tabulation arrays to zero
         call ZEROTAB

c ---    Determine the met. grid point closest to the source
         ixs=1.0+xar2grd(nvert2(i)+1,it,i)
         iys=1.0+yar2grd(nvert2(i)+1,it,i)
c
c
c ---    Source off the computational grid -- write a FATAL message
         if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.iys.lt.jbcomp.or.
     1      iys.gt.jecomp)then
            write(io6,20)i,it,ixs,iys
20       format(/1x,'FATAL -- an area source with variable ',
     1   'emissions is off the computational grid'/
     2   1x,'source no. (i) = ',i6,2x,'emis. per. (it) = ',i6,2x,
     3   'nearest grid point (ixs,iys) = (',i5,',',i5,')')
            problem=.TRUE.
            goto 100
         endif
c
c --------------------------------
c --- Numerical Plume Rise Section
c --------------------------------
c
c ---    Construct met. profiles at this grid cell
         call NUMMET(ixs,iys,ldb)
c
c ---    Prepare data header record for RISE.DAT file
c ---    (control for output to scratch file is within subroutine)
         call NRISEHD(itype4,i,ndhrb,nsecb,ndhre,nsece,ndhrqb3(it,ia),
     &        nsecqb3(it,ia),ndhrqe3(it,ia),nsecqe3(it,ia),elar2(it,i),
     &        htar2(it,i),tkar2(it,i),refar2(it,i),wefar2(it,i),
     &        xar2grd(nvert2(i)+1,it,i),yar2grd(nvert2(i)+1,it,i))
c
c --     Tabulate plume rise in arrays
         ntr=ntr0
         call NUMRISE(mprime,ldb,htar2(it,i),tkar2(it,i),
     &             refar2(it,i),wefar2(it,i),sydum,szdum,
     &             ntr,xtr,ztr,rtr,htr)
         rise=ztr(ntr)-htar2(it,i)
         htrel=htar2(it,i)
c
c ---    Extract stack height wind speed & other met. variables
         call RLSMET(ldb,ixs,iys,htrel,mfact,
     &               mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,ustr,
     &               wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)

c ---    Set sigma y, sigma z at the source
         szsrc=AMAX1(szmin,sz0ar2(it,i))
         call SYAREA(xar2grd(1,it,i),yar2grd(1,it,i),nvert2(i),dgrid,
     &               flow,ldb,sysrc)
         sysrc=AMAX1(symin,sysrc)
c
c ---    Revise height for met data: choose height midway between
c ---    release (typically near ground for area sources) and minimum
c ---    of final rise and PBL depth (only if release is below PBL)
         if(mpartlba.EQ.1 .AND. htrel.LT.dpbl) then
            htmet=0.5*(htrel+AMIN1(dpbl,ztr(ntr)))
            call RLSMET(ldb,ixs,iys,htmet,mfact,
     &               mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,ustr,
     &               wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)
         endif
         if(i2dmet.EQ.1) then
            tempk=temp2d(ixs,iys)
         elseif(i2dmet.EQ.0) then
            tempk=tempss(issta)
         else
            write(*,*)'Subr. AREAS2:  Invalid I2DMET = ',i2dmet
            stop
         endif
c
c ---    Adjust for partial penetration of elevated stable layer
c ---    Calculate buoyancy flux (9.80665 m/s**2 = g)
         dtemp=tkar2(it,i)-tempk
         dtemp=amax1(dtemp,0.0)
         fluxb=(9.80665*refar2(it,i)**2*wefar2(it,i)/tkar2(it,i))*dtemp
         if(mpartlba.EQ.1 .and.
     &      istab.LE.4 .and. fluxb.GT.0.0) then
c ---       Set thickness (m) of transition region above mixing height
            dzinv=30.
c ---       Estimate potential temperature gradient above mixed layer
            if(LCALGRD) then
c ---          Use temperatures provided by met model
               htinv=amax1(dpbl,htrel)
               call PTLAPS(ixs,iys,htinv,ptgrad0,dzinv,ptginv,tmix)
            else
c ---          Use default potential temperature lapse rate
               if(jsup.LE.4) then
                  ptginv=ptgrad0
               elseif(jsup.EQ.5) then
                  ptginv=amax1(ptg0(1),ptgrad0)
               else
                  ptginv=amax1(ptg0(2),ptgrad0)
               endif
            endif
c ---       Estimate potential temperature change across inversion
            if(dptinvo.GT.0.0) then
c ---          Use observed value provided in met file
               dptinv=dptinvo
            else
               dptinv=ptginv*dzinv
            endif
            call PRFPP(rise,fluxb,ws,htrel,dpbl,tempk,ptginv,
     &                 dptinv,fmix,hmax)
c ---       Clip rise table at new final height
            call NUMCLIP(mxrise,htrel,rise,ntr,xtr,ztr,rtr,htr)
            if(ldb) then
               write(io6,*)'AREAS2 Partial Penetration --'
               write(io6,*)'ws,ptginv,dptinv =',ws,ptginv,dptinv
               write(io6,*)'fmix,hmax,ntr    =',fmix,hmax,ntr
               write(io6,*)'Revised rise rise trajectory:'
               write(io6,*)'    I          XTR        ZTR'
               do ir=1,ntr
                 write(io6,'(i5,2x,2f11.4)')ir,xtr(ir),ztr(ir)
               enddo
               write(io6,*)
            endif
c
         else
            fmix=1.0
            hmax=dpbl
         endif
c
c ---    Set variance associated with buoyancy-enhanced growth @ final
c ---    rise
         xf=xtr(ntr)
         bidsq=twobypi*rtr(ntr)**2
c ---    Set downwash flag to zero (no building downwash)
         idw=0
c ---    Set final plume height
         heff=ztr(ntr)
c
c ---------------------------------------------------------
c ---    Compute number of puffs for this emissions period
c ---------------------------------------------------------
c ---    Use CALMET/PROFILE winds at final rise to set release/sampling
c ---    data
         if(metfm.EQ.1 .OR. metfm.EQ.4 .OR. metfm.EQ.5) then
         call rlsmet(ldb,ixs,iys,heff,mfact,
     &               mfact0fr,ilayerfr,wsfr,flowfr,ivecfr,istab,
     &               dpbl,el,ustr,wstr,tsigvfr,tsigwfr,iru,issta,
     &               sqrtsfr,idoptyfr,idoptzfr)
            wsnew=AMAX1(ws,wsfr)
         else
            wsnew=ws
         endif

c ---    Start-time for emission period during timestep
         if(ndhrqb3(it,ia).LT.ndhrb) then
            ndhr1=ndhrb
            nsec1=nsecb
         elseif(ndhrqb3(it,ia).EQ.ndhrb .AND.
     &          nsecqb3(it,ia).LT.nsecb) then
            ndhr1=ndhrb
            nsec1=nsecb
         else
            ndhr1=ndhrqb3(it,ia)
            nsec1=nsecqb3(it,ia)
         endif
c ---    End-time for emission period during timestep
         if(ndhrqe3(it,ia).GT.ndhre) then
            ndhr2=ndhre
            nsec2=nsece
         elseif(ndhrqe3(it,ia).EQ.ndhre .AND.
     &          nsecqe3(it,ia).GT.nsece) then
            ndhr2=ndhre
            nsec2=nsece
         else
            ndhr2=ndhrqe3(it,ia)
            nsec2=nsecqe3(it,ia)
         endif
c ---    Duration of emission period within timestep (seconds)
         call DELTSEC(ndhr1,nsec1,ndhr2,nsec2,ntemit)
         temit=FLOAT(ntemit)
c ---    Apply transport constraints
         npnewt=wsnew*smxi1*temit/dtsec+1
         npnewt=MIN(npnewt,mxnew)
         temit=temit/FLOAT(npnewt)
c ---    Update puff numbers
         newpuf=newpuf+npnewt
         newar2(i)=newar2(i)+npnewt
c
c ---    If puff arrays are full, remove puffs that are off the grid
c ---    and "roll down" arrays to make room for new puffs
c ---    (this also applies to the DA file of tabulated arrays)
         if(npuffs+newpuf.gt.mxpuff) call rolldn(np)
c ---    Check to see if roll-down was adequate
         if(npuffs+newpuf.gt.mxpuff)then
            write(io6,*) ' ERROR in subr. AREAS2'
            write(io6,*)'Too many puffs on grid for array dimensions',
     1      ' -- NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2      ' MXPUFF = ',mxpuff
            stop
         endif
c
c******
      if(ldb)then
         write(io6,204)i,ilayer,ixs,iys,ws,istab,dpbl,issta,npnewt,
     1    newpuf,temit
204      format(5x,'IS: ',i5,2x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'NPNEWT: ',i4,2x,'NEWPUF: ',i5/
     3    5x,'DT: ',f7.2)
c
         write(io6,210)idw,heff,rise,xf,sysrc,szsrc
210      format(5x,'IDW: ',i5,2x,'HEFF: ',f8.2,2x,'RISE : ',f8.2,2x,
     1    'XF : ',f8.2,2x,'SYSRC: ',f8.2,2x,'SZSRC: ',f8.2)
c
         write(io6,208)i,np,iru,temit,sqrts
208      format(5x,'I: ',i5,2x,'NP: ',i5,2x,
     1    'IRU: ',i2,2x,'DT: ',f7.2,2x,'SQRTS: ',f7.3)
      endif
c*****
c ----------------------------------------------------------
c ---    Initialize current step's new puffs for this source
c ----------------------------------------------------------
         do 50 j=1,npnewt
         np=np+1
c
c ---    Use SWAP to start with all puff/slug variables equal to zero
         call swap(np,0)
c
c ---    Fill non-zero values
         xpb(np)=xar2grd(nvert2(i)+1,it,i)
         ypb(np)=yar2grd(nvert2(i)+1,it,i)
         zitibl(np)=-1.0
         elbase(np)=elar2(it,i)
         sigyb(np)=symin
         sigzb(np)=szsrc
c ---    Final plume rise results
         zfinal(np)=heff
         zpb(np)=heff
         zpe(np)=heff
         xfinal(np)=xf
         bidfnl(np)=bidsq
         isplit(np)=1
c ---    Time-of-release data
         ht0(np)=htar2(it,i)
         temit0(np)=temit
         ws0(np)=ws
         istab0(np)=istab
         sqrts0(np)=sqrts
         iru0(np)=iru
         sigv0(np)=tsigv
         sigw0(np)=tsigw
         el0(np)=el
         plexp0(np)=plexp
c ---    Set vector/scalar ws ratio to 1.0
         srat0(np)=1.0
c ---    Additional time-of-release parameters needed for
c ---    receptor-specific calculations
         idw0(np)=idw
         heff20(np)=heff
         sy0(np)=sysrc
         sz0(np)=szsrc

c ---    Place end-time of emission period for this puff into
c ---    TMTOTB(mxpuff) array, expressed as a fraction of the timestep
c ---    This will be used in COMP when computing the sampling steps
c ---    used to advect the freshly emitted puff during the remainder
c ---    of the timestep, and then reset.
c ---    Seconds from start of emissions period to end of timestep
         call DELTSEC(ndhr1,nsec1,ndhre,nsece,ntot)
         tmtotb(np)=(FLOAT(ntot)-temit*j)/dtsec

c ---    Emission period index for this puff
         iemstep(np)=it

c ---    Set puff identity where IRLSNUM is the puff number released
c ---    from a source this time step, ISRCNUM is the source number
c ---    of type ISRCTYP from which the puff was released.
c ---    (Type =4 for buoyant area sources)
         jj=newar2(i)-npnewt+j
         irlsnum(np)=jj
         isrcnum(np)=i
         isrctyp(np)=4
c
c ----------------------------------------------------------
c ---    Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---    Note that "oldest" end of slug is at the source, as is the
c ---    "newest end; oldest end moves away and grows during the step,
c ---    while newest end remains fixed in size at the source.
c
         if(mslug.EQ.1 .AND. mfact0.GT.0) then
c ---       Set coordinates of oldest end of slug (in met. grid units)
            xpe(np)=xpb(np)
            ype(np)=ypb(np)
            xtote(np)=xtotb(np)
            tmtote(np)=tmtotb(np)
c ---       Set sigmas for oldest end of slug
            sigye(np)=sigyb(np)
            sigze(np)=sigzb(np)
         endif
c
c -------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c -------------------------------------------------------------------
c ---    Swap emission rate for source 'i' into 1D array
         do ispec=1,nspec
            q(ispec)=qar2(ispec,it,i)
         enddo
         call INJECT(np,nspec,temit,mfact0,q,heff,hmax,dpbl,fmix,istab)

c ------------------------------------------------------------------
c ---    Transfer tabulated arrays record to DA file using full
c ---    MXRISE dimension
c ------------------------------------------------------------------
         call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

50       continue

c --- End loop over emission periods within this timestep
100   continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine syarea(xargrd,yargrd,nvert,dgrid,vecrad,ldbhr,
     &                  sysrc)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                 SYAREA
c                D. Strimaitis,   SRC
c
c --- PURPOSE:  For a polygon area source, determine the effective
c               initial sigma-y based on the projection of the source
c               in the crosswind direction for this met period.
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): change coordinate arrays for
c                                  verticies so that single array dim.
c                                  can be used
c
c --- INPUTS:
c
c         XARGRD(mxvert) - real    - X coordinates (m) of the vertices of
c                                    the polygon area source.
c         YARGRD(mxvert) - real    - Y coordinates (m) of the vertices of
c                                    the polygon area source.
c                  NVERT - integer - # vertices of the polygon area source.
c                  DGRID - real    - MET grid cell length  (m)
c                 VECRAD - real    - Flow vector (radians)
c                  LDBHR - logical - Debug control
c
c
c --- OUTPUTS:
c
c                  SYSRC - real    - Effective initial sigma-y (m) for
c                                    source
c
c
c --- SYAREA called by:  AREAS1, AREAS2
c --- SYAREA calls:      none
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      real xargrd(mxvert),yargrd(mxvert)
      logical ldbhr

      data piby2/1.5707963/,rt2pi/2.5066283/
c
c --- Transform vertex coordinates into upwind/crosswind frame,
c     keeping track of the max & min crosswind coordinates
c
c --- Rotation angle (CW)
      rot=-vecrad+piby2
      sinrot=sin(rot)
      cosrot=cos(rot)
c --- New crosswind coordinate of vertex #1
      yprime=-sinrot*xargrd(1)+cosrot*yargrd(1)
      ymin=yprime
      ymax=yprime
c --- Process rest of vertices
      do iv=2,nvert
         yprime=-sinrot*xargrd(iv)+cosrot*yargrd(iv)
         ymin=amin1(ymin,yprime)
         ymax=amax1(ymax,yprime)
      enddo
c
c --- Compute initial sigma-y as L/SQRT(2*pi)
      sysrc=(ymax-ymin)*dgrid/rt2pi
c
      if(LDBHR) then
         write(io6,*) 'SYAREA -- '
         write(io6,*) 'ymin,ymax (met grid) = ',ymin,ymax
         write(io6,*) 'coord rotation (rad) = ',rot
         write(io6,*) 'initial sigma-y (m)  = ',sysrc
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine vols(mvolume,iv,i,nspec,ndhrb,nsecb,ndhre,nsece,dtsec,
     &                smxi1,ldb,mfact,np,newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                   VOLS
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff/slug variables for
c               VOLUME SOURCES prescribed in the control-file, or
c               VOLUME SOURCES prescribed in VOLEMARB.DAT
c
c --- UPDATE
c --- V6.22-V6.261  080520  (DGS): Place rise tables in DA file
c --- V6.1-V6.22    070921  (DGS): Change J to I in debug output
c                   070921  (DGS): Revise MVOLUME if-loop error traps
c                   070921  (DGS): Set TMTOTB variable for variable
c                                  emissions file (not usually zero)
c                   070921  (DGS): Replace intrinsic function AMIN0()
c                                  with MIN() when both result and
c                                  arguments are integers
c --- V5.72-V6.1    050915  (DGS): generalize treatment of time for
c                                  variable emissions files --
c                                  resolve time to seconds, and
c                                  allow variable emissions timesteps
c --- V5.7-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.4-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.0-V5.4     000602  (DGS): combine VOLS1 & VOLS2
c                   000602  (DGS): add message to "stop"
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V5.0-V5.0     980304  (DGS): drop any new puffs if emissions = 0 
c --- V5.0-V5.0     980304  (DGS): place source sigmas in SY0,SZ0
c --- V4.0-V5.0     971107  (DGS): add variable emissions factor call
c                                  to function VEMFAC
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c
c --- INPUTS:
c       MVOLUME - integer - Flag for origin of volume source data
c                            1 = Control file (/vol1/)
c                            2 = VOLEMARB.DAT file (/vol2/)
c            IV - integer - VOLEMARB.DAT file index
c             I - integer - Volume source index
c         NSPEC - real    - Number of species modeled
c         NDHRB - integer - Julian day, hour beginning current step
c         NSECB - integer - Seconds at beginning of current step
c         NDHRE - integer - Julian day, hour at end of current step
c         NSECE - integer - Seconds at end of current step
c         DTSEC - real    - Length (seconds) of a basic time step
c         SMXI1 - real    - Reciprocal of speed required to travel max
c                           allowed distance in 1 timestep
c           LDB - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW, SYMIN, SZMIN, WSCALM
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MHFTSZ
c     Common block /GRID/ variables:
c           IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /METHR/ variables:
c           PLEXP
c     Common block /METHD/ variables:
c           I2DMET
c     Common block /PUFF/ variables:
c           NPUFFS
c     Common block /VOL1/ variables:
c           XVL1GRD(mxvol),YVL1GRD(mxvol),HTVL1(mxvol),
c           ELVL1(mxvol),SY0VL1(mxvol),SZ0VL1(mxvol),
c           QVL1(mxspec,mxvol),NEWVL1(mxvol),
c           ivvl1(mxspec,mxvol),iq12vl1(mxspec,mxvol)
c     Common block /VOL2/ variables:
c           NSTEP4(mxemdat),NDHRQB4(mxqstep,mxemdat),
c           NSECQB4(mxqstep,mxemdat),NDHRQE4(mxqstep,mxemdat),
c           NSECQE4(mxqstep,mxemdat),
c           XVL2GRD(mxqstep,mxvol),YVL2GRD(mxqstep,mxvol),
c           HTVL2(mxqstep,mxvol),ELVL2(mxqstep,mxvol),
c           SY0VL2(mxqstep,mxvol),SZ0VL2(mxqstep,mxvol),
c           QVL2(mxspec,mxqstep,mxvol),NEWVL2(mxvol)
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXSPEC, MXVOL, MXQSTEP, MXEMDAT,
c           IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /VOL1/ variables:
c           NEWVL1(mxvol)
c     Common block /VOL2/ variables:
c           NEWVL2(mxvol)
c     Common block /PUFF/ variables:
c           all variables in common block
c     Common block /SLUG/ variables:
c           all variables in common block
c
c --- VOLS called by:  INITPUF
c --- VOLS calls:      RLSMET, ROLLDN, SWAP, INJECT, VEMFAC,
c                      ZEROTAB, SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'comparm.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methr.puf'
      include 'vol1.puf'
      include 'vol2.puf'
      include 'puff.puf'
      include 'slug.puf'
c frr (09/01)
      include 'methd.puf'
c
      real q(mxspec)
      logical ldb,problem
      character*16 vltype

c --- Initialize number of new puffs from this source, this timestep
      npnew=0

c --- Set source emission period range, and screen MVOLUME
      if(mvolume.EQ.1) then
         nt=1
      elseif(mvolume.EQ.2) then
         nt=nstep4(iv)
      else
         write(io6,*)
         write(io6,*)'VOLS:  Invalid volume source type: ',mvolume
         write(io6,*)'       Valid types are 1 (control file)'
         write(io6,*)'                       2 (VOLEMARB.DAT)'
         write(*,*)
         stop 'Halted in VOLS -- see list file.'
      endif

c --- Initialize source tabulation specifications to zero
      call ZEROTAB

c --- Loop over emission periods within this timestep
      do 100 it=1,nt

c ---    Assign variables for current source
         if(mvolume.EQ.1) then
            vltype=' Control File '
            xvlgrd=xvl1grd(i)
            yvlgrd=yvl1grd(i)
            heff=htvl1(i)
            elvl=elvl1(i)
            szsrc=amax1(szmin,sz0vl1(i))
            sysrc=amax1(symin,sy0vl1(i))
            do is=1,nspec
               q(is)=qvl1(is,i)
            enddo
         elseif(mvolume.EQ.2) then
            vltype=' VOLEMARB.DAT '
            xvlgrd=xvl2grd(it,i)
            yvlgrd=yvl2grd(it,i)
            heff=htvl2(it,i)
            elvl=elvl2(it,i)
            szsrc=amax1(szmin,sz0vl2(it,i))
            sysrc=amax1(symin,sy0vl2(it,i))
            do is=1,nspec
               q(is)=qvl2(is,it,i)
            enddo
         else
            write(*,*)'Subr. VOLS:  Invalid MVOLUME = ',mvolume
            stop
         endif
c
c ***
      if(ldb) then
         write(io6,*)
         write(io6,*) 'VOLS: Source Number ',i,'  Source Type ',vltype
         if(mvolume.EQ.2) write(io6,*) '   Emissions period ',it
      endif
c ***
c
c ---    Determine the met. grid point closest to the source
         ixs=1.0+xvlgrd
         iys=1.0+yvlgrd
c
c ---    Source off the computational grid -- write a FATAL message
         if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.iys.lt.jbcomp.or.iys.gt.
     1      jecomp)then
            write(io6,20) vltype,i,ixs,iys
20          format(/1x,'FATAL -- a volume source of Type ',a16,
     1      'is off the computational grid'/1x,'source no. (i) = ',
     2      i6,2x,'nearest grid point (ixs,iys) = (',i5,',',i5,')')
            problem=.TRUE.
            goto 100
         endif
c
c ---    Extract release height wind speed & other met. variables
         call rlsmet(ldb,ixs,iys,heff,mfact,
     &               mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &               ustr,wstr,tsigv,tsigw,iru,issta,sqrts,idopty,
     &               idoptz)
c
c frr (09/01) new calmet format (2D temp)
         if(i2dmet.EQ.1) then
            temp=temp2d(ixs,iys)
         elseif(i2dmet.EQ.0) then
            temp=tempss(issta)
         else
            write(*,*)'Subr. VOLS:  Invalid I2DMET = ',i2dmet
            stop
         endif

c --------------------------------------------------------------------
c ---    Do not generate puff for this step if all emissions are ZERO!
c --------------------------------------------------------------------
c ---    Adjust TYPE-1 emissions for source 'i' and obtain total
         qtot=0.0
         do is=1,nspec
            if(mvolume.EQ.1) q(is)=q(is)*VEMFAC(ldb,ivvl1(is,i),
     &                             iq12vl1(is,i),temp,ws,istab)
            qtot=qtot+q(is)
         enddo
         if(qtot.EQ.0.0) then
c ***
            if(ldb) then
               write(io6,*)
               write(io6,*) 'No emissions this step from Source ',i
               write(io6,*)
            endif
c ***
            goto 100
         endif

c ---    Establish emitting time
         if(mvolume.EQ.1) then
            ndhr1=ndhrb
            nsec1=nsecb
            ndhr2=ndhre
            nsec2=nsece
         elseif(mvolume.EQ.2) then
c ---       Start-time for emission period during timestep
            if(ndhrqb4(it,iv).LT.ndhrb) then
               ndhr1=ndhrb
               nsec1=nsecb
            elseif(ndhrqb4(it,iv).EQ.ndhrb .AND.
     &             nsecqb4(it,iv).LT.nsecb) then
               ndhr1=ndhrb
               nsec1=nsecb
            else
               ndhr1=ndhrqb4(it,iv)
               nsec1=nsecqb4(it,iv)
            endif
c ---       End-time for emission period during timestep
            if(ndhrqe4(it,iv).GT.ndhre) then
               ndhr2=ndhre
               nsec2=nsece
            elseif(ndhrqe4(it,iv).EQ.ndhre .AND.
     &             nsecqe4(it,iv).GT.nsece) then
               ndhr2=ndhre
               nsec2=nsece
            else
               ndhr2=ndhrqe4(it,iv)
               nsec2=nsecqe4(it,iv)
            endif
         else
            write(*,*)'Subr. VOLS:  Invalid MVOLUME = ',mvolume
            stop
         endif
c ---    Duration of emission period within timestep (seconds)
         call DELTSEC(ndhr1,nsec1,ndhr2,nsec2,ntemit)
         temit=FLOAT(ntemit)

c ---    Apply transport constraints
         npnewt=ws*smxi1*temit/dtsec+1
         npnewt=MIN(npnewt,mxnew)
         temit=temit/FLOAT(npnewt)
c ---    Update puff numbers
         npnew=npnew+npnewt
         newpuf=newpuf+npnewt
         if(mvolume.EQ.1) then
            newvl1(i)=npnew
         elseif(mvolume.EQ.2) then
            newvl2(i)=npnew
         else
            write(*,*)'Subr. VOLS:  Invalid MVOLUME = ',mvolume
            stop
         endif

c ---    If puff arrays are full, remove puffs that are off the grid
c ---    and "roll down" arrays to make room for new puffs
c ---    (this also applies to the DA file of tabulated arrays)
         if(npuffs+newpuf.gt.mxpuff) call rolldn(np)
c ---    Check to see if roll-down was adequate
         if(npuffs+newpuf.gt.mxpuff)then
            write(io6,*) ' ERROR in subr. VOLS'
            write(io6,*)'Too many puffs on grid for array dimensions',
     1      ' -- NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2      ' MXPUFF = ',mxpuff
            write(*,*)
            stop 'Halted in VOLS -- see list file.'
         endif
c
c ---    Set variance associated with buoyancy-enhanced growth @ final
c ---    rise
         xf=0.0
         rise=0.0
         bidsq=0.0
c ---    Set downwash flag to zero (no building downwash)
         idw=0

c******
      if(ldb)then
         write(io6,204)i,ilayer,ixs,iys,ws,istab,dpbl,issta,npnewt,
     1    newpuf,temit
204      format(5x,'IS: ',i5,2x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'NPNEWT: ',i4,2x,'NEWPUF: ',i5/
     3    5x,'DT: ',f7.2)
c
         write(io6,210)idw,heff,rise,xf,sysrc,szsrc
210      format(5x,'IDW: ',i5,2x,'HEFF: ',f8.2,2x,'RISE : ',f8.2,2x,
     1    'XF : ',f8.2,2x,'SYSRC: ',f8.2,2x,'SZSRC: ',f8.2)
c
         write(io6,208)i,np,iru,temit,sqrts
208      format(5x,'I: ',i5,2x,'NP: ',i5,2x,
     1    'IRU: ',i2,2x,'DT: ',f7.2,2x,'SQRTS: ',f7.3)
      endif
c*****
c ----------------------------------------------------------
c ---    Initialize current hour's new puffs for this source
c ----------------------------------------------------------
         do 50 j=1,npnewt
         np=np+1
c
c ---    Use SWAP to start with all puff/slug variables equal to zero
         call swap(np,0)
c
c ---    Fill non-zero values
         xpb(np)=xvlgrd
         ypb(np)=yvlgrd
         zitibl(np)=-1.0
         elbase(np)=elvl
         sigyb(np)=sysrc
         sigzb(np)=szsrc
c ---    Final plume rise results
         zfinal(np)=heff
         zpb(np)=heff
         zpe(np)=heff
         xfinal(np)=xf
         bidfnl(np)=bidsq
         isplit(np)=1
c ---    Time-of-release data
         ht0(np)=heff
         temit0(np)=temit
         ws0(np)=ws
         istab0(np)=istab
         sqrts0(np)=sqrts
         iru0(np)=iru
         sigv0(np)=tsigv
         sigw0(np)=tsigw
         el0(np)=el
         plexp0(np)=plexp
c ---    Set vector/scalar ws ratio to 1.0
         srat0(np)=1.0
c ---    Additional time-of-release parameters needed for
c ---    receptor-specific calculations (downwash)
         idw0(np)=idw
         heff20(np)=heff
         sy0(np)=sysrc
         sz0(np)=szsrc

         if(mvolume.EQ.2) then
c ---       Place end-time of emission period for this puff into
c ---       TMTOTB(mxpuff) array, expressed as fraction of the timestep
c ---       This will be used in COMP when computing the sampling steps
c ---       used to advect the freshly emitted puff during remainder
c ---       of the timestep, and then reset.
c ---       Seconds from start of emissions period to end of timestep
            call DELTSEC(ndhr1,nsec1,ndhre,nsece,ntot)
            tmtotb(np)=(FLOAT(ntot)-temit*j)/dtsec
         endif

c ---    Emission period index for this puff
         iemstep(np)=it

c ---    Set puff identity where IRLSNUM is the puff number released
c ---    from a source this time step, ISRCNUM is the source number
c ---    of type ISRCTYP from which the puff was released.
c ---    (Type =7 for control file volume sources)
c ---    (Type =8 for VOLEMARB.DAT volume sources)
         jj=npnew-npnewt+j
         irlsnum(np)=jj
         isrcnum(np)=i
         if(mvolume.EQ.1) then
            isrctyp(np)=7
         elseif(mvolume.EQ.2) then
            isrctyp(np)=8
         else
            write(*,*)'Subr. VOLS:  Invalid MVOLUME = ',mvolume
            stop
         endif
c
c ----------------------------------------------------------
c ---    Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---    Note that "oldest" end of slug is at the source, as is the
c ---    "newest end; oldest end moves away and grows during the step,
c ---    while newest end remains fixed in size at the source.
c
         if(mslug.EQ.1 .AND. mfact0.GT.0) then
c ---       Set coordinates of oldest end of slug (in met. grid units)
            xpe(np)=xpb(np)
            ype(np)=ypb(np)
            xtote(np)=xtotb(np)
            tmtote(np)=tmtotb(np)
c ---       Set sigmas for oldest end of slug
            sigye(np)=sigyb(np)
            sigze(np)=sigzb(np)
         endif
c
c ------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c ------------------------------------------------------------------
c ---    Set partial penetration variables to null values
         fmix=1.0
         hmax=dpbl
         call inject(np,nspec,temit,mfact0,q,heff,hmax,dpbl,fmix,istab)

c ------------------------------------------------------------------
c ---    Transfer NULL tabulated arrays record to DA file
c ------------------------------------------------------------------
         call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

50       continue

c --- End loop over emission periods within this timestep
100   continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine points1(i,nspec,ndhrb,nsecb,ndhre,nsece,dthr,
     &                   xtmp1,ldbhr,mfact,metfm,np,
     &                   newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                POINTS1
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff/slug variables for
c               POINT SOURCES with constant emissions
c
c --- UPDATE
c --- V6.26-V6.261  080520  (DGS): Place rise tables in DA file
c --- V6.222-V6.26  080430  (DGS): Add RISE.DAT output calls
c                                  (requires timestamp in arg list)
c                   080430  (DGS): Add numerical rise option
c --- V6.2-V6.22    070921  (DGS): Initialize variables
c                                  INDEX = 0
c --- V5.75-V6.2    070629  (DGS): Initialize variables
c                                  HB, HW, HEFF2, ZLY, RINIT = 0.0
c                   070629  (DGS): Fix debug output index from J to I
c                   070629  (DGS): Fix name of IRU used in PRIME section
c                                  when the meteorology at building-ht
c                                  is extracted (IRUB was not defined)
c --- V5.74-V5.75   050225  (DGS): add platform adjustment to ISC
c                                  building downwash (MBDW=1)
c                   050225  (DGS): Add DPBL arg to SETCSIG for TAULY
c --- V5.72-V5.74   040715  (DGS): add METFM=5 (AERMET)
c --- V5.7-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.5-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c                   030402  (DGS): implement PRIME downwash option
c --- V5.4-V5.5     010730  (DGS): store initial sigmas from control
c                                  file in SYSRC0 and SZSRC0 for use
c                                  in downwash zone
c                   010730  (DGS): revise building-array index to match
c                                  ISC
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c                   000602  (DGS): add MFOG option
c --- V5.0-V5.3     991222b (DGS): reset momentum flux using FMFAC
c                   991222b (DGS): pass momentum flux to STKTIP
c --- V5.0-V5.0     980807  (DGS): use final rise CALMET/PROFILE winds 
c                                  to set release step
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V5.0-V5.0     980304  (DGS): drop any new puffs if emissions = 0 
c                   980304  (DGS): use initial sigmay,z arrays from 
c                                  control file
c                   980304  (DGS): place source sigmas in SY0,SZ0
c --- V4.0-V5.0     971107  (DGS): add variable emissions factor call
c                                  to function VEMFAC
c                   971107  (DGS): updated /PT1/ variables used (doc)
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c                   971107  (DGS): add observed inversion strength
c
c --- INPUTS:
c             I - integer - Point source index
c         NSPEC - real    - Number of species modeled
c         NDHRB - integer - Julian day, hour beginning current step
c         NSECB - integer - Seconds at beginning of current step
c         NDHRE - integer - Julian day, hour at end of current step
c         NSECE - integer - Seconds at end of current step
c          DTHR - real    - Length (seconds) of a basic time step
c         XTMP1 - real    - Reciprocal of speed required to travel max
c                           allowed distance in 1 timestep
c         LDBHR - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c         METFM - integer - Meteorological data format
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW, SYMIN, SZMIN, PTG0(2), WSCALM, TBD
c     Common block /DISPDAT/ variables:
c           JSUP
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MTIP, MSHEAR, MPARTL, MHFTSZ, MFOG, MBDW,
c           MRISE
c     Common block /FOG/ variables:
c           TXSMXFOG
c     Common block /GRID/ variables:
c           IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /METHD/ variables:
c           LCALGRD, I2DMET
c     Common block /METHR/ variables:
c           PLEXP, PTG(2), DPTINVO
c     Common block /PUFF/ variables:
c           NPUFFS
c     Common block /PT1/ variables:
c           XPT1GRD(mxpt1),YPT1GRD(mxpt1),HTSTAK(mxpt1),
c           ELSTAK(mxpt1),DIAM(mxpt1),EXITW(mxpt1),TSTAK(mxpt1),
c           IDOWNW(mxpt1),QSTAK(mxspec,mxpt1),NPT1,
c           SYIPT1(mxpt1),SZIPT1(mxpt1),FMFPT1(mxpt1),
c           BWIDTH(36,mxpt1),BHT(36,mxpt1),
c           BLN1(36,mxpt1),XBADJ1(36,mxpt1),YBADJ1(36,mxpt1),
c           ivpt1(mxspec,mxpt1),iq12pt1(mxspec,mxpt1),
c           ZPLATPT1(mxpt1)
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXPT1, MXSPEC, MXRISE,
c           IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /FOG/ variables:
c           TXSMXFOG
c     Common block /PT1/ variables:
c           NEWPT1(mxpt1)
c     Common block /PUFF/ variables:
c           all variables in common block
c     Common block /SLUG/ variables:
c           all variables in common block
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c           
c
c --- POINTS1 called by:  INITPUF
c --- POINTS1 calls:      RLSMET, ROLLDN, PTLAPS, SETCSIG, SIGTY,
c                         SIGTZ, STKTIP, DWSIGS, PRSS, PRFIN, PRM,
c                         PRFINSH, PRFPP, NUMMET, NUMRISE, NUMCLIP,
c                         WAKE_INI, WAKE_FIN, CAV_CONC, WAKE_DBG,
c                         NRISEHD, SWAP, INJECT, VEMFAC,
c                         ZEROTAB, SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'comparm.puf'
      include 'csigma.puf'
      include 'dispdat.puf'
      include 'flags.puf'
      include 'fog.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'puff.puf'
      include 'pt1.puf'
      include 'slug.puf'
      include 'srctab.puf'
c
      real q(mxspec),qcav(mxspec)
      logical ldbhr,problem
      logical LBRIGGS

c --- PRIME logicals to configure primary (LPRM) and cavity (LCAV) puff
      logical lprm,lcav
c
      data rt2/1.4142136/, rt2pi/2.5066283/, piby4/0.7853982/
c --- Set minimum allowed potential temperature gradient PTGRAD0,
      data ptgrad0/.005/
c --- Set minimum allowed wind speed for building downwash
      data wsdw0/1.0/

c --- Set source type (1 for POINTS1)
      data itype1/1/

c --- Initialize local ISC building downwash variables
      index=0
      hb=0.0
      hw=0.0
      heff2=0.0
      zly=0.0
      rinit=0.0

c --- Set specific plume rise variables for Briggs and Numerical
c --- rise to clarify treatment
c --- Briggs
      xfinm_B=0.0
      xfinb_B=0.0
      zfinm_B=0.0
      zfinb_B=0.0
      xf_B=0.0
      rise_B=0.0
      fmix_B=1.0
      hmax_B=0.0
      bidsq_B=0.0
      heff_B=0.0
c --- Numerical
      xfinm_N=0.0
      xfinb_N=0.0
      zfinm_N=0.0
      zfinb_N=0.0
      xf_N=0.0
      rise_N=0.0
      fmix_N=1.0
      hmax_N=0.0
      bidsq_N=0.0
      heff_N=0.0
c
c ***
      if(ldbhr) then
         write(io6,*)
         write(io6,*) 'POINTS1:  Source Number    ',i
      endif
c ***
c
c --- Determine the met. grid point closest to the stack
      ixs=1.0+xpt1grd(i)
      iys=1.0+ypt1grd(i)
c
c --- Source off the computational grid -- write a FATAL message
      if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.iys.lt.jbcomp.or.iys.gt.
     1   jecomp)then
         write(io6,20)i,ixs,iys
20       format(/1x,'FATAL -- a point source with constant emissions ',
     1   'is off the computational grid'/1x,'source no. (i) = ',i6,2x,
     2   'nearest grid point (ixs,iys) = (',i5,',',i5,')')
         problem=.TRUE.
         return
      endif
c
c --- Extract stack height wind speed & other met. variables;
c --- and set CALM configuration if triggered
      call rlsmet(ldbhr,ixs,iys,htstak(i),mfact,
     &            mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &            ustr,wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)
c
c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
         temp=temp2d(ixs,iys)
      elseif(i2dmet.EQ.0) then
         temp=tempss(issta)
      else
         write(*,*)'Subr. POINTS1:  Invalid I2DMET = ',i2dmet
         stop
      endif

c --- Swap emission rate for source 'i' into 1D array and scale
      qtot=0.0
      do is=1,nspec
         q(is)=qstak(is,i)*VEMFAC(ldbhr,ivpt1(is,i),iq12pt1(is,i),
     &                            temp,ws,istab)
         qtot=qtot+q(is)
      enddo
c --- Return without generating new puffs if all species have zero
c --- mass in puff
      if(qtot.EQ.0.0) then
c ***
         if(ldbhr) then
            write(io6,*)
            write(io6,*) 'No emissions this step from Source ',i
            write(io6,*)
         endif
c ***
         return
      endif

c --- Initialize source tabulation arrays to zero
      call ZEROTAB

c --- Set volume flux from stack
      vf0=piby4*exitw(i)*(diam(i))**2

c --- Set temperature excess at release
c frr(09/01)
c      dtemp=tstak(i)-tempss(issta)
      dtemp=tstak(i)-temp
c      dtemp=amax1(dtemp,0.01)
      dtemp=amax1(dtemp,0.0)

      if(MFOG.GT.0) then
c ---    Place the temperature excess emission rate (K-m^3/s) in Q(2)
c ---    Note that nspec should be 2 for FOG option
         q(2)=dtemp*vf0
c ---    Maximum temperature excess used to compute RH will be limited
c ---    to the minimum temperature excess among FOG sources
         txsmxfog=AMIN1(dtemp,txsmxfog)
      endif
c
c -------------------------------------------------------------
c --- Compute the final plume rise and distance to final rise
c -------------------------------------------------------------
c --- Calculate fluxes
c --- Buoyancy flux:  2.4516625 = g/4., where g = 9.80665 m/s**2
      fluxb=(2.4516625*diam(i)**2*exitw(i)/tstak(i))*dtemp
c --- Momentum flux
c frr(09/01)
c      fluxm=0.25*(exitw(i)*diam(i))**2*tempss(issta)/tstak(i)
      fluxm=0.25*(exitw(i)*diam(i))**2*temp/tstak(i)
c --- Apply vertical momentum flux factor of zero or one
c --- Use simple test for ZERO instead of forming the product:
c ---     fluxm=fluxm*fmfpt1(i)
      if(fmfpt1(i).LT.0.5) fluxm=0.0
c
c --- Adjustment for stack-tip downwash (NOT for bldg downwash!)
      if(mtip.EQ.1) then
         call stktip(htstak(i),diam(i),fluxm,exitw(i),ws,tipdw)
      else
         tipdw=0.0
      endif

c --- Briggs Rise (always computed)
c ---------------------------------
c --- Final plume rise (no downwash considered)
      call prfin(exitw(i),diam(i),fluxm,fluxb,ws,istab,sqrts,
     &           xfinm_B,xfinb_B,xf_B,zfinm_B,zfinb_B,rise_B)
c
c --- Compute vertical wind shear effects
      if(mshear.EQ.1)then
         call prfinsh(fluxb,ws,plexp,htstak(i),xfinb_B,istab,sqrts,
     1                zfinsh)
c ---    Final buoyant rise is the LOWER of the Briggs & shear hts.
         zfinb_B=amin1(zfinb_B,zfinsh)
c ---    Final plume rise is the HIGHER of the momentum & buoyant hts.
         rise_B=amax1(zfinb_B,zfinm_B)
      endif
c
c --- Adjust for partial penetration of elevated stable layer
c     if(mpartl.EQ.1 .and. istab.LE.3 .and. htstak(i).LT.dpbl) then
      if(mpartl.EQ.1 .and. istab.LE.4 .and. fluxb.GT.0.0) then
c ---    Set thickness (m) of transition region above mixing height
         dzinv=30.
c ---    Estimate potential temperature gradient above mixed layer
         if(LCALGRD) then
c ---       Use temperatures provided by met model
            htinv=amax1(dpbl,htstak(i))
            call ptlaps(ixs,iys,htinv,ptgrad0,dzinv,ptginv,tmix)
         else
c ---       Use default potential temperature lapse rate
            if(jsup.LE.4) then
               ptginv=ptgrad0
            elseif(jsup.EQ.5) then
               ptginv=amax1(ptg0(1),ptgrad0)
            else
               ptginv=amax1(ptg0(2),ptgrad0)
            endif
         endif
c ---    Estimate potential temperature change across inversion
         if(dptinvo.GT.0.0) then
c ---       Use observed value provided in met file
            dptinv=dptinvo
         else
            dptinv=ptginv*dzinv
         endif
         call prfpp(rise_B,fluxb,ws,htstak(i),dpbl,temp,ptginv,
     &              dptinv,fmix_B,hmax_B)
c ---    Reset component final rise heights for use in gradual rise
         if(zfinb_B.GT.rise_B) zfinb_B=rise_B
         if(zfinm_B.GT.rise_B) zfinm_B=rise_B
c
      else
         fmix_B=1.0
         hmax_B=dpbl
      endif
c
c --- Set variance associated with buoyancy-enhanced growth @ final rise
      bidsq_B=(rise_B/3.5)**2
c
c --- Set final plume height
      heff_B=htstak(i)-tipdw+rise_B
c
c --- Set selected data in /CSIGMA/ for sigma calls in ISC downwash
      call SETCSIG(idopty,idoptz,iru,ws,istab,el,sqrts,
     &             tsigv,tsigw,symin,szmin,heff_B,dpbl)

c --- Numerical Rise (conditional)
c --------------------------------
      if(mrise.EQ.2) then
c ---    Construct met. profiles at this grid cell
         call NUMMET(ixs,iys,ldbhr)
c ---    Set stack radius
         reff=0.5*diam(i)
c ---    Set effective release height
         hteff=AMAX1(0.0,htstak(i)-tipdw)
c ---    Prepare data header record for RISE.DAT file
c ---    (control for output to scratch file is within subroutine)
         call NRISEHD(itype1,i,ndhrb,nsecb,ndhre,nsece,ndhrb,nsecb,
     &                ndhre,nsece,elstak(i),hteff,tstak(i),
     &                reff,exitw(i),xpt1grd(i),ypt1grd(i))
c ---    Compute plume rise
         mprime=0
c ---    Use full MXRISE points in rise table
         ntr=mxrise
         call NUMRISE(mprime,ldbhr,hteff,tstak(i),reff,exitw(i),
     &                syipt1(i),szipt1(i),ntr,xtr,ztr,rtr,htr)
         rise_N=htr(ntr)
c ---    Adjust for partial penetration of elevated stable layer
         if(mpartl.EQ.1 .and. istab.LE.4 .and. fluxb.GT.0.0) then
c ---       (ptginv, dptinv computed in Briggs Rise section)
            call PRFPP(rise_N,fluxb,ws,htstak(i),dpbl,temp,ptginv,
     &                 dptinv,fmix_N,hmax_N)
c ---       Clip rise table at new final height
            call NUMCLIP(mxrise,hteff,rise_N,ntr,xtr,ztr,rtr,htr)
         else
            fmix_N=1.0
            hmax_N=dpbl
         endif
c ---    Assign final plume height and distance
         heff_N=ztr(ntr)
         xf_N=xtr(ntr)
c ---    Variance associated with buoyancy-enhanced growth @ final rise
         bidsq_N=(rise_N/3.5)**2
      endif
c
c --------------------------------------------------------------------
c --- Determine if building downwash effects on plume rise and sigmas
c --- should be considered
c --------------------------------------------------------------------
      sz0dw=0.0
      sy0dw=0.0
      xshift=0.0
      xshift2=0.0
      lprm=.FALSE.
      lcav=.FALSE.
c --- Initialize downwash flag to zero (no building downwash)
c --- Note:  idw=0  no downwash
c ---        idw=1  Huber-Snyder model
c ---        idw=2  Schulman-Scire model
c ---        idw=3  PRIME model (puff released from primary source)
c ---        idw=4  PRIME model (puff released from cavity source)
      idw=0

      if(idownw(i).EQ.1 .AND. ws.GE.wsdw0 .AND. mbdw.EQ.2) then
c        --------------------------------
c        --- PRIME Downwash Section
c        --------------------------------
         mprime=1
c ---    Get direction-specific building data (direction at stack ht)
         index=INT(0.1*FLOAT(ivec)+0.4999)
         if(index.eq.0)index=36
         dsbh=bht(index,i)
         dsbw=bwidth(index,i)
         dsbl=bln1(index,i)
         xadj=xbadj1(index,i)
         yadj=ybadj1(index,i)
         hl=AMIN1(dsbh,dsbw)
c ---    Screen for GEP stack (regulatory definition)
         geptest=dsbh+1.5*hl
         if(htstak(i).LT.geptest) then
            idw=3
c ---       Set stack radius
            reff=0.5*diam(i)
c ---       Set met data at top of building
            call RLSMET(ldbhr,ixs,iys,dsbh,mfact,
     &                  mfact0b,ilayer,wsb,flowb,ivecb,istabb,dpbl,
     &                  elb,ustrb,wstrb,tsigvb,tsigwb,iru,issta,
     &                  sqrtsb,idoptyb,idoptzb)
c ---       Reset /CSIGMA/ data for met data at top of building
            if(mrise.EQ.2) then
               zht=AMAX1(heff_N,dsbh)
            else
               zht=AMAX1(heff_B,dsbh)
            endif
            call SETCSIG(idoptyb,idoptzb,iru,wsb,istabb,elb,sqrtsb,
     &                   tsigvb,tsigwb,symin,szmin,zht,dpbl)

c ---       Refresh /WAKEDAT/ variables
            call WAKE_INI(ldbhr,istab,iru,dsbh,dsbw,dsbl,xadj,yadj,
     &                    wsb,ws,tsigvb,tsigwb,idoptyb,idoptzb)
c ---       Construct met. profiles at this grid cell
            call NUMMET(ixs,iys,ldbhr)
c ---       Prepare data header record for RISE.DAT file
c ---       (control for output to scratch file is within subroutine)
            call NRISEHD(itype1,i,ndhrb,nsecb,ndhre,nsece,ndhrb,nsecb,
     &                   ndhre,nsece,elstak(i),htstak(i),tstak(i),
     &                   reff,exitw(i),xpt1grd(i),ypt1grd(i))
c ---       Compute plume rise and wake structure
c ---       Use full MXRISE points in rise table
            ntr=mxrise
            call NUMRISE(mprime,ldbhr,htstak(i),tstak(i),reff,exitw(i),
     &                   syipt1(i),szipt1(i),ntr,xtr,ztr,rtr,htr)
c ---       Pass final wake structure to source arrays (without BID)
            call WAKE_FIN(ldbhr,nwk,xwk,szwk,sywk,drwk,szw0,syw0,
     &                    ncv,xcv,szcv,sycv,szc0,syc0,fqcvpt1(i))
c
c ---       Set logicals (primary & cavity) and partition mass
            if(fqcvpt1(i).LE.0.001) then
               lcav=.FALSE.
               lprm=.TRUE.
               do is=1,nspec
                  qcav(is)=0.0
               enddo
            elseif(fqcvpt1(i).GE.0.999) then
               lcav=.TRUE.
               lprm=.FALSE.
               do is=1,nspec
                  qcav(is)=q(is)
                  q(is)=0.0
               enddo
            else
               lcav=.TRUE.
               lprm=.TRUE.
               do is=1,nspec
                  qcav(is)=q(is)*fqcvpt1(i)
                  q(is)=q(is)-qcav(is)
               enddo
            endif
c ---       Compute near-cavity concentrations for current source, 
c ---       return location of cavity source on the met grid, and
c ---       return the distance from the source to the end of the
c ---       cavity transition zone
            call CAV_CONC(ldbhr,nspec,q,qcav,xpt1grd(i),ypt1grd(i),
     &                    ntr,xtr,ztr,flow,dpbl,xcavgrd,ycavgrd,
     &                    xshift,xshift2)

c ---       Assign final plume height, rise, and distance for primary
c ---       source
            heff_N=ztr(ntr)
            rise_N=htr(ntr)
            xf_N=xtr(ntr)
c
c ---       Reset BID and tip downwash
            tipdw=0.0
            bidsq_N=(rise_N/3.5)**2
c
c ---       Report selected data to file for debug
            if(ldbhr) call WAKE_DBG(io6,ntr,xtr,ztr,rtr,htr,
     &                              .FALSE.,htstak(i))
         endif
      endif

      if(idownw(i).GE.1 .AND. ws.GE.wsdw0 .AND. mbdw.EQ.1) then
c        --------------------------------
c        --- HS/SS Downwash Section
c        --------------------------------
c ---    Get direction-specific building width and height
         index=INT(0.1*FLOAT(ivec)+0.4999)
         if(index.eq.0)index=36
         hb=bht(index,i)
         hw=bwidth(index,i)
         hl=amin1(hb,hw)
c
c ---    Assign platform height
         zplat=0.0
         if(idownw(i).EQ.2) zplat=zplatpt1(i)
c
c ---    Calculate the momentum rise at 2*hb and test for downwash
         xarg=2.*hb
         call prm(diam(i),exitw(i),fluxm,ws,istab,sqrts,xarg,
     &           xfinm_B,zfinm_B,z2hb)
         heff2=htstak(i)+z2hb
         dwtest=hb+1.5*hl
c
         if((heff2-zplat).LE.dwtest) then
c ---       Set downwash flag to ACTIVE
            idw=1
c ---       (1)  Compute sigmas at 10*hl
            xarg10=10.*hl
            xarg10km=0.001*xarg10
            targ10=xarg10/ws
            call dwsigs(tbd,hw,hb,mhftsz,ws,htstak(i),heff2,zplat,
     &                  xarg10,sy10,sz10)
c
c ---       (2)  Final Plume rise altered if Schulman-Scire (SS) active
            sstest=hb+0.5*hl
            if((htstak(i)-zplat).LT.sstest) then
c ---          Schulman-Scire downwash ACTIVE
               idw=2
c ---          Set sigmas at 3*hl
               xarg=3.*hl
               call dwsigs(tbd,hw,hb,mhftsz,ws,htstak(i),heff2,zplat,
     &                     xarg,sy3,sz3)
c ---          Determine line source parameters, ZLY and RINIT
c ---          Calculate ZLY
               if((heff2-zplat).GT.(1.2*hb)) then
                  zly=0.0
               elseif(sy3.GT.sz3) then
                  zly=rt2pi*(sy3-sz3)
               else
                  zly=0.0
               endif
c ---          Calculate initial radius of plume, RINIT
               rinit=rt2*sz3
c ---          Compute SS final plume rise
c ---          Set max distance to final rise
               xarg=amax1(xfinm_B,xfinb_B)
               call prss(xarg,zly,rinit,ws,istab,sqrts,diam(i),
     &                   exitw(i),fluxm,fluxb,xfinm_B,xfinb_B,rise_B)
c
c ---          Reset BID and tip downwash = 0
               bidsq_B=0.0
               tipdw=0.0
            endif
c
c ---       Set final plume height
            heff_B=htstak(i)-tipdw+rise_B
c
         endif
      endif

c --- Select appropriate rise results
c -----------------------------------
      if(idw.EQ.1 .OR. idw.EQ.2) then
c ---    ISC-type downwash for this source: assign Briggs results
         LBRIGGS=.true.
      elseif(idw.EQ.3 .OR. idw.EQ.4) then
c ---    PRIME downwash for this source: assign Numerical results
         LBRIGGS=.false.
      elseif(idw.EQ.0 .AND. mrise.EQ.1) then
c ---    No downwash for this source and Briggs rise is selected
         LBRIGGS=.true.
      elseif(idw.EQ.0 .AND. mrise.EQ.2) then
c ---    No downwash for this source and Numerical rise is selected
         LBRIGGS=.false.
      else
         write(io6,*) ' ERROR in subr. POINTS1'
         write(io6,*)'Invalid source treatment found -- ',
     1   'IDW(0,1,2,3, or 4) = ',idw,' MRISE(1 or 2) = ',mrise
         write(*,*)
         stop 'Halted in POINTS1 -- see list file.'
      endif
      if(LBRIGGS) then
         xfinm=xfinm_B
         xfinb=xfinb_B
         zfinm=zfinm_B
         zfinb=zfinb_B
         xf=xf_B
         rise=rise_B
         fmix=fmix_B
         hmax=hmax_B
         bidsq=bidsq_B
         heff=heff_B
      else
         xfinm=xfinm_N
         xfinb=xfinb_N
         zfinm=zfinm_N
         zfinb=zfinb_N
         xf=xf_N
         rise=rise_N
         fmix=fmix_N
         hmax=hmax_N
         bidsq=bidsq_N
         heff=heff_N
      endif

c ---------------------------------------------------------
c --- Compute the number of puffs/slugs released this hour
c --- from this source
c ---------------------------------------------------------
c --- Use CALMET/PROFILE winds at final rise to set release/sampling
c --- data and to check MFACT0 determination (slug changed to puff
c --- only if CALM is detected at both heights)
      if(metfm.EQ.1 .OR. metfm.EQ.4 .OR. metfm.EQ.5) then
         call rlsmet(ldbhr,ixs,iys,heff,mfact,
     &               mfact0fr,ilayerfr,wsfr,flowfr,ivecfr,istab,dpbl,
     &               el,ustr,wstr,tsigvfr,tsigwfr,iru,issta,sqrtsfr,
     &               idoptyfr,idoptzfr)
         mfact0=MAX0(mfact0,mfact0fr)
         wsnew=AMAX1(ws,wsfr)
      else
         wsnew=ws
      endif
c
      npnew=wsnew*xtmp1+1
      npnew=max0(npnew,1)
      npnew=min0(npnew,mxnew)
c
      if(lcav.AND.lprm) then
c ---    PRIME downwash produces both a primary and a cavity source
         newpt1(i)=2*npnew
      else
         newpt1(i)=npnew
      endif
c
      newpuf=newpuf+newpt1(i)
c --- If puff arrays are full, remove puffs that are off the grid
c --- and "roll down" arrays to make room for new puffs
c --- (this also applies to the DA file of tabulated arrays)
      if(npuffs+newpuf.gt.mxpuff) call rolldn(np)
c --- Check to see if roll-down was adequate
      if(npuffs+newpuf.gt.mxpuff)then
         write(io6,*) ' ERROR in subr. POINTS1'
         write(io6,*)'Too many puff on grid for array dimensions -- ',
     1   'NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2   ' MXPUFF = ',mxpuff
         write(*,*)
         stop 'Halted in POINTS1 -- see list file.'
      endif
c
c --- DT is the time (sec) over which each puff is emitted
      dt=dthr/float(npnew)

c ---------------------------
c --- FOG processing Option
c ---------------------------
      if(MFOG.GT.0) then
c ---    Compute initial sigma consistent with volume flux
         ws3= wsnew * wsnew * wsnew
         if(ws3.GE.(vf0/dt**2)) then
            sigvf=SQRT(vf0/wsnew)/rt2pi
         else
            sigvf=((vf0*dt)**.3333333)/rt2pi
         endif
      else
         sigvf=0.0
      endif

c ------------------------------------
c --- Set initial sigmas at the source
c ------------------------------------
      szini=AMAX1(sigvf,szipt1(i))
      syini=AMAX1(sigvf,syipt1(i))

      szsrc=AMAX1(szmin,szini)
      sysrc=AMAX1(symin,syini)
c
      if(idw.EQ.3) then
c ---    PRIME: initial sigma already used
         sysrc=AMAX1(symin,syw0)
         sysrc2=AMAX1(symin,syc0)
         szsrc=AMAX1(szmin,szw0)
         szsrc2=AMAX1(szmin,szc0)
      elseif(idw.GT.0) then
c ---    Downwash is active: initial sigmas at the source must reproduce
c ---    the modified sigmas at 10 hl, using ambient growth curve.  The
c ---    modified sigmas add the downwash sigmas and any other initial
c ---    sigmas in quadrature. (HS/SS)
c
c ---    (1)  Add initial sigmas to downwash sigmas at 10 hl
         if(szini.GT.0.) then
            sigz=SQRT(szini**2+sz10**2)
         else
            sigz=sz10
         endif
         if(syini.GT.0.) then
            sigy=SQRT(syini**2+sy10**2)
         else
            sigy=sy10
         endif
c
c ---    (2)  Calculate virtual time/distance for these sigmas
         call sigtz(sigz,0.0,0.0,htstak(i),szamb,v10tz,v10dz)
         call sigty(sigy,0.0,0.0,syamb,v10ty,v10dy)
c
c ---    (3)  Set corresponding sigmas at the source (sy0dw,sz0dw)
c ---    this will allow the effects of downwash on the sigmas to
c ---    influence puff size beyond 10*hl
         ydxkm=amax1(0.0,v10dy-xarg10km)
         ydt=amax1(0.0,v10ty-targ10)
         zdxkm=amax1(0.0,v10dz-xarg10km)
         zdt=amax1(0.0,v10tz-targ10)
         call sigtz(0.0,zdxkm,zdt,htstak(i),sz0dw,virtz,virdz)
         call sigty(0.0,ydxkm,ydt,sy0dw,virty,virdy)

         sysrc=amax1(symin,sy0dw)
         szsrc=amax1(szmin,sz0dw)
      endif


c*****
      if(ldbhr)then
         write(io6,204)i,ilayer,ixs,iys,ws,istab,dpbl,issta,npnew,
     1    newpuf,dt
204      format(5x,'IS: ',i5,2x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'NPNEW: ',i4,2x,'NEWPUF: ',i5/
     3    5x,'DT: ',f7.2)
c
         write(io6,206)htstak(i),diam(i),exitw(i),tstak(i),
c frr(09/01)
c    1    tempss(issta),dtemp,fluxb,fluxm,xf,heff,tipdw
     1    temp,dtemp,fluxb,fluxm,xf,heff,tipdw
206      format(5x,'HTSTAK: ',f6.1,2x,'DIAM: ',f6.3,2x,'EXITW: ',
     1    f6.3,2x,'TSTAK: ',f6.2,2x,'TEMPSS: ',f6.2,2x,'DTEMP: ',f6.3,
     2    2x,'FLUXB : ',f8.3,2x,'FLUXM: ',f6.1/5x,'XF: ',f6.1,2x,
     3    'HEFF: ',f6.1,2x,'TIPDW: ',f6.1)
c
         write(io6,210)idw,heff2,zly,rinit,rise
210      format(5x,'IDW: ',i5,2x,'HEFF2: ',f8.2,2x,'ZLY : ',f8.2,2x,
     1    'RINIT : ',f8.2,'RISE : ',f8.2)
         if(mbdw.EQ.2) then
            write(io6,*) 'hb,hw,index = ',dsbh,dsbw,index
            write(io6,*) 'len,[x,y]adj = ',dsbl,xadj,yadj
         else
            write(io6,*) 'hb,hw,index = ',hb,hw,index
         endif
c
         write(io6,208)i,np,idopty,idoptz,iru,sysrc,szsrc,dt,istab
208      format(5x,'I: ',i5,2x,'NP: ',i5,2x,'IDOPTY: ',i2,2x,
     1    'IDOPTZ: ',i2,2x,'IRU: ',i2,/2x,'SIGYB: ',f8.2,2x,
     2    'SIGZB: ',f8.2,2x,'DT: ',f7.2,2x,'ISTAB: ',i1)

         if(mfog.GT.0) write(io6,*)'TXSMXFOG = ',txsmxfog
      endif
c*****
c ----------------------------------------------------------
c ---    Initialize current hour's new puffs for this source
c ----------------------------------------------------------
      if((.NOT.lcav .AND. .NOT.lprm) .OR. lprm) then
         do 50 j=1,npnew
         np=np+1
c
c ---    Use SWAP to start with all puff/slug variables equal to zero
         call swap(np,0)
c
c ---    Fill non-zero values
         xpb(np)=xpt1grd(i)
         ypb(np)=ypt1grd(i)
         zitibl(np)=-1.0
         elbase(np)=elstak(i)
         sigyb(np)=sysrc
         sigzb(np)=szsrc
c ---    Final plume rise results
         zfinal(np)=heff
         zpb(np)=heff
         zpe(np)=heff
         xfinal(np)=xf
         bidfnl(np)=bidsq
c ---    Intermediate results for calc. gradual rise
         fb(np)=fluxb
         fm(np)=fluxm
         xbfin(np)=xfinb
         xmfin(np)=xfinm
         zbfin(np)=zfinb
         zmfin(np)=zfinm
         stipdw(np)=tipdw
         isplit(np)=1
c ---    Time-of-release data
         ht0(np)=htstak(i)
         exitw0(np)=exitw(i)
         diam0(np)=diam(i)
         temit0(np)=dt
         ws0(np)=ws
         istab0(np)=istab
         sqrts0(np)=sqrts
         iru0(np)=iru
         sigv0(np)=tsigv
         sigw0(np)=tsigw
         el0(np)=el
         plexp0(np)=plexp
c ---    Set vector/scalar ws ratio to 1.0
         srat0(np)=1.0
c ---    Additional time-of-release parameters needed for
c ---    receptor-specific calculations (downwash)
         idw0(np)=idw
         hb0(np)=hb
         hw0(np)=hw
         heff20(np)=heff2
         zly0(np)=zly
         r0(np)=rinit
         xshift0(np)=xshift
         sysrc0(np)=syini
         szsrc0(np)=szini
         sy0(np)=sysrc
         sz0(np)=szsrc

c ---    Set puff identity where IRLSNUM is the puff number released
c ---    from a source this time step, ISRCNUM is the source number
c ---    of type ISRCTYP from which the puff was released.
c ---    (Type =1 for const. point sources)
         irlsnum(np)=j
         isrcnum(np)=i
         isrctyp(np)=1
c
c ----------------------------------------------------------
c ---    Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---    Note that "oldest" end of slug is at the source, as is the
c ---    "newest end; oldest end moves away and grows during the step,
c ---    while newest end remains fixed in size at the source.
c
         if(mslug.EQ.1 .AND. mfact0.GT.0) then
c ---       Set coordinates of oldest end of slug (in met. grid units)
            xpe(np)=xpb(np)
            ype(np)=ypb(np)
            xtote(np)=xtotb(np)
            tmtote(np)=tmtotb(np)
c ---       Set sigmas for oldest end of slug
            sigye(np)=sigyb(np)
            sigze(np)=sigzb(np)
         endif
c
c ------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c ------------------------------------------------------------------
         call inject(np,nspec,dt,mfact0,q,heff,hmax,dpbl,fmix,istab)

c ------------------------------------------------------------------
c ---    Transfer tabulated arrays record to DA file using full
c ---    MXRISE dimension
c ------------------------------------------------------------------
         call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

50       continue
      endif

c ---------------------------------------------------------
c --- Initialize new puffs for PRIME cavity source (idw=4)
c ---------------------------------------------------------
      if(lcav) then
      do 150 j=1,npnew
         np=np+1
c
c ---    Use SWAP to start with all puff/slug variables equal to zero
         call swap(np,0)
c
c ---    Fill non-zero values
         xpb(np)=xcavgrd
         ypb(np)=ycavgrd
         zitibl(np)=-1.0
         elbase(np)=elstak(i)
         sigyb(np)=sysrc2
         sigzb(np)=szsrc2
         stipdw(np)=tipdw
         isplit(np)=1
c ---    Time-of-release data
c ---    Set release ht to building ht for this cavity source (puffs
c ---    are released at ZERO, but are initially advected with wind
c ---    at building ht)
         ht0(np)=dsbh
         exitw0(np)=0.0
         diam0(np)=0.0
         temit0(np)=dt
         ws0(np)=ws
         istab0(np)=istab
         sqrts0(np)=sqrts
         iru0(np)=iru
         sigv0(np)=tsigv
         sigw0(np)=tsigw
         el0(np)=el
         plexp0(np)=plexp
c ---    Set vector/scalar ws ratio to 1.0
         srat0(np)=1.0
c ---    Additional time-of-release parameters needed for
c ---    receptor-specific calculations (downwash)
         idw0(np)=4
         hb0(np)=dsbh
         hw0(np)=dsbw
         xshift0(np)=xshift2
         sysrc0(np)=0.0
         szsrc0(np)=0.0
         sy0(np)=sysrc2
         sz0(np)=szsrc2

c ---    Emission period index for this puff
         iemstep(np)=1

c ---    Set puff identity where IRLSNUM is the puff number released
c ---    from a source this time step, ISRCNUM is the source number
c ---    of type ISRCTYP from which the puff was released.
c ---    (Type =1 for const. point sources)
         irlsnum(np)=j
         isrcnum(np)=i
         isrctyp(np)=1
c
c ----------------------------------------------------------
c ---    Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---    Note that "oldest" end of slug is at the source, as is the
c ---    "newest end; oldest end moves away and grows during the step,
c ---    while newest end remains fixed in size at the source.
c
         if(mslug.EQ.1 .AND. mfact0.GT.0) then
c ---       Set coordinates of oldest end of slug (in met. grid units)
            xpe(np)=xpb(np)
            ype(np)=ypb(np)
            xtote(np)=xtotb(np)
            tmtote(np)=tmtotb(np)
c ---       Set sigmas for oldest end of slug
            sigye(np)=sigyb(np)
            sigze(np)=sigzb(np)
         endif
c
c ------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c ------------------------------------------------------------------
         call inject(np,nspec,dt,mfact0,qcav,0.0,hmax,dpbl,fmix,istab)

c ------------------------------------------------------------------
c ---    Transfer tabulated arrays record to DA file using full
c ---    MXRISE dimension
c ------------------------------------------------------------------
         call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

150   continue
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine points2(ip,i,nspec,ndhrb,nsecb,ndhre,nsece,dtsec,
     &                   smxi1,ldb,mfact,metfm,np,newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                POINTS2
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff/slug variables for
c               POINT SOURCES with VARIABLE emissions
c
c --- UPDATE
c --- V6.26-V6.261  080520  (DGS): Place rise tables in DA file
c --- V6.25-V6.26   080430  (DGS): Add RISE.DAT output calls
c                                  (requires timestamp in arg list)
c                   080430  (DGS): Add numerical rise option
c --- V6.22-V6.25   080227  (DGS): Halt run if any source is not on the
c                                  computational grid (replaces a
c                                  warning)
c --- V6.2-V6.22    070921  (DGS): Initialize variables
c                                  INDEX = 0
c                   070921  (DGS): Replace intrinsic function AMIN0()
c                                  with MIN() when both result and
c                                  arguments are integers
c --- V6.0-V6.2     070629  (DGS): Initialize variables
c                                  HB, HW, HEFF2, ZLY, RINIT = 0.0
c                   070629  (DGS): Fix debug output index from J to I
c                   070629  (DGS): Fix name of IRU used in PRIME section
c                                  when the meteorology at building-ht
c                                  is extracted (IRUB was not defined)
c --- V5.75-V6.0    050915  (DGS): generalize treatment of time for
c                                  variable emissions files --
c                                  resolve time to seconds, and
c                                  allow variable emissions timesteps
c --- V5.74-V5.75   050225  (DGS): add platform adjustment to ISC
c                                  building downwash (MBDW=1)
c                   050225  (DGS): Add DPBL arg to SETCSIG for TAULY
c --- V5.72-V5.74   040715  (DGS): add METFM=5 (AERMET)
c --- V5.7-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.5-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c                   030402  (DGS): implement PRIME downwash option
c --- V5.4-V5.5     010730  (DGS): store initial sigmas from PTEMARB
c                                  file in SYSRC0 and SZSRC0 for use
c                                  in downwash zone
c                   010730  (DGS): revise building-array index to match
c                                  ISC
c --- V5.4-V5.4     000602_8 (DGS): add constraint that buoyancy flux
c                                   (FLUXB) be greater than zero
c                                   to conditions that must be met for
c                                   calling partial penetration sub.
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c                   000602  (DGS): add initial sigmay,z arrays
c                   000602  (DGS): add MFOG option to process emissions
c                                  file from CTEMISS
c --- V5.0-V5.3     991222b (DGS): reset momentum flux using FMFAC
c                   991222b (DGS): pass momentum flux to STKTIP
c --- V5.0-V5.0     980807  (DGS): use final rise CALMET/PROFILE winds 
c                                  to set release step
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V5.0-V5.0     980430  (DGS): assign PROBLEM (compiler warning)
c --- V5.0-V5.0     980304  (DGS): place source sigmas in SY0,SZ0
c --- V4.0-V5.0     971107  (DGS): modify partial penetration logic to
c                                  be consistent with POINTS1
c                   971107  (DGS): add building downwash
c                   971107  (DGS): remove volume flux from PT2 input
c                                  processing
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c                   971107  (DGS): add observed inversion strength
c
c --- INPUTS:
c            IP - integer - PTEMARB.DAT file index
c             I - integer - Point source index
c         NSPEC - real    - Number of species modeled
c         NDHRB - integer - Julian day, hour beginning current step
c         NSECB - integer - Seconds at beginning of current step
c         NDHRE - integer - Julian day, hour at end of current step
c         NSECE - integer - Seconds at end of current step
c         DTSEC - real    - Length (seconds) of a basic time step
c         SMXI1 - real    - Reciprocal of speed required to travel max
c                           allowed distance in 1 timestep
c           LDB - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c         METFM - integer - Meteorological data format
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW, SYMIN, SZMIN, PTG0(2), WSCALM, TBD
c     Common block /DISPDAT/ variables:
c           JSUP
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MTIP, MSHEAR, MPARTL, MHFTSZ, MFOG, MBDW,
c           MRISE
c     Common block /FOG/ variables:
c           TXSMXFOG
c     Common block /GRID/ variables:
c           IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /METHD/ variables:
c           LCALGRD, I2DMET
c     Common block /METHR/ variables:
c           PLEXP, PTG(2), DPTINVO
c     Common block /PUFF/ variables:
c           NPUFFS
c     Common block /PT2/ variables:
c           TIEM2(8,mxpt2), NPT2,
c           BHT2(36,mxpt2), BWD2(36,mxpt2),
c           BLN2(36,mxpt2),XBADJ2(36,mxpt2),YBADJ2(36,mxpt2),
c           SYIPT2(mxqstep,mxpt2),SZIPT2(mxqstep,mxpt2),ZPLATPT2(mxpt2)
c           NSTEP2(mxemdat), NDHRQB2(mxqstep,mxemdat),
c           NSECQB2(mxqstep,mxemdat),
c           NDHRQE2(mxqstep,mxemdat),NSECQE2(mxqstep,mxemdat),
c           TSTAK2(mxqstep,mxpt2),EXITW2(mxqstep,mxpt2),
c           QSTAK2(mxspec,mxqstep,mxpt2)
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXQSTEP, MXPT2, MXRISE,
c           IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /FOG/ variables:
c           TXSMXFOG
c     Common block /PT2/ variables:
c           NEWPT2(mxqstep,mxpt2)
c     Common block /PUFF/ variables:
c           all variables in common block
c     Common block /SLUG/ variables:
c           all variables in common block
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c --- POINTS2 called by:  INITPUF
c --- POINTS2 calls:      RLSMET, ROLLDN, PTLAPS, SETCSIG, SIGTY,
c                         SIGTZ, STKTIP, DWSIGS, PRSS, PRFIN, PRM,
c                         PRFINSH, PRFPP, NUMMET, NUMRISE, NUMCLIP,
c                         WAKE_INI, WAKE_FIN, CAV_CONC, WAKE_DBG,
c                         NRISEHD, SWAP, INJECT, DELTSEC,
c                         ZEROTAB, SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'comparm.puf'
      include 'csigma.puf'
      include 'dispdat.puf'
      include 'flags.puf'
      include 'fog.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'puff.puf'
      include 'pt2.puf'
      include 'slug.puf'
      include 'srctab.puf'
c
      real q(mxspec),qcav(mxspec)
      logical ldb,problem
      logical LBRIGGS

c --- PRIME logicals to configure primary (LPRM) and cavity (LCAV) puff
      logical lprm,lcav
c
      data rt2/1.4142136/, rt2pi/2.5066283/, piby4/0.7853982/
c --- Set minimum allowed potential temperature gradient PTGRAD0,
      data ptgrad0/.005/
c --- Set minimum allowed wind speed for building downwash
      data wsdw0/1.0/

c --- Set source type (2 for POINTS2)
      data itype2/2/

c --- Initialize local ISC building downwash variables
      index=0
      hb=0.0
      hw=0.0
      heff2=0.0
      zly=0.0
      rinit=0.0

c --- Transfer selected data from TIEM2 array for clarity
      xgrd=tiem2(1,i)
      ygrd=tiem2(2,i)
      htstak=tiem2(3,i)
      diam=tiem2(4,i)
      elstak=tiem2(5,i)
      idownw=NINT(tiem2(6,i))
      fmfpt2=tiem2(7,i)
c
c --- Initialize number of new puffs from this source, this timestep
      newpt2(i)=0
c
c ***
      if(ldb) then
         write(io6,*)
         write(io6,*) 'POINTS2:  Source Number    ',i
         write(io6,*) '--------'
      endif
c ***
c
c --- Do not generate puffs for this source if all emissions are ZERO!
      qsum=0.0
      do it=1,nstep2(ip)
         do is=1,nspec
            qsum=qsum+qstak2(is,it,i)
         enddo
      enddo
      if(qsum.EQ.0.0) return
c
c --- Determine the met. grid point closest to the stack
      ixs=1.0+xgrd
      iys=1.0+ygrd
c
c --- Source off the computational grid -- write a FATAL message
      if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.iys.lt.jbcomp.or.iys.gt.
     1   jecomp)then
         write(io6,20)i,ixs,iys
20       format(/1x,'FATAL -- a point source with variable emissions',
     1   ' is off the computational grid'/1x,'source no. (i) = ',i6,2x,
     2   'nearest grid point (ixs,iys) = (',i5,',',i5,')')
         problem=.TRUE.
         return
      endif
c
c --- Extract stack height wind speed & other met. variables
c --- and set CALM configuration if triggered
      call RLSMET(ldb,ixs,iys,htstak,mfact,
     &            mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &            ustr,wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)
c
c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
         temp=temp2d(ixs,iys)
      elseif(i2dmet.EQ.0) then
         temp=tempss(issta)
      else
         write(*,*)'Subr. POINTS2:  Invalid I2DMET = ',i2dmet
         stop
      endif
c
c --- Compute the number of puffs/slugs released this timestep
c --- from this source, consistent with transport constraints
      npnewt=ws*smxi1
c --- Add in the number of puffs/slugs needed to resolve changes in
c --- the emissions data, for conservative estimate
      npnewt=npnewt+nstep2(ip)
      newpuft=newpuf+npnewt
c --- If puff arrays are full, remove puffs that are off the grid
c --- and "roll down" arrays to make room for new puffs
c --- (this also applies to the DA file of tabulated arrays)
      if(npuffs+newpuft.gt.mxpuff) call ROLLDN(np)
c --- Check to see if roll-down was adequate
      if(npuffs+newpuft.gt.mxpuff)then
         write(io6,*) ' ERROR in subr. POINTS2'
         write(io6,*)'Too many puff on grid for array dimensions -- ',
     1   'NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuft,
     2   ' MXPUFF = ',mxpuff
         stop
      endif

c --- Loop over emission periods within this timestep
      do 100 it=1,nstep2(ip)
c
c --------------------------------------------------------------------
c ---    Do not generate puff for this step if all emissions are ZERO!
c --------------------------------------------------------------------
         qsum=0.0
         do is=1,nspec
            qcav(is)=0.0
            q(is)=qstak2(is,it,i)
            qsum=qsum+q(is)
         enddo
         if(qsum.EQ.0.0) goto 100
c ---    Place source data for this step into local variables
         tstak=tstak2(it,i)
         exitw=exitw2(it,i)

c ---    Initialize source tabulation arrays to zero
         call ZEROTAB

c ---    Set specific plume rise variables for Briggs and Numerical
c ---    rise to clarify treatment
c ---    Briggs
         xfinm_B=0.0
         xfinb_B=0.0
         zfinm_B=0.0
         zfinb_B=0.0
         xf_B=0.0
         rise_B=0.0
         fmix_B=1.0
         hmax_B=0.0
         bidsq_B=0.0
         heff_B=0.0
c ---    Numerical
         xfinm_N=0.0
         xfinb_N=0.0
         zfinm_N=0.0
         zfinb_N=0.0
         xf_N=0.0
         rise_N=0.0
         fmix_N=1.0
         hmax_N=0.0
         bidsq_N=0.0
         heff_N=0.0

c -------------------------------------------------------------
c --- Compute the final plume rise and distance to final rise
c -------------------------------------------------------------
c ---    Calculate fluxes
         dtemp=tstak-temp
         dtemp=amax1(dtemp,0.0)
c ---    Buoyancy flux:  2.4516625 = g/4., where g = 9.80665 m/s**2
         fluxb=(2.4516625*diam**2*exitw/tstak)*dtemp
c ---    Momentum flux
         fluxm=0.25*(exitw*diam)**2*temp/tstak
c ---    Apply vertical momentum flux factor of zero or one
c ---    Use simple test for ZERO instead of forming the product:
c ---    fluxm=fluxm*fmfpt2
         if(fmfpt2.LT.0.5) fluxm=0.0
c
c ---    Adjustment for stack-tip downwash (NOT for bldg downwash!)
         if(mtip.EQ.1) then
            call stktip(htstak,diam,fluxm,exitw,ws,tipdw)
         else
            tipdw=0.0
         endif

c --- Briggs Rise (always computed)
c ---------------------------------
c ---    Final plume rise (no downwash considered)
         call prfin(exitw,diam,fluxm,fluxb,ws,istab,sqrts,
     &              xfinm_B,xfinb_B,xf_B,zfinm_B,zfinb_B,rise_B)
c
c ---    Compute vertical wind shear effects
         if(mshear.eq.1)then
            call prfinsh(fluxb,ws,plexp,htstak,xfinb_B,istab,sqrts,
     1       zfinsh)
c ---        Final buoyant rise is the LOWER of the Briggs & shear hts.
             zfinb_B=amin1(zfinb_B,zfinsh)
c ---        Final plume rise is the HIGHER of momentum & buoyant hts.
             rise_B=amax1(zfinb_B,zfinm_B)
         endif
c
c ---    Adjust for partial penetration of elevated stable layer
c        if(mpartl.EQ.1 .and. istab.LE.3 .and. htstak.LT.dpbl) then
         if(mpartl.EQ.1 .and. istab.LE.4 .and. fluxb.GT.0.0) then
c ---       Set thickness (m) of transition region above mixing height
            dzinv=30.
c ---       Estimate potential temperature gradient above mixed layer
            if(LCALGRD) then
c ---          Use temperatures provided by met model
               htinv=amax1(dpbl,htstak)
               call ptlaps(ixs,iys,htinv,ptgrad0,dzinv,ptginv,tmix)
            else
c ---          Use default potential temperature lapse rate
               if(jsup.LE.4) then
                  ptginv=ptgrad0
               elseif(jsup.EQ.5) then
                  ptginv=amax1(ptg0(1),ptgrad0)
               else
                  ptginv=amax1(ptg0(2),ptgrad0)
               endif
            endif
c ---       Estimate potential temperature change across inversion
            if(dptinvo.GT.0.0) then
c ---          Use observed value provided in met file
               dptinv=dptinvo
            else
               dptinv=ptginv*dzinv
            endif
            call prfpp(rise_B,fluxb,ws,htstak,dpbl,temp,ptginv,
     &                 dptinv,fmix_B,hmax_B)
c ---       Reset component final rise heights for use in gradual rise
            if(zfinb_B.GT.rise_B) zfinb_B=rise_B
            if(zfinm_B.GT.rise_B) zfinm_B=rise_B
c
         else
            fmix_B=1.0
            hmax_B=dpbl
         endif
c
c ---    Set variance associated with buoyancy-enhanced growth at
c ---    final rise
         bidsq_B=(rise_B/3.5)**2
c
c ---    Set final plume height
         heff_B=htstak-tipdw+rise_B
c
c ---    Set selected data in /CSIGMA/ for sigma calls
         call SETCSIG(idopty,idoptz,iru,ws,istab,el,sqrts,
     &                tsigv,tsigw,symin,szmin,heff_B,dpbl)

c ---    Numerical Rise (conditional)
c -------------------------------------
         if(mrise.EQ.2) then
c ---       Construct met. profiles at this grid cell
            call NUMMET(ixs,iys,ldb)
c ---       Set stack radius
            reff=0.5*diam
c ---       Set effective release height
            hteff=AMAX1(0.0,htstak-tipdw)
c ---       Prepare data header record for RISE.DAT file
c ---       (control for output to scratch file is within subroutine)
            call NRISEHD(itype2,i,ndhrb,nsecb,ndhre,nsece,
     &                   ndhrqb2(it,ip),nsecqb2(it,ip),ndhrqe2(it,ip),
     &                   nsecqe2(it,ip),elstak,hteff,tstak,reff,exitw,
     &                   xgrd,ygrd)
c ---       Compute plume rise
            mprime=0
c ---       Use full MXRISE points in rise table
            ntr=mxrise
            call NUMRISE(mprime,ldb,hteff,tstak,reff,exitw,syipt2(it,i),
     &                   szipt2(it,i),ntr,xtr,ztr,rtr,htr)
            rise_N=htr(ntr)
c ---       Adjust for partial penetration of elevated stable layer
            if(mpartl.EQ.1 .and. istab.LE.4 .and. fluxb.GT.0.0) then
c ---          (ptginv, dptinv computed in Briggs Rise section)
               call PRFPP(rise_N,fluxb,ws,htstak,dpbl,temp,ptginv,
     &                    dptinv,fmix_N,hmax_N)
c ---          Clip rise table at new final height
               call NUMCLIP(mxrise,hteff,rise_N,ntr,xtr,ztr,rtr,htr)
            else
               fmix_N=1.0
               hmax_N=dpbl
            endif
c ---       Assign final plume height and distance
            heff_N=ztr(ntr)
            xf_N=xtr(ntr)
c ---       Variance associated with buoyancy-enhanced growth
c ---       @ final rise
            bidsq_N=(rise_N/3.5)**2
         endif

c --------------------------------------------------------------------
c --- Determine if building downwash effects on plume rise and sigmas
c --- should be considered
c --------------------------------------------------------------------
         sz0dw=0.0
         sy0dw=0.0
         xshift=0.0
         xshift2=0.0
         lprm=.FALSE.
         lcav=.FALSE.
c ---    Initialize downwash flag to zero (no building downwash)
c ---    Note:  idw=0  no downwash
c ---           idw=1  Huber-Snyder model
c ---           idw=2  Schulman-Scire model
c ---           idw=3  PRIME model (puff released from primary source)
c ---           idw=4  PRIME model (puff released from cavity source)
         idw=0

         if(idownw.EQ.1 .AND. ws.GE.wsdw0 .AND. mbdw.EQ.2) then
c        --------------------------------
c        --- PRIME Downwash Section
c        --------------------------------
            mprime=1
c ---       Get direction-specific building data (direction at stack ht)
            index=INT(0.1*FLOAT(ivec)+0.4999)
            if(index.eq.0)index=36
            dsbh=bht2(index,i)
            dsbw=bwd2(index,i)
            dsbl=bln2(index,i)
            xadj=xbadj2(index,i)
            yadj=ybadj2(index,i)
            hl=AMIN1(dsbh,dsbw)
c ---       Screen for GEP stack (regulatory definition)
            geptest=dsbh+1.5*hl
            if(htstak.LT.geptest) then
               idw=3
c ---          Set stack radius
               reff=0.5*diam
c ---          Set met data at top of building
               call RLSMET(ldb,ixs,iys,dsbh,mfact,
     &                  mfact0b,ilayer,wsb,flowb,ivecb,istabb,dpbl,
     &                  elb,ustrb,wstrb,tsigvb,tsigwb,iru,issta,
     &                  sqrtsb,idoptyb,idoptzb)
c ---          Reset /CSIGMA/ data for met data at top of building
               if(mrise.EQ.2) then
                  zht=AMAX1(heff_N,dsbh)
               else
                  zht=AMAX1(heff_B,dsbh)
               endif
               call SETCSIG(idoptyb,idoptzb,iru,wsb,istabb,elb,sqrtsb,
     &                   tsigvb,tsigwb,symin,szmin,zht,dpbl)

c ---          Refresh /WAKEDAT/ variables
               call WAKE_INI(ldb,istab,iru,dsbh,dsbw,dsbl,xadj,yadj,
     &                    wsb,ws,tsigvb,tsigwb,idoptyb,idoptzb)
c ---          Construct met. profiles at this grid cell
               call NUMMET(ixs,iys,ldb)
c ---          Prepare data header record for RISE.DAT file
c ---          (control for output to scratch file is within subroutine)
               call NRISEHD(itype2,i,ndhrb,nsecb,ndhre,nsece,
     &                   ndhrqb2(it,ip),nsecqb2(it,ip),ndhrqe2(it,ip),
     &                   nsecqe2(it,ip),elstak,htstak,tstak,
     &                   reff,exitw,xgrd,ygrd)
c ---          Compute plume rise and wake structure
c ---          Use full MXRISE points in rise table
               ntr=mxrise
               call NUMRISE(mprime,ldb,htstak,tstak,reff,exitw,
     &                syipt2(it,i),szipt2(it,i),ntr,xtr,ztr,rtr,htr)
c ---          Pass final wake structure to source arrays without BID
               call WAKE_FIN(ldb,nwk,xwk,szwk,sywk,drwk,szw0,syw0,
     &                       ncv,xcv,szcv,sycv,szc0,syc0,fqcvpt2(i))
c
c ---          Set logicals (primary & cavity) and partition mass
               if(fqcvpt2(i).LE.0.001) then
                  lcav=.FALSE.
                  lprm=.TRUE.
                  do is=1,nspec
                     qcav(is)=0.0
                  enddo
               elseif(fqcvpt2(i).GE.0.999) then
                  lcav=.TRUE.
                  lprm=.FALSE.
                  do is=1,nspec
                     qcav(is)=q(is)
                     q(is)=0.0
                  enddo
               else
                  lcav=.TRUE.
                  lprm=.TRUE.
                  do is=1,nspec
                     qcav(is)=q(is)*fqcvpt2(i)
                     q(is)=q(is)-qcav(is)
                  enddo
               endif
c ---          Compute near-cavity concentrations for current source, 
c ---          return location of cavity source on the met grid, and
c ---          return the distance from the source to the end of the
c ---          cavity transition zone
               call CAV_CONC(ldb,nspec,q,qcav,xgrd,ygrd,
     &                       ntr,xtr,ztr,flow,dpbl,xcavgrd,ycavgrd,
     &                       xshift,xshift2)
c
c ---          Assign final plume height, rise, and distance for primary
c ---          source
               heff_N=ztr(ntr)
               rise_N=htr(ntr)
               xf_N=xtr(ntr)
c
c ---          Reset BID and tip downwash
               tipdw=0.0
               bidsq_N=(rise_N/3.5)**2
c
c ---          Report selected data to file for debug
               if(ldb) call WAKE_DBG(io6,ntr,xtr,ztr,rtr,htr,
     &                              .FALSE.,htstak)
            endif
         endif

         if(idownw.GE.1 .AND. ws.GE.wsdw0 .AND. mbdw.EQ.1) then
c        --------------------------------
c        --- HS/SS Downwash Section
c        --------------------------------
c ---       Set direction-specific building width and height
            index=INT(0.1*FLOAT(ivec)+0.4999)
            if(index.eq.0)index=36
            hb=bht2(index,i)
            hw=bwd2(index,i)
            hl=amin1(hb,hw)
c
c ---       Assign platform height
            zplat=0.0
            if(idownw.EQ.2) zplat=zplatpt2(i)

c ---       Calculate the momentum rise at 2*hb and test for downwash
            xarg=2.*hb
            call prm(diam,exitw,fluxm,ws,istab,sqrts,xarg,
     &               xfinm_B,zfinm_B,z2hb)
            heff2=htstak+z2hb
            dwtest=hb+1.5*hl
c
            if((heff2-zplat).LE.dwtest) then
c ---          Set downwash flag to ACTIVE
               idw=1
c ---          (1)  Compute downwash sigmas at 10*hl for setting up
c ---          virtual sigmas at the source
               xarg10=10.*hl
               xarg10km=0.001*xarg10
               targ10=xarg10/ws
               call dwsigs(tbd,hw,hb,mhftsz,ws,htstak,heff2,zplat,
     &                     xarg10,sy10,sz10)
c
c ---          (2)  Alter Final Plume rise if Schulman-Scire (SS) active
               sstest=hb+0.5*hl
               if((htstak-zplat).LT.sstest) then
c ---             Schulman-Scire downwash ACTIVE
                  idw=2
c ---             Set sigmas at 3*hl
                  xarg=3.*hl
                  call dwsigs(tbd,hw,hb,mhftsz,ws,htstak,heff2,zplat,
     &                        xarg,sy3,sz3)
c ---             Determine line source parameters, ZLY and RINIT
c ---             Calculate ZLY
                  if((heff2-zplat).GT.(1.2*hb)) then
                     zly=0.0
                  elseif(sy3.GT.sz3) then
                     zly=rt2pi*(sy3-sz3)
                  else
                     zly=0.0
                  endif
c ---             Calculate initial radius of plume, RINIT
                  rinit=rt2*sz3
c ---             Compute SS final plume rise
c ---             Set max distance to final rise
                  xarg=amax1(xfinm_B,xfinb_B)
                  call prss(xarg,zly,rinit,ws,istab,sqrts,diam,
     &                   exitw,fluxm,fluxb,xfinm_B,xfinb_B,rise_B)
c
c ---             Reset BID and tip downwash = 0
                  bidsq_B=0.0
                  tipdw=0.0
               endif
c
c ---          Set final plume height
               heff_B=htstak-tipdw+rise_B
c
            endif
         endif

c ---    Select appropriate rise results
c --------------------------------------
         if(idw.EQ.1 .OR. idw.EQ.2) then
c ---       ISC-type downwash for this source: assign Briggs results
            LBRIGGS=.true.
         elseif(idw.EQ.3 .OR. idw.EQ.4) then
c ---       PRIME downwash for this source: assign Numerical results
            LBRIGGS=.false.
         elseif(idw.EQ.0 .AND. mrise.EQ.1) then
c ---       No downwash for this source and Briggs rise is selected
            LBRIGGS=.true.
         elseif(idw.EQ.0 .AND. mrise.EQ.2) then
c ---       No downwash for this source and Numerical rise is selected
            LBRIGGS=.false.
         else
            write(io6,*) ' ERROR in subr. POINTS1'
            write(io6,*)'Invalid source treatment found -- ',
     1      'IDW(0,1,2,3, or 4) = ',idw,' MRISE(1 or 2) = ',mrise
            write(*,*)
            stop 'Halted in POINTS1 -- see list file.'
         endif
         if(LBRIGGS) then
            xfinm=xfinm_B
            xfinb=xfinb_B
            zfinm=zfinm_B
            zfinb=zfinb_B
            xf=xf_B
            rise=rise_B
            fmix=fmix_B
            hmax=hmax_B
            bidsq=bidsq_B
            heff=heff_B
         else
            xfinm=xfinm_N
            xfinb=xfinb_N
            zfinm=zfinm_N
            zfinb=zfinb_N
            xf=xf_N
            rise=rise_N
            fmix=fmix_N
            hmax=hmax_N
            bidsq=bidsq_N
            heff=heff_N
         endif

c ---------------------------------------------------------
c ---    Compute number of puffs for this emissions period
c ---------------------------------------------------------
c ---    Use CALMET/PROFILE winds at final rise to set release/sampling
c ---    data and to check MFACT0 determination (slug changed to puff
c ---    only if CALM is detected at both heights)
         if(metfm.EQ.1 .OR. metfm.EQ.4 .OR. metfm.EQ.5) then
            call RLSMET(ldb,ixs,iys,heff,mfact,
     &               mfact0fr,ilayerfr,wsfr,flowfr,ivecfr,istab,dpbl,
     &               el,ustr,wstr,tsigvfr,tsigwfr,iru,issta,sqrtsfr,
     &               idoptyfr,idoptzfr)
            mfact0=MAX0(mfact0,mfact0fr)
            wsnew=AMAX1(ws,wsfr)
         else
            wsnew=ws
         endif

c ---    Start-time for emission period during timestep
         if(ndhrqb2(it,ip).LT.ndhrb) then
            ndhr1=ndhrb
            nsec1=nsecb
         elseif(ndhrqb2(it,ip).EQ.ndhrb .AND.
     &          nsecqb2(it,ip).LT.nsecb) then
            ndhr1=ndhrb
            nsec1=nsecb
         else
            ndhr1=ndhrqb2(it,ip)
            nsec1=nsecqb2(it,ip)
         endif
c ---    End-time for emission period during timestep
         if(ndhrqe2(it,ip).GT.ndhre) then
            ndhr2=ndhre
            nsec2=nsece
         elseif(ndhrqe2(it,ip).EQ.ndhre .AND.
     &          nsecqe2(it,ip).GT.nsece) then
            ndhr2=ndhre
            nsec2=nsece
         else
            ndhr2=ndhrqe2(it,ip)
            nsec2=nsecqe2(it,ip)
         endif

c ---    Duration of emission period within timestep (seconds)
         call DELTSEC(ndhr1,nsec1,ndhr2,nsec2,ntemit)
         temit=FLOAT(ntemit)
c ---    Apply transport constraints
         npnewt=wsnew*smxi1*temit/dtsec+1
         npnewt=MIN(npnewt,mxnew)
         temit=temit/FLOAT(npnewt)

c ---    PRIME downwash produces both a primary and a cavity source
         new=npnewt
         if(lcav.AND.lprm) new=2*npnewt
c ---    Update puff numbers
c ---    Individual puff release-steps
         newpt2(i)=newpt2(i)+npnewt
c ---    Total new puffs
         newpuf=newpuf+new

c ---    If puff arrays are full, remove puffs that are off the grid
c ---    and "roll down" arrays to make room for new puffs
c ---    (this also applies to the DA file of tabulated arrays)
         if(npuffs+newpuf.gt.mxpuff) call rolldn(np)
c ---    Check to see if roll-down was adequate
         if(npuffs+newpuf.gt.mxpuff)then
            write(io6,*) ' ERROR in subr. POINTS2'
            write(io6,*)'Too many puff on grid for array dimensions',
     1      ' -- NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2      ' MXPUFF = ',mxpuff
            write(*,*)
            stop 'Halted in POINTS2 -- see list file.'
         endif

c ---------------------------
c --- FOG processing Option
c ---------------------------
         if(MFOG.GT.0) then
c ---       Screen for minimum temperature excess
            txsmxfog=AMIN1(txsmxfog,dtemp)
c ---       Compute initial sigma consistent with volume flux
            vf0=piby4*exitw*diam**2
            ws3= wsnew * wsnew * wsnew
            if(ws3.GE.(vf0/temit**2)) then
               sigvf=SQRT(vf0/wsnew)/rt2pi
            else
               sigvf=((vf0*temit)**.3333333)/rt2pi
            endif
         else
            sigvf=0.0
         endif

c ------------------------------------
c --- Set initial sigmas at the source
c ------------------------------------
         szini=AMAX1(sigvf,szipt2(it,i))
         syini=AMAX1(sigvf,syipt2(it,i))

         szsrc=AMAX1(szmin,szini)
         sysrc=AMAX1(symin,syini)

         if(idw.EQ.3) then
c ---       PRIME: set values without initial sigma option
            sysrc=AMAX1(symin,syw0)
            sysrc2=AMAX1(symin,syc0)
            szsrc=AMAX1(szmin,szw0)
            szsrc2=AMAX1(szmin,szc0)
      
         elseif(idw.GT.0) then
c ---       Downwash is active: initial sigmas at source must reproduce
c ---       the modified sigmas at 10 hl, using ambient growth curve.
c ---       The modified sigmas add the downwash sigmas and any other
c ---       initial sigmas in quadrature.
c
c ---       (1)  Add initial sigmas to downwash sigmas at 10 hl
            if(szini.GT.0.) then
               sigz=SQRT(szini**2+sz10**2)
            else
               sigz=sz10
            endif
            if(syini.GT.0.) then
               sigy=SQRT(syini**2+sy10**2)
            else
               sigy=sy10
            endif
c
c ---       (2)  Calculate virtual time/distance for these sigmas
            call sigtz(sigz,0.0,0.0,htstak,szamb,v10tz,v10dz)
            call sigty(sigy,0.0,0.0,syamb,v10ty,v10dy)
c
c ---       (3)  Set corresponding sigmas at the source (sy0dw,sz0dw)
c ---       this will allow the effects of downwash on the sigmas to
c ---       influence puff size beyond 10*hl
            ydxkm=amax1(0.0,v10dy-xarg10km)
            ydt=amax1(0.0,v10ty-targ10)
            zdxkm=amax1(0.0,v10dz-xarg10km)
            zdt=amax1(0.0,v10tz-targ10)
            call sigtz(0.0,zdxkm,zdt,htstak,sz0dw,virtz,virdz)
            call sigty(0.0,ydxkm,ydt,sy0dw,virty,virdy)

            sysrc=amax1(symin,sy0dw)
            szsrc=amax1(szmin,sz0dw)
         endif

c******
      if(ldb)then
         write(io6,*)
         write(io6,*)'Variable emissions step: ',it
         write(io6,204)i,ilayer,ixs,iys,ws,istab,dpbl,issta,npnewt,
     1    newpuf,temit
204      format(5x,'IS: ',i5,2x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'NPNEWT: ',i4,2x,'NEWPUF: ',i5/
     3    5x,'DT: ',f7.2)
c
         write(io6,206)htstak,diam,exitw,tstak,
cfrr 1    tempss(issta),dtemp,fluxb,fluxm,xf,heff,tipdw
     1    temp,dtemp,fluxb,fluxm,xf,heff,tipdw
206      format(5x,'HTSTAK: ',f6.1,2x,'DIAM: ',f6.3,2x,'EXITW: ',
     1    f6.3,2x,'TSTAK: ',f6.2,2x,'TEMPSS: ',f6.2,2x,'DTEMP: ',f6.3,
     2    2x,'FLUXB : ',f8.3,2x,'FLUXM: ',f6.1/5x,'XF: ',f6.1,2x,
     3    'HEFF: ',f6.1,2x,'TIPDW: ',f6.1)
c
         write(io6,210)idw,rise
210      format(5x,'IDW: ',i5,2x,'RISE : ',f8.2)
         if(mbdw.EQ.2) then
            write(io6,*) 'hb,hw,index = ',dsbh,dsbw,index
            write(io6,*) 'len,[x,y]adj = ',dsbl,xadj,yadj
         else
            write(io6,*) 'hb,hw,index = ',hb,hw,index
         endif
c
         write(io6,208)i,np,iru,sysrc,szsrc,temit,istab
208      format(5x,'I: ',i5,2x,'NP: ',i5,2x,
     1    'IRU: ',i2,2x,'SIGYB: ',f8.2,2x,'SIGZB: ',f8.2,2x/
     2    5x,'DT: ',f7.2,2x,'ISTAB: ',i1)
         if(mfog.GT.0) write(io6,*)'TXSMXFOG = ',txsmxfog
      endif
c*****
c ----------------------------------------------------------
c ---    Initialize current hour's new puffs for this source
c ----------------------------------------------------------
         if((.NOT.lcav .AND. .NOT.lprm) .OR. lprm) then
            do 50 j=1,npnewt
            np=np+1
c
c ---      Use SWAP to start with all puff/slug variables equal to zero
            call swap(np,0)
c
c ---       Fill non-zero values
            xpb(np)=xgrd
            ypb(np)=ygrd
            zitibl(np)=-1.0
            elbase(np)=elstak
            sigyb(np)=sysrc
            sigzb(np)=szsrc
c ---       Final plume rise results
            zfinal(np)=heff
            zpb(np)=heff
            zpe(np)=heff
            xfinal(np)=xf
            bidfnl(np)=bidsq
c ---       Intermediate results for calc. gradual rise
            fb(np)=fluxb
            fm(np)=fluxm
            xbfin(np)=xfinb
            xmfin(np)=xfinm
            zbfin(np)=zfinb
            zmfin(np)=zfinm
            stipdw(np)=tipdw
            isplit(np)=1
c ---       Time-of-release data
            ht0(np)=htstak
            exitw0(np)=exitw
            diam0(np)=diam
            temit0(np)=temit
            ws0(np)=ws
            istab0(np)=istab
            sqrts0(np)=sqrts
            iru0(np)=iru
            sigv0(np)=tsigv
            sigw0(np)=tsigw
            el0(np)=el
            plexp0(np)=plexp
c ---       Set vector/scalar ws ratio to 1.0
            srat0(np)=1.0
c ---       Additional time-of-release parameters needed for
c ---       receptor-specific calculations (downwash)
            idw0(np)=idw
            hb0(np)=hb
            hw0(np)=hw
            heff20(np)=heff2
            zly0(np)=zly
            sysrc0(np)=syini
            szsrc0(np)=szini
            r0(np)=rinit
            xshift0(np)=xshift
            sy0(np)=sysrc
            sz0(np)=szsrc

c ---       Place end-time of emission period for this puff into
c ---       TMTOTB(mxpuff) array, expressed as fraction of the timestep
c ---       This will be used in COMP when computing the sampling steps
c ---       used to advect the freshly emitted puff during remainder
c ---       of the timestep, and then reset.
c ---       Seconds from start of emissions period to end of timestep
            call DELTSEC(ndhr1,nsec1,ndhre,nsece,ntot)
            tmtotb(np)=(FLOAT(ntot)-temit*j)/dtsec

c ---       Emission period index for this puff
            iemstep(np)=it

c ---       Set puff identity where IRLSNUM is the puff number released
c ---       from a source this time step, ISRCNUM is the source number
c ---       of type ISRCTYP from which the puff was released.
c ---       (Type =2 for point sources with VARIABLE emiss.)
            jj=newpt2(i)-npnewt+j
            irlsnum(np)=jj
            isrcnum(np)=i
            isrctyp(np)=2
c
c ----------------------------------------------------------
c ---    Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---       Note that "oldest" end of slug is at the source, as is the
c ---       "newest end; oldest end moves away and grows during the
c ---       step, while newest end remains fixed in size at the source.
c
            if(mslug.EQ.1 .AND. mfact0.GT.0) then
c ---          Set coordinates of oldest end of slug (met. grid units)
               xpe(np)=xpb(np)
               ype(np)=ypb(np)
               xtote(np)=xtotb(np)
               tmtote(np)=tmtotb(np)
c ---          Set sigmas for oldest end of slug
               sigye(np)=sigyb(np)
               sigze(np)=sigzb(np)
            endif
c
c ------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c ------------------------------------------------------------------
            call inject(np,nspec,temit,mfact0,q,heff,hmax,dpbl,fmix,
     &                  istab)

c ------------------------------------------------------------------
c ---       Transfer tabulated arrays record to DA file using full
c ---       MXRISE dimension
c ------------------------------------------------------------------
            call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))
c
50          continue
         endif

c ------------------------------------------------------------
c ---    Initialize new puffs for PRIME cavity source (idw=4)
c ------------------------------------------------------------
         if(lcav) then
         do 150 j=1,npnewt
            np=np+1
c
c ---       Use SWAP to start with all puff/slug variables equal to zero
            call swap(np,0)
c
c ---       Fill non-zero values
            xpb(np)=xcavgrd
            ypb(np)=ycavgrd
            zitibl(np)=-1.0
            elbase(np)=elstak
            sigyb(np)=sysrc2
            sigzb(np)=szsrc2
            stipdw(np)=tipdw
            isplit(np)=1
c ---       Time-of-release data
c ---       Set release ht to building ht for this cavity source (puffs
c ---       are released at ZERO, but are initially advected with wind
c ---       at building ht)
            ht0(np)=dsbh
            exitw0(np)=0.0
            diam0(np)=0.0
            temit0(np)=temit
            ws0(np)=ws
            istab0(np)=istab
            sqrts0(np)=sqrts
            iru0(np)=iru
            sigv0(np)=tsigv
            sigw0(np)=tsigw
            el0(np)=el
            plexp0(np)=plexp
c ---       Set vector/scalar ws ratio to 1.0
            srat0(np)=1.0
c ---       Additional time-of-release parameters needed for
c ---       receptor-specific calculations (downwash)
            idw0(np)=4
            hb0(np)=dsbh
            sysrc0(np)=0.0
            szsrc0(np)=0.0
            hw0(np)=dsbw
            xshift0(np)=xshift2
            sy0(np)=sysrc2
            sz0(np)=szsrc2

c ---       Place end-time of emission period for this puff into
c ---       TMTOTB(mxpuff) array, expressed as fraction of the timestep
c ---       This will be used in COMP when computing the sampling steps
c ---       used to advect the freshly emitted puff during remainder
c ---       of the timestep, and then reset.
c ---       Seconds from start of emissions period to end of timestep
            call DELTSEC(ndhr1,nsec1,ndhre,nsece,ntot)
            tmtotb(np)=(FLOAT(ntot)-temit*j)/dtsec

c ---       Emission period index for this puff
            iemstep(np)=it

c ---       Set puff identity where IRLSNUM is the puff number released
c ---       from a source this time step, ISRCNUM is the source number
c ---       of type ISRCTYP from which the puff was released.
c ---       (Type =2 for point sources with VARIABLE emiss.)
            jj=newpt2(i)-npnewt+j
            irlsnum(np)=jj
            isrcnum(np)=i
            isrctyp(np)=2
c
c ----------------------------------------------------------
c ---       Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---       Note that "oldest" end of slug is at the source, as is the
c ---       "newest end; oldest end moves away and grows during step,
c ---       while newest end remains fixed in size at the source.
c
            if(mslug.EQ.1 .AND. mfact0.GT.0) then
c ---          Set coordinates of oldest end of slug (met. grid units)
               xpe(np)=xpb(np)
               ype(np)=ypb(np)
               xtote(np)=xtotb(np)
               tmtote(np)=tmtotb(np)
c ---          Set sigmas for oldest end of slug
               sigye(np)=sigyb(np)
               sigze(np)=sigzb(np)
            endif
c
c ---------------------------------------------------------------------
c ---       Inject emissions into proper layer (above/below mixing ht.)
c ---------------------------------------------------------------------
            call inject(np,nspec,dt,mfact0,qcav,0.0,hmax,dpbl,fmix,
     &                  istab)

c ------------------------------------------------------------------
c ---       Transfer tabulated arrays record to DA file using full
c ---       MXRISE dimension
c ------------------------------------------------------------------
            call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

150      continue
         endif


c --- End loop over emission periods within this timestep
100   continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine lines1(nspec,dthr,xtmp1,ldbhr,mfact,metfm,np,
     &                  newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                 LINES1
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff/slug variables for
c               LINE SOURCES with constant emissions
c
c --- UPDATE
c --- V5.75-V6.261  080520  (DGS): Place rise tables in DA file
c --- V5.74-V5.75   050225  (DGS): Add DPBL arg to SETCSIG for TAULY
c --- V5.72-V5.74   040715  (DGS): add METFM=5 (AERMET)
c --- V5.7-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.4-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.0     980807  (DGS): use final rise CALMET/PROFILE winds 
c                                  to set release step
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V5.0-V5.0     980304  (DGS): drop any new puffs if emissions = 0 
c --- V4.0-V5.0     971107  (DGS): add variable emissions factor call
c                                  to function VEMFAC
c                   971107  (DGS): alter calling arg for SETLINE, used
c                                  for both LINES1 and LINES2
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c
c --- INPUTS:
c         NSPEC - real    - Number of species modeled
c          DTHR - real    - Length (seconds) of a basic time step
c         XTMP1 - real    - Reciprocal of speed required to travel max
c                           allowed distance in 1 timestep
c         LDBHR - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c         METFM - integer - Meteorological data format
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW, SYMIN, SZMIN, WSCALM
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MTIP, MHFTSZ, MSHEAR
c     Common block /GRID/ variables:
c           DGRID, IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /LN1/ variables:
c           NLINES,XL,HBL,WBL,WML,DXL,FPRIMEL,WSEP,FPTOT,FBPT,
c           XLBEGGRD(mxlines),YLBEGGRD(mxlines),XLENDGRD(mxlines),
c           YLENDGRD(mxlines),HSL(mxlines),BELEVL(mxlines),
c           XLBAR,YLBAR,ORIENTL,MXNSEG,QTL(mxspec,mxlines),
c           ivln1(mxspec,mxlines),iq12ln1(mxspec,mxlines),
c           NLRISE
c     Common block /METHR/ variables:
c           PLEXP
c     Common block /METHD/ variables:
c           I2DMET
c     Common block /PUFF/ variables:
c           NPUFFS
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXLINES, MXSPEC, MXRISE
c           IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /LN1/ variables:
c           NEWLN1(mxline), NSEG(mxlines),
c     Common block /PUFF/ variables:
c           all variables in common block
c     Common block /SLUG/ variables:
c           all variables in common block
c     Common block /SRCTAB/ variables:
c           NTR, XTR(mxrise), ZTR(mxrise)
c
c --- LINES1 called by:  INITPUF
c --- LINES1 calls:      RLSMET, ROLLDN, HEFTRAN, SIGTY, SIGTZ, SETLINE,
c                        SETCSIG, SWAP, INJECT, VEMFAC, ZEROTAB,
c                        SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'

      include 'comparm.puf'
      include 'csigma.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methr.puf'
      include 'ln1.puf'
      include 'puff.puf'
      include 'slug.puf'
c frr(09/01)
      include 'methd.puf'
      include 'srctab.puf'

      real q(mxspec)
      logical ldbhr,problem,lcalm

c --- Set minimum allowed wind speed for building downwash (.GE.1)
      data wsdw0/1.0/

      data oneby2pi/0.1591549/,rt2pi/2.5066283/,rt2bypi/0.7978846/
      data zero/0.0/


c ***
      if(ldbhr) then
         write(io6,*)
         write(io6,*) 'LINES1:  Processing 1 Group of ',nlines,' lines'
      endif
c ***
c
c -------------------------------------------------------------------
c --- Get met data for block of line sources
c -------------------------------------------------------------------
c
c --- Determine the met. grid point closest to the CENTER of the array
c --- of line sources
      ixs=1.0+xlbar
      iys=1.0+ylbar
c
c --- Source off the computational grid -- write a FATAL message
      if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.iys.lt.jbcomp.or.iys.gt.
     1   jecomp)then
         i=1
         write(io6,20)i,ixs,iys
20       format(/1x,'FATAL -- a line source with constant emissions ',
     1   'is off the computational grid'/1x,'source no. (i) = ',i6,2x,
     2   'nearest grid point (ixs,iys) = (',i5,',',i5,')')
         problem=.TRUE.
         return
      endif

c --- Initialize source tabulation arrays to zero
      call ZEROTAB
c
c --- Extract wind speed & other met. variables;
c --- and set CALM configuration if triggered
      call rlsmet(ldbhr,ixs,iys,hbl,mfact,
     &            mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &            ustr,wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)
c
c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
         temp=temp2d(ixs,iys)
      elseif(i2dmet.EQ.0) then
         temp=tempss(issta)
      else
         write(*,*)'Subr. LINES1:  Invalid I2DMET = ',i2dmet
         stop
      endif

c --- Set logical to identify calm conditions
      if(ws.LT.wscalm) then
         lcalm=.TRUE.
      else
         lcalm=.FALSE.
      endif
c
c --- Calculate the virtual times and sigmas at Heffter transition
      uavg=amax1(.5,ws)
c
c --- Set selected data in /CSIGMA/ for sigma calls
      call setcsig(idopty,idoptz,iru,uavg,istab,el,sqrts,
     &            tsigv,tsigw,symin,szmin,hbl,dpbl)
c
      if(mhftsz.EQ.0)then
         szh=syh
         call sigty(syh,zero,zero,dum,thfty,dhfty)
      else
         call heftran(1,hsl(1),symin,szmin,zero,zero,zero,zero)
      endif
c
c --------------------------------------------------------------------
c --- Calculate modified plume rise parameters for group, and tabulate
c --- rise from point of full buoyancy (XFB) to point of final rise
c --------------------------------------------------------------------
c
c --- Find angle between flow and orientation of line sources (theta)
      theta=flow-orientl
c
c --- Compute attributes of the line sources for this meteorology,
c --- and update rise tabulation
      ntr=nlrise
      call setline(mshear,theta,ws,istab,sqrts,plexp,nlines,xl,
     &             hbl,wml,fprimel,wsep,fptot,fbpt,ntr,
     &             xle,xld,rzero,xtr,ztr)
c
c --- Set trig. factors for flow direction
      sinf=sin(flow)
      cosf=cos(flow)
c
c --- Find the along-flow coordinate that defines the line source
c --- element furthest upwind: (YY0GRD in met grid units)
c --- Rotate coord. system to place the yy-axis along the flow (line 1)
      yybeg=xlbeggrd(1)*sinf+ylbeggrd(1)*cosf
      yyend=xlendgrd(1)*sinf+ylendgrd(1)*cosf
      yy0grd=amin1(yybeg,yyend)
c --- Continue with other lines, if used
      do i=2,nlines
         yy=xlbeggrd(i)*sinf+ylbeggrd(i)*cosf
         yy0grd=amin1(yy0grd,yy)
         yy=xlendgrd(i)*sinf+ylendgrd(i)*cosf
         yy0grd=amin1(yy0grd,yy)
      enddo

c --- Use CALMET/PROFILE winds at final rise to set release/sampling
c --- data
      if(metfm.EQ.1 .OR. metfm.EQ.4 .OR. metfm.EQ.5) then
         heff=hbl+ztr(ntr)
         call rlsmet(ldbhr,ixs,iys,heff,mfact,
     &               mfact0fr,ilayerfr,wsfr,flowfr,ivecfr,istab,dpbl,el,
     &               ustr,wstr,tsigvfr,tsigwfr,iru,issta,sqrtsfr,
     &               idoptyfr,idoptzfr)
         wsnew=AMAX1(ws,wsfr)
      else
         wsnew=ws
      endif
c
c******
      if(ldbhr)then
         write(io6,204) ilayer,ixs,iys,ws,istab,dpbl,issta,theta
204      format(5x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'THETA: ',f5.1)
c
         write(io6,206) xtr(1),ztr(1),xle,xld,xtr(ntr),ztr(ntr)
206      format(5x,'XFB : ',f6.1,2x,'ZFB : ',f6.1,2x,'XLE : ',
     1    f6.1,2x,'XLD : ',f6.1,2x,'XFIN0: ',f6.1,2x,'ZFIN0: ',f6.1)
c
      endif
c*****
c
c --------------------------------------------------
c --- Loop over lines
c --------------------------------------------------
c
      do 100 i=1,nlines
c
c --- Swap emission rate for source 'i' into 1D array and scale
      qtot=0.0
      do is=1,nspec
         q(is)=qtl(is,i)*VEMFAC(ldbhr,ivln1(is,i),iq12ln1(is,i),
     &                          temp,ws,istab)
         qtot=qtot+q(is)
      enddo
c --- Skip to next line if all species have zero mass in puff
      if(qtot.EQ.0.0) then
c ***
         if(ldbhr) then
            write(io6,*)
            write(io6,*) 'No emissions this step from Source ',i
            write(io6,*)
         endif
c ***
         goto 100
      endif

c --- Rotate coord. system to place the yy-axis along the flow
      xxbeg=xlbeggrd(i)*cosf-ylbeggrd(i)*sinf
      xxend=xlendgrd(i)*cosf-ylendgrd(i)*sinf
      yybeg=xlbeggrd(i)*sinf+ylbeggrd(i)*cosf
      yyend=xlendgrd(i)*sinf+ylendgrd(i)*cosf

c --- Find cross-wind and along-wind length of this line in meters
      xcrossm=abs(xxbeg-xxend)*dgrid
      yalongm=abs(yybeg-yyend)*dgrid

c --- Compute the number of puffs/slugs released this hour
c --- from this line source
      npnew=wsnew*xtmp1+1
      npnew=max0(npnew,1)
      npnew=min0(npnew,mxnew)
      newln1(i)=npnew
c
c --- DT is the time (sec) over which each puff is emitted
      dt=dthr/float(npnew)

c ---------------------------------------------------------
c --- Compute number of segments needed for one line (NSEG)
c ---------------------------------------------------------
      if(mslug.EQ.0 .OR. lcalm) then
c ---    Puffs are released, so use all MXNSEG segments
         nsegy=0
         nsegz=0
         nseg(i)=mxnseg
      else
c ---    Slugs are released
c
c ---    Calculate the virtual times and sigmas at Heffter transition
         if(mhftsz.EQ.0)then
            szh=syh
            call sigty(syh,zero,zero,dum,thfty,dhfty)
         else
            call heftran(1,hsl(i),syab1,szab1,zero,zero,zero,zero)
         endif
c ---    Set NSEGY as function of transport speed, sigma-y,
c ---    and cross-wind length of line (make it an ODD integer)
         thalf=0.5*dt
         xhalfkm=0.001*uavg*thalf
         call sigty(zero,xhalfkm,thalf,syhalf,dum,dum)
         nsegy=nint(xcrossm/(rt2pi*syhalf))
         iodd=mod(nsegy,2)
         if(iodd.EQ.0) nsegy=nsegy+1
c ---    Set NSEGZ as function of transport speed, sigma-z, release ht,
c ---    and along-wind change in rise (make it an ODD integer)
         call sigtz(zero,xhalfkm,thalf,hsl(i),szhalf,dum,dum)
         nsegz=nint(2.0*ztr(1)/szhalf)
         iodd=mod(nsegz,2)
         if(iodd.EQ.0) nsegz=nsegz+1
c ---    Take the larger of the two
         nseg(i)=MAX0(nsegz,nsegy)
c ---    Cap result at MXNSEG
         nseg(i)=MIN0(nseg(i),mxnseg)
      endif

c --- Line releases npnew clouds this hour, with nseg elements
c --- in each cloud
      newpuf=newpuf+npnew*nseg(i)
c --- If puff arrays are full, remove puffs that are off the grid
c --- and "roll down" arrays to make room for new puffs
c --- (this also applies to the DA file of tabulated arrays)
      if(npuffs+newpuf.gt.mxpuff) call rolldn(np)
c --- Check to see if roll-down was adequate
      if(npuffs+newpuf.gt.mxpuff)then
         write(io6,*) ' ERROR in subr. LINES1'
         write(io6,*)'Too many puffs on grid for array dimensions -- ',
     1   'NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2   ' MXPUFF = ',mxpuff
         write(*,*)
         stop 'Halted in LINES1 -- see list file.'
      endif
c
c --------------------------------------------------------------------
c --- Calculate building downwash effects on initial plume sigmas
c --------------------------------------------------------------------
c --- Initialize downwash variables to zero (no building downwash)
      sz0dw=0.0
      sy0dw=0.0
      idw=0
      if(ws.GT.wsdw0 .AND. .NOT.lcalm) then
c ---    Set downwash flag to ACTIVE
         idw=1
c ---    Use BLP calculation of downwash sigmas
         sz0dw=rt2bypi*rzero
         sy0dw=0.5*sz0dw
      endif
c
c --- Set initial sigma y, sigma z for puff/slug, including effective
c --- spread due to length of line source element (add length effects
c --- and downwash effects in quadrature)
c --- Crosswind variance: 0.25*(line width)**2/(2pi)
      if(lcalm) then
         xlen2=(xcrossm**2+yalongm**2)/(nseg(i)**2)
      else
         xlen2=(xcrossm/nseg(i))**2
      endif
      sy2=0.25*oneby2pi*xlen2+sy0dw*sy0dw
      sysrc=amax1(symin,sqrt(sy2))
c --- Alongwind variance: 0.25*(line length * rise rate)**2/(2pi)
      if(lcalm) then
         sz2=0.0
         szsrc=szmin
      else
         sz2=0.25*oneby2pi*((yalongm/nseg(i))*
     &                      ztr(1)/xtr(1))**2+sz0dw*sz0dw
         szsrc=amax1(szmin,sqrt(sz2))
      endif

c******
      if(ldbhr)then
         write(io6,*)
         write(io6,*) 'Line Source # ',i
         write(io6,*)
         write(io6,*) 'LINES1:  thalf,xhalfkm = ',thalf,xhalfkm
         write(io6,*) '          syhalf,nsegy = ',syhalf,nsegy
         write(io6,*) '          szhalf,nsegz = ',szhalf,nsegz
         write(io6,*) '                  nseg = ',nseg(i)
         write(io6,208) xcrossm,npnew,newpuf,dt,
     2                  idw,rzero,sysrc,szsrc
208      format(5x,'XCROSSM: ',f6.1,2x,
     2    'NPNEW: ',i4,2x,'NEWPUF: ',i5,2x,'DT: ',f7.2,2x/5x,
     3    'IDW: ',i3,2x,'RZERO: ',f6.1,2x,'SYSRC: ',f6.1,2x,
     4    'SZSRC: ',f6.1)
      endif
c*****
c
c -------------------------------------------------------------
c --- Loop over "point" sources (each segment) along line
c -------------------------------------------------------------
c
c --- Set up the distance increments along the line
      dxgrd=(xlendgrd(i)-xlbeggrd(i))/nseg(i)
      dxgrdby2=0.5*dxgrd
      dygrd=(ylendgrd(i)-ylbeggrd(i))/nseg(i)
      dygrdby2=0.5*dygrd

      do 90 ipt=1,nseg(i)

c ---  Set location in met grid units
       xptgrd=xlbeggrd(i)+(ipt-1)*dxgrd+dxgrdby2
       yptgrd=ylbeggrd(i)+(ipt-1)*dygrd+dygrdby2

c ---  Set the shift in distance (m) of this point from the upwind edge
       yyptgrd=xptgrd*sinf+yptgrd*cosf
       xshift=(yyptgrd-yy0grd)*dgrid
       if(xshift.LT.0.0) xshift=0.0
       if(xshift.GT.xtr(1)) xshift=xtr(1)

c ---  Set the final height and distance to final rise for this puff
       if(lcalm) then
          xshift=0.0
          xfrise=0.0
          heff=hsl(i)+ztr(ntr)
       else
          if(xtr(1).LE.xtr(ntr)) then
c ---        Case 1:  final rise reached beyond XFB
             heff=hsl(i)+ztr(ntr)-xshift*ztr(1)/xtr(1)
             xfrise=xtr(ntr)-xshift
          else
c ---        Case 2:  final rise reached before XFB
             size=1.0-xshift/xtr(1)
             heff=hsl(i)+ztr(ntr)*size
             xfrise=xtr(ntr)*size
          endif
       endif
c
c******
      if(ldbhr)then
         write(io6,*) 'Element #  ',ipt
         write(io6,210) hsl(i),heff,xfrise,xshift,xptgrd,yptgrd
210      format(5x,'HSL : ',f6.1,2x,'HEFF: ',f6.1,'XFRISE: ',f6.1,2x,
     1    'XSHIFT: ',f6.1,2x,'XPTGRD: ',f8.4,2x,'YPTGRD: ',f8.4)
      endif
c*****
c ----------------------------------------------------------
c ---    Initialize current hour's new puffs for this source
c ----------------------------------------------------------
         do 50 j=1,npnew
         np=np+1
c
c ---    Use SWAP to start with all puff/slug variables equal to zero
         call swap(np,0)
c
c ---    Fill non-zero values
         xpb(np)=xptgrd
         ypb(np)=yptgrd
         zitibl(np)=-1.0
         elbase(np)=belevl(i)
         sigyb(np)=sysrc
         sigzb(np)=szsrc
c ---    Final plume rise results for puff
         zfinal(np)=heff
         zpb(np)=heff
         zpe(np)=heff
         xfinal(np)=xfrise
c ---    Intermediate results for calc. gradual rise
         fb(np)=fbpt
c ---    Set xbfin and zbfin to negatives to signal use of final
c ---    rise if calm
         if(lcalm) then
            xbfin(np)=-1.0
            zbfin(np)=-1.0
         else
            xbfin(np)=xtr(ntr)
            zbfin(np)=ztr(ntr)
         endif
         isplit(np)=1
c ---    Time-of-release data
         ht0(np)=hsl(i)
         temit0(np)=dt
         ws0(np)=ws
         istab0(np)=istab
         sqrts0(np)=sqrts
         iru0(np)=iru
         sigv0(np)=tsigv
         sigw0(np)=tsigw
         el0(np)=el
         plexp0(np)=plexp
c ---    Set vector/scalar ws ratio to 1.0
         srat0(np)=1.0
c ---    Additional time-of-release parameters needed for
c ---    receptor-specific calculations (downwash - point sources)
         idw0(np)=idw
         hb0(np)=hsl(i)
         hw0(np)=xcrossm
         heff20(np)=hsl(i)
         zly0(np)=xld
         r0(np)=rzero
c ---    Additional data for line sources
         xshift0(np)=xshift
         sy0(np)=sy0dw
         sz0(np)=sz0dw

c ---    Emission period index for this puff
         iemstep(np)=1

c ---    Set puff identity where IRLSNUM is the puff number released
c ---    from a source this time step, ISRCNUM is the source number
c ---    of type ISRCTYP from which the puff was released.
c ---    (Type =5 for const. line sources)
         irlsnum(np)=j
         isrcnum(np)=i
         isrctyp(np)=5
c
c ---    !-NOTE 1-!
c ---    The puff number really refers to the number of emission
c ---    steps, which equals the puff number when ONE puff is released
c ---    from a source each emission step.  But many puffs are released
c ---    each step when simulating a line source (distributed along
c ---    the line).  Subsequent use is made of IRLSNUM in controlling
c ---    sampling functions, which depend on the emission steps, so we
c ---    explicitly place the emission-step index in the array.
c
c ----------------------------------------------------------
c ---    Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---    !-NOTE 2-!
c ---    OLD slugs from each segment are modeled explicitly, but
c ---    NEW releases are modelled using the numerical area-source
c ---    method for the ENTIRE line.  Therefore, we add a marker to
c ---    all slugs after segment 1, so that these can be identified
c ---    and ignored when NEW.  The marker consists of adding 1000 to
c ---    ISRCNUM, which would indicate that the puff comes from
c ---    line-source ISRCNUM=1000+i.  A check is made in READCF which
c ---    stops execution if parameter (mxlines .GE. 1000) to insure
c ---    that no valid line-source ID exceeds 999.
c
         if(mslug.eq.1 .AND. .NOT.lcalm) then
c
c ---       Set PUFID marker
            if(ipt.GT.1) isrcnum(np)=isrcnum(np)+1000
c
c ---       Set coordinates of oldest end of slug (in met. grid units)
c ---       Note that "oldest" end of slug is at the source, as is the
c ---       "newest" end; oldest end moves away and grows during the
c ---       step, while newest end remains fixed in size at the source.
            xpe(np)=xpb(np)
            ype(np)=ypb(np)
            xtote(np)=xtotb(np)
            tmtote(np)=tmtotb(np)
c ---       Set sigmas for oldest end of slug
            sigye(np)=sigyb(np)
            sigze(np)=sigzb(np)
         endif
c
c ------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c ------------------------------------------------------------------
c ---    Set partial penetration variables to null values
         fmix=1.0
         hmax=dpbl
c ---    Mass emitted into each line segment needs to be divided by
c ---    nseg, which is the number of segments.  Accomplish that here
c ---    by dividing the timestep by nseg.
         dtseg=dt/nseg(i)
         call inject(np,nspec,dtseg,mfact0,q,heff,hmax,dpbl,fmix,istab)

c ------------------------------------------------------------------
c ---    Transfer tabulated arrays record to DA file using full
c ---    MXRISE dimension
c ------------------------------------------------------------------
         call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

50       continue
90     continue
100   continue

      return
      end
c----------------------------------------------------------------------
      subroutine rlsmet(ldbhr,ixs,iys,htr,mfact,
     &                  mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &                  ustr,wstr,tsigv,tsigw,iru,issta,sqrts,
     &                  idopty,idoptz)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 060309                 RLSMET
c                D. Strimaitis,  SRC
c
c --- PURPOSE:  Obtain release height wind speed & other met. variables
c
c --- UPDATE
c --- V5.75-V6.11   060309  (DGS): Add overwater SVMIN,SWMIN
c --- V5.7-V5.75    050225  (DGS): Add UATZI for TURBSET's AERSWV call
c --- V5.4-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.0     981228  (DGS): restore flow units
c --- V5.0-V5.0     980807  (DGS): enforce time-growth sigmas if CALM
c                   980807  (DGS): use surface stability for all hts
c                                  when stable
c --- V5.0-V5.0     980722  (DGS): SVMIN & SWMIN by stability class
c --- V5.0-V5.0     980722  (DGS): remove FLOW=0 assignment for CALMS
c                                  (use WD from WINDSET)
c --- V4.0-V5.0     971107  (DGS): use release ht = MAX(htr,z0)
c
c --- INPUTS:
c         LDBHR - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c       IXS,IYS - integer - Met grid cell index for puff
c           HTR - real    - Release height (m)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c
c     Common block /COMPARM/ variables:
c           XMINZI, XMAXZI, SVMIN(6,2), SWMIN(6,2), WSCALM
c     Common block /DISPDAT/ variables:
c           IURB1, IURB2, JSUP
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MDISP, MDISP2
c     Common block /GRID/ variables:
c           ZFACE(mxnzp1), NZP1, ZGPT(mxnz)
c     Common block /METHR/ variables:
c           UMET(mxnx,mxny,mxnz),VMET(mxnx,mxny,mxnz),IPGT(mxnx,mxny),
c           HTMIX(mxnx,mxny), XMONIN(mxnx,mxny), USTAR(mxnx,mxny),
c           WSTAR(mxnx,mxny), PTG(2), PLEXP,
c           TEMPSS(mxss),TEMP2D
c     Common block /METHD/ variables:
c           NEARS(mxnx,mxny), ILANDU(mxnx,mxny), Z0(mxnx,mxny),
c           NSSTA, LCALGRD, I2DMET
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXSS, IO6
c
c --- OUTPUT:
c        MFACT0 - integer - Current stepping index to identify slugs
c                           vs. puffs (puff used for calms)
c        ILAYER - integer - Met layer index for release height
c            WS - real    - Wind speed (m/s)
c          FLOW - real    - Flow direction (radians CW from N)
c          IVEC - integer - Vector flow direction (deg CW from N)
c         ISTAB - integer - Stability class (1-6)
c          DPBL - real    - Mixing height (m)
c            EL - real    - Monin-Obukhov length (m)
c          USTR - real    - Friction velocity (m/s)
c          WSTR - real    - Convective velocity scale (m/s)
c         TSIGV - real    - Lateral turbulence velocity (m/s)
c         TSIGW - real    - Vertical turbulence velocity (m/s)
c           IRU - integer - Rural/Urban indicator (rural=0, urban=1)
c         ISSTA - integer - Index of nearest surface met station
c         SQRTS - real    - Root of stability parameter (1/s);
c                           (same as Brunt-Vaisala frequency)
c        IDOPTY - integer - Current dispersion option for sigma-y
c        IDOPTZ - integer - Current dispersion option for sigma-z
c
c --- RLSMET called by:  AREAS1, AREAS2, LINES1, POINTS1, POINTS2,
c                        VOLS 
c --- RLSMET calls:      ZFIND, WINDSET, TURBSET, PTLAPS
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'comparm.puf'
      include 'dispdat.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
c
      logical ldbhr
c
      data g/9.80665/
c --- Set minimum allowed potential temperature gradient PTGRAD0,
c --- and the layer above stack-top over which it is calculated DELZ
      data ptgrad0/.005/, delz/100./
c --- Set transport wind speed for "calm"
      data ucalm/0.001/
c
c --- Select properties for this cell
      istab=MIN0(ipgt(ixs,iys),6)
      dpbl=AMAX1(htmix(ixs,iys),xminzi)
      dpbl=AMIN1(dpbl,xmaxzi)
      el=xmonin(ixs,iys)
      ustr=ustar(ixs,iys)
      wstr=wstar(ixs,iys)
      z0m=z0(ixs,iys)
c --- Set land (1) water (2) index for SVMIN,SWMIN
      ilw=1
      if(ilandu(ixs,iys).GE.iwat1 .AND.
     &   ilandu(ixs,iys).LE.iwat2) ilw=2

c
c --- Find the layer containing the release height (m)
      htrel=AMAX1(htr,z0m)
      call ZFIND(htrel,zface,nzp1,ilayer)
c --- Extract wind speed (m/s) and direction (deg)
      call WINDSET(htrel,ilayer,ixs,iys,z0m,el,dpbl,istab,ws,wd)
      flow=wd+180.
      if(flow.LT.0.) then
         flow=flow+360.
      elseif(flow.GE.360.) then
         flow=flow-360.
      endif
      ivec=NINT(flow)
c
c --- For puffs above mixed layer, use stability class "JSUP" to
c --- calculate SIGMA Y and SIGMA Z growth (if JSUP=0, use
c --- mixed-layer stability class)
      jdstab=istab
      if(istab.LT.5 .and. htrel.GT.dpbl .and. jsup.ne.0)jdstab=jsup
c
c --- Set turbulence velocities and activate dispersion options
      if(mdisp.EQ.1 .OR. mdisp.EQ.2 .OR. mdisp.EQ.5) then
c ---    Extract wind speed (m/s) at Zi
         call ZFIND(dpbl,zface,nzp1,ilayerzi)
         call WINDSET(dpbl,ilayerzi,ixs,iys,z0m,el,dpbl,istab,
     &                   uatzi,wdzi)
         call TURBSET(ldbhr,ustr,el,wstr,jdstab,dpbl,z0m,htrel,
     &                uatzi,ws,wd,ixs,iys,ilw,
     &                tsigv,tsigw,idopty,idoptz)
      else
         idopty=mdisp
         idoptz=mdisp
         tsigw=swmin(jdstab,ilw)
         tsigv=svmin(jdstab,ilw)
      endif
c
c --- Extract IRU value (rural=0, urban=1) for source
      iru=0
      if(ilandu(ixs,iys) .GE. iurb1 .AND.
     &   ilandu(ixs,iys) .LE. iurb2) iru=1
c
c --- Identify surface met station nearest source
      issta=NEARS(ixs,iys)
      if(issta.gt.nssta)then
         write(io6,*) ' ERROR in subr. RLSMET'
         write(io6,*)'ISSTA > NSSTA -- ISSTA = ',issta,' NSSTA = ',
     1                nssta
         write(*,*)
         stop 'Halted in RLSMET -- see list file.'
      endif
c
c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
         temp=temp2d(ixs,iys)
      elseif(i2dmet.EQ.0) then
         temp=tempss(issta)
      else
         write(*,*)'Subr. RLSMET:  Invalid I2DMET = ',i2dmet
         stop
      endif

c --- Compute stratification parameter = Brunt-Vaisala freq.
      if(LCALGRD) then
c ---    Use temperature (K) gradient between stack-top and
c ---    DELZ above stack-top
         call PTLAPS(ixs,iys,htr,ptgrad0,delz,ptgrad,t0)
         sqrts=SQRT(g*ptgrad/t0)
      else
c ---    Use default potential temperature lapse rate with the
c ---    surface temperature from the nearest station
         if(istab.LE.4) then
            ptgrad=0.0
         elseif(istab.EQ.5) then
            ptgrad=AMAX1(ptg(1),ptgrad0)
         else
            ptgrad=AMAX1(ptg(2),ptgrad0)
         endif
         sqrts=SQRT(g*ptgrad/temp)
      endif
c
c --- If CALM is detected, make sure PUFF ID stepping index is 0 to 
c --- use PUFFS
      mfact0=mfact
      if(ws.LT.wscalm) then
         ws=AMAX1(ws,ucalm)
         mfact0=0
c ---    Reset dispersion option ("calms" use time-based sigmas)
         idopty=1
         idoptz=1
      endif

c --- Convert flow from degrees to radians
      flow=flow*.0174533

      return
      end
c----------------------------------------------------------------------
      subroutine zfind(z,zface,nzp1,ilayer)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                  ZFIND
c                J. Scire, SRC
c
c --- PURPOSE:  Find the vertical layer containing height "Z"
c
c --- INPUTS:
c             Z - real    - Height (m) of interest
c   ZFACE(nzp1) - real    - Array of face heights (m)
c          NZP1 - integer - Number of vertical cell faces
c                           (no. layers + 1)
c
c --- OUTPUT:
c        ILAYER - integer - Vertical containing height "Z"
c                           (ILAYER=1  returned if Z < face ht. #1)
c                           (ILAYER=NZ returned if Z > face ht. #NZP1)
c
c --- ZFIND called by:  RLSMET, ADVWND
c --- ZFIND calls:      none
c----------------------------------------------------------------------
c
      real zface(nzp1)
c
c --- Find first face height above height "Z"
      do 10 i=2,nzp1
      if(z.lt.zface(i))then
         ilayer=i-1
         go to 12
      endif
10    continue
c
c --- "Z" must be above top face
      ilayer=nzp1-1
c
12    continue
      return
      end
c----------------------------------------------------------------------
      subroutine ptlaps(i,j,htbase,dptmin,delz,dtheta,tht)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 060725                 PTLAPS
c ---            J. Scire, D. Strimaitis,  SRC
c
c --- PURPOSE:  Calculate the potential temperature lapse rate
c               (deg. K/m) in a layer "DELZ" meters deep above the
c               a specified height, using either the temperature
c               data from the MET file, or the PROFILE.DAT file
c
c --- UPDATE
c --- V5.74-V6.114  060725  (DGS): fix case where upper height exceeds
c                                  middle of top layer (ku must be nz)
c --- V5.4-V5.74    040715  (DGS): add METFM=5 (AERMET)
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V4.0-V5.0     971107  (DGS): check PROBLEM returned by XTPRF
c
c --- INPUTS:
c                  I,J - integers      - Grid cell indexes
c               HTBASE - real          - Height (m) of bottom of layer
c               DPTMIN - real          - Minimum potential temperature
c                                        lapse rate (deg. K/m)
c                 DELZ - real          - Depth (m) of layer through
c                                        which potential temp. lapse
c                                        rate is computed
c    Common block /COMPARM/ variables:
c         WSCALM, XMINZI, XMAXZI
c     Common Block /GEN/ variables:
c         METFM
c     Common Block /GRID/ variables:
c         NZ, ZGPT(mxnz)
c    Common block /METHR/ variables:
c         TMET(mxnx,mxny,mxnz)
c         IPGT(mxnx,mxny), HTMIX(mxnx,mxny), XMONIN(mxnx,mxny)
c         PTG(2), TPRF(mxprfz), ZPRF(mxprfz), NZPRF
c    Parameters:
c         MXNX, MXNY, MXNZ, MXPRFZ, IO6
c
c --- OUTPUT:
c               DTHETA - real          - Potential temperature lapse rate
c                                        (deg. K) in "DELZ" meter layer
c                  THT - real          - Temperature at bottom of layer
c
c --- PTLAPS called by:  RLSMET, POINTS1, POINTS2, LINES1
c --- PTLAPS calls:      XTPRF
c----------------------------------------------------------------------
c
c --- include parameters
      include 'params.puf'
      include 'comparm.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'methr.puf'
c
      logical problem
c
      if(metfm.EQ.1) then
c ---    MET layers
c ---    Find level just below htbase
         kl=nz-1
         do 10 k=2,nz
            if(zgpt(k).lt.htbase) go to 10
            kl=k-1
            go to 12
10       continue
12       continue
c
c ---    Find level just above htbase+delz
c ---    Initialize to NZ
         ku=nz
         htpdz=htbase+delz
         klp1=kl+1
         do 15 k=klp1,nz
            if(zgpt(k).lt.htpdz) go to 15
            ku=k
            go to 16
15       continue
16       continue
c
c ---    If two adjacent levels were found, just take dt/dz between them
         if((ku-kl).eq.1) then
            dtheta=.0098+(tmet(i,j,ku)-tmet(i,j,kl))/(zgpt(ku)-zgpt(kl))
            tht=tmet(i,j,kl)
         else
c ---       Obtain temperatures (deg. K) at htbase & htbase + delz
c ---       by interpolation
            klp1=kl+1
            tht=tmet(i,j,klp1)-(tmet(i,j,klp1)-tmet(i,j,kl))*
     1                       (zgpt(klp1)-htbase)/(zgpt(klp1)-zgpt(kl))
            kum1=ku-1
            thtp=tmet(i,j,ku)-(tmet(i,j,ku)-tmet(i,j,kum1))*
     1                      (zgpt(ku)-htpdz)/(zgpt(ku)-zgpt(kum1))
c
c ---       Compute potential temperature lapse rate (deg. K/m)
            dtheta=(thtp-tht)/delz+0.0098
         endif

      elseif(metfm.EQ.4 .OR. metfm.EQ.5) then
c ---    PROFILE.DAT data
         problem=.FALSE.
c ---    Set current surface layer properties
         istab=ipgt(i,j)
         istab=MIN0(istab,6)
         dpbl=AMAX1(htmix(i,j),xminzi)
         dpbl=AMIN1(dpbl,xmaxzi)
         el=xmonin(i,j)
c ---    Do not need z0 for temperature (set to 0.1 m)
         z0m=0.1

c ---    Extract temperatures at top and bottom of layer
         call XTPRF(nzprf,tprf,zprf,htbase,'tmp',z0m,el,
     &              dpbl,istab,ptg,tht,problem)
         htop=htbase+delz
         call XTPRF(nzprf,tprf,zprf,htop,'tmp',z0m,el,
     &              dpbl,istab,ptg,thtp,problem)

c ---    Results are invalid if XTPRF reported PROBLEM=TRUE
         if(PROBLEM) then
            write(io6,*) 'PTLAPS:  FATAL ERROR reported when ',
     &                   'extracting temp from PROFILE ---'
            write(io6,*) 'There are no valid data'
            write(*,*)
            stop 'Halted in PTLAPS -- see list file.'
         endif
c
c ---    Compute potential temperature lapse rate (deg. K/m)
         dtheta=(thtp-tht)/delz+0.0098
      endif
c
c --- dptmin is minimum stable pot. temp. lapse rate
      dtheta=amax1(dtheta,dptmin)
c
      return
      end
c----------------------------------------------------------------------
      subroutine inject(np,nspec,dt,mfact0,q,heff,hmax,dpbl,fmix,istab)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980615                 INJECT
c                D. Strimaitis,  SRC
c
c --- PURPOSE:   Inject emissions into proper layer (above/below
c                mixing ht.)
c
c --- UPDATE
c --- V5.0-V5.0
c          950715 - 980615  (DGS): Use 2-layer puff codes for partial
c                                  penetration
c
c --- INPUTS:
c            NP - integer - Index of puff/slug
c         NSPEC - real    - Number of species modeled
c            DT - real    - Time over which puff is emitted (s)
c        MFACT0 - integer - Stepping index to identify slugs vs puffs
c             Q - real ar.- Emission rate (g/s) for period DT
c          HEFF - real    - Effective puff ht. at final rise (m)
c          HMAX - real    - Top of upper layer (partial penetration)
c          DPBL - real    - Current mixing height (m)
c          FMIX - real    - Fraction of mass in mixed layer
c         ISTAB - integer - Stability class in surface layer
c
c     Common block /FLAGS/ variables:
c           MGAUSS
c     Common block /PUFF/ variables:
c           NPUFFS
c     Parameters:
c           MXSPEC, MXPUFF
c
c --- OUTPUT:
c
c     Common block /PUFF/ variables:
c           IPUFFCD(mxpuff),ZIMAX(mxpuff),ZIOLD(mxpuff),
c           QM(mxspec,mxpuff),QU(mxspec,mxpuff)
c
c --- INJECT called by:  AREAS1, AEREAS2, VOLS, POINTS1,
c                        POINTS2, LINES1
c --- INJECT calls:      none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'flags.puf'
      include 'puff.puf'
c
      real q(mxspec)

c --- Set unlimited mixing height (m)
      data ziunlm/1.0e04/
c
      if(fmix.NE.1.0 .and. fmix.NE.0.0) then
c ---    Partial penetration of inversion was calculated
c ------------------------------------------------------
         zimax(np)=hmax
         ziold(np)=dpbl
         do ispec=1,nspec
            qtotal=q(ispec)*dt
            qm(ispec,np)=qtotal*fmix
            qu(ispec,np)=qtotal-qm(ispec,np)
         enddo
         if(mgauss.EQ.1)then
c ---       Gaussian puff or slug within mixed layer
            ipufcd(np)=5+mfact0
         else
c ---       Uniform puff or slug within mixed layer
            ipufcd(np)=6+mfact0
         endif
c
      elseif(heff.LE.dpbl)then
c ---    Within surface layer
c ---------------------------
         do ispec=1,nspec
            qm(ispec,np)=q(ispec)*dt
            qu(ispec,np)=0.0
         enddo
         if(mgauss.EQ.1)then
c ---       Gaussian puff or slug
            ipufcd(np)=1+mfact0
            if(istab.GE.5) then
c ---          Stable regime -- set up for unlimited mixing
               zimax(np)=ziunlm
               ziold(np)=ziunlm
            else
c ---          Non-stable regime -- use current mixing height
               zimax(np)=dpbl
               ziold(np)=dpbl
            endif
         else
c ---       Uniform puff or slug within mixed layer
            ipufcd(np)=2+mfact0
            zimax(np)=dpbl
            ziold(np)=dpbl
         endif
c
      else
c ---    Above surface layer
c ---------------------------
         if(mgauss.EQ.1)then
c ---       Gaussian puff or slug above mixed layer
            if(istab.GE.5) then
c ---          Stable regime -- treat as unlimited mixed layer
               ipufcd(np)=1+mfact0
               zimax(np)=ziunlm
               ziold(np)=ziunlm
               do ispec=1,nspec
                  qm(ispec,np)=q(ispec)*dt
                  qu(ispec,np)=0.0
               enddo
            else
c ---          Non-stable regime -- place mass above mixed layer
               ipufcd(np)=3+mfact0
               zimax(np)=dpbl
               ziold(np)=dpbl
               do ispec=1,nspec
                  qm(ispec,np)=0.0
                  qu(ispec,np)=q(ispec)*dt
               enddo
            endif
         else
c ---       Uniform puff or slug above mixed layer
            ipufcd(np)=4+mfact0
            zimax(np)=dpbl
            ziold(np)=dpbl
            do ispec=1,nspec
               qm(ispec,np)=0.0
               qu(ispec,np)=q(ispec)*dt
            enddo
         endif
c
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine dwsigs(tbd,hw,hb,mhftsz,ws,hs,heff,zplat,xdown,
     &                  sigy,sigz)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050225                 DWSIGS
c ---            J. Scire, D. Strimaitis, SRC
c
c --- PURPOSE:  Compute the dispersion coefficients, sigma y and
c               sigma z due to building downwash effects. (Values
c               returned are the max. obtained with or without
c               building downwash)
c
c --- UPDATE
c --- V5.0-V5.75    050225  (DGS): Add platform ht adjustment
c --- V4.0-V5.0     971107  (DGS): Return "zero" sigmas for distances
c                                  within "3Hb" of source
c
c --- INPUTS:
c           TBD - real     - Variable determining switch-over pt. from
c                           Schulman-Scire scheme to Huber-Snyder
c                           scheme (SS used for Hs < Hb + TBD * HL,
c                           TBD < 0   ==> always use Huber-Synder
c                           TBD = 1.5 ==> always use Schulman-Scire
c                           TBD = 0.5 ==> ISC switch-point
c            HW - real     - Wind-direction specific building width (m)
c                            (for current wind)
c            HB - real     - Wind-direction specific building height (m)
c                            (for current wind)
c        MHFTSZ - integer  - Use Heffter sigma-z (0:NO  1:YES)
c            WS - real     - Stack height wind speed (m/s)
c            HS - real     - Stack height (m)
c          HEFF - real     - Effective stack ht. (m) accounting for
c                            momentum rise alone at a downwind distance
c                            of 2. building heights
c         ZPLAT - real     - Platform ht (m) (non-zero for structures
c                            that are elevated above the surface)
c         XDOWN - real     - Downwind distance (m) of receptor
c
c --- OUTPUT:
c          SIGY - real     - Horizontal dispersion coefficient (m)
c          SIGZ - real     - Vertical dispersion coefficient (m)
c
c --- DWSIGS called by:  PUFRECS, SLGRECS, PLGRECS, POINTS1, POINTS2
c --- DWSIGS calls:      HEFTRAN, SIGTY, SIGTZ
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'csigma.puf'
c
      sigy=0.0
      sigz=0.0
c
      hl=AMIN1(hw,hb)
      hl3=3.*hl
      hl10=10.*hl
c
c --- Return zero values for the sigmas at distances < "3Hb"
c --- Allow for precision uncertainty
      if(xdown.LT.0.99*hl3) return

c --- Valid platform height?
      if(zplat.LT.0.) stop 'DWSIGS: Platform height is negative'
c --- Adjusted stack height above platform
      hsplat=AMAX1((hs-zplat),0.0)
c --- Adjusted stack height above platform
      heplat=AMAX1((heff-zplat),0.0)

c --- Calculate the virtual times and sigmas at Heffter transition
      if(mhftsz.EQ.0)then
         szh=syh
         call sigty(syh,0.0,0.0,dum,thfty,dhfty)
      else
         call heftran(1,hs,sigy,sigz,0.0,0.0,0.0,0.0)
      endif
c
c --- Compute the downwind distance to use in the downwash eqns.
      if(xdown.le.hl3)then
         xarg=hl3
      else if(xdown.ge.hl10)then
         xarg=hl10
      else
         xarg=xdown
      endif
c --- Convert to time and distance used in dispersion formulas
      targ=xarg/ws
      xargkm=0.001*xarg
c
c --- Get "ambient" sigmas
c
      call sigty(0.0,xargkm,targ,syamb,virty,virdy)
      call sigtz(0.0,xargkm,targ,hs,szamb,virtz,virdz)
c
c --- Now get "downwash" sigmas
c
c ---------------------------------------
c --- Huber-Synder Calculations ---------
c ---------------------------------------
      xtemp=0.067*(xarg-hl3)
      sigz=0.7*hl+xtemp
c
      if(hw.ge.hb)then
c ---    Squat building
c ---    Determine if sigma y enhancement occurs
         if(heplat.le.1.2*hb)then
            if(hw.lt.5.*hb)then
               sigy=0.35*hw+xtemp
            else
               sigy=0.35*hb+xtemp
c ---          (Note: "lower bound" ISC2 option is not available)
            endif
         else
            sigy=0.0
         endif
      else
c
c ---    Tall building
c ---    Determine if sigma y enhancement occurs
         if(heplat.le.1.2*hb)then
            sigy=0.35*hw+xtemp
         else
            sigy=0.0
         endif
      endif
c
c -----------------------------------------
c --- Schulman-Scire Calculations ---------
c -----------------------------------------
      if(tbd.ge.0.0 .AND. hsplat.le.hb+tbd*hl)then
c
c ---    Determine linear scaling function for sigz
         if(heplat.le.hb)then
            a=1.0
         else if(heplat.le.hb+2.*hl)then
            a=(hb-heplat)/(2.*hl)+1.0
         else
            a=0.0
         endif
c
c ---    Scale the vertical dispersion coefficient
         sigz=a*sigz
      endif
c
c --- Select the greater of the ambient and downwash sigmas
      sigy=amax1(syamb,sigy)
      sigz=amax1(szamb,sigz)

      return
      end
c----------------------------------------------------------------------
      subroutine setline(mshear,theta,wsr,istab,sqrts,plawx,
     &                   nlines,xl,hbl,wml,fprimel,wsep,fptot,fbpt,
     &                   nlrise,xle,xld,r0,xrise,zrise)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 981228                SETLINE
c ---            D. Strimaitis, SRC
c
c --- PURPOSE:  Perform initial processing for buoyant line sources
c               for current meteorology, and compute rise table
c
c --- UPDATE
c --- V5.0-V5.0     981228  (DGS): add line width term to XFB for single
c                                  line and use BLP code for effective
c                                  width for parallel winds
c --- V4.0-V5.0     971107  (DGS): add all io to argument list to allow
c                                  use with variable line sources as
c                                  well as constant lines
c
c --- INPUTS:
c        MSHEAR - integer      - Flag for including wind shear in rise
c                                calcs. (0=NO shear;  1=shear)
c         THETA - real         - Angle between wind and axis of
c                                line source (radians)
c           WSR - real         - Wind speed at release height (m/s)
c         ISTAB - integer      - Stability class (PG)
c         SQRTS - real         - Square root of stability parameter
c                                  (sqrt(s)=(g*(dtheta/dz)/tair)**0.5)
c         PLAWX - real         - Wind speed profile power law exponent
c        NLINES - integer      - Number of line sources
c            XL - real         - Average line source length (m)
c           HBL - real         - Average line source height (m)
c           WML - real         - Average line source width (m)
c       FPRIMEL - real         - Average buoyancy parameter/line
c                                in units of (m**4/s**3)
c          WSEP - real         - Average separation between lines
c         FPTOT - real         - Total buoyancy parameter
c          FBPT - real         - "Point Source" buoyancy parameter
c        NLRISE - integer      - Number of points used to tabulate
c                                plume rise from block of lines
c
c --- OUTPUT:
c           XLE - real     - Cross-wind effective line length (m)
c           XLD - real     - Effective downwash length (m)
c            R0 - real     - Initial dilution radius (m)
c XRISE(mxrise) - real     - Tabulated distances (m) from source
c ZRISE(mxrise) - real     - Tabulated rise heights (m) above source
c
c --- SETLINE called by:  LINES1, LINES2
c --- SETLINE calls:      ROOT3
c----------------------------------------------------------------------
c
      include 'params.puf'
      real rt3(3)
      real xrise(mxrise),zrise(mxrise)

c --- (beta=0.6)
      data beta/0.6/, beta2/0.36/, betai/1.6666667/, pibeta/1.8849556/
      data pi/3.1415927/, twopi/6.2831853/
      data half/0.5/, third/0.3333333/

c --- Set a minimum wind speed to use for calculating final rise (m/s)
      data wsrise/1.0/

c --- Calculate sine & cosine, taking results in first quadrant
      cost=abs(cos(theta))
      sint=abs(sin(theta))

      ws=amax1(wsr,wsrise)
      ws3=ws*ws*ws

c ---------------------------------------------------------------------
c --- Get the downwind distance to full buoyancy (XFB) and the
c --- effective line length (XLE) for current meteorology
c ---------------------------------------------------------------------

c --- Set xfb
      xfb=xl*cost+(nlines-1)*wsep*sint
      if(nlines.EQ.1) xfb=xfb+wml*sint
      xfb2=xfb*xfb

c --- Set virtual line length for winds parallel to line sources (wmlv)
      if(nlines.EQ.1) then
         wmlv=wml
      else
c ---    Height at which plumes from adjacent lines interact (hi)
         hi=half*wsep*betai
c ---    Distance at which adjacent plumes interact (xi)
c ---    First, assume that xi < xl:
         xibyxl3=ws3*(hi/xl)**3*((twopi*beta2*xl/fprimel)*
     &                           (1.+3.*wml/(pibeta*hi)))
         if(xibyxl3.GT.1.) then
            xi=half*xl*(1.+third*SQRT(12.*xibyxl3-3.))
            wmlv=fptot*(third*xl**2+xi*(xi-xl))/(2.*beta*ws3*hi**2)-
     &                  third*pibeta*hi
         else
            wmlv=fptot*(third*xl**2*xibyxl3)/(2.*beta*ws3*hi**2)-
     &                  third*pibeta*hi
         endif
      endif

c --- Set effective line length for current wind direction
      xle=xl*sint+wmlv*cost

c ---------------------------------------------------------------------
c --- Effective building downwash length (XLD) and initial radius (R0)
c ---------------------------------------------------------------------
      xld=xle*sint
      r0=amin1(hbl,xld)

c ---------------------------------------------------------------------
c --- Effective wind speed if shear effect on rise is included
c ---------------------------------------------------------------------
c --- Note: do not apply shear to case where wind speed is less than
c ---       the minimum speed "wsrise"
      if(mshear.EQ.1 .AND. wsr.GE.wsrise) then
         if(istab.LE.4) then
c ---       "Neutral"
            eps=2.0+3.0*plawx
            epsi=1.0/eps
c ---       Get distance to final rise (no shear)
            if(fbpt.LE.55.) then
               xfin0=3.5*14*fbpt**.625
            else
               xfin0=3.5*34.49*fbpt**.4
            endif
c ---       Get shear-modified final rise
            zeps=(0.25*(eps*xfin0)**2)*(fptot*hbl**(3.0*plawx))/
     &            ((2.0+plawx)*beta*xl*ws3)
            zshear=zeps**epsi
c ---       Get effective wind speed
            ws3=(xfin0/zshear)**2*fptot/(2.0*beta*xl)
            ws=ws3**third
c ---       Effective speed must be no less than wsr (speed at release)
            if(ws.LT.wsr) then
               ws=wsr
               ws3=ws*ws*ws
            endif
         else
c ---       "Stable"
            twopp=2.0+plawx
            twoppi=1.0/twopp
            s=sqrts**2
c ---       Get shear-modified final rise
            zshear=( twopp*fptot*hbl**plawx/(beta*xl*ws*s) )**twoppi
c ---       Get effective wind speed
            ws=2.0*fptot/(beta*xl*s*zshear*zshear)
c ---       Effective speed must be no less than wsr (speed at release)
            if(ws.LT.wsr) then
               ws=wsr
            else
               ws3=ws*ws*ws
            endif
         endif
      endif

c ---------------------------------------------------------------------
c --- Final rise & distance to final rise from the most upwind point
c --- "zfin0,xfin0"
c ---------------------------------------------------------------------
      aa3=1.0
      aa2=(3.*betai)*(xle/pi+r0)
      aa1=(3.*r0/beta2)*(2.*xld/pi+r0)
      aa00=-0.5*fbpt/(beta2*ws3)
      if(istab.LE.4) then
c ---    "Neutral"
         if(fbpt.LE.55.) then
            xfin0=3.5*14*fbpt**.625
         else
            xfin0=3.5*34.49*fbpt**.4
         endif
         if(xfin0.LT.xfb) then
            aa0=aa00*xfin0**3/xfb
         else
            aa0=aa00*(xfb2+3.*xfin0*(xfin0-xfb))
         endif
         call root3(aa3,aa2,aa1,aa0,nr,rt3)
c ---    Pick largest root
         zfin0=rt3(1)
         do i=2,nr
            zfin0=amax1(zfin0,rt3(i))
         enddo
      else
c ---    "Stable"
         s=sqrts**2
         aa0=-6.*fbpt/(beta2*ws*s)
         call root3(aa3,aa2,aa1,aa0,nr,rt3)
c ---    Pick the largest real root
         zfin0=rt3(1)
         do i=2,nr
            zfin0=amax1(zfin0,rt3(i))
         enddo
c ---    Now use neutral transient rise eqn. to get distance to zfin0
c ---    First, assume that xfin0 < xfb:
         ws2bys=ws*ws/s
         xfin0=(12.0*ws2bys*xfb)**third
         if(xfin0.GT.xfb) then
c ---       Must be beyond xfb
            xfin0=0.5*(xfb+sqrt(16.0*ws2bys-xfb2*third))
         endif
c ---    Distance should not be greater than result without downwash
         xfin=ws*pi/sqrts
         xfin0=amin1(xfin0,xfin)
      endif

c ---------------------------------------------------------------------
c --- Rise at XFB from the most upwind point (ZFB)
c ---------------------------------------------------------------------
      aa0=aa00*xfb2
      call root3(aa3,aa2,aa1,aa0,nr,rt3)
c --- Pick largest root
      zfb=rt3(1)
      do i=2,nr
         zfb=amax1(zfb,rt3(i))
      enddo
      zfb=amin1(zfb,zfin0)

c----------------------------------------------------------------------
c --- Fill in rise table between xfb and xfin0, inclusive
c----------------------------------------------------------------------
c --- Fill in new information for current met.
      xrise(1)=xfb
      zrise(1)=zfb
      xrise(nlrise)=xfin0
      zrise(nlrise)=zfin0

      dx=(xfin0-xfb)/(nlrise-1)

      if(xfb.GE.xfin0) then
c ---    Final rise reached before XFB -- just plug final rise values
         do ir=2,nlrise-1
            xrise(ir)=xrise(ir-1)+dx
            zrise(ir)=zfb
         enddo
      else
c ---    Final rise reached beyond XFB -- compute gradual rise values
         do ir=2,nlrise-1
            xibl=xrise(ir-1)+dx
            aa0=aa00*(xfb2+3.0*(xibl*xibl-xfb*xibl))
            call root3(aa3,aa2,aa1,aa0,nr,rt3)
c ---       Pick largest root
            zibl=rt3(1)
            do i=2,nr
               zibl=amax1(zibl,rt3(i))
            enddo
            zrise(ir)=amin1(zibl,zfin0)
            xrise(ir)=xibl
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine rolldn(np)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                 ROLLDN
c                D. Strimaitis,  SRC
c
c --- PURPOSE:  Identifies inactive puff/slug indices, and "rolls down"
c               arrays to free space for new puffs/slugs
c
c --- INPUTS:
c            NP - integer - Index of last puff/slug initialized
c
c     Common block /PUFF/ variables:
c           NPUFFS, IPUFCD
c     Common block /OUTPT/ variables:
c           IMESG
c     Parameters:
c           MXPUFF
c
c --- OUTPUT:
c            NP - integer - Revised index of last puff/slug initialized
c     Common block /PUFF/ variables:
c           NPUFFS
c
c --- ROLLDN called by: AREAS1, LINES1, POINTS1, POINTS2, VOLS,
c                       SPLIT, RESTARTO
c --- ROLLDN calls:     SWAP
c----------------------------------------------------------------------
c --- NOTE:
c     Inactive indices are searched in ascending order, and are filled
c     with next active "old" puff/slug in descending order.  Once gaps
c     in the "old" locations have been filled, the new puffs/slugs
c     initialized this timestep are added to the top of the arrays,
c     retaining the order.
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'puff.puf'
      include 'outpt.puf'
c
c --- Identify number of NEW puffs/slugs already initialized
      nnew=np-npuffs
c
c --- Set starting index for ascending search for inactive puffs
      inact=1
c
c --- Loop over "old" puffs/slugs in descending order
      do j=npuffs,1,-1
         if(ipufcd(j).LT.99) then
c ---       Active puff found: use this to replace next inactive puff
            do i=inact,j
               if(ipufcd(i).EQ.99) then
c ---             Inactive puff found, replace it and EXIT do-i
                  call swap(i,j)
                  goto 10
               endif
            enddo
c ---       Inactive puff NOT found, replacement complete: EXIT do-j
            goto 50

10          inact=i
         endif
      enddo

50    continue
c --- Reset number of "old" puffs/slugs
      ntop=npuffs
      npuffs=j
c
c --- Inactive indices have been filled; place new puffs already
c --- initialized at the top of the arrays
      do ii=1,nnew
         i=npuffs+ii
         j=ntop+ii
         call swap(i,j)
      enddo
c
c --- Reset the index for the last puff/slug initialized
      np0=np
      np=npuffs+nnew

c --- Report activity to screen (controlled by IMESG)
      if(imesg.GT.0) then
         nlost=np0-np
         print 9,nlost
9        format('+',44x,'-',i8,' inactive puffs removed')
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine swap(i,j)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                   SWAP
c                D. Strimaitis
c
c --- PURPOSE:  Transfers puff/slug array elements from index "J"
c               to index "I".  If J=0, array elements are initialized
c               to ZERO.
c
c --- UPDATE
c --- V6.1-V6.261   080520  (DGS): Added call to SWAPTAB to perform
c ---                              transfer of tabulated source data
c --- V5.72-V6.1    050915  (DGS): IEMSTEP array added
c --- V5.4-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.0-V5.4     010730  (DGS): SYSRC0, SZSRC0 arrays added
c --- V5.0-V5.0     980615  (DGS): SPEED0 array added
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c                   971107  (DGS): STIPDW array added
c
c --- INPUTS:
c             I - integer - New index
c             J - integer - Old index
c
c     Common block /GEN/ variables:
c           NSPEC
c     Common block /PUFF/ variables:
c           all variables
c     Common block /SLUG/ variables:
c           all variables
c     Parameters:
c           MXPUFF, MXSPEC
c
c --- OUTPUT:
c     Common block /PUFF/ variables:
c           all variables
c     Common block /SLUG/ variables:
c           all variables
c
c --- SWAP called by: ROLLDN, SPLIT, AREAS1, AREAS2, POINTS1, POINTS2,
c                     VOLS, LINES1, LINES2, BCS1
c --- SWAP calls:     SWAPTAB
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'gen.puf'
      include 'puff.puf'
      include 'slug.puf'

      data zero/0.0/

      if(j.GT.0) then

c ---       Source tables in Direct Access file
            call SWAPTAB(i,j)

c ---       PUFF.PUF
            xpb(i)       =xpb(j)
            ypb(i)       =ypb(j)
            zpb(i)       =zpb(j)
            zimax(i)     =zimax(j)
            ziold(i)     =ziold(j)
            zitibl(i)    =zitibl(j)
            sigyb(i)     =sigyb(j)
            sigzb(i)     =sigzb(j)
            xtotb(i)     =xtotb(j)
            tmtotb(i)    =tmtotb(j)
            zfinal(i)    =zfinal(j)
            xfinal(i)    =xfinal(j)
            bidfnl(i)    =bidfnl(j)
            fb(i)        =fb(j)
            fm(i)        =fm(j)
            xbfin(i)     =xbfin(j)
            xmfin(i)     =xmfin(j)
            zbfin(i)     =zbfin(j)
            zmfin(i)     =zmfin(j)
            stipdw(i)    =stipdw(j)
            do is=1,nspec
               qu(is,i)  =qu(is,j)
               qm(is,i)  =qm(is,j)
            enddo
            irlsnum(i)   =irlsnum(j)
            isrcnum(i)   =isrcnum(j)
            isrctyp(i)   =isrctyp(j)
            ipufcd(i)    =ipufcd(j)
            elbase(i)    =elbase(j)
            do i3=1,3
               do i2=1,2
                  tcon(i3,i2,i)  =tcon(i3,i2,j)
               enddo
            enddo
            isplit(i)    =isplit(j)
            iemstep(i)   =iemstep(j)
            idw0(i)      =idw0(j)
            ht0(i)       =ht0(j)
            exitw0(i)    =exitw0(j)
            diam0(i)     =diam0(j)
            ws0(i)       =ws0(j)
            istab0(i)    =istab0(j)
            sqrts0(i)    =sqrts0(j)
            srat0(i)     =srat0(j)
            temit0(i)    =temit0(j)
            hb0(i)       =hb0(j)
            hw0(i)       =hw0(j)
            heff20(i)    =heff20(j)
            iru0(i)      =iru0(j)
            sigv0(i)     =sigv0(j)
            sigw0(i)     =sigw0(j)
            el0(i)       =el0(j)
            plexp0(i)    =plexp0(j)
            zly0(i)      =zly0(j)
            r0(i)        =r0(j)
            sysrc0(i)    =sysrc0(j)
            szsrc0(i)    =szsrc0(j)
            xshift0(i)   =xshift0(j)
            sy0(i)       =sy0(j)
            sz0(i)       =sz0(j)

c ---       SLUG.PUF
            xpe(i)       =xpe(j)
            ype(i)       =ype(j)
            zpe(i)       =zpe(j)
            sigye(i)     =sigye(j)
            sigze(i)     =sigze(j)
            xtote(i)     =xtote(j)
            tmtote(i)    =tmtote(j)
            speed0(i)    =speed0(j)

      else

c ---       PUFF.PUF
            xpb(i)       =zero
            ypb(i)       =zero
            zpb(i)       =zero
            zimax(i)     =zero
            ziold(i)     =zero
            zitibl(i)    =zero
            sigyb(i)     =zero
            sigzb(i)     =zero
            xtotb(i)     =zero
            tmtotb(i)    =zero
            zfinal(i)    =zero
            xfinal(i)    =zero
            bidfnl(i)    =zero
            fb(i)        =zero
            fm(i)        =zero
            xbfin(i)     =zero
            xmfin(i)     =zero
            zbfin(i)     =zero
            zmfin(i)     =zero
            stipdw(i)    =zero
            do is=1,nspec
               qu(is,i)  =zero
               qm(is,i)  =zero
            enddo
            irlsnum(i)   =0
            isrcnum(i)   =0
            isrctyp(i)   =0
            ipufcd(i)    =0
            elbase(i)    =zero
            do i3=1,3
               do i2=1,2
                  tcon(i3,i2,i)  =zero
               enddo
            enddo
            isplit(i)    =0
            iemstep(i)   =0
            idw0(i)      =0
            ht0(i)       =zero
            exitw0(i)    =zero
            diam0(i)     =zero
            ws0(i)       =zero
            istab0(i)    =0
            sqrts0(i)    =zero
            srat0(i)     =zero
            temit0(i)    =zero
            hb0(i)       =zero
            hw0(i)       =zero
            heff20(i)    =zero
            iru0(i)      =0
            sigv0(i)     =zero
            sigw0(i)     =zero
            el0(i)       =zero
            plexp0(i)    =zero
            zly0(i)      =zero
            r0(i)        =zero
            sysrc0(i)    =zero
            szsrc0(i)    =zero
            xshift0(i)   =zero
            sy0(i)       =zero
            sz0(i)       =zero

c ---       SLUG.PUF
            xpe(i)       =zero
            ype(i)       =zero
            zpe(i)       =zero
            sigye(i)     =zero
            sigze(i)     =zero
            xtote(i)     =zero
            tmtote(i)    =zero
            speed0(i)    =zero

      endif

      return
      end
c----------------------------------------------------------------------
      function vemfac(ldb,ivary,iq12,tdegk,ws,istab)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                 VEMFAC
c                D. Strimaitis, EARTH TECH
c
c --- PURPOSE:  Provide a scaling factor for the emission rate from
c               values provided in the control file
c
c --- UPDATES
c --- V5.4-V6.1     050915  (DGS): begin-end time used in /DATEHR/, so
c                                  nmo replaced with nmob
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.1-V5.2     991104  (JSS): Error messages written to list
c                                  file as well as to screen
c --- V5.0-V5.0     981228  (DGS): alter ITCAT eqn to obtain T bins
c                                  listed in control file
c                   980918  (DGS): Impose ITCAT=1 as lower limit
c
c --- INPUTS:
c           LDB - logical       - Output debug writes when .TRUE.
c         IVARY - integer       - Type of emission variability
c                                  0:  NO variation
c                                  1:  Diurnal (24 values)
c                                  2:  Monthly (12 values)
c                                  3:  Hour & Season (96 values)
c                                  4:  Speed & Stability (36 values)
c                                  5:  Temperature (12 values)
c          IQ12 - integer       - Pointer to starting location in VQFAC
c         TDEGK - real          - Ambient temperature (K)
c            WS - real          - Wind speed (m/s)
c         ISTAB - integer       - Stability class - PG
c
c     Common block /COMPARM/:
c           WSCAT(5), VQFAC(12,mxq12), IQNUM(5),
c     Common block /DATEHR/:
c           nmob,nhrind
c     Parameters:
c           MXQ12
c
c --- OUTPUT:
c        VEMFAC - real          - Emission rate factor for current
c                                 conditions
c
c --- VEMFAC called by:  POINTS1, AREAS1, LINES1, VOLS
c --- VEMFAC calls:      none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include commons
      include 'comparm.puf'
      include 'datehr.puf'

      logical ldb
      integer iseas(12)

      data iseas/1,1,2,2,2,3,3,3,4,4,4,1/

c --- Select factor based on type of variation
      if(ivary.EQ.0) then
c ---    No variation
         vemfac=1.0
         return
      elseif(ivary.EQ.1) then
c ---    Diurnal (24 values)
         j=iq12
         n12=nhrind
         if(n12.GT.12) then
            n12=n12-12
            j=j+1
         endif
         vemfac=vqfac(n12,j)
      elseif(ivary.EQ.2) then
c ---    Monthly (12 values)
         j=iq12
         n12=nmob
         vemfac=vqfac(n12,j)
      elseif(ivary.EQ.3) then
c ---    Hour & Season (96 values)
         j=iq12+(iseas(nmob)-1)*2
         n12=nhrind
         if(n12.GT.12) then
            n12=n12-12
            j=j+1
         endif
         vemfac=vqfac(n12,j)
      elseif(ivary.EQ.4) then
c ---    Speed & Stability (36 values)
         iws=1
         do ii=1,5
            if(ws.GT.wscat(ii)) iws=ii+1
         enddo
         if(istab.LE.2) then
            j=iq12
            n12=iws+6*(istab-1)
         elseif(istab.LE.4) then
            j=iq12+1
            n12=iws+6*(istab-3)
         else
            j=iq12+2
            n12=iws+6*(istab-5)
         endif
         vemfac=vqfac(n12,j)
      elseif(ivary.EQ.5) then
c ---    Temperature (12 values)
         itcat=0.2*(tdegk-268.16)+1
         itcat=MIN0(itcat,12)
         itcat=MAX0(itcat,1)
         j=iq12
         n12=itcat
         vemfac=vqfac(n12,j)
      else
         write(io6,*)'VEMFAC -- FATAL Error, Invalid IVARY = ',ivary
         write(*,*)
         stop 'Halted in VEMFAC -- see list file.'
      endif

c --- Debug output
      if(LDB) then
         write(io6,*)'VEMFAC --   ivary,iq12: ',ivary,iq12
         write(io6,*)'           T, ws, stab: ',tdegk,ws,istab
         write(io6,*)'           j, n12, fac: ',j,n12,vemfac
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine lines2(ig,nspec,ndhrb,nsecb,ndhre,nsece,dtsec,
     &                   smxi1,ldb,mfact,metfm,np,newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                 LINES2
c                D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff/slug variables for
c               LINE SOURCES with variable parameters (one group
c               processed)
c
c --- UPDATE
c --- V6.22-V6.261  080520  (DGS): Place rise tables in DA file
c --- V6.1-V6.22    070921  (DGS): initialize variables written in debug
c                                  output that may not be computed in
c                                  loop over lines (thalf,xhalfkm,
c                                  syhalf,szhalf)
c                   070921  (DGS): Replace intrinsic function AMIN0()
c                                  with MIN() when both result and
c                                  arguments are integers
c --- V5.75-V6.1    050915  (DGS): generalize treatment of time for
c                                  variable emissions files --
c                                  resolve time to seconds, and
c                                  allow variable emissions timesteps
c --- V5.74-V5.75   050225  (DGS): Add DPBL arg to SETCSIG for TAULY
c --- V5.72-V5.74   040715  (DGS): add METFM=5 (AERMET)
c --- V5.4-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.0     980807  (DGS): use final rise CALMET/PROFILE winds 
c                                  to set release step
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c --- V4.0-V5.0     971107  (DGS): ZPB,ZPE arrays added
c
c --- INPUTS:
c            IG - integer - Index for line source group processed
c         NSPEC - real    - Number of species modeled
c         NDHRB - integer - Julian day, hour beginning current step
c         NSECB - integer - Seconds at beginning of current step
c         NDHRE - integer - Julian day, hour at end of current step
c         NSECE - integer - Seconds at end of current step
c         DTSEC - real    - Length (seconds) of a basic time step
c         SMXI1 - real    - Reciprocal of speed required to travel max
c                           allowed distance in 1 timestep
c           LDB - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c         MFACT - integer - Stepping index to identify slugs vs puffs
c         METFM - integer - Meteorological data format
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /COMPARM/ variables:
c           XMXLEN, MXNEW, SYMIN, SZMIN, WSCALM
c     Common block /FLAGS/ variables:
c           MGAUSS, MSLUG, MTIP, MHFTSZ, MSHEAR
c     Common block /GRID/ variables:
c           DGRID, IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /LN2/ variables:
c           NLRISE2,NLINES2(mxqstep),
c           NL2(mxqstep,mxlngrp),XL2(mxqstep,mxlngrp),
c           HBL2(mxqstep,mxlngrp),WBL2(mxqstep,mxlngrp),
c           WML2(mxqstep,mxlngrp),DXL2(mxqstep,mxlngrp),
c           FPRIMEL2(mxqstep,mxlngrp),WSEP2(mxqstep,mxlngrp),
c           FPTOT2(mxqstep,mxlngrp),FBPT2(mxqstep,mxlngrp),
c           ILNGRP(mxqstep,mxlines),XL2BEGGRD(mxqstep,mxlines),
c           YL2BEGGRD(mxqstep,mxlines),XL2ENDGRD(mxqstep,mxlines),
c           YL2ENDGRD(mxqstep,mxlines),HSL2(mxqstep,mxlines),
c           BELEVL2(mxqstep,mxlines),XVERTL2(4,mxqstep,mxlines),
c           YVERTL2(4,mxqstep,mxlines),XL2BAR(mxqstep,mxlngrp),
c           YL2BAR(mxqstep,mxlngrp),ORIENTL2(mxqstep,mxlngrp),
c           ARLINE2(mxqstep,mxlines),QTL2(mxspec,mxqstep,mxlines)
c           NSEG2(mxqstep,mxlines)
c
c     Common block /METHR/ variables:
c           PLEXP
c     Common block /PUFF/ variables:
c           NPUFFS
c     Parameters:
c           MXRISE, MXLINES, MXLNGRP, MXQSTEP, MXSPEC, IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /LN2/ variables:
c           NEWLN2(mxqstep,mxlines), NSEG2(mxqstep,mxlines),
c     Common block /PUFF/ variables:
c           all variables in common block
c     Common block /SLUG/ variables:
c           all variables in common block
c     Common block /SRCTAB/ variables:
c           NTR, XTR(mxrise), ZTR(mxrise)
c
c --- LINES2 called by:  INITPUF
c --- LINES2 calls:      RLSMET, ROLLDN, HEFTRAN, SIGTY, SIGTZ, SETLINE,
c                        SWAP, INJECT, ZEROTAB, SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'

      include 'comparm.puf'
      include 'csigma.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methr.puf'
      include 'ln2.puf'
      include 'puff.puf'
      include 'slug.puf'
      include 'srctab.puf'

      real q(mxspec)
      logical ldb,problem,lcalm

c --- Set minimum allowed wind speed for building downwash (.GE.1)
      data wsdw0/1.0/

      data oneby2pi/0.1591549/,rt2pi/2.5066283/,rt2bypi/0.7978846/
      data zero/0.0/

c ***
      if(ldb) then
         write(io6,*)
         write(io6,*) 'LINES2:  Processing Line Group ',ig
         write(io6,*) '         # of emission periods ',nstep5
      endif
c ***

c --- Loop over emission periods within this timestep
      do 500 it=1,nstep5

c ---    Skip inactive groups this emission step
         if(nl2(it,ig).LE.0) goto 500

c -------------------------------------------------------------------
c ---    Get met data for block of line sources
c -------------------------------------------------------------------
c
c ---    Determine the met. grid point closest to the CENTER of the
c ---    array of line sources
         ixs=1.0+xl2bar(it,ig)
         iys=1.0+yl2bar(it,ig)
c
c ---    Source off the computational grid -- write a FATAL message
         if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.
     1      iys.lt.jbcomp.or.iys.gt.jecomp) then
            write(io6,20) ig,ixs,iys
20       format(/1x,'FATAL -- a line source with variable emissions ',
     1   'is off the computational grid'/1x,'group no. (i) = ',i6,2x,
     2   'nearest grid point (ixs,iys) = (',i5,',',i5,')')
            problem=.TRUE.
            return
         endif

c ---    Initialize source tabulation arrays to zero
         call ZEROTAB
c
c ---    Extract wind speed & other met. variables;
c ---    and set CALM configuration if triggered
         call rlsmet(ldb,ixs,iys,hbl2(it,ig),mfact,
     &            mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &            ustr,wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)
c
c ---    Set logical to identify calm conditions
         if(ws.LT.wscalm) then
            lcalm=.TRUE.
         else
            lcalm=.FALSE.
         endif
c
c ---    Calculate the virtual times and sigmas at Heffter transition
         uavg=amax1(.5,ws)
c
c ---    Set selected data in /CSIGMA/ for sigma calls
         call setcsig(idopty,idoptz,iru,uavg,istab,el,sqrts,
     &            tsigv,tsigw,symin,szmin,hbl2(it,ig),dpbl)
c
         if(mhftsz.EQ.0)then
            szh=syh
            call sigty(syh,zero,zero,dum,thfty,dhfty)
         else
            call heftran(1,hsl2(it,1),symin,szmin,zero,zero,zero,zero)
         endif
c
c --------------------------------------------------------------------
c ---    Calculate modified plume rise parameters for group, and
c ---    tabulate rise from point of full buoyancy (XFB) to point of
c ---    final rise
c --------------------------------------------------------------------
c
c ---    Find angle between flow and orientation of line sources (theta)
         theta=flow-orientl2(it,ig)
c
c ---    Compute attributes of the line sources for this meteorology,
c ---    and update rise tabulation
         ntr=nlrise2
         call setline(mshear,theta,ws,istab,sqrts,plexp,nl2(it,ig),
     &             xl2(it,ig),hbl2(it,ig),wml2(it,ig),fprimel2(it,ig),
     &             wsep2(it,ig),fptot2(it,ig),fbpt2(it,ig),
     &             ntr,xle,xld,rzero,xtr,ztr)
c
c ---    Set trig. factors for flow direction
         sinf=sin(flow)
         cosf=cos(flow)
c
c ---    Find the along-flow coordinate that defines the line source
c ---    element furthest upwind: (YY0GRD in met grid units)
c ---    Rotate coord. system to place the yy-axis along the flow
c ---   (line 1)
         do il=nlines2(it),1,-1
            if(ilngrp(il).EQ.ig) il1=il
         enddo
         yybeg=xl2beggrd(it,il1)*sinf+yl2beggrd(it,il1)*cosf
         yyend=xl2endgrd(it,il1)*sinf+yl2endgrd(it,il1)*cosf
         yy0grd=amin1(yybeg,yyend)
c ---    Continue with other lines, if used
         do i=2,nl2(it,ig)
            lni=i-1+il1
            yy=xl2beggrd(it,lni)*sinf+yl2beggrd(it,lni)*cosf
            yy0grd=amin1(yy0grd,yy)
            yy=xl2endgrd(it,lni)*sinf+yl2endgrd(it,lni)*cosf
            yy0grd=amin1(yy0grd,yy)
         enddo

c ---    Use CALMET/PROFILE winds at final rise to set release/sampling
c ---    data
         if(metfm.EQ.1 .OR. metfm.EQ.4 .OR. metfm.EQ.5) then
            heff=hbl2(it,ig)+ztr(ntr)
            call rlsmet(ldb,ixs,iys,heff,mfact,
     &               mfact0fr,ilayerfr,wsfr,flowfr,ivecfr,istab,dpbl,
     &               el,ustr,wstr,tsigvfr,tsigwfr,iru,issta,sqrtsfr,
     &               idoptyfr,idoptzfr)
            wsnew=AMAX1(ws,wsfr)
         else
            wsnew=ws
         endif
c
c******
      if(ldb)then
         write(io6,204) ilayer,ixs,iys,ws,istab,dpbl,issta,theta
204      format(5x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'THETA: ',f5.1)
c
         write(io6,206) xtr(1),ztr(1),xle,xld,
     1                  xtr(ntr),ztr(ntr)
206      format(5x,'XFB : ',f6.1,2x,'ZFB : ',f6.1,2x,'XLE : ',
     1    f6.1,2x,'XLD : ',f6.1,2x,'XFIN0: ',f6.1,2x,'ZFIN0: ',f6.1)
c
      endif
c*****


c ---    Start-time for emission period during timestep
         if(ndhrqb5(it).LT.ndhrb) then
            ndhr1=ndhrb
            nsec1=nsecb
         elseif(ndhrqb5(it).EQ.ndhrb .AND.
     &          nsecqb5(it).LT.nsecb) then
            ndhr1=ndhrb
            nsec1=nsecb
         else
            ndhr1=ndhrqb5(it)
            nsec1=nsecqb5(it)
         endif
c ---    End-time for emission period during timestep
         if(ndhrqe5(it).GT.ndhre) then
            ndhr2=ndhre
            nsec2=nsece
         elseif(ndhrqe5(it).EQ.ndhre .AND.
     &          nsecqe5(it).GT.nsece) then
            ndhr2=ndhre
            nsec2=nsece
         else
            ndhr2=ndhrqe5(it)
            nsec2=nsecqe5(it)
         endif
c ---    Duration of emission period within timestep (seconds)
         call DELTSEC(ndhr1,nsec1,ndhr2,nsec2,ntemit)
         temit=FLOAT(ntemit)
c ---    Apply transport constraints
         npnewt=wsnew*smxi1*temit/dtsec+1
         npnewt=MIN(npnewt,mxnew)
         temit=temit/FLOAT(npnewt)

         if(ldb)then
            write(io6,*)
            write(io6,*) 'Emissions start:',ndhrqb5(it),nsecqb5(it)
            write(io6,*) 'Emissions   end:',ndhrqe5(it),nsecqe5(it)
            write(io6,*) 'Puff step start:',ndhrb,nsecb
            write(io6,*) 'Puff step   end:',ndhre,nsece
            write(io6,*) 'Use       start:',ndhr1,nsec1
            write(io6,*) 'Use         end:',ndhr2,nsec2
         endif

c
c --------------------------------------------------
c ---    Loop over lines
c --------------------------------------------------
c
         do 100 ii=1,nlines2(it)

         i=idline(it,ii)

c ---    Skip line sources that are not in current group
         if(ilngrp(i).NE.ig) goto 100

c ---    Skip lines that have no emissions this step
         qsum=0.0
         do is=1,nspec
            qsum=qsum+qtl2(is,it,i)
         enddo
         if(qsum.EQ.0.0) goto 100

c ---    Rotate coord. system to place the yy-axis along the flow
         xxbeg=xl2beggrd(it,i)*cosf-yl2beggrd(it,i)*sinf
         xxend=xl2endgrd(it,i)*cosf-yl2endgrd(it,i)*sinf
         yybeg=xl2beggrd(it,i)*sinf+yl2beggrd(it,i)*cosf
         yyend=xl2endgrd(it,i)*sinf+yl2endgrd(it,i)*cosf

c ---    Find cross-wind and along-wind length of this line in meters
         xcrossm=abs(xxbeg-xxend)*dgrid
         yalongm=abs(yybeg-yyend)*dgrid

c ---------------------------------------------------------
c ---    Compute number of segments needed for one line (NSEG)
c ---------------------------------------------------------
         if(mslug.EQ.0 .OR. lcalm) then
c ---       Puffs are released, so use all MXNSEG segments
            thalf=0.
            xhalfkm=0.
            syhalf=0.
            szhalf=0.
            nsegy=0
            nsegz=0
            nseg2(it,i)=mxnseg2
         else
c ---       Slugs are released
c
c ---       Calculate the virtual times and sigmas at the Heffter
c ---       transition
            if(mhftsz.EQ.0)then
               szh=syh
               call sigty(syh,zero,zero,dum,thfty,dhfty)
            else
               call heftran(1,hsl2(it,i),syab1,szab1,
     &                      zero,zero,zero,zero)
            endif
c ---       Set NSEGY as function of transport speed, sigma-y,
c ---       and cross-wind length of line (make it an ODD integer)
            thalf=0.5*dtsec
            xhalfkm=0.001*uavg*thalf
            call sigty(zero,xhalfkm,thalf,syhalf,dum,dum)
            nsegy=nint(xcrossm/(rt2pi*syhalf))
            iodd=mod(nsegy,2)
            if(iodd.EQ.0) nsegy=nsegy+1
c ---       Set NSEGZ as function of transport speed, sigma-z, release
c ---       ht, and along-wind change in rise (make it an ODD integer)
            call sigtz(zero,xhalfkm,thalf,hsl2(it,i),szhalf,dum,dum)
            nsegz=nint(2.0*ztr(1)/szhalf)
            iodd=mod(nsegz,2)
            if(iodd.EQ.0) nsegz=nsegz+1
c ---       Take the larger of the two
            nseg2(it,i)=MAX0(nsegz,nsegy)
c ---       Cap result at MXNSEG
            nseg2(it,i)=MIN0(nseg2(it,i),mxnseg2)
         endif

c ---    Update puff numbers
c ---    Keep track of number of new puffs from each segment
         newln2(i)=newln2(i)+npnewt
c ---    Line releases npnewt clouds this emissions step, with nseg
c ---    elements in each cloud
         newpuf=newpuf+npnewt*nseg2(it,i)
c ---    If puff arrays are full, remove puffs that are off the grid
c ---    and "roll down" arrays to make room for new puffs
c ---    (this also applies to the DA file of tabulated arrays)
         if(npuffs+newpuf.gt.mxpuff) call rolldn(np)
c ---    Check to see if roll-down was adequate
         if(npuffs+newpuf.gt.mxpuff)then
            write(io6,*) ' ERROR in subr. LINES2'
            write(io6,*)'Too many puffs on grid for array dimensions',
     1      ' -- NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2      ' MXPUFF = ',mxpuff
            write(*,*)
            stop 'Halted in LINES2 -- see list file.'
         endif
c
c --------------------------------------------------------------------
c ---    Calculate building downwash effects on initial plume sigmas
c --------------------------------------------------------------------
c ---    Initialize downwash variables to zero (no building downwash)
         sz0dw=0.0
         sy0dw=0.0
         idw=0
         if(ws.GT.wsdw0 .AND. .NOT.lcalm) then
c ---       Set downwash flag to ACTIVE
            idw=1
c ---       Use BLP calculation of downwash sigmas
            sz0dw=rt2bypi*rzero
            sy0dw=0.5*sz0dw
         endif
c
c ---    Set initial sigma y, sigma z for puff/slug, including
c ---    effective spread due to length of line source element
c ---    (add length effects and downwash effects in quadrature)
c ---    Crosswind variance: 0.25*(line width)**2/(2pi)
         if(lcalm) then
            xlen2=(xcrossm**2+yalongm**2)/(nseg2(it,i)**2)
         else
            xlen2=(xcrossm/nseg2(it,i))**2
         endif
         sy2=0.25*oneby2pi*xlen2+sy0dw*sy0dw
         sysrc=amax1(symin,sqrt(sy2))
c ---    Alongwind variance: 0.25*(line length * rise rate)**2/(2pi)
         if(lcalm) then
            sz2=0.0
            szsrc=szmin
         else
            sz2=0.25*oneby2pi*((yalongm/nseg2(it,i))*
     &                      ztr(1)/xtr(1))**2+sz0dw*sz0dw
            szsrc=amax1(szmin,sqrt(sz2))
         endif
c
c ---    Swap emission rate for source 'i' into 1D array
         do is=1,nspec
            q(is)=qtl2(is,it,i)
         enddo
c******
      if(ldb)then
         write(io6,*)
         write(io6,*) 'Line Source # ',i
         write(io6,*) 'Emission step ',it
         write(io6,*)
         write(io6,*) 'LINES2:  thalf,xhalfkm = ',thalf,xhalfkm
         write(io6,*) '          syhalf,nsegy = ',syhalf,nsegy
         write(io6,*) '          szhalf,nsegz = ',szhalf,nsegz
         write(io6,*) '                  nseg = ',nseg2(it,i)
         write(io6,208) xcrossm,npnewt,newpuf,dtsec,
     2                  idw,rzero,sysrc,szsrc
208      format(5x,'XCROSSM: ',f6.1,2x,
     2    'NPNEWT: ',i4,2x,'NEWPUF: ',i5,2x,'DTSEC: ',f7.2,2x/5x,
     3    'IDW: ',i3,2x,'RZERO: ',f6.1,2x,'SYSRC: ',f6.1,2x,
     4    'SZSRC: ',f6.1)
      endif
c*****
c
c -------------------------------------------------------------
c ---    Loop over "point" sources (each segment) along line
c -------------------------------------------------------------
c
c ---    Set up the distance increments along the line
         dxgrd=(xl2endgrd(it,i)-xl2beggrd(it,i))/nseg2(it,i)
         dxgrdby2=0.5*dxgrd
         dygrd=(yl2endgrd(it,i)-yl2beggrd(it,i))/nseg2(it,i)
         dygrdby2=0.5*dygrd

         do 90 ipt=1,nseg2(it,i)

c ---      Set location in met grid units
           xptgrd=xl2beggrd(it,i)+(ipt-1)*dxgrd+dxgrdby2
           yptgrd=yl2beggrd(it,i)+(ipt-1)*dygrd+dygrdby2

c ---      Set shift in distance (m) of this point from the upwind edge
           yyptgrd=xptgrd*sinf+yptgrd*cosf
           xshift=(yyptgrd-yy0grd)*dgrid
           if(xshift.LT.0.0) xshift=0.0
           if(xshift.GT.xtr(1)) xshift=xtr(1)

c ---      Set final height and distance to final rise for this puff
           if(lcalm) then
             xshift=0.0
             xfrise=0.0
             heff=hsl2(it,i)+ztr(ntr)
           else
             if(xtr(1).LE.xtr(ntr)) then
c ---           Case 1:  final rise reached beyond XFB
                heff=hsl2(it,i)+ztr(ntr)-xshift*ztr(1)/xtr(1)
                xfrise=xtr(ntr)-xshift
             else
c ---           Case 2:  final rise reached before XFB
                size=1.0-xshift/xtr(1)
                heff=hsl2(it,i)+ztr(ntr)*size
                xfrise=xtr(ntr)*size
             endif
           endif
c
c******
      if(ldb)then
         write(io6,*) 'Element #  ',ipt
         write(io6,210) hsl2(it,i),heff,xfrise,xshift,xptgrd,yptgrd
210      format(5x,'HSL : ',f6.1,2x,'HEFF: ',f6.1,'XFRISE: ',f6.1,2x,
     1    'XSHIFT: ',f6.1,2x,'XPTGRD: ',f8.4,2x,'YPTGRD: ',f8.4)
      endif
c*****
c ----------------------------------------------------------
c ---      Initialize current hour's new puffs for this source
c ----------------------------------------------------------
           do 50 j=1,npnewt
             np=np+1
c
c ---        Use SWAP to start with all puff/slug variables = zero
             call swap(np,0)
c
c ---        Fill non-zero values
             xpb(np)=xptgrd
             ypb(np)=yptgrd
             zitibl(np)=-1.0
             elbase(np)=belevl2(it,i)
             sigyb(np)=sysrc
             sigzb(np)=szsrc
c ---        Final plume rise results for puff
             zfinal(np)=heff
             zpb(np)=heff
             zpe(np)=heff
             xfinal(np)=xfrise
c ---        Intermediate results for calc. gradual rise
             fb(np)=fbpt2(it,ig)
c ---        Set xbfin and zbfin to negatives to signal use of final
c ---        rise if calm
             if(lcalm) then
                xbfin(np)=-1.0
                zbfin(np)=-1.0
             else
                xbfin(np)=xtr(ntr)
                zbfin(np)=ztr(ntr)
             endif
             isplit(np)=1
c ---        Time-of-release data
             ht0(np)=hsl2(it,i)
             temit0(np)=temit
             ws0(np)=ws
             istab0(np)=istab
             sqrts0(np)=sqrts
             iru0(np)=iru
             sigv0(np)=tsigv
             sigw0(np)=tsigw
             el0(np)=el
             plexp0(np)=plexp
c ---        Set vector/scalar ws ratio to 1.0
             srat0(np)=1.0
c ---        Additional time-of-release parameters needed for
c ---        receptor-specific calculations (downwash - point sources)
             idw0(np)=idw
             hb0(np)=hsl2(it,i)
             hw0(np)=xcrossm
             heff20(np)=hsl2(it,i)
             zly0(np)=xld
             r0(np)=rzero
c ---        Additional data for line sources
             xshift0(np)=xshift
             sy0(np)=sy0dw
             sz0(np)=sz0dw 

c ---    Place end-time of emission period for this puff into
c ---    TMTOTB(mxpuff) array, expressed as a fraction of the timestep
c ---    This will be used in COMP when computing the sampling steps
c ---    used to advect the freshly emitted puff during the remainder
c ---    of the timestep, and then reset.
c ---    Seconds from start of emissions period to end of timestep
             call DELTSEC(ndhr1,nsec1,ndhre,nsece,ntot)
             tmtotb(np)=(FLOAT(ntot)-temit*j)/dtsec

c ---        Emission period index for this puff
             iemstep(np)=it

c ---        Set puff identity where IRLSNUM is puff number released
c ---        from a source this time step, ISRCNUM is the source number
c ---        of type ISRCTYP from which the puff was released.
c ---        (Type =6 for variable line sources)
             jj=newln2(i)-npnewt+j
             irlsnum(np)=jj
             isrcnum(np)=i
             isrctyp(np)=6
c
c ---    !-NOTE 1-!
c ---    The puff number really refers to the number of emission
c ---    steps, which equals the puff number when ONE puff is released
c ---    from a source each emission step.  But many puffs are released
c ---    each step when simulating a line source (distributed along
c ---    the line).  Subsequent use is made of IRLSNUM in controlling
c ---    sampling functions, which depend on the emission steps, so we
c ---    explicitly place the emission-step index in the array.
c
c ----------------------------------------------------------
c ---        Do same for additional SLUG parameters
c ----------------------------------------------------------

c ---    !-NOTE 2-!
c ---    OLD slugs from each segment are modeled explicitly, but
c ---    NEW releases are modelled using the numerical area-source
c ---    method for the ENTIRE line.  Therefore, we add a marker to
c ---    all slugs after segment 1, so that these can be identified
c ---    and ignored when NEW.  The marker consists of adding 1000 to
c ---    ISRCNUM, which would indicate that the puff comes from
c ---    line-source ISRCNUM=1000+i.  A check is made in READCF which
c ---    stops execution if parameter (mxlines .GE. 1000) to insure
c ---    that no valid line-source ID exceeds 999.
c
             if(mslug.eq.1 .AND. .NOT.lcalm) then
c
c ---          Set PUFID marker
               if(ipt.GT.1) isrcnum(np)=isrcnum(np)+1000
c
c ---          Set coordinates of oldest end of slug (met. grid units)
c ---          Note that "oldest" end of slug is at source, as is the
c ---          "newest" end; oldest end moves away and grows during the
c ---          step, while newest end remains fixed in size at source.
               xpe(np)=xpb(np)
               ype(np)=ypb(np)
               xtote(np)=xtotb(np)
               tmtote(np)=tmtotb(np)
c ---          Set sigmas for oldest end of slug
               sigye(np)=sigyb(np)
               sigze(np)=sigzb(np)
             endif
c
c --------------------------------------------------------------------
c ---        Inject emissions into proper layer (above/below mixing ht)
c --------------------------------------------------------------------
c ---        Set partial penetration variables to null values
             fmix=1.0
             hmax=dpbl
c ---        Mass emitted into each line segment needs to be divided by
c ---        nseg, which is the number of segments.  Accomplish that
c ---        here by dividing the timestep by nseg.
             dtseg=temit/nseg2(it,i)
             call inject(np,nspec,dtseg,mfact0,q,heff,hmax,dpbl,
     &                   fmix,istab)
c

c ------------------------------------------------------------------
c ---      Transfer tabulated arrays record to DA file using full
c ---      MXRISE dimension
c ------------------------------------------------------------------
           call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))
50         continue
90       continue
100      continue
500   continue

      return
      end
c----------------------------------------------------------------------
      subroutine ln2fill(iq,lngrp,nsrc5,idmap,em5grp,em5dat,nvarln,
     &                   problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                LN2FILL
c                D. Strimaitis
c
c --- PURPOSE:  Fill common /LN2/ for LINE SOURCES with variable
c               parameters
c
c --- UPDATE
c --- V6.1-V6.22    070921  (DGS): initialize PROBLEM to false
c --- V5.71-V6.1    050915  (DGS): add emission substep to arrays
c                                  and update line/group mapping
c --- V5.0-V5.71    030528  (DGS): require non-negative emissions
c --- V5.0-V5.0     980430  (DGS): add number of variables before
c                                  emissions in EM5DAT as argument
c
c --- INPUTS:
c               IQ - integer - Current emission timestep index
c            LNGRP - integer - Number of groups of line sources
c                              active this period
c            NSRC5 - integer - Max number of lines in  LNEMARB file
c  EM5GRP(7,lngrp) - real ar - Time-varying LNEMARB group data
c  EM5DAT(nse5+nvarln,nsrc5)
c                  - real ar - Time-varying LNEMARB line data
c           NVARLN - integer - Number of variables in EM5DAT array
c                              before emissions
c          PROBLEM - logical - Flag indicating errors are found
c                              when true
c
c     Common block /GRID/ variables:
c           DGRID, DGRIDI, XORIG, YORIG
c
c     Common block /LN2/ variables:
c           NSE5,ILNGRP(mxlines)
c
c     Parameters:
c           MXLINES, MXLNGRP, MXSPEC
c
c --- OUTPUT:
c          PROBLEM - logical - Flag indicating errors are found
c                              when true (updated here)
c
c     Common block /LN2/ variables:
c           ILNGRP(mxlines),NLINES2(mxqstep),
c           IDLINE(mxqstep,mxlines),
c           NL2(mxqstep,mxlngrp),XL2(mxqstep,mxlngrp),
c           HBL2(mxqstep,mxlngrp),WBL2(mxqstep,mxlngrp),
c           WML2(mxqstep,mxlngrp),DXL2(mxqstep,mxlngrp),
c           FPRIMEL2(mxqstep,mxlngrp),WSEP2(mxqstep,mxlngrp),
c           FPTOT2(mxqstep,mxlngrp),FBPT2(mxqstep,mxlngrp),
c           XL2BEGGRD(mxqstep,mxlines),
c           YL2BEGGRD(mxqstep,mxlines),XL2ENDGRD(mxqstep,mxlines),
c           YL2ENDGRD(mxqstep,mxlines),HSL2(mxqstep,mxlines),
c           BELEVL2(mxqstep,mxlines),XVERTL2(4,mxqstep,mxlines),
c           YVERTL2(4,mxqstep,mxlines),XL2BAR(mxqstep,mxlngrp),
c           YL2BAR(mxqstep,mxlngrp),ORIENTL2(mxqstep,mxlngrp),
c           ARLINE2(mxqstep,mxlines),QTL2(mxspec,mxqstep,mxlines)
c
c --- LN2FILL called by:  INITPUF
c --- LN2FILL calls:      none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'grid.puf'
      include 'ln2.puf'

      real em5dat(nse5+nvarln,nsrc5),em5grp(7,lngrp)
      integer idmap(nsrc5)
      logical problem, lqneg, lok

c --- Initialize PROBLEM
      problem=.FALSE.

c --- Place the map from the active line source index to the master
c --- line source ID into this emission step
      do k=1,nsrc5
         idline(iq,k)=idmap(k)
      enddo

c --- Have all lines been assigned a group?
      lok=.TRUE.
      maxgid=0
      do k=1,nsrc5
         maxgid=MAX(maxgid,ilngrp(k))
         if(ilngrp(k).LE.0) lok=.FALSE.
      enddo

c --- Set any unassigned group IDs for these active lines
      if(.not.LOK) then
         lnumber=0
c ---    Loop over active groups
         do ig=1,lngrp
            last=lnumber
            ng=0
            keep=0
c ---       Loop over active lines in group
            do n=1,NINT(em5grp(1,ig))
               lnumber=lnumber+1
               k=idmap(lnumber)
               if(ilngrp(k).GT.0) then
                  ng=ng+1
                  keep=ilngrp(k)
               endif
            enddo
            if(ng.EQ.0) then
c ---          No lines in this group have been assigned
               maxgid=maxgid+1
               lnumber=last
               do n=1,NINT(em5grp(1,ig))
                  lnumber=lnumber+1
                  k=idmap(lnumber)
                  ilngrp(k)=maxgid
               enddo
            elseif(ng.LT.NINT(em5grp(1,ig))) then
c ---          Some lines in this group have been assigned
               lnumber=last
               do n=1,NINT(em5grp(1,ig))
                  lnumber=lnumber+1
                  k=idmap(lnumber)
                  if(ilngrp(k).LE.0) ilngrp(k)=keep
               enddo
            endif
         enddo
      endif

c --- QA: group ID must be the same for all lines in current group
      lnumber=0
c --- Loop over active groups
      do ig=1,lngrp
         last=lnumber
c ---    Loop over active lines in group
         do n=1,NINT(em5grp(1,ig))
            lnumber=lnumber+1
            k=idmap(lnumber)
            if(n.EQ.1) then
               itest=ilngrp(k)
               k1=k
            elseif(ilngrp(k).NE.itest) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. LN2FILL -- Lines in ',
     1            'this input group are from different groups'
               write(io6,*)'LNEMARB Source / Group:'
               write(io6,*)cid5(k1),' / ',itest
               write(io6,*)cid5(k),' / ',ilngrp(k)
               problem=.TRUE.
            endif
         enddo
      enddo
      if(PROBLEM) return

c --- Loop over active line groups this emission step
      nlines2(iq)=0
      do ig=1,lngrp
         nlprev=nlines2(iq)
c ---    Assign group ID for this active group
         k=nlprev+1
         igid=ilngrp(k)
c ---    Assign group properties
         nl2(iq,igid)=NINT(em5grp(1,ig))
         nlines2(iq)=nlines2(iq)+nl2(iq,igid)
         xl2(iq,igid)=em5grp(2,ig)
         hbl2(iq,igid)=em5grp(3,ig)
         wbl2(iq,igid)=em5grp(4,ig)
         wml2(iq,igid)=em5grp(5,ig)
         dxl2(iq,igid)=em5grp(6,ig)
         fprimel2(iq,igid)=em5grp(7,ig)
c ---    Separation between centers of adjacent lines (average)
         wsep2(iq,igid)=wbl2(iq,igid)+dxl2(iq,igid)
c ---    Total buoyancy flux from all line sources in block
         fptot2(iq,igid)=fprimel2(iq,igid)*em5grp(1,ig)
c ---    Corresponding point-source buoyancy flux (fptot/pi)
         fbpt2(iq,igid)=fptot2(iq,igid)*0.3183099
c ---    Set half average line width for area calculations below
         wmlby2=0.5*wml2(iq,igid)
         wmlby2=FLOAT(INT(wmlby2)+1)
c ---    Loop over lines
         do i=nlprev+1,nlines2(iq)
            xl2beggrd(iq,i)=(1000.*em5dat(1,i)-xorig)*dgridi
            yl2beggrd(iq,i)=(1000.*em5dat(2,i)-yorig)*dgridi
            xl2endgrd(iq,i)=(1000.*em5dat(3,i)-xorig)*dgridi
            yl2endgrd(iq,i)=(1000.*em5dat(4,i)-yorig)*dgridi
            hsl2(iq,i)=em5dat(5,i)
            belevl2(iq,i)=em5dat(6,i)
            lqneg=.FALSE.
            do is=1,nse5
               k=is+nvarln
               qtl2(ixrem5(is),iq,i)=em5dat(k,i)
               if(qtl2(ixrem5(is),iq,i).LT.0.0) lqneg=.TRUE.
            enddo
c ---       Report problem if any emissions are negative
            if(lqneg) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. LN2FILL -- Invalid ',
     1         'emission rate  (must NOT be negative)'
               write(io6,*)' -- LNEMARB Source = ',i
               problem=.TRUE.
            endif
            if(PROBLEM) return
c
c ---       Compute the vertex coordinates for corresponding
c ---       area-source representation
            xdiffm=(xl2beggrd(iq,i)-xl2endgrd(iq,i))*dgrid
            ydiffm=(yl2beggrd(iq,i)-yl2endgrd(iq,i))*dgrid
c ---       Let "c" denote 1/slope of line
            if(abs(ydiffm).LE.1.0e-10) then
               dx=0.0
               dy=-wmlby2
            else
               c=xdiffm/ydiffm
               dx=wmlby2/SQRT(1+c*c)
               dy=-dx*c
            endif
c ---       Convert deltas to grid units
            dxgrd=dx*dgridi
            dygrd=dy*dgridi
c ---       Pass vertices to arrays in /LN2/
            xvertl2(1,iq,i)=xl2beggrd(iq,i)-dxgrd
            yvertl2(1,iq,i)=yl2beggrd(iq,i)-dygrd
            xvertl2(2,iq,i)=xl2beggrd(iq,i)+dxgrd
            yvertl2(2,iq,i)=yl2beggrd(iq,i)+dygrd
            xvertl2(3,iq,i)=xl2endgrd(iq,i)+dxgrd
            yvertl2(3,iq,i)=yl2endgrd(iq,i)+dygrd
            xvertl2(4,iq,i)=xl2endgrd(iq,i)-dxgrd
            yvertl2(4,iq,i)=yl2endgrd(iq,i)-dygrd
c ---       Corresponding area of line source in m^2
            arline2(iq,i)=2.*wmlby2*SQRT(xdiffm*xdiffm+ydiffm*ydiffm)
         enddo
c
c ---    Find center of array of line sources, and orientation
c ---    for this group
         xbeg=0.0
         ybeg=0.0
         xend=0.0
         yend=0.0
         fac=1.0/em5grp(1,ig)
         do i=nlprev+1,nlines2(iq)
            xbeg=xbeg+xl2beggrd(iq,i)
            ybeg=ybeg+yl2beggrd(iq,i)
            xend=xend+xl2endgrd(iq,i)
            yend=yend+yl2endgrd(iq,i)
         enddo
         xbeg=xbeg*fac
         ybeg=ybeg*fac
         xend=xend*fac
         yend=yend*fac
c
         xl2bar(iq,igid)=0.5*(xbeg+xend)
         yl2bar(iq,igid)=0.5*(ybeg+yend)
         orientl2(iq,igid)=ATAN2((xbeg-xend),(ybeg-yend))
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine ln2swap(nspec,iqinp,iqout)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                LN2FILL
c                D. Strimaitis,  EARTH TECH
c
c --- PURPOSE:  Swap variables in common /LN2/ for LINE SOURCES with
c               variable parameters, from emission step iqinp to
c               emission step iqout
c
c --- INPUTS:
c            NSPEC - integer - Number of species
c            IQINP - integer - Emission step 'input'
c            IQOUT - integer - Emission step 'output'
c
c     Common block /LN2/ variables:
c           IXREM5(mxspec)
c
c     Parameters:
c           MXLINES, MXLNGRP, MXSPEC
c
c --- OUTPUT:
c
c     Common block /LN2/ variables:
c           NDHRQB5(mxqstep),NSECQB5(mxqstep),
c           NDHRQE5(mxqstep),NSECQE5(mxqstep),
c           NLINES2(mxqstep),
c
c           NL2(mxqstep,mxlngrp),XL2(mxqstep,mxlngrp),
c           HBL2(mxqstep,mxlngrp),WBL2(mxqstep,mxlngrp),
c           WML2(mxqstep,mxlngrp),DXL2(mxqstep,mxlngrp),
c           FPRIMEL2(mxqstep,mxlngrp),WSEP2(mxqstep,mxlngrp),
c           FPTOT2(mxqstep,mxlngrp),FBPT2(mxqstep,mxlngrp),
c           XL2BAR(mxqstep,mxlngrp),YL2BAR(mxqstep,mxlngrp),
c           ORIENTL2(mxqstep,mxlngrp),
c
c           IDLINE(mxqstep,mxlines),
c           XL2BEGGRD(mxqstep,mxlines),YL2BEGGRD(mxqstep,mxlines),
c           XL2ENDGRD(mxqstep,mxlines),YL2ENDGRD(mxqstep,mxlines),
c           HSL2(mxqstep,mxlines),BELELN2(mxqstep,mxlines),
c           XVERTL2(4,mxqstep,mxlines),YVERTL2(4,mxqstep,mxlines),
c           ARLINE2(mxqstep,mxlines),NSEG2(mxqstep,mxlines),
c           QTL2(mxspec,mxqstep,mxlines),NEWLN2(mxqstep,mxlines)
c
c --- LN2SWAP called by:  INITPUF
c --- LN2SWAP calls:      none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'ln2.puf'

      integer igrp(mxlngrp)

c --- Initialize marker for groups to 0
      do k=1,mxlngrp
         igrp(k)=0
      enddo

c --- Date - time
      ndhrqb5(iqout)=ndhrqb5(iqinp)
      nsecqb5(iqout)=nsecqb5(iqinp)
      ndhrqe5(iqout)=ndhrqe5(iqinp)
      nsecqe5(iqout)=nsecqe5(iqinp)

c --- Total number of lines
      nlines2(iqout)=nlines2(iqinp)

c --- Loop over lines
      do i=1,nlines2(iqout)
         idline(iqout,i)=idline(iqinp,i)
         xl2beggrd(iqout,i)=xl2beggrd(iqinp,i)
         yl2beggrd(iqout,i)=yl2beggrd(iqinp,i)
         xl2endgrd(iqout,i)=xl2endgrd(iqinp,i)
         yl2endgrd(iqout,i)=yl2endgrd(iqinp,i)
         hsl2(iqout,i)=hsl2(iqinp,i)
         belevl2(iqout,i)=belevl2(iqinp,i)
         do k=1,4
            xvertl2(k,iqout,i)=xvertl2(k,iqinp,i)
            yvertl2(k,iqout,i)=yvertl2(k,iqinp,i)
         enddo
         arline2(iqout,i)=arline2(iqinp,i)
         nseg2(iqout,i)=nseg2(iqinp,i)
         newln2(i)=newln2(i)
         do is=1,nspec
            qtl2(ixrem5(is),iqout,i)=qtl2(ixrem5(is),iqinp,i)
         enddo
c ---    Mark group for this line
         k=ilngrp(idline(iqout,i))
         igrp(k)=1
      enddo

c --- Loop over line-group variables
      do ig=1,mxlngrp
         if(igrp(ig).EQ.0) then
            nl2(iqout,ig)=0
         else
            nl2(iqout,ig)=nl2(iqinp,ig)
            xl2(iqout,ig)=xl2(iqinp,ig)
            hbl2(iqout,ig)=hbl2(iqinp,ig)
            wbl2(iqout,ig)=wbl2(iqinp,ig)
            wml2(iqout,ig)=wml2(iqinp,ig)
            dxl2(iqout,ig)=dxl2(iqinp,ig)
            fprimel2(iqout,ig)=fprimel2(iqinp,ig)
            wsep2(iqout,ig)=wsep2(iqinp,ig)
            fptot2(iqout,ig)=fptot2(iqinp,ig)
            fbpt2(iqout,ig)=fbpt2(iqinp,ig)
            xl2bar(iqout,ig)=xl2bar(iqinp,ig)
            yl2bar(iqout,ig)=yl2bar(iqinp,ig)
            orientl2(iqout,ig)=orientl2(iqinp,ig)
         endif
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine ctadj(zterr,zht,zstak,zbase,ppcoef,zpa)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                  CTADJ
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Adjust puff-height to simulate terrain effects when
c               either the ISC terrain treatment (MCTADJ = 1) or the
c               partial plume height correction (MCTADJ = 3) is used
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): Allow receptors below stack base
c                                  in ISC treatment
c                   971107  (DGS): Also continue to apply partial
c                                  height eqn. with negative terrain ht
c
c --- INPUTS:
c             ZTERR - real    - Terrain elevation (m MSL) at receptor
c               ZHT - real    - Puff height before adjustments (m)
c             ZSTAK - real    - Stack height of source of puff (m)
c             ZBASE - real    - Stack base elevation MSL (m)
c            PPCOEF - real    - Plume Path Coefficient
c
c     Common Block /FLAGS/ variables:
c        MCTADJ
c     Parameters:
c        MXREC
c
c
c --- OUTPUTS:
c         ZPA - real      - Adjusted puff height above ground (m)
c
c --- CTADJ called by:  VCBAR, PUFRECS, SLGRECS, RECSPEC0
c --- CTADJ calls:      none
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'flags.puf'
      include 'nongrd.puf'

c --- Set minimum height of slug above the ground
      data zmin/0.0/

c --- Apply terrain adjustment
      if(mctadj .EQ. 1) then
c ---    ISC terrain adjustment
c ---    Chop terrain at stack-top (set relative to stack-base)
         zrterr = AMIN1(zterr-zbase,zstak)
c ---    Allow negative zrterr to pass (as in ISCST)
         zpa=AMAX1(zmin, (zht - zrterr))
      elseif(mctadj .EQ. 3) then
c ---    Partial Plume Height adjustment (e.g. half-height)
         delzr=zterr-zbase
c ---    Allow terrain below stack-base (delzr can be negative)
         zpa=zht-(1.-ppcoef)*AMIN1(zht,delzr)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine ctadj2(r,zpold,xold,yold,xnew,ynew,szold,bvf,ws,
     &                  ldbhr,strain,zpnew,fracz,lup)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991104a                CTADJ2
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute strain-induced adjustment factor for vertical
c               dispersion, where the strain in the flow is approx.
c               from the underlying gridded terrain field.
c               Also, compute changes in puff height above ground for
c               stably stratified flow.  This is used when MCTADJ=2.
c
c --- UPDATE
c --- V5.0-V5.2     991104a (DGS): add constraint that R <= 1.0
c --- V4.0-V5.0     971107  (DGS): clean up treatment of degenerate
c                                  cases; use approximate expressions
c                                  for functions of small argument
c                   971107  (DGS): use puff height and local terrain
c                                  relief for determining etabyh, and
c                                  use local relief in Froude number
c                   971107  (DGS): set ratio of step length to
c                                  horizontal scale of surrogate hill
c                                  equal to step rise/relief
c                   971107  (JCC): separate max/min function calls
c --- V4.0-V5.0     971107  (DGS): adjust puff height for stable flows
c
c --- INPUTS:
c           R - real      - ratio of sigma-z at the start of step
c                           to that at end of step, before accounting
c                           for strain during the step
c       ZPOLD - real      - Puff height above ground (m) at start
c        XOLD - real      - Old puff x-position (Met Grid Units)
c        YOLD - real      - Old puff y-position (Met Grid Units)
c        XNEW - real      - New puff x-position (Met Grid Units)
c        YNEW - real      - New puff y-position (Met Grid Units)
c       SZOLD - real      - Sigma-z at start of step (m)
c         BVF - real      - Current Brunt-Vaisala freq (1/s)
c          WS - real      - Current wind speed (m/s)
c       LDBHR - logical   - Debug write logical
c
c       Common block /GRID/ variables:
c             dgrid, relief(5,mxnx,mxny), nx, ny
c       Parameters:
c             IO6,MXNX,MXNY
c
c --- OUTPUT:
c      STRAIN - real      - Dispersion adjustment factor for the
c                           current step
c       ZPNEW - real      - Puff height above ground (m) at end of step
c       FRACZ - real      - Fraction of step beyond which puff height is
c                           is constant (ZPNEW) for upslope flow, or up
c                           to which puff height is constant (ZPOLD) for
c                           downslope flow
c         LUP - logical   - Flag indicating upslope flow when .TRUE.
c
c --- CTADJ2 called by:  SETPUF, SETSLG
c --- CTADJ2 calls:      GETELEV
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'grid.puf'

      logical ldbhr,lup

      data two/2./,one/1./,half/0.5/,third/0.3333333/,zero/0.0/,
     &     small/1.0e-4/

c --- Condition ratio r to be <= 1
      r=AMIN1(1.0,r)

c --- Set met cell location for old and new puff locations
      icello=1+AMAX1(zero,xold)
      jcello=1+AMAX1(zero,yold)
      icelln=1+AMAX1(zero,xnew)
      jcelln=1+AMAX1(zero,ynew)

      icello=MIN0(nx,icello)
      jcello=MIN0(ny,jcello)
      icelln=MIN0(nx,icelln)
      jcelln=MIN0(ny,jcelln)

c --- Compute horizontal distance of step, and rise along step (m)
      xstep=(xnew-xold)*dgrid
      ystep=(ynew-yold)*dgrid
      delx=SQRT(xstep**2+ystep**2)
      call GETELEV(xold,yold,elold)
      call GETELEV(xnew,ynew,elnew)
      rise=elnew-elold
      arise=abs(rise)
      if(rise.GT.zero) then
         lup=.TRUE.
      else
         lup=.FALSE.
      endif

c --- Set relief height for this trajectory
c --- ( tan(22.5)=0.4142 , tan(67.5)=2.4142)
      if(ABS(ystep).GT.2.4142*ABS(xstep)) then
c ---    North-South
         rlf=AMAX1(relief(1,icello,jcello),relief(1,icelln,jcelln))
      else
         ybyx=ystep/xstep
         if(ybyx.GT.0.4142) then
c ---       NorthEast-SouthWest
            rlf=AMAX1(relief(2,icello,jcello),relief(2,icelln,jcelln))
         elseif(ybyx.LT.-0.4142) then
c ---       SouthEast-NorthWest
            rlf=AMAX1(relief(4,icello,jcello),relief(4,icelln,jcelln))
         else
c ---       East-West
            rlf=AMAX1(relief(3,icello,jcello),relief(3,icelln,jcelln))
         endif
      endif

c --- Set peak terrain elevation near this trajectory
      eltop=AMAX1(relief(5,icello,jcello),relief(5,icelln,jcelln))

c --- Compute puff height changes and strain function
c
      if(delx.LE.small .OR. arise.LE.small) then
c ---    Treat degenerate case of no step or no slope
         dtz=zero
         slope=zero
         xbyl=zero
         dxbyl=zero
         strat=zero
         tz=one
         tzsq=one
         strain=one
         zpnew=zpold
         fracz=zero
c
      else
c
c ---    Compute the slope of the terrain along the trajectory segment
         slope=rise/delx
         aslope=ABS(slope)

c ---    Compute change in puff height above ground along step to
c ---    account for deflection of stable layer beneath puff
c ---    NOTE: puffs embedded in downslope flow are not allowed to
c ---    rise over layers below Hd
         if(bvf.GT.zero .AND. lup) then
c ---       Determine dividing-streamline elevation (m MSL)
            elds=eltop-ws/bvf
c ---       Find fraction of step at which height change either
c ---       begins or ends based on dividing-streamline
            fracz=(elds-elold)/rise
c ---       For upslope flow, add constraint that puff height is not
c ---       reduced beyond point where zp/sigz < 1.8, assuming linear
c ---       growth in sigz during step.  This is the point at which the
c ---       presence of the ground increases C(zp) by about .15% over
c ---       free-puff value, and the GLC is about 40% of C(zp).
            if(fracz.GT.zero) then
               sznew=szold/r
               fraczs=(zpold-1.8*szold)/(rise+1.8*(sznew-szold))
               fraczs=AMAX1(zero,fraczs)
               fracz=AMIN1(fraczs,fracz)
            endif
c ---       Compute puff height above ground at at end of step
            if(fracz.LE.zero) then
               zpnew=zpold
            elseif(fracz.GE.one) then
               zpnew=zpold-rise
            else
               zpnew=zpold-rise*fracz
            endif
         else
            zpnew=zpold
            fracz=zero
         endif

c ---    Set ratio of streamline height (eta) / height of the
c ---    surrogate hill (h) equal to the ratio of the "average" puff
c ---    height to the height of the local terrain relief;
c ---    condition eta/H within range 0.1 to 10.0
         zp=half*(zpold+zpnew)
         if(rlf.LE.0.1*zp) then
            etabyh=10.
         else
            etabyh=AMAX1(0.1,zp/rlf)
         endif

c ---    Compute 1/Froude number for the surrogate hill, where the local
c ---    relief is used as the hill height
         fri=bvf*rlf/ws
c ---    Limit Fr>1.0, so that 1/Fr<1.0
         fri=AMIN1(one,fri)

c ---    Set ratio of streamline height (eta) / horizontal scale of the
c ---    surrogate hill (L), and corresponding EXP(+\-)
         etabyl=two*etabyh*aslope
         if(etabyl.GE.0.1) then
           expnl=EXP(etabyl)
           expnli=one/expnl
         else
           expnl=one+etabyl
           expnli=one-etabyl
         endif

c ---    Compute the stratification parameter
         strat=fri*etabyh
         if(strat.GE.0.1) then
            sinln=SIN(strat)
            cosln=COS(strat)
         else
            sinln=strat
            cosln=one-half*strat**2
         endif
c
c ---    Find position on surrogate hill at which change in strain is
c ---    greatest
         trig=sinln/(cosln-expnl)

         if(slope.GT.zero) then
c ---       Upwind face
c ---       No stratification:
            xbyl=-SQRT(third*(one+two*aslope*(one-expnli)/etabyl))
            if(ABS(trig).GE.0.01) then
c ---          Stronger stratification:
               xbyl=xbyl+half*(one-SQRT(one+trig**2))/trig
            else
c ---          Weaker stratification:
               xbyl=xbyl-half*half*trig
            endif
         else
c ---       Downwind face
c ---       No stratification:
c ---       Use small argument approximation to *(one-expnli)/etabyl=1
            xbyl= SQRT(third*(one+two*aslope*(one-expnli)/etabyl))
            if(ABS(trig).GE.0.01) then
c ---          Stronger stratification:
               xbyl=xbyl+(one-SQRT(one+trig**2))/trig
            else
c ---          Weaker stratification:
               xbyl=xbyl-half*trig
            endif
         endif
         xbyl2=xbyl*xbyl
c
c ---    Compute strain factor at XBYL
         tzi=one+(two*aslope/(etabyl*(one+xbyl2))) *
     &           (one-expnli*(cosln-xbyl*sinln))
         tz=one/tzi
         tzsq=tz*tz
c
c ---    Set ratio of step length / length-scale of the
c ---    surrogate hill (delx/L) equal to |rise|/relief
         dxbyl=one
         if(arise.LT.rlf) dxbyl=arise/rlf
c
c ---    Compute rate of change in strain at XBYL, times the scaled
c ---    step length dxbyl
         dtz=-dxbyl*(two*aslope*tzsq/(etabyl*(one+xbyl2)**2)) *
     &        (-two*xbyl+expnli*(two*xbyl*cosln+(one-xbyl2)*sinln))
c
c ---    Compute diffusion adjustment factor due to strain in the flow
         sfcnsq=exp(two*(one-tz))
         rsq=r*r
         arg=two*dtz
         exparg=EXP(-arg)
         if(ABS(arg).GT.0.05) then
            strain=rsq+sfcnsq*(one-rsq)*(one-exparg)/arg
         else
            strain=rsq+sfcnsq*(one-rsq)
         endif
         strain=SQRT(strain)
c
      endif
c
c --- DEBUG output
      if(ldbhr) then
         write(io6,*)
         write(io6,*)'CTADJ2:    r= ',r,'  delx(m)= ',delx
         write(io6,*)'xold,yold(MGU)  = ',xold,yold
         write(io6,*)'xnew,ynew(MGU)  = ',xnew,ynew
         write(io6,*)'elold,elnew(mMSL)= ',elold,elnew,'slope= ',slope
         write(io6,*)'bvf= ',bvf,' ws= ',ws,' relief =',rlf
         write(io6,*)'eltop,elds    = ',eltop,elds
         write(io6,*)'zpold,zpnew(m)= ',zpold,zpnew
         write(io6,*)'fracz,lup     = ',fracz,lup
         write(io6,*)'eta/H= ',etabyh,' delx/L= ',dxbyl
         write(io6,*)'1/Fr= ',fri,' strat= ',strat
         write(io6,*)'xbyl= ',xbyl,'  tz= ',tz,'  dtz= ',dtz
         write(io6,*)'S^2= ',sfcnsq,'  strain= ',strain
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine slugct2(x,y,lclip,rhoci,rhocf,fracsi,fracsy,fracso,
     &                   xr1,yr1,xr2,yr2,zpr,fracsr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                SLUGCT2
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute receptor-specific slug height and associated
c               properties, for MCTADJ=2.
c
c --- INPUTS:
c           X,Y - real    - Receptor coordinates (m)
c                           to that at end of step, before accounting
c                           for strain during the step
c         LCLIP - logical - No extrapolation of slug properties beyond
c                           footprint during step when TRUE
c   RHOCI,RHOCF - real    - Cross-slug receptor position (m) at initial
c                           and final slug locations of the step
c         FRACSI- real    - Along-slug receptor position from young end,
c                           as fraction of the slug length, at initial
c                           slug location
c  FRACSY,FRACSO- real    - Along-step receptor position, as fraction of
c                           the step length, for the young and old ends
c                           of the slug
c
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1,
c        XE1, YE1, ZE1, fracz1, lup1,
c        XB2, YB2, ZB2,
c        XE2, YE2, ZE2, fracz2, lup2,
c
c     Parameters:
c        IO6
c
c --- OUTPUT:
c       XR1,YR1 - real    - Coordinates (m) of old end of slug when
c                           slug interacts with receptor
c       XR2,YR2 - real    - Coordinates (m) of young end of slug when
c                           slug interacts with receptor
c           ZPR - real    - Receptor-specific slug ht above ground (m)
c        FRACSR - real    - Along-slug receptor position from young end,
c                           as fraction of the slug length, at position
c                           where slug interacts with receptor
c
c --- SLUGCT2 called by:  SLGRECS
c --- SLUGCT2 calls:      SLGFRAC
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'current.puf'

      logical lclip, ldb

      data one/1./,zero/0.0/,small/1.0e-3/
      data ldb/.FALSE./

c --- Use the cross-slug position of the receptor at the start
c --- and end of the step to find fraction of step when slug AXIS
c --- aligns with receptor (FRACSA)
      rhodif=rhocf-rhoci
      rhomax=AMAX1(ABS(rhocf),ABS(rhoci),small)
      rhotest=ABS(rhodif)/rhomax
      if(rhotest.LT.small) then
c ---    Axis does not move enough during the step, so find
c ---    the nearest approach of old or young slug-end
c ---    (where either end might be used, choose the younger)
         if(fracsy.GE.zero .AND. fracsy.LE.one) then
c ---       Young end passes receptor during step
            fracsa=fracsy
            fracsr=zero
         elseif(fracso.GE.zero .AND. fracso.LE.one) then
c ---       Old end passes receptor, but not young end
            fracsa=fracso
            fracsr=one
         elseif(fracsi.GE.zero .AND. fracsi.LE.one) then
c ---       Slug ends bracket receptor at start of step
            fracsa=zero
            fracsr=fracsi
         elseif(fracsy.GT.one) then
            if(fracso.GE.fracsy) then
c ---          Young end approaches nearer receptor at end of step
               fracsr=zero
               fracsa=fracsy
            else
c ---          Old end approaches nearer receptor at end of step
               fracsr=one
               fracsa=fracso
            endif
         elseif(fracsy.LT.zero) then
            if(fracso.LE.fracsy) then
c ---          Young end approaches nearer receptor at start of step
               fracsr=zero
               fracsa=fracsy
            else
c ---          Old end approaches nearer receptor at start of step
               fracsr=one
               fracsa=fracso
            endif
         endif
      else
c ---    Axis moves so compute fraction of step when slug AXIS
c ---    aligns with receptor
         fracsa=-rhoci/rhodif
         if(LCLIP) then
            fracsa=AMIN1(one,fracsa)
            fracsa=AMAX1(zero,fracsa)
         endif
c ---    Compute slug-end locations at FRACSA of step
         xr1=xb1+fracsa*(xe1-xb1)
         yr1=yb1+fracsa*(ye1-yb1)
         xr2=xb2+fracsa*(xe2-xb2)
         yr2=yb2+fracsa*(ye2-yb2)
c ---    Compute fractional along-slug distance to receptor from
c ---    young end (FRACSR), evaluated at FRACSA
         call SLGFRAC(x,y,xr1,yr1,xr2,yr2,rhoar,rhocr,fracsr,
     &                d12,d12i)
         if(fracsr.LT.zero) then
c ---       Use slug height at "young" end at nearest point
c ---       (reset FRACSA and FRACSR)
            fracsa=fracsy
            fracsr=zero
         elseif(fracsr.GT.one) then
c ---       Use slug height at "old" end at nearest point
c ---       (reset FRACSA and FRACSR)
            fracsa=fracso
            fracsr=one
         endif
      endif

c --- Impose clipping along transport (conditional)
      if(LCLIP) then
         fracsa=AMIN1(one,fracsa)
         fracsa=AMAX1(zero,fracsa)
      endif

c --- Compute slug-end locations at (Final) FRACSA
      xr1=xb1+fracsa*(xe1-xb1)
      yr1=yb1+fracsa*(ye1-yb1)
      xr2=xb2+fracsa*(xe2-xb2)
      yr2=yb2+fracsa*(ye2-yb2)

c --- Compute elevation of each end of slug at FRACSA
c --- Older end
      if(lup1) then
c ---    Upslope (ht may fall)
         if(fracz1.LE.zero) then
            zr1=zb1
         else
            zjump=ze1-zb1
            if(fracz1.LT.one) zjump=zjump/fracz1
            zr1=zb1+AMIN1(fracsa,fracz1)*zjump
         endif
      else
c ---    Downslope (ht may rise)
         if(fracz1.GE.one) then
            zr1=zb1
         else
            zjump=ze1-zb1
            if(fracz1.GT.zero) zjump=zjump/(one-fracz1)
            zr1=zb1+AMAX1(zero,(fracsa-fracz1))*zjump
         endif
      endif
c --- Younger end
      if(lup2) then
c ---    Upslope (ht may fall)
         if(fracz2.LE.zero) then
            zr2=zb2
         else
            zjump=ze2-zb2
            if(fracz2.LT.one) zjump=zjump/fracz2
            zr2=zb2+AMIN1(fracsa,fracz2)*zjump
         endif
      else
c ---    Downslope (ht may rise)
         if(fracz2.GE.one) then
            zr2=zb2
         else
            zjump=ze2-zb2
            if(fracz2.GT.zero) zjump=zjump/(one-fracz2)
            zr2=zb2+AMAX1(zero,(fracsa-fracz2))*zjump
         endif
      endif

c --- Interpolate slug height between ends
      zpr=zr2+fracsr*(zr1-zr2)

c --- Debug output section
      if(ldb) then
         write(io6,*)'SLUGCT2:'
         write(io6,*)'zpr,zr1,zr2   = ',zpr,zr1,zr2
         write(io6,*)'fracsr,fracsa = ',fracsr,fracsa
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine puffct2(frac,xr1,yr1,zpr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                PUFFCT2
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute receptor-specific puff height for MCTADJ=2.
c
c --- INPUTS:
c          FRAC - real    - Along-step receptor position, as fraction of
c                           the step length
c
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1,
c        XE1, YE1, ZE1, fracz1, lup1
c
c     Parameters:
c        IO6
c
c --- OUTPUT:
c       XR1,YR1 - real    - Puff coordinates (m) when puff interacts
c                           with receptor
c           ZPR - real    - Receptor-specific puff ht above ground (m)
c
c --- PUFFCT2 called by:  PUFRECS
c --- PUFFCT2 calls:      SLGFRAC
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'current.puf'

      data one/1./,zero/0.0/

c --- Compute puff location at FRAC
      xr1=xb1+frac*(xe1-xb1)
      yr1=yb1+frac*(ye1-yb1)

c --- Compute elevation at FRAC
      if(lup1) then
c ---    Upslope (ht may fall)
         if(fracz1.LE.zero) then
            zpr=zb1
         else
            zjump=ze1-zb1
            if(fracz1.LT.one) zjump=zjump/fracz1
            zpr=zb1+AMIN1(frac,fracz1)*zjump
         endif
      else
c ---    Downslope (ht may rise)
         if(fracz1.GE.one) then
            zpr=zb1
         else
            zjump=ze1-zb1
            if(fracz1.GT.zero) zjump=zjump/(one-fracz1)
            zpr=zb1+AMAX1(zero,(frac-fracz1))*zjump
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine getelev(x,y,z)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                GETELEV
c
c --- PURPOSE:  Employs bilinear interpolation to obtain terrain
c               elevation at a point within the MET grid.
c
c --- INPUTS:
c           X - real      - x-position (Met Grid Units)
c           Y - real      - y-position (Met Grid Units)
c
c       Common block /METHD/ variables:
c             ELEV(mxnx,mxny)
c       Common block /GRID/ variables:
c             nx,ny
c       Parameters:
c             mxnx, mxny
c
c --- OUTPUT:
c           Z - real      - Terrain elevation (m MSL)
c
c --- GETELEV called by: ELEVI, VCBAR, CTADJ2
c --- GETELEV calls:     none
c----------------------------------------------------------------------
c  NOTE:  this routine interpolates among elevations assigned to the
c         CENTER of cells in the MET grid, and assumes that the
c         terrain varies linearly between adjacent CENTERS.
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'methd.puf'
      include 'grid.puf'
c
c --- Trap case of single grid-cell
      if(nx.eq.1 .AND. ny.eq.1) then
         z=elev(1,1)
         return
      endif
c
c --- Compute cell x-index of nearest lower left grid-point
c --- (ll denotes lower left-grid point)
      if(nx.eq.1) then
         ixll=1
         ixllp1=1
      else
         ixll=(x+0.5)
c ---    Shift index if needed to stay within grid
         nxm1=nx-1
         ixll=max0(ixll,1)
         ixll=min0(ixll,nxm1)
c ---    Other corners
         ixllp1=ixll+1
      endif
c
c --- Compute cell y-index of nearest lower left grid-point
c --- (ll denotes lower left-grid point)
      if(ny.eq.1) then
         iyll=1
         iyllp1=1
      else
         iyll=(y+0.5)
c ---    Shift index if needed to stay within grid
         nym1=ny-1
         iyll=max0(iyll,1)
         iyll=min0(iyll,nym1)
c ---    Other corners
         iyllp1=iyll+1
      endif
c
c --- Position of point relative to the ll grid-point (grid units)
      t=(x-(ixll-0.5))
      onemt=1.-t
      u=(y-(iyll-0.5))
      onemu=1.-u

c -- Interpolated value
      z=onemt*onemu*elev(ixll,iyll)
     1  +t*onemu*elev(ixllp1,iyll)
     2  +t*u*elev(ixllp1,iyllp1)
     3  +u*onemt*elev(ixll,iyllp1)

      return
      end
c----------------------------------------------------------------------
      subroutine trelief(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                TRELIEF
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute local relief of the terrain for each cell in
c               the meteorological grid, and also the peak elevation
c               associated with this relief.  The relief height and
c               peak terrain elevation are used for MCTADJ = 2
c
c --- INPUTS:
c         LDB - logical   - Debug write logical
c
c       Common block /GRID/ variables:
c             NX,NY
c       Common block /METHD/ variables:
c             ELEV(MXNX,MXNY)
c       Parameters:
c             IO6,MXNX,MXNY
c
c --- OUTPUT:
c       Common block /GRID/ variables:
c             RELIEF(5,mxnx,mxny)
c
c --- TRELIEF called by:  SETUP
c --- TRELIEF calls:      TERAVG
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'grid.puf'
      include 'methd.puf'

      logical ldb

      data zero/0.0/, one/1.0/, beta/1.0/

c --- BETA is the criterion for identifying the "end-point" of the
c --- height profile associated with a cell; this test is applied to
c --- the ratio of the slope for the current position to the original
c --- slope, so that if the ratio is outside the range
c --- BETA to 1+BETA, the segment of the profile is completed

c --- Loop over each cell in the grid
c ------------------------------------
      do j=1,ny
      do i=1,nx

c ---    Initial peak elevation equals cell elevation
         rise=zero

c ---    Process 4 orientations (1:N/S, 2:NE/SW, 3:E/W, 4:SE/NW)
c ---    N/S
c ------------
c ---    Direction of Increasing y-cell index
c ---    Reliefi > 0 if terrain increases in this direction
         reliefi=zero
         if(j.LT.ny) then
            delh1=elev(i,j+1)-elev(i,j)
            reliefi=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i,j+1)
               do jj=j+1,ny-1,1
                  elavg0=elavg
                  call TERAVG(ldb,i,j,i,jj+1,elavg)
                  delh=elavg-elavg0
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefi=reliefi+delh
                  else
                     goto 110
                  endif
               enddo
            endif
         endif
110      continue
c ---    Direction of Decreasing y-cell index
c ---    Reliefd > 0 if terrain decreases in this direction
         reliefd=zero
         if(j.GT.1) then
            delh1=-(elev(i,j-1)-elev(i,j))
            reliefd=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i,j-1)
               do jj=j-1,2,-1
                  elavg0=elavg
                  call TERAVG(ldb,i,j,i,jj-1,elavg)
                  delh=-(elavg-elavg0)
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefd=reliefd+delh
                  else
                     goto 120
                  endif
               enddo
            endif
         endif
120      continue
         rplus=ABS(reliefi+reliefd)
         rminus=ABS(reliefi-reliefd)
         if(rplus.GT.rminus) then
            relief(1,i,j)=rplus
         else
            relief(1,i,j)=AMAX1(ABS(reliefi),ABS(reliefd))
         endif
         rise=AMAX1(rise,reliefi)
         rise=AMAX1(rise,-reliefd)

c ---    NE/SW
c ------------
c ---    Direction of Increasing x,y-cell index
c ---    Reliefi > 0 if terrain increases in this direction
         reliefi=zero
         if(j.LT.ny .AND. i.LT.nx) then
            delh1=elev(i+1,j+1)-elev(i,j)
            reliefi=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i+1,j+1)
c ---          Limit do-loop range using cell index nearest edge of grid
               nxy=MIN0((nx-i),(ny-j))
               do k=1,nxy-1
                  ii=i+k
                  jj=j+k
                  elavg0=elavg
                  call TERAVG(ldb,i,j,ii+1,jj+1,elavg)
                  delh=elavg-elavg0
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefi=reliefi+delh
                  else
                     goto 210
                  endif
               enddo
            endif
         endif
210      continue
c ---    Direction of Decreasing x,y-cell index
c ---    Reliefd > 0 if terrain decreases in this direction
         reliefd=zero
         if(j.GT.1 .AND. i.GT.1) then
            delh1=-(elev(i-1,j-1)-elev(i,j))
            reliefd=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i-1,j-1)
c ---          Limit do-loop range using cell index nearest edge of grid
               nxy=MIN0(i,j)-1
               do k=1,nxy-1
                  ii=i-k
                  jj=j-k
                  elavg0=elavg
                  call TERAVG(ldb,i,j,ii-1,jj-1,elavg)
                  delh=-(elavg-elavg0)
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefd=reliefd+delh
                  else
                     goto 220
                  endif
               enddo
            endif
         endif
220      continue
         rplus=ABS(reliefi+reliefd)
         rminus=ABS(reliefi-reliefd)
         if(rplus.GT.rminus) then
            relief(2,i,j)=rplus
         else
            relief(2,i,j)=AMAX1(ABS(reliefi),ABS(reliefd))
         endif
         rise=AMAX1(rise,reliefi)
         rise=AMAX1(rise,-reliefd)


c ---    E/W
c ------------
c ---    Direction of Increasing x-cell index
c ---    Reliefi > 0 if terrain increases in this direction
         reliefi=zero
         if(i.LT.nx) then
            delh1=elev(i+1,j)-elev(i,j)
            reliefi=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i+1,j)
               do ii=i+1,nx-1,1
                  elavg0=elavg
                  call TERAVG(ldb,i,j,ii+1,j,elavg)
                  delh=elavg-elavg0
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefi=reliefi+delh
                  else
                     goto 310
                  endif
               enddo
            endif
         endif
310      continue
c ---    Direction of Decreasing x-cell index
c ---    Reliefd > 0 if terrain decreases in this direction
         reliefd=zero
         if(i.GT.1) then
            delh1=-(elev(i-1,j)-elev(i,j))
            reliefd=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i-1,j)
               do ii=i-1,2,-1
                  elavg0=elavg
                  call TERAVG(ldb,i,j,ii-1,j,elavg)
                  delh=-(elavg-elavg0)
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefd=reliefd+delh
                  else
                     goto 320
                  endif
               enddo
            endif
         endif
320      continue
         rplus=ABS(reliefi+reliefd)
         rminus=ABS(reliefi-reliefd)
         if(rplus.GT.rminus) then
            relief(3,i,j)=rplus
         else
            relief(3,i,j)=AMAX1(ABS(reliefi),ABS(reliefd))
         endif
         rise=AMAX1(rise,reliefi)
         rise=AMAX1(rise,-reliefd)


c ---    SE/NW
c ------------
c ---    Direction of Increasing x, decreasing y-cell index
c ---    Reliefi > 0 if terrain increases in this direction
         reliefi=zero
         if(j.GT.1 .AND. i.LT.nx) then
            delh1=elev(i+1,j-1)-elev(i,j)
            reliefi=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i+1,j-1)
c ---          Limit do-loop range using cell index nearest edge of grid
               nxy=MIN0((nx-i),(j-1))
               do k=1,nxy-1
                  ii=i+k
                  jj=j-k
                  elavg0=elavg
                  call TERAVG(ldb,i,j,ii+1,jj-1,elavg)
                  delh=elavg-elavg0
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefi=reliefi+delh
                  else
                     goto 410
                  endif
               enddo
            endif
         endif
410      continue
c ---    Direction of Decreasing x, increasing y-cell index
c ---    Reliefd > 0 if terrain decreases in this direction
         reliefd=zero
         if(j.LT.ny .AND. i.GT.1) then
            delh1=-(elev(i-1,j+1)-elev(i,j))
            reliefd=delh1
            if(ABS(delh1).GT.zero) then
               elavg=elev(i-1,j+1)
c ---          Limit do-loop range using cell index nearest edge of grid
               nxy=MIN0((i-1),(ny-j))
               do k=1,nxy-1
                  ii=i-k
                  jj=j+k
                  elavg0=elavg
                  call TERAVG(ldb,i,j,ii-1,jj+1,elavg)
                  delh=-(elavg-elavg0)
                  rr=ABS(delh/delh1-one)
                  if(rr.LE.beta) then
                     reliefd=reliefd+delh
                  else
                     goto 420
                  endif
               enddo
            endif
         endif
420      continue
         rplus=ABS(reliefi+reliefd)
         rminus=ABS(reliefi-reliefd)
         if(rplus.GT.rminus) then
            relief(4,i,j)=rplus
         else
            relief(4,i,j)=AMAX1(ABS(reliefi),ABS(reliefd))
         endif
         rise=AMAX1(rise,reliefi)
         rise=AMAX1(rise,-reliefd)

c ---    Identify peak elevation near this cell
         relief(5,i,j)=elev(i,j)+rise

      enddo
      enddo

      if(ldb) then
c ---    Write out a subset of the terrain difference fields
         write(io6,*)
         write(io6,*)'TRELIEF: terrain near center of met grid'
         write(io6,*)'         i, j, RELIEF(N/NE/E/SE), PEAK in m ='
         i0=nx/2
         do j=ny,1,-1
c         do i=i0,i0+1
            i=i0
            write(io6,'(2i4,5f10.1)')i,j,(relief(k,i,j),k=1,5)
c         enddo
         enddo
         ibeg=MAX0(1,i0-10)
         iend=MIN0(nx,ibeg+19)
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'TRELIEF: PEAK in local RELIEF'
         write(io6,*)'E-W Cell Index  -----'
         write(io6,'(5x,20i5)') (ii,ii=ibeg,iend)
         write(io6,*)
         do jj=ny,1,-1
           write(io6,'(i3,2x,20f5.0)')jj,(relief(5,ii,jj),ii=ibeg,iend)
         enddo
         write(io6,*)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine teravg(ldb,i0,j0,i,j,elavg)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                 TERAVG
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute average elevation of a strip of cells containing
c               cell (i,j), which lie across a 45 degree sector centered
c               on the direction from cell (i0,j0) to cell (i,j).
c
c --- INPUTS:
c         LDB - logical   - Debug write logical
c       I0,J0 - integer   - Cell at origin of sector
c         I,J - integer   - Cell at center of sector direction
c
c       Common block /GRID/ variables:
c             NX,NY
c       Common block /METHD/ variables:
c             ELEV(MXNX,MXNY)
c       Parameters:
c             IO6,MXNX,MXNY
c
c --- OUTPUT:
c       ELAVG - real      - Average elevation in strip of cells which
c                           is perpendicular to sector direction, and
c                           which includes cell (i,j)
c
c --- TERAVG called by:  TRELIEF
c --- TERAVG calls:      none
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'grid.puf'
      include 'methd.puf'

      logical ldb

      data zero/0.0/, tan225/0.4142136/

      if(i0.EQ.i) then
c ---    Process N/S sector orientation
c ---    Select E/W strip of cells that lie in 45 degree sector
         jdel=IABS(j-j0)
         idel=INT(FLOAT(jdel)*tan225)
         ixmin=MAX0(1,i-idel)
         ixmax=MIN0(nx,i+idel)
         nsum=0
         tsum=zero
         do ix=ixmin,ixmax
            nsum=nsum+1
            tsum=tsum+elev(ix,j)
         enddo
         elavg=tsum/nsum

      elseif(j0.EQ.j) then
c ---    Process E/W sector orientation
c ---    Select N/S strip of cells that lie in 45 degree sector
         idel=IABS(i-i0)
         jdel=INT(FLOAT(idel)*tan225)
         jymin=MAX0(1,j-jdel)
         jymax=MIN0(ny,j+jdel)
         nsum=0
         tsum=zero
         do jy=jymin,jymax
            nsum=nsum+1
            tsum=tsum+elev(i,jy)
         enddo
         elavg=tsum/nsum

      elseif((j-j0).EQ.(i-i0)) then
c ---    Process NE/SW sector orientation
c ---    Select NW/SE strip of cells that lie in 45 degree sector
         kdiag=IABS(i-i0)
         kdiag=INT(FLOAT(kdiag)*tan225)
         jymin=MAX0(1,j-kdiag)
         jymax=MIN0(ny,j+kdiag)
         ixmin=MAX0(1,i-kdiag)
         ixmax=MIN0(nx,i+kdiag)
c ---    Set edge of valid domain
         kleft=-MIN0((i-ixmin),(jymax-j))
         krght=MIN0((ixmax-i),(j-jymin))
c ---    Sum the elevations in the strip
         nsum=zero
         tsum=zero
         do k=kleft,krght
            ii=i+k
            jj=j-k
            nsum=nsum+1
            tsum=tsum+elev(ii,jj)
         enddo

c ---    ADD half-step cells (one half-step further along direction)
         nx2=2*nx
         ny2=2*ny
         i02=2*i0
c ---    Increment i2,j2 one "half-cell" along direction
         i2=2*i+1
         j2=2*j+1
         if(i.LT.i0) i2=i2-2
         if(j.LT.j0) j2=j2-2
         kdiag=IABS(i2-i02)
         kdiag=INT(FLOAT(kdiag)*tan225)
         jymin=MAX0(2,j2-kdiag)
         jymax=MIN0(ny2,j2+kdiag)
         ixmin=MAX0(2,i2-kdiag)
         ixmax=MIN0(nx2,i2+kdiag)
c ---    Set edge of valid domain
         kleft=-MIN0((i2-ixmin),(jymax-j2))
         krght=MIN0((ixmax-i2),(j2-jymin))
c ---    Sum the elevations in the strip
         do k=kleft,krght
            ii=i2+k
            jj=j2-k
c ---       Process only full-cell positions
            if(MOD(ii,2).EQ.0 .AND. MOD(jj,2).EQ.0) then
               ii=ii/2
               jj=jj/2
               nsum=nsum+1
               tsum=tsum+elev(ii,jj)
            endif
         enddo

c ---    Average the elevations in the strip
         elavg=tsum/nsum

      elseif((j-j0).EQ.-(i-i0)) then
c ---    Process NW/SE orientation
c ---    Select SW/NE strip of cells that lie in 45 degree sector
         kdiag=IABS(i-i0)
         kdiag=INT(FLOAT(kdiag)*tan225)
         jymin=MAX0(1,j-kdiag)
         jymax=MIN0(ny,j+kdiag)
         ixmin=MAX0(1,i-kdiag)
         ixmax=MIN0(nx,i+kdiag)
c ---    Set edge of valid domain
         kleft=-MIN0((i-ixmin),(j-jymin))
         krght=MIN0((ixmax-i),(jymax-j))
c ---    Sum the elevations in the strip
         nsum=zero
         tsum=zero
         do k=kleft,krght
            ii=i+k
            jj=j+k
            nsum=nsum+1
            tsum=tsum+elev(ii,jj)
         enddo

c ---    ADD half-step cells (one half-step further along direction)
         nx2=2*nx
         ny2=2*ny
         i02=2*i0
c ---    Increment i2,j2 one "half-cell" along direction
         i2=2*i+1
         j2=2*j+1
         if(i.LT.i0) i2=i2-2
         if(j.LT.j0) j2=j2-2
         kdiag=IABS(i2-i02)
         kdiag=INT(FLOAT(kdiag)*tan225)
         jymin=MAX0(2,j2-kdiag)
         jymax=MIN0(ny2,j2+kdiag)
         ixmin=MAX0(2,i2-kdiag)
         ixmax=MIN0(nx2,i2+kdiag)
c ---    Set edge of valid domain
         kleft=-MIN0((i2-ixmin),(j2-jymin))
         krght=MIN0((ixmax-i2),(jymax-j2))
c ---    Sum the elevations in the strip
         do k=kleft,krght
            ii=i2+k
            jj=j2+k
c ---       Process only full-cell positions
            if(MOD(ii,2).EQ.0 .AND. MOD(jj,2).EQ.0) then
               ii=ii/2
               jj=jj/2
               nsum=nsum+1
               tsum=tsum+elev(ii,jj)
            endif
         enddo

c ---    Average the elevations in the strip
         elavg=tsum/nsum

      endif

c --- Debug Output Section
      if(LDB) then
         if(i.EQ.j .AND. (j.LE.3 .OR. j.GE.(ny-2))) then
            write(io6,*)'TERAVG:    i0,j0,i,j= ',i0,j0,i,j
            write(io6,*)'          elavg,nsum= ',elavg,nsum
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine walltrap(ldb,syb,sye,z,xb,yb,xe,ye,bvf,ws,itrap)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107               WALLTRAP
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute local valley width at height "z" above cell
c               elevation for position at beginning and end of step;
c               then limit growth of sigma-y during step if valley
c               width is small enough (used for MCTADJ = 2)
c
c --- INPUTS:
c         LDB - logical   - Debug write logical
c     SYB,SYE - real      - Sigma-y at beginning and end of step (m)
c           Z - real      - Puff height above ground (m)
c       XB,YB - real      - Beginning puff position (Met Grid Units)
c       XE,YE - real      - Ending puff position (Met Grid Units)
c         BVF - real      - Brunt-Vaisala Frequency (1/s)
c          WS - real      - Wind Speed (m/s)
c
c       Common block /GRID/ variables:
c             DGRID, RELIEF(5,mxnx,mxny)
c             IVALW(mxvalz,mxnx,mxny), DZVAL
c       Common block /METHD/ variables:
c             ELEV(MXNX,MXNY)
c       Parameters:
c             IO6,MXNX,MXNY,MXVALZ
c
c --- OUTPUT:
c         SYE - real      - Sigma-y at end of step (m)    [revised]
c       ITRAP - integer   - Flag denotes when SYE changes
c                           (0:  No Change;  1:  Change)
c
c --- WALLTRAP called by:  SETPUF, SETSLG
c --- WALLTRAP calls:      none
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'grid.puf'
      include 'methd.puf'

      logical ldb

      data zero/0.0/, one/1.0/

c --- Criterion for trapping is ratio RCRIT=sigma-y/L at which area
c --- under the Gaussian curve equals area of top-hat of width L, with
c --- the same peak concentration
      data rcrit/0.4/

c --- Initialize data
      itrap=0
      syeold=sye

c --- No Trapping if puff is above the dividing streamline
      if(bvf.LE.zero) goto 500

c --- Set met cell location for old and new puff locations
      ixb=1+AMAX1(zero,xb)
      jyb=1+AMAX1(zero,yb)
      ixe=1+AMAX1(zero,xe)
      jye=1+AMAX1(zero,ye)

      ixb=MIN0(nx,ixb)
      jyb=MIN0(ny,jyb)
      ixe=MIN0(nx,ixe)
      jye=MIN0(ny,jye)

c --- Determine dividing-streamline elevation (m MSL)
c --- Set peak terrain elevation near this step
      eltop=AMAX1(relief(5,ixb,jyb),relief(5,ixe,jye))
      elds=eltop-ws/bvf

c --- Set minimum puff elevation (m MSL)
      elpuff=AMIN1(elev(ixb,jyb),elev(ixe,jye))+z

      if(elpuff.LE.elds) then

c ---    Perform trapping calculations
c ------------------------------------

c ---    Compute valley widths at "z"
         zgrid=z/dzval
         izbot=INT(zgrid)
         if(izbot.EQ.0) then
            izbot=1
            dzfac=zero
         else
            dzfac=zgrid-FLOAT(izbot)
         endif
         iztop=izbot+1

c ---    No trapping if puff is above valley
         if(izbot.GE.mxvalz) goto 500

c ---    No trapping if puff not in valley at either beginning
c ---    or end of step
         if(ivalw(iztop,ixb,jyb).EQ.-1) goto 500
         if(ivalw(iztop,ixe,jye).EQ.-1) goto 500
         if(ivalw(izbot,ixb,jyb).EQ.-1) goto 500
         if(ivalw(izbot,ixe,jye).EQ.-1) goto 500

c ---    Interpolate valley width(m) at beginning and end
         wb=dgrid*((one-dzfac)*FLOAT(ivalw(izbot,ixb,jyb))+
     &                   dzfac*FLOAT(ivalw(iztop,ixb,jyb)))
         we=dgrid*((one-dzfac)*FLOAT(ivalw(izbot,ixe,jye))+
     &                   dzfac*FLOAT(ivalw(iztop,ixe,jye)))

c ---    Check for trapping criterion at ends of step
         rb=syb/wb
         re=sye/we
         if(AMAX1(rb,re).LE.rcrit) then
c ---       No trapping within step
            goto 500
         elseif(AMIN1(rb,re).GE.rcrit) then
c ---       Full trapping within step
            itrap=1
            f=zero
            frac=-999
            sye=syb
            goto 500
         else
c ---       Trapping for only part of step
c ---       Assume linear changes over step, and compute fraction of
c ---       step at which RCRIT criterion is met
            frac=AMAX1(zero,(syb-rcrit*wb)/((we-wb)*rcrit-(sye-syb)))
            itrap=1
            if(re.GE.rcrit) then
               f=frac
            elseif(rb.GE.rcrit) then
               f=one-frac
            endif
            sye=syb+f*(sye-syb)
         endif
      endif

c --- Report DEBUG information
500   if(LDB .AND. itrap.EQ.1) then
         write(io6,*)
         write(io6,*)'WALLTRAP:  z,bvf,ws = ',z,bvf,ws
         write(io6,*)'    ixb,jyb,ixe,jye = ',ixb,jyb,ixe,jye
         write(io6,*)'    Valley   wb, we = ', wb, we
         write(io6,*)'       syb,sye(old) = ',syb,syeold
         write(io6,*)'  f, frac ,sye(new) = ',f,frac,sye
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine vwidth(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                 VWIDTH
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute local valley width in met grid cell units
c               as a function of height at each cell
c
c --- UPDATES
c --- V5.2-V5.4    000602  (DGS): add message to "stop"
c --- V5.1-V5.2    991104  (JSS): Error messages written to list
c                                 file as well as to screen
c --- V5.0  971107-980304  (DGS): replace NX with NY in range check for
c                                 y-indices (bug)
c                          (DGS): change AMAX1(int) to MAX0(int) etc.
c
c --- INPUTS:
c         LDB - logical   - Debug write logical
c
c       Common block /GRID/ variables:
c             NX,NY
c       Common block /METHD/ variables:
c             ELEV(MXNX,MXNY)
c       Parameters:
c             IO6,MXNX,MXNY
c
c --- OUTPUT:
c       Common block /GRID/ variables:
c             IVALW(mxvalz,mxnx,mxny), DZVAL
c
c --- VWIDTH called by:  SETUP
c --- VWIDTH calls:      none
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
      include 'grid.puf'
      include 'methd.puf'

      logical ldb,lwidth

      data big/9000./
      data dzmin/10./, qahit/0.5/

c --- DZMIN is the minimum delta-z used in resolving width as a
c --- function of height
c --- QAHIT if min fraction of cells in a strip that constitutes a wall

c --- Initialize widths, and search elevations for max/min values (m)
      zmax=-big
      zmin=big
      do j=1,ny
      do i=1,nx
         if(elev(i,j).GT.zmax) zmax=elev(i,j)
         if(elev(i,j).LT.zmin) zmin=elev(i,j)
         do k=1,mxvalz
            ivalw(k,i,j)=-1
         enddo
      enddo
      enddo

c --- Set initial height interval
      dzval=(zmax-zmin)/FLOAT(mxvalz)
1     dzval=AMAX1(dzmin,dzval)

c --- Loop over heights above the cell elevation
      do k=1,mxvalz

c ---    Did the valley disappear too soon?  --- Increase resolution
         if(k.GT.1 .AND. .NOT.lwidth .AND. dzval.GT.dzmin) then
c ---       Recalculate the height increment and start over
            dzval=delz/FLOAT(mxvalz)
            do j0=1,ny
            do i0=1,nx
               do k0=1,mxvalz
                  ivalw(k0,i0,j0)=-1
               enddo
            enddo
            enddo
            goto 1
         endif

         delz=k*dzval
         lwidth=.FALSE.

c ---    Loop over each cell in the grid
c ---------------------------------------
         do j=1,ny
         do i=1,nx

c ---       Do not process this height for this cell if no valley width
c ---       had been found at the previous height
            if(k.GT.1) then
               if(ivalw(k-1,i,j).EQ.-1) goto 500
            endif

c ---       Set target elevation for cell (i,j)
            ztarget=elev(i,j)+delz

c ---       Find # cells from (i,j) to terrain that exceeds target
c ---       in each of 4 quadrants (N, S, E, W)
            lookNS=-1
            lookEW=-1

c ---       N
c ------------
c ---       Direction of Increasing y-cell index
c ---       March in cell-steps to North of cell (i,j)
            do jy=j+1,ny
               jdel=jy-j
c ---          Look at E-W strip within 90 degree sector about N
               ixmin=MAX0(1,i-jdel)
               ixmax=MIN0(nx,i+jdel)
c !!!          iqa=NINT(FLOAT(ixmax-ixmin)*qahit)
               iqa=NINT(FLOAT(ixmax-ixmin)*qahit)+1
               ihit=0
               do ix=ixmin,ixmax
                  if(elev(ix,jy).GE.ztarget) then
                     ihit=ihit+1
                     if(ihit.EQ.iqa) then
                        lookNS=jy
                        goto 100
                     endif
                  endif
               enddo
            enddo

100         continue
c ---       If target elevation was not found to the north, skip the
c ---       look to the south for the "other side" of the valley
            if(lookNS.LT.0) goto 200

c ---       S
c ------------
c ---       Direction of Decreasing y-cell index
c ---       March in cell-steps to South of cell (i,j)
            do jy=j-1,1,-1
               jdel=j-jy
c ---          Look at E-W strip within 90 degree sector about S
               ixmin=MAX0(1,i-jdel)
               ixmax=MIN0(nx,i+jdel)
c !!!          iqa=NINT(FLOAT(ixmax-ixmin)*qahit)
               iqa=NINT(FLOAT(ixmax-ixmin)*qahit)+1
               ihit=0
               do ix=ixmin,ixmax
                  if(elev(ix,jy).GE.ztarget) then
                     ihit=ihit+1
                     if(ihit.EQ.iqa) then
                        lookNS=lookNS-jy
                        goto 200
                     endif
                  endif
               enddo
            enddo
c ---       Reset to "null" value
            lookNS=-1

200         continue

c ---       E
c ------------
c ---       Direction of Increasing x-cell index
c ---       March in cell-steps to East of cell (i,j)
            do ix=i+1,nx
               idel=ix-i
c ---          Look at N-S strip within 90 degree sector about E
               jymin=MAX0(1,j-idel)
               jymax=MIN0(ny,j+idel)
c !!!          iqa=NINT(FLOAT(jymax-jymin)*qahit)
               iqa=NINT(FLOAT(jymax-jymin)*qahit)+1
               ihit=0
               do jy=jymin,jymax
                  if(elev(ix,jy).GE.ztarget) then
                     ihit=ihit+1
                     if(ihit.EQ.iqa) then
                        lookEW=ix
                        goto 300
                     endif
                  endif
               enddo
            enddo

300         continue
c ---       If target elevation was not found to the east, skip
c ---       look to the west for the "other side" of the valley;
            if(lookEW.LT.0) goto 400

c ---       W
c ------------
c ---       Direction of Decreasing x-cell index
c ---       March in cell-steps to West of cell (i,j)
            do ix=i-1,1,-1
               idel=i-ix
c ---          Look at N-S strip within 90 degree sector about W
               jymin=MAX0(1,j-idel)
               jymax=MIN0(ny,j+idel)
c !!!          iqa=NINT(FLOAT(jymax-jymin)*qahit)
               iqa=NINT(FLOAT(jymax-jymin)*qahit)+1
               ihit=0
               do jy=jymin,jymax
                  if(elev(ix,jy).GE.ztarget) then
                     ihit=ihit+1
                     if(ihit.EQ.iqa) then
                        lookEW=lookEW-ix
                        goto 400
                     endif
                  endif
               enddo
            enddo
c ---       Reset to "null" value
            lookEW=-1

400         continue

c ---       Set cross-valley width at this elevation, for this cell,
c ---       equal to the minimum NS or EW span
            itest=lookNS*lookEW
            if(itest.LT.0) then
c ---          Only one of the directions produced a valley width, so
c ---          take the maximum to select the valid width
               ivalw(k,i,j)=MAX0(lookNS,lookEW)
            else
c ---          Both are valid or both are invalid, so take the minimum
               ivalw(k,i,j)=MIN0(lookNS,lookEW)
            endif
            if(ivalw(k,i,j).GT.1) lwidth=.TRUE.

c ---       Test width
            if(ivalw(k,i,j).NE.-1 .AND. ivalw(k,i,j).LT.2) then
               write(io6,*) 'FATAL Problem in VWIDTH'
               write(io6,*) '-- invalid valley width computed'
               write(io6,*) '-- i,j,k,width = ',i,j,k,ivalw(k,i,j)
               write(*,*)
               stop 'Halted in VWIDTH -- see list file.'
            endif

500         continue

         enddo
         enddo

c --- End Loop over heights
      enddo

      if(ldb) then
c ---    Write out key setup info
         write(io6,*)
         write(io6,*)'VWIDTH: Information about process:'
         write(io6,*)'         zmax,zmin = ',zmax,zmin
         write(io6,*)'      mxvalz,dzval = ',mxvalz,dzval

         do k=1,mxvalz
c ---       Write out a subset of the valley width fields
            delz=dzval*k
            i0=nx/2
            ibeg=MAX0(1,i0-10)
            iend=MIN0(nx,ibeg+19)
            write(io6,*)
            write(io6,*)
            write(io6,*)'VWIDTH: Valley Width(cells) at Height(m) ',delz
            write(io6,*)'E-W Cell Index  -----'
            write(io6,'(5x,20i4)') (ii,ii=ibeg,iend)
            write(io6,*)
            do jj=ny,1,-1
              write(io6,'(i3,2x,20i4)') jj,(ivalw(k,ii,jj),ii=ibeg,iend)
            enddo
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine axis(ht,aax,bax)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940831                    AXIS
c ---            D. Strimaitis, SRC
c
c  PURPOSE:     Given a contour height above the grid-plane,
c               subroutine returns the major and minor axis lengths
c               of the hill.
c
c  ARGUMENTS:
c     PASSED:   ht              contour height above grid-plane (m)  [r]
c   RETURNED:   aax,bax         major, minor axis lengths (m)        [r]
c
c  CALLING ROUTINES:    CTPAR
c
c  EXTERNAL ROUTINES:   none
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'
      real ax(2)

      if(ht .LE. small) then
         aax=axmax(1,ih)
         bax=axmax(2,ih)
c  Restrict axis lengths so that defined major axis never becomes less
c  than defined minor axis
      if(bax .GT. aax) bax=aax
         return
      endif

c  Scale height of contour by the relief height of the hill
      htbyh=ht/h

      do 10 i=1,2
        ax(i)=scale(i,ih)*((one-htbyh)/(htbyh+
     1       (scale(i,ih)/axmax(i,ih))**expo(i,ih)))**(one/expo(i,ih))
10    continue
      aax=ax(1)
      bax=ax(2)
c  Restrict axis lengths so that defined major axis never becomes less
c  than defined minor axis
      if(bax .GT. aax) bax=aax

      return
      end
c-----------------------------------------------------------------------
      subroutine bi(afac,argm,argp,b)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                      BI
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes the quantity B(E,Eo) for the special case in
c               which sigma-z is virtually constant
c
c ARGUMENTS:
c    PASSED:    afac            1/(2*sz**2)  (m**-2)                 [r]
c               argm            Eo-length  (m)                       [r]
c               argp            Eo+length  (m)                       [r]
c  RETURNED:    b               B(E,Eo)                              [r]
c
c CALLING ROUTINES:     UPPER, LOWER
c
c EXTERNAL ROUTINES:
c-----------------------------------------------------------------------

      INCLUDE 'const.puf'

      exarg1=afac*argm**2
      exarg2=afac*argp**2

      term1=zero
      term2=zero

      if(exarg1 .LT. expmax) term1=EXP(-exarg1)
      if(exarg2 .LT. expmax) term2=EXP(-exarg2)

      b=two*(term1+term2)

      return
      end
c-----------------------------------------------------------------------
      subroutine bji(ak,dm,dp,d0,eoimh,eoiph,ej,bj)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                     BJI
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes the quantity B(E,Eo)
c
c ARGUMENTS:
c    PASSED:    ak              1/sqrt2*sze*szo*szpt  (m**-3)        [r]
c               dm              szpt**2 (Eo-Hd)  (m**3)              [r]
c               dp              szpt**2 (Eo+Hd)  (m**3)              [r]
c               d0              ak*sze**2 (zlid-Hd)  (m**3)          [r]
c               eoimh           Eo-Hd  (m)                           [r]
c               eoiph           Eo+Hd  (m)                           [r]
c               ej              E  (m)                               [r]
c  RETURNED:    bj              B(E,Eo)                              [r]
c
c CALLING ROUTINES:     UPPER
c
c EXTERNAL ROUTINES:    ERF
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

      dum=half/szesq
      akd1=ak*(dm+szosq*ej)
      akd2=ak*(dm-szosq*ej)
      akd3=ak*(dp-szosq*ej)
      akd4=ak*(dp+szosq*ej)

      exarg1=dum*(ej-eoimh)*(ej-eoimh)
      exarg2=dum*(ej+eoimh)*(ej+eoimh)
      exarg3=dum*(ej+eoiph)*(ej+eoiph)
      exarg4=dum*(ej-eoiph)*(ej-eoiph)

      term1=zero
      term2=zero
      term3=zero
      term4=zero

      if(exarg1 .LT. expmax) term1=EXP(-exarg1)*(ERF(d0-akd1)+ERF(akd1))
      if(exarg2 .LT. expmax) term2=EXP(-exarg2)*(ERF(d0-akd2)+ERF(akd2))
      if(exarg3 .LT. expmax) term3=EXP(-exarg3)*(ERF(d0+akd3)-ERF(akd3))
      if(exarg4 .LT. expmax) term4=EXP(-exarg4)*(ERF(d0+akd4)-ERF(akd4))

      bj=term1+term2+term3+term4

      return
      end
c-----------------------------------------------------------------------
      subroutine bjil(ak,b1,ej,eoi,bj)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                    BJIL
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes the quantity B(E,Eo) for LOWER
c
c ARGUMENTS:
c    PASSED:    ak              1/sqrt2*sz*szo*szp  (m**-3)          [r]
c               b1              Hd*sz**2  (m**3)                     [r]
c               eoi             Eo  (m)                              [r]
c               ej              E  (m)                               [r]
c  RETURNED:    bj              B(E,Eo)                              [r]
c
c CALLING ROUTINES:     LOWER
c
c EXTERNAL ROUTINES:    ERF
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

      dum=half/szsq
      b2=ej*szosq
      b3=eoi*szpsq

      exarg1=dum*(ej-eoi)*(ej-eoi)
      exarg2=dum*(ej+eoi)*(ej+eoi)

      term1=zero
      term2=zero

      arg1p=ak*(b1+b2+b3)
      arg1m=ak*(b1-b2-b3)
      arg2p=ak*(b1+b2-b3)
      arg2m=ak*(b1-b2+b3)

      if(exarg1 .LT. expmax) term1=EXP(-exarg1)*(ERF(arg1p)+ERF(arg1m))
      if(exarg2 .LT. expmax) term2=EXP(-exarg2)*(ERF(arg2p)+ERF(arg2m))

      bj=term1+term2

      return
      end
c-----------------------------------------------------------------------
      subroutine ctinit(dgrid,mhillin,nhill,hilldat,nctrec,xrct,yrct)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                  CTINIT
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Transfers data that are needed for the subgrid-scale
c               terrain option to common/CTPASS/, and initializes
c               data passed in common/CONST/.
c
c ARGUMENTS:
c    PASSED:
c               dgrid           spacing of cells in met grid (m)    [r]
c               mhillin         method for input of hill terrain    [i]
c                                     and receptor data
c                                     1 = Created by CTDM processor
c                                         programs (in CTDM format)
c                                     2 = Created by OPTHILL
c                                         processor & read in Input
c                                         Groups (6b, 6c)
c               nhill           number of subgrid-scale terrain     [i]
c                                     features
c               hilldat         hill data from control file        [ra]
c               nctrec          number of special complex terrain   [i]
c                                     receptors
c               xrct            X coordinate of complex terrain    [ra]
c                                     receptor (met. grid units)
c               yrct            Y coordinate of complex terrain    [ra]
c                                     receptor (met. grid units)
c
c  RETURNED:    (if CTDM receptor file is used)
c               xrct            X coordinate of complex terrain    [ra]
c                                     receptor (met. grid units)
c               yrct            Y coordinate of complex terrain    [ra]
c                                     receptor (met. grid units)
c
c CALLING ROUTINES:     SETUP
c
c EXTERNAL ROUTINES:    INPREC, INPTER
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

c  Dimension arrays passed through the argument list
      real hilldat(11,mxhill),xrct(mxrect),yrct(mxrect)

c  Set constants that are passed in common
      zero=0.
      one=1.
      two=2.
      three=3.
      four=4.
      half=0.5
      twoby3=two/three
      rt2=SQRT(two)
      pi=3.1415927
      rtpi=SQRT(pi)
      pii=one/pi
      rtpii=one/rtpi
      piby2=half*pi
      twopi=two*pi
      dtor=pi/180.
      small=.000001
      expmax=69.
      alphai=1.20
      hslfac=0.05
      epsint=0.01
      epsrefl=0.01
      mxrefl=50

c  Set the number of points along the trajectory to the maximum allowed
c  by the parameter MXTPTS in this implementation
      ntpts=mxtpts

c  Transfer flag to /CTPASS/ variable for type of terrain data
      mhillt=mhillin

c  Transfer hill information.  (These are placed in common/CTPASS/)
c              mhillt: method for hill data input
c                      1 = HILL.DAT file from CTDM
c                      2 = Input Subgroup 6b (OPTHILL)
      if(mhillt.eq.1) then
c ---    Read and process data from HILL.DAT (CTDM Terrain Processor)
         call INPTER
         do i=1,nhill
c ---       Change height reference from m (MSL) to m above hill base
            do inz=1,nzh(i)
               zh(inz,i)=zh(inz,i)-zgrid(i)
            enddo
         enddo

      elseif(mhillt.eq.2) then
c ---    Swap data from arrays filled from input file (Subgroup 6b)
         do i=1,nhill
c ---       Compute (xc,yc) as meters from MET grid origin
            xc(i)=dgrid*hilldat(1,i)
            yc(i)=dgrid*hilldat(2,i)
            thetah(i)=hilldat(3,i)
            zgrid(i)=hilldat(4,i)
            relief(i)=hilldat(5,i)
            expo(1,i)=hilldat(6,i)
            expo(2,i)=hilldat(7,i)
            scale(1,i)=hilldat(8,i)
            scale(2,i)=hilldat(9,i)
            axmax(1,i)=hilldat(10,i)
            axmax(2,i)=hilldat(11,i)
         enddo
      endif

c  Transfer receptor information.  (placed in common/CTPASS/)
c              mhillt: method for receptor data input
c                      1 = HILLRCT.DAT file from CTDM
c                      2 = Input Subgroup 6c
      if(mhillt.eq.1) then
c ---    Read & process data from HILLREC.DAT (CTDM Receptor Generator)
         call INPREC
c ---    Transfer receptor information to common/CTSGDAT/: change
c ---    distance units from meters to MET grid
         do i=1,nctrec
            xrct(i)= xrctm(i)/dgrid
            yrct(i)= yrctm(i)/dgrid
         enddo
      elseif(mhillt.eq.2) then
c ---    Transfer receptor information: change distance units from MET
c ---    grid to meters from MET grid origin (placed in common/CTPASS/)
         do i=1,nctrec
            xrctm(i)=dgrid*xrct(i)
            yrctm(i)=dgrid*yrct(i)
         enddo
      endif
c  Initialize variables
      ip=0
      ih=0
      tstart=0.

      return
      end
c-----------------------------------------------------------------------
      subroutine ctpar
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                   CTPAR
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes parameters for complex terrain option which
c               depend only on specification of puff and hill data.
c
C
C MODIFICATION:  1.  Changes made during EPA-sponsored upgrade to the
C                    FLOW algorithm have been made here.  This is now
C                    consistent with INPUFF 3.0 (10/93).
c
c                2.  Option added to accept hill information in CTDM
c                    format, or in original OPTHILL format, controlled
c                    by variable MHILLT:
c                               1 = CTDM format
c                               2 = OPTHILL format
c
c                3.  Modify method of computing and incorporating shear
c                    (this differs from INPUFF 3.0 (10/93)
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): Speed shear modification is applied
c                                  only when speed at hilltop is at
c                                  least 1/10 puff speed
c
c ARGUMENTS:    none
c
c CALLING ROUTINES:     CTSG
c
c EXTERNAL ROUTINES:    ROTATE, AXIS, KLOSE, MUNU, IREG, HILROT, SPEED,
c                       PATH, XINTRP
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'
      INCLUDE 'flvar.puf'

      real mu,nu

c  Define parameters used in CTDM flow algorithm
c *** Begin Modifications 7/4/91. Sigma Research Corp.  DGS.
c     data b0n/1.25/,rnlz/0.69315/
c *** Restore rnlz ('92 Modification).  Sigma Research Corp.  DGS.
      data rnlz/0.5/
c *** End Modifications 7/4/91. Sigma Research Corp.  DGS.

c  Shift puff position to hill-centered coordinate system, with
c       x-axis along the flow.
      xpc=xp-xc(ih)
      ypc=yp-yc(ih)
      rotflo=three*piby2-thetaw*dtor
      call ROTATE(xpc,ypc,rotflo,xpf,ypf)

c  Get axis lengths for hill below Hd at the lesser of Hd and puff ht.
      ht=AMIN1(zpuff,hd)
      if(mhillt .EQ. 1) then
c ---    CTDM format hill information
c        Use the ellipse parameters already fit to the hill, and select
c        the values for height 'ht' as in CTDMPLUS.  Note that the
c        center of the ellipse, and its orientation are taken from the
c        polynomial hill that was fit to the entire terrain element.
c        (Section modified from CTDMPLUS)
C         GET MAJOR, MINOR AXIS FOR THE HILL BELOW hd
C         KLOW IS THE ARRAY INDEX TO THE HEIGHT CLOSEST TO (BUT LESS
C         THAN) ht
          KLOW = KLOSE( ZH(1,ih), NZH(ih), ht )
          IF( KLOW .EQ. 0 ) KLOW = 1
          BASEHW = ZH(KLOW,ih)
          IF( KLOW .EQ. NZH(ih) ) THEN
C             THE CRITICAL HT IS ABOVE LAST CONTOUR VALUE
C             DO NOT INTERPOLATE, BUT USE INVERSE POLYNOMIAL FORMULA
C
C             COMPUTE MAJOR & MINOR AXIS LENGTHS: INTERPOLATE BETWEEN
C             MAJAXW, MINAXW AND 0.0 IF ABOVE THE LAST CONTOUR
C
              FRACT =  1.0 - (ht - BASEHW)/(h - BASEHW)
              aax = MAJAXW(KLOW,ih) * FRACT
              bax = MINAXW(KLOW,ih) * FRACT
          ELSE
C             LINEARLY INTERPOLATE BETWEEN TWO VALUES
              aax = XINTRP( ZH(KLOW,ih), ZH(KLOW+1,ih),  ht,
     *                       MAJAXW(KLOW,ih), MAJAXW(KLOW+1,ih))
              bax = XINTRP( ZH(KLOW,ih), ZH(KLOW+1,ih),  ht,
     *                       MINAXW(KLOW,ih), MINAXW(KLOW+1,ih))
          ENDIF
      elseif(mhillt .EQ. 2) then
c ---    OPTHILL format hill information
         call AXIS(ht,aax,bax)
      endif
      baxi=one/bax

c  ----- Compute attributes of flow below Hd -----

c  Make sure that initial puff position used to define source streamline
c  is far enough away from hill
c     xpfi=AMIN1(xpf,-two*aax)
      xpfi=AMIN1(xpf,-100.*aax)

c  Find alpha-w (wind direction CW from major axis of ellipse)
c  (note that alpha-w has a range of 0-360 degrees)
      alfw=(thetaw-thetah(ih))*dtor
      if(alfw .LT. zero) alfw=alfw+twopi

c  Find beta (angle CCW from flow direction to "beta direction")
      r=aax*baxi
      top=r*SIN(alfw)
      bot=COS(alfw)
      alfs=ATAN2(top,bot)
c  (make sure that alpha-s has a range of 0-360 degrees)
      if(alfs .LT. zero) alfs=alfs+twopi
      beta=alfw-alfs

c  Find impingement pt. in ellipse coord. system (x along major axis)
      xoe=aax*COS(-alfw)
      yoe=bax*SIN(-alfw)

c  Rotate ellipse system to place x-axis along the flow direction
      rotang=pi-alfw
      call ROTATE(xoe,yoe,rotang,xof,yof)

c  Find the x-coord of the impingement pt. in the beta system
c       (note that this is the boundary between regions 1 and 2,
c        and the negative is the boundary between regions 2 and 3
c        in the flow below Hd)
      call ROTATE(xof,yof,beta,xob,yob)

c  Find puff position in beta coordinate system
      call ROTATE(xpf,ypf,beta,xpb,ypb)

c  Find d, the distance between the puff SL and stagnation SL
c  - Find initial puff position in ellipse coord system
      call ROTATE(xpfi,ypf,-rotang,xpei,ypei)
c  - Convert to elliptical coordinates
      call MUNU(0,xpei*baxi,ypei*baxi,r,mu,nu)
c  - Compute d
      d=(aax+bax)*SINH(mu)*SIN(nu+alfw)

c  ----- Compute attributes of flow above Hd -----

c  Determine boundaries between regions above Hd
      sbeta=SIN(beta)
      cbeta=COS(beta)
      x12f=(xob-ypf*sbeta)/cbeta
      x23f=(-xob-ypf*sbeta)/cbeta

c  Compute time-of-travel from puff at the start of the time-step to
c       the boundary(1,2).  This applies to the flow both above and
c       below Hd.  Note that t12p < 0 when puff is already past the
c       (1,2) boundary.
      x12p=x12f-xpf
      t12p=x12p/u

c  Compute the age of puff at the impingement point (timpg)
      timpg=tstart+t12p

c  Compute sigmas at the impingement point
      tlow=AMAX1(timpg,zero)
c old szo=SIGMA(tlow,sz1,tstart,sz2,tstep,szr,frac)
      szimpg=SIGMA(2,zpuff,u,tlow,sz1,tstart,sz2,tstep,szr,frac)
      szimpg=AMAX1(szmn,szimpg)
c old syo=SIGMA(tlow,sy1,tstart,sy2,tstep,syr,frac)
      syimpg=SIGMA(1,zpuff,u,tlow,sy1,tstart,sy2,tstep,syr,frac)
      syimpg=AMAX1(symn,syimpg)

c  Obtain Gaussian hill length scale for each axis of hill (above Hd)
      halfht=half*(h+hd)
      call AXIS(halfht,axa,axb)
      ah=axa*alphai
      bh=axb*alphai

c  Determine angle between the minor axis of the hill and the flow
c  in radians.  Note that use of psi is invariant to shifts of +/- pi
      psi=(thetaw-thetah(ih))*dtor-piby2

c  Set variables contained in common FLVARS:
c  Cut-off hill height and Froude number above Hd
      hh=h-hd
      fr=ubyn/hh
c  Find parameters for rotated hill
      call HILROT(ah,bh,psi)

c  Adapt section of code from CTDM subroutine FLOW ----------
c  (Note: speed shear ALF is no longer passed on to FLOPUFF)
C *** COMPUTE NEEDED LENGTH SCALE FACTORS.
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c *** Restore LZI ('92 Modification). Sigma Research Corp.
      LZI = SQRT(HALF * (LXI2 + LYI2) ) / RNLZ
c     lzi = sqrt( lxi2 + lyi2 )
c  LN and LNI are now computed in flopuff
c     LN  = HALF * rtpi * LZ
c     LNI = ONE / LN
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
      LZ  = ONE / LZI
C
C     COMPUTE THE HILL ASYMMETRY FACTOR HASYM. ....EQN. A-19B
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c *** Restore HASYM ('92 Modification). Sigma Research Corp.
      HASYM = SQRT(1.0+LX*LX*LYI2)
c     hasym = one
      IF(HASYM .GT. rt2) HASYM = rt2
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
c

c *** Begin shear modifications (1996).  EARTH TECH -- DGS
c --- Find speed shear from 1/2 the cut-off hill height to 1.5 the
c --- cut-off hill height
      hlo=half*(h+hd)
      hhi=two*h-hlo
      alf=(SPEED(hhi-hd)-SPEED(hlo-hd))/hh
      if(alf.LT.zero) alf=zero
c --- Modify neutral length scale, using shear and wind speed at hilltop
c --- provided speed at top is at least 1/10 puff speed
      speedhh=SPEED(hh)
      if(speedhh.GT.0.1*u) then
         lni=lzi+alf/speedhh
      else
         lni=lzi
      endif
      ln=one/lni
c *** End shear modifications (1996).  EARTH TECH -- DGS

c
C *** COMPUTE CORRECTED STRATIFICATION, S.
      BVUI = zero
      IF(ubyn .LT. 999.) BVUI=one/ubyn
      BVUI2 = BVUI * BVUI
      S = BVUI * HASYM
      S2 = S*S
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c  -B0N2 is not used, and B0,B02 are computed in FLOPUFF
c     B0N2 = B0N * B0N
c     B0 = S * LZ * RTPII * B0N
c     B02 = B0 * B0
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.

c *** Begin shear modifications (1996).  EARTH TECH -- DGS
c     Compute B0, and B02 here once again
      b0=s*ln
      b02=b0*b0
c *** End shear modifications (1996).  EARTH TECH -- DGS

c  End section of code from CTDM subroutine FLOW ********************

c  Define streamline height above Hd for obtaining distortion factors.
c  Use puff-center height above Hd, but set minimum value to hslfac
c  times the cut-off hill height (HH).
      hslmin=hslfac*hh
      hsl=AMAX1(zpuff-hd,hslmin)

c  Do not allow the ht of streamline to exceed upper limit compatible
c  with the flow routine
      hslmax=hh+piby2*ubyn/hasym
      hsl=AMIN1(hsl,hslmax)

c  Set up array of distortion factors at ntpts points along puff
c  trajectory, centered at x=xmf, covering a range of 3*el.
c  The length el is one half the distance between points of
c  intersection of the line y=0 (the centerplane of the flow over the
c  hill) with the ellipse that forms the base hill below Hd.
c  But xmf is the mid-point of the intersection of the puff trajectory
c  (without deflection) and the ellipse.  Note that at(1,-)=th, and
c  at(2,-)=tl; tu will be obtained from 1/(th*tl)
      spsi=SIN(psi)
      cpsi=COS(psi)
      spsi2=spsi*spsi
      cpsi2=cpsi*cpsi
      aax2=aax*aax
      bax2=bax*bax
      c1=(aax2-bax2)*spsi*cpsi
      c2=bax2*spsi2+aax2*cpsi2
      c2i=one/c2
      c4=aax2*bax2
      xmf=-c1*ypf*c2i
      el=SQRT(c4*c2i)
      xspace=three*el/(ntpts-1)
      xbegin=xmf-half*(ntpts-1)*xspace
      xend=xbegin+three*el

c  Set a flag so that factors = 1 if trajectory passes to side of hill
      iflag=0
      if(ypf*ypf .LT. c2) iflag=1

c  Loop over points
c  Set factors for first and last points equal to 1
      k=1
      at(1,k)=one
      at(2,k)=one
      k=ntpts
      at(1,k)=one
      at(2,k)=one

c  Set initial guess for streamline position upwind of hill before
c  entering loop.  PATH will use "current" ysl,zsl values when searching
c  for the streamline position at the next x-value.
      ysl=ypf
      zsl=hsl
      do 10 k=2,ntpts-1
         at(1,k)=one
         at(2,k)=one
         x=(k-1)*xspace+xbegin
         if(iflag .NE. 1) then
            ysl=ypf
            zsl=hsl
         else
c           call PATH(at(1,k),at(2,k),dum,x,ypf,hsl,ysl,zsl)
            call PATH(at(1,k),at(2,k),dum,x,ypf,hsl,xspace,ysl,zsl)
c *** Diagnostic write statement:
c           if(at(1,k) .LE. zero .OR. at(2,k) .LE. zero)
c    1                                 print *,k,(at(i,k),i=1,2)
         endif
10    continue

c --- Report DEBUG information
      if(ldb) then
         write(idebug,*)
         write(idebug,*) 'CTPAR: Flow below Hd ----'
         write(idebug,*) 'Height for axes (m) = ',ht
         write(idebug,*) 'Axis lengths (m)    = ',aax,bax
         write(idebug,*) 'Dist to imp pt (m)  = ',x12p
         write(idebug,*) 'Time to imp pt (s)  = ',timpg
         write(idebug,*) 'Sigma y,z at imp pt = ',syimpg,szimpg
         write(idebug,*) 'Crosswind y to SSL  = ',d
         write(idebug,*)
         write(idebug,*) 'CTPAR: Flow above Hd ----'
         write(idebug,*) 'Axis lengths (m)    = ',ah,bh
         write(idebug,*) 'Upper Froude No     = ',fr
      endif


      return
      end
c-----------------------------------------------------------------------
      subroutine ctrec
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                   CTREC
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes receptor position in various coordinate
c               systems and obtains travel times from regional bounds.
c
c ARGUMENTS:    none
c
c CALLING ROUTINES:     CTSG
c
c EXTERNAL ROUTINES:    ROTATE, IREG
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

c  Shift receptor position to hill-centered coordinate system with
c       x-axis along the flow
      xrc=xr-xc(ih)
      yrc=yr-yc(ih)
      call ROTATE(xrc,yrc,rotflo,xrf,yrf)

c  Find receptor position in ellipse coordinate system
      call ROTATE(xrf,yrf,-rotang,xre,yre)

c  Reset receptor location to the surface of the elliptic cylinder
c  if it lies outside of the ellipse (RMU > 0), by changing RMU and
c  computing a new X,Y (Adapted from CTDM+ modification!)
c  Compute the elliptic coordinates of the receptor
      if(zrec. LT. hd) then
         call MUNU(0,xre*baxi,yre*baxi,r,rmu,rnu)
         if(rmu .GT. 0) then
           rsq=r*r
           if(rsq .LT. one) rsq=one
           dum1=SQRT(rsq-one)

           if(dum1 .NE. 0.0) then
c ---        Not a circle (dum1 = 0)
             rmu0=ALOG((r+one)/dum1)
             sinnu=SIN(rnu)
             cosnu=COS(rnu)
             sinhmu=SINH(rmu0)
             coshmu=COSH(rmu0)
             xre=(dum1*coshmu*cosnu)/baxi
             yre=(dum1*sinhmu*sinnu)/baxi
           else

c ---        For a circle centered at (0,0), decrease XRE,YRE by
c ---        the ratio of the radial distance to the ellipse divided
c ---        by the radial distance to (XRE,YRE)

             factor=one/(SQRT(xre*xre+yre*yre)*baxi)
             xre=xre*factor
             yre=yre*factor
           endif

c  Recalculate receptor location with x-axis along the flow
           call ROTATE(xre,yre,rotang,xrf,yrf)

         endif
      endif

c  Find receptor position in beta coordinate system
      call ROTATE(xrf,yrf,beta,xrb,yrb)

c  Determine regions above and below Hd
      iregu=IREG(xrf,x12f,x23f)
      iregl=IREG(xrb,xob,-xob)

c  Compute time-of-travel from boundary(1,2) to receptor
c  - Upper flow:
      t12ru=(xrf-x12f)/u
c  - Lower flow:
      t12rl=(xrb-xob)/(u*cbeta)

      return
      end
c-----------------------------------------------------------------------
      subroutine ctsg(ldbin,irin,ipin,qin,uin,dirin,zlidin,xpin,ypin,
     *                zpin,iscin,zrin,ihin,stepin,tin,sz1in,sz2in,
     *                sy1in,sy2in,szrin,syrin,szmnin,symnin,frin,
     *                conc,cflat)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                    CTSG
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Main subroutine that controls computation of
c               concentrations on sub-grid-scale terrain features
c
c ARGUMENTS:
c   PASSED:     ldbin           debug logical                        [l]
c               irin            receptor number                      [i]
c               ipin            puff number                          [i]
c               qin             mass in puff (g)                     [r]
c               uin,dirin       wind speed, direction (m/s, deg CCW) [r]
c               zlidin          mixing lid (m)                       [r]
c               xpin,ypin,zpin  puff coordinates (m) at start of step[r]
c               iscin           stability class                      [i]
c               zrin            receptor height (m)                  [r]
c               ihin            hill ID                              [i]
c               stepin          time step (s)                        [r]
c               tin             age of puff at start of time-step (s)[r]
c               sz1in,sy1in     puff sigmas at start of time-step (m)[r]
c               sz2in,sy2in     puff sigmas at end of time-step (m)  [r]
c               szmnin,symnin   minimum value for sigmas (m)         [r]
c               frin            interpolation fraction for receptor  [r]
c                               position (0:start, 1:end of step)
c               szrin,syrin     puff sigmas at the receptor (m)      [r]
c   RETURNED:   conc            concentration (g/m**3)               [r]
c               cflat           concentration (g/m**3) without hill  [r]
c
c CALLING ROUTINES:     (main)
c
c EXTERNAL ROUTINES:    CTPAR, CTREC, PUFFC, UPPER, LOWER
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

      logical ldbin

c  Check to see if CTSG has just been called for the same time period,
c  the same puff, and the same hill:
      isame=0
      if(tstart .EQ. tin) then
         if(ip .EQ. ipin) then
            if(ih .EQ. ihin) then
               isame=1
            endif
         endif
      endif

c  Transfer debug unit number to CTPASS variable
      idebug=io6

c  Pass argument list into common CTPASS
      ldb=ldbin
      ir=irin
      ip=ipin
      q=qin
      u=uin
      thetaw=dirin
      zlid=zlidin
      xp=xpin
      yp=ypin
      zpuff=zpin
      isc=iscin
      xr=xrctm(irin)
      yr=yrctm(irin)
      zrec=zrin
      ih=ihin
      tstep=stepin
      tstart=tin
      sz1=sz1in
      sz2=sz2in
      sy1=sy1in
      sy2=sy2in
      frac=frin
      szr=szrin
      syr=syrin
      szmn=szmnin
      symn=symnin

c  Calculate diffusivities for the time-step
      if(frac.EQ.zero .OR. frac.EQ.one) then
c ---    Use diffusivity over full step
         twokz=(sz2**2-sz1**2)/tstep
         twoky=(sy2**2-sy1**2)/tstep
      elseif(frac.GT.half) then
c ---    Use diffusivity from receptor position to end of step
         timefac=1./((one-frac)*tstep)
         twokz=(sz2**2-szr**2)*timefac
         twoky=(sy2**2-syr**2)*timefac
      else
c ---    Use diffusivity from start of step to receptor position
         timefac=1./(frac*tstep)
         twokz=(szr**2-sz1**2)*timefac
         twoky=(syr**2-sy1**2)*timefac
      endif
      if(twokz.LT.small) twokz=0.0
      if(twoky.LT.small) twoky=0.0

c  Report argument list in DEBUG mode, and the inferred diffusivity
      if(ldb .AND. irin.eq.1) then
         write(io6,*)
         write(io6,*)'CTSG input data'
         write(io6,*)' ir = ',ir,' ip = ',ip,' q = ',q,
     1  ' u = ',u,' wd = ',thetaw,' zlid = ',zlid,' xp = ',xp,
     2  ' yp = ',yp,' zpuff = ',zpuff,' isc = ',isc,
     3  ' ih = ',ih,' tstep = ',tstep,' tstart = ',tstart,
     4  ' frac = ',frac,
     5  ' sz1 = ',sz1,' sz2 = ',sz2,' sy1 = ',sy1,
     6  ' sy2 = ',sy2,' szr = ',szr,' syr = ',syr,
     7  ' symn = ',symn,' szmn = ',szmn,
     8  ' hd = ',hda(ih),' u/N = ',ubyna(ih),
     9  ' h = ',relief(ih),' 2Kz = ',twokz,' 2Ky = ',twoky
      endif

c  Adjust height of receptor from height above sea level to
c  height above base-plane for current hill.
      zrec=zrec-zgrid(ih)

c  If current hill, puff, or time step differs from the last, compute
c  terrain-related parameters for puff trajectory.
      if(isame .EQ. 0) then
         hd=hda(ih)
         ubyn=ubyna(ih)
         h=relief(ih)
         call CTPAR
      endif

c  Compute receptor-related parameters
      call CTREC

c  Compute concentration
c       When terrain influence is modeled by using a receptor-on-a-pole
c       the standard puff sampling algorithm is called with an argument
c       of either 1 or 2.  Argument 1 signals the use of a pole of
c       height zpole; 2 signals the same plus the use of the distance
c       (d, passed as dpole) from the puff trajectory to the stagnation
c       SL in place of the usual off-axis distance to the receptor.

      cu=zero
      cl=zero
      if(zrec .GT. hd) then
         if(zlid .GT. hd) then
            if(iregu .EQ. 1) then
               zpole=hd
               call PUFFC(1,zpole,zero,cu)
            else
               call UPPER(cu)
            endif
            if(iregl .NE. 1 .and. hd .GT. zero) call LOWER(cl)
         endif
      elseif(hd .GT. zero) then
c ---    Remove test for receptors near base of hill, and treat all
c ---    receptors in the same way
c ---    zmin=0.1*AMIN1(hd,zpuff)
         zpole=zrec
         dpole=d
c ---    if(zpole .LT. zmin) then
c ---       call PUFFC(1,zpole,zero,cl)
c ---    else
            if(iregl .EQ. 1) then
               call PUFFC(2,zpole,dpole,cl)
            else
               call LOWER(cl)
            endif
c ---    endif
      endif

c  Do a "flat" calc. for comparison
      call PUFFC(0,zero,zero,cflat)

      conc=cu+cl

c  Report results in DEBUG mode
      if(ldb .AND. irin.eq.1)then
         write(io6,*)
         write(io6,*)'CTSG output for receptor ',irin
         write(io6,*)'  hd = ',hd,'   u/N = ',ubyn
         write(io6,*)'conc = ',conc,' cflat = ',cflat
      endif

      return
      end
c-----------------------------------------------------------------------
      function fcty(t)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                    FCTY
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes value of integrand function denoted as fcty,
c               at time t.
c
c ARGUMENTS:
c    PASSED:    t       time-of-travel of puff (sec)                 [r]
c
c CALLING ROUTINES:     UPPER
c
c EXTERNAL ROUTINES:    TFAC
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

c  Obtain Th and Tu
      delt=t-timpg
      x=x12f+delt*u
      call TFAC(x,th,tl,tu)

c  Compute integrand
      fcty=twoky*EXP(two*(one-tl))

      return
      end
c-----------------------------------------------------------------------
      function fctz(t)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 951005                    FCTZ
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes value of integrand function denoted as fctz,
c               at time t.
c
c ARGUMENTS:
c    PASSED:    t       time-of-travel of puff (sec)                 [r]
c
c CALLING ROUTINES:     UPPER
c
c EXTERNAL ROUTINES:    TFAC
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

c  Obtain Th and Tu
      delt=t-timpg
      x=x12f+delt*u
      call TFAC(x,th,tl,tu)

c  Compute integrand
      fctz=twokz*tu*tu*EXP(two*(one-th))

      return
      end
c-----------------------------------------------------------------------
      subroutine flopuff(x,y,z,eta,del,thi,tli,tu)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                 FLOPUFF
c ---            R. Yamartino, SRC
c ---            (D. Strimaitis, SRC)
c
C PURPOSE:      (adapted from CTDM subroutine FLOW)
C     COMPUTES THE PERTURBATION WINDS UP,VP,WP AT (X,Y,Z) AND
C     COMPUTES THE VERTICAL AND LATERAL DEFLECTIONS (ETA,DEL) OF THE
C     STREAMLINE THAT PASSES THROUGH THE POINT (X,Y,Z) ABOVE THE
C     SURFACE OF A ROTATED GAUSSIAN HILL.
C *** THIS CODE NOW COMPUTES IDYY, AND IXXDYY TO COMPUTE T-FACTORS.
C     TLI    = 1.0 - D(DEL)/DY = 1.0 + (IDYY + BVUI2*IXXDYY)
C     THI    = 1.0 - D(ETA)/DZ = 1.0 + IDZZ
C
C *** THIS STRATIFIED FLOW CALCULATION ACCOUNTS FOR ARBITRARY
C     STRATIFICATION, N/U, (INCLUDING NEUTRAL) IN THE NEAR FIELD
C     OF THE HILL (I.E. X < LX, Y < LY, Z << LX OR LY ).
C *** LINEAR WIND SHEAR CORRECTIONS ARE ADDED IN SUCH THAT NEUTRAL
C     DEFLECTIONS ARE CORRECT TO LOWEST ORDER IN THE SHEAR GRADIENT.
C *** U''/U = 0 IS ASSUMED BUT N/U IS COMPUTED FROM FR ABOVE HC.
C
C     MODIFICATION:  Changes made during EPA-sponsored upgrade to the
C                    FLOW algorithm have been made here.  This is now
C                    consistent with INPUFF 3.0 (10/93).
C
C ARGUMENTS:
C    PASSED:    X       X COORDINATE (POSITIVE DOWNWIND OF HILL      [r]
C                       CENTER) (m)
C               Y       Y COORDINATE (POSITIVE LEFT OF HILL          [r]
C                       CENTER) (m)
C               Z       Z COORDINATE (POSITIVE ABOVE HILL            [r]
C                       SURFACE) (m)
C  RETURNED:    ETA     VERTICAL DEFL. OF STREAMLINE PASSING         [r]
C                       (X,Y,Z) (m)
C               DEL     LATERAL DEFLECTION OF STREAMLINE PASSING     [r]
C                       (X,Y,Z) (m)
C               TLI     1.0/(TL FACTOR) AT (X,Y,Z)                   [r]
C               THI     1.0/(TH FACTOR) AT (X,Y,Z)                   [r]
C               TU      TU FACTOR AT (X,Y,Z)                         [r]
C
C CALLING ROUTINES:  UPPER, PATH
C
C EXTERNAL ROUTINES: SPEED
C----------------------------------------------------------------------C

      INCLUDE 'const.puf'
      INCLUDE 'flvar.puf'
C                                                                       FLW00470
      REAL*4 I,IDY,IDZ,IDX,IDXX,IDXY,IDXZ                               FLW00490
      REAL*4 IX,IXDY,IXX,IXXDY,IDYY,IDZZ,IXXDYY,ID3Y,IXXD3Y             FLW00500
      DATA WTB/1.25/                                                    FLW00530
C                                                                       FLW00540
C *** MOST OF THIS CODE COMPUTES I AND ITS INTEGRALS AND DERIVATIVES.   FLW00550
C     THE NOTATION IS SEEN IN THE EXAMPLE IXDY, WHICH IS I INTEGRATED   FLW00560
C     ONCE IN X (FROM -INFINITY TO X) AND DIFFERENTIATED IN Y.          FLW00570
C                                                                       FLW00580
C *** COMPUTE DIMENSIONLESS COORDINATES
      XDLX = X * LXI                                                    FLW00710
      YDLY = Y * LYI                                                    FLW00720
      YDLY2 = YDLY * YDLY                                               FLW00730
C                                                                       FLW00740
C *** COMPUTE THE MODIFIED COORDINATES XM,YM AND THEIR                  FLW00750
C     DIMENSIONLESS FORMS XMDLX,YMDLY.                                  FLW00760
      XM = X + GAM*LX*LX*Y                                              FLW00770
      YM = Y + GAM*LY*LY*X                                              FLW00780
      XMDLX = XM * LXI                                                  FLW00790
      XMDLX2 = XMDLX * XMDLX                                            FLW00800
      YMDLY = YM * LYI                                                  FLW00810
      YMDLY2 = YMDLY * YMDLY                                            FLW00820
C                                                                       FLW00830
      GAMLX = GAM * LX                                                  FLW00840
      GAMLX2 = GAMLX * GAMLX                                            FLW00850
      GAMP = ONE - GAMLX2*LY*LY                                         FLW00860
      GAMP2 = GAMP * GAMP                                               FLW00870
C                                                                       FLW00880
C     HHXY = HH * HILHGT(X,Y)   BUT COMPUTE IN CODE BELOW.              FLW00890
      ARG = XDLX*XDLX + YDLY*YDLY + 2.0*GAM*X*Y                         FLW00900
      IF(ARG .GT. 30.) ARG = 30.                                        FLW00910
      EXPARG = EXP(-ARG)                                                FLW00920
      HHXY = HH * EXPARG                                                FLW00930
C                                                                       FLW00940
C *** OBTAIN CORRECT WIND SPEED, U, USING SPEED                         FLW00950
C                                                                       FLW00960
      U = SPEED(HHXY+Z)                                                 FLW00970
      UI = ONE / U                                                      FLW00980
C                                                                       FLW00990
C     COMPUTE THE SHEAR FACTORS THAT ARE NEEDED.                        FLW01000
C                                                                       FLW01010
c !!! Begin shear modifications 1996.  EARTH TECH -- DGS
c
c dgs U0 = AMIN1(SPEED(HHXY),U)                                         FLW01020
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c     SHRF = SQRT(U0*UI)                                                FLW01030
c     SHRFDZ = -HALF * ALF * UI                                         FLW01040
c     SHRC=HALF*ALF/U0                                                  FLW01050
c dgs shrf = u / u0
c dgs ln  = lz * shrf
c dgs lni = one / ln
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
c
C *** COMPUTE THE ADDITIONAL Z SUPRESSION FACTOR FROM NEUTRAL FLOW MATCHFLW01060
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c     ZFACI = ONE / (ONE + LNI * Z)                                     FLW01070
c     ZFACDZ = -TWO * LNI * ZFACI                                       FLW01080
      zfaci = exp(-lni * z)
C *** COMBINE WITH SHEAR FACTOR TO GIVE TOTAL Z ADJUSTMENT FACTOR.      FLW01090
c     TZFAC = SHRF * ZFACI * ZFACI                                      FLW01100
c     TZFDZ = SHRFDZ + ZFACDZ                                           FLW01110
c     TZFDZZ = TZFDZ*TZFDZ - SHRFDZ*ALF*UI - ZFACDZ*LNI*ZFACI           FLW01120
c *** Combine with shear factor to give total z adjustment factor.
c dgs b0 = s * ln
c dgs b02 = b0 * b0
c dgs tzfac = zfaci * lz  / (one + b02)
      tzfac = zfaci * ln  / (one + b02)
      tzfdz = -lni
      tzfdzz = lni*lni
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
c !!! End shear modifications 1996.  EARTH TECH -- DGS

C                                                                       FLW01130
C                                                                       FLW01260
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c     AST = TWO * RTPII * S2 * LZ * PII * B0N2 - SHRC                   FLW01270
      ast = one
C --- ASTDS2 IS ACTUALLY AST/(S*BVUI)                                   FLW01280
c     ASTDS2 = TWO * RTPII * LZ * PII * HASYM                           FLW01290
      astds2 = one
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
c
C --- HHM IS THE COEFFICIENT OF I AT X=Y=0                              FLW01300
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c     HHM = HH * LN / (ONE + B02)                                       FLW01310
      hhm = hh
C --- HHXYM IS THE COEFFICIENT OF I AWAY FROM HILL CREST                FLW01320
      HHXYM = HHM * EXPARG                                              FLW01330
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
C *** COMPUTE THE STRATIFICATION HEIGHT, SZ.                            FLW01340
      SZ = S * Z                                                        FLW01350
C                                                                       FLW01360
C *** COMPUTE THE VARIOUS 'ANGULAR FACTORS', AFN, AND THEIR DERIVATIVES,FLW01370
C     ADN, CONDITIONED ON THE VALUE OF SZ.                              FLW01380
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c     IF(SZ .LE. 0.005) THEN                                            FLW01390
c        CSZ = ONE                                                      FLW01400
c        SSZ = SZ                                                       FLW01410
c        AF1 = Z                                                        FLW01420
c        AD1 = ONE                                                      FLW01430
c        ADD1 = S * SZ                                                  FLW01440
c     ELSE                                                              FLW01450
c        SI  = ONE / S                                                  FLW01460
c        CSZ = COS(SZ)                                                  FLW01470
c        SSZ = SIN(SZ)                                                  FLW01480
c        AF1 = SSZ * SI                                                 FLW01490
c        AD1 = CSZ                                                      FLW01500
c        ADD1 = -S * SSZ                                                FLW01510
c     ENDIF                                                             FLW01520
      csz = cos(sz)
      ssz = sin(sz)
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
C                                                                       FLW01530
C     AF0 = CSZ / ZFACI                                                 FLW01540
C     AD0 = LNI * CSZ  -  S * SSZ / ZFACI                               FLW01550
C *** OVERRIDE AF0=CSZ WITH AF0=ONE. 10/8/86                            FLW01560
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
c     AF0 = ONE / ZFACI                                                 FLW01570
c     AD0 =  LNI                                                        FLW01580
c     ADD0 = -S2 / ZFACI                                                FLW01590
c     AF2SHR = TWO * LNI + SHRC                                         FLW01600
c     AF2 = S * CSZ + AF2SHR * SSZ                                      FLW01610
c     AD2 = -S2 * SSZ + AF2SHR * S * CSZ                                FLW01620
c     ADD2 = -S2 * (S * CSZ + AF2SHR * SSZ)                             FLW01630
c
      af0 = csz
      ad0 =  -s * ssz
      add0 = -s2 * csz
c
      af1 = b0 * ssz
      ad1 = b0 * s * csz
      add1 = -b0 * s2 * ssz
c
      af2 = b0 * csz  +  ssz
      ad2 = -b0 * s * ssz  +  s * csz
      add2 = -s2 * (b0 * csz  +  ssz)
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
C                                                                       FLW01640
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR I.                         FLW01650
      T0 = ONE                                                          FLW01660
c *** Begin Modifications 7/4/91. Sigma Research Corp.  RJY.
      T1 = -AST                                                         FLW01670
c or  t1 = -one
C ??? T2 = -ASTDS2*XMDLX                                                FLW01680
C ---------- TRY SETTING T2=0. FOR XM LESS THAN ZERO ------------       FLW01690
c     T2 = 0.                                                           FLW01700
c     IF(XM .GE. 0.) T2 = -ASTDS2*XMDLX                                 FLW01710
      t2 = -astds2*xmdlx
c or  t2 = -xmdlx
c *** End Modifications 7/4/91. Sigma Research Corp.  RJY.
C                                                                       FLW01720
      TI0 = T0 * AF0                                                    FLW01730
      TI1 = T1 * AF1                                                    FLW01740
      TI2 = T2 * AF2                                                    FLW01750
      SUM = TI0 + TI1 + TI2                                             FLW01760
C                                                                       FLW01770
C *** COMPUTE THE BASIC QUANTITY I.   ....EQN. A-27                     FLW01780
      I = TZFAC * HHXYM * SUM                                           FLW01790
C                                                                       FLW01800
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IDZ.                       FLW01810
      TI0 = T0 * AD0                                                    FLW01820
      TI1 = T1 * AD1                                                    FLW01830
      TI2 = T2 * AD2                                                    FLW01840
      SUM = TI0 + TI1 + TI2                                             FLW01850
C                                                                       FLW01860
C *** COMPUTE THE DERIVATIVE OF I WITH RESPECT TO Z.  ....EQN. A-28     FLW01870
      TERM1 = TZFAC * HHXYM * SUM                                       FLW01880
      IDZ =  TERM1  +  TZFDZ * I                                        FLW01890
C                                                                       FLW01900
C *** COMPUTE THE SECOND DERIVATIVE OF I WITH RESPECT TO Z.             FLW01910
      TI0 = T0 * ADD0                                                   FLW01920
      TI1 = T1 * ADD1                                                   FLW01930
      TI2 = T2 * ADD2                                                   FLW01940
      SUM = TI0 + TI1 + TI2                                             FLW01950
C                                                                       FLW01960
C *** COMPUTE THE SECOND DERIVATIVE OF I WITH RESPECT TO Z. ....EQN.A-29FLW01970
      IDZZ = TZFAC * HHXYM * SUM  +  TWO * TZFDZ * TERM1  +  TZFDZZ * I FLW01980
C                                                                       FLW01990
C                                                                       FLW02000
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IDX AND IDXZ.              FLW02010
C     T0 = ZERO                                                         FLW02020
C     T1 = ZERO                                                         FLW02030
      T2 = -ASTDS2 * LXI                                                FLW02040
C                                                                       FLW02050
C     TI0 = T0 * AF0                                                    FLW02060
C     TI1 = T1 * AF1                                                    FLW02070
      TI2 = T2 * AF2                                                    FLW02080
C     SUM = TI0 + TI1 + TI2                                             FLW02090
      SUM = TI2                                                         FLW02100
C                                                                       FLW02110
C *** COMPUTE THE QUANTITY IDX.    ....EQN. A-30                        FLW02120
      TERM2 = TZFAC * HHXYM * SUM                                       FLW02130
      IDX = -TWO * XMDLX * LXI * I  +  TERM2                            FLW02140
C                                                                       FLW02150
C     NOW COMPUTE THE D/DZ TERMS.                                       FLW02160
C     TI0 = T0 * AD0                                                    FLW02170
C     TI1 = T1 * AD1                                                    FLW02180
      TI2 = T2 * AD2                                                    FLW02190
C     SUM = TI0 + TI1 + TI2                                             FLW02200
      SUM = TI2                                                         FLW02210
C                                                                       FLW02220
C *** COMPUTE THE DERIVATIVE OF IDX WITH RESPECT TO Z.  ....EQN. A-32   FLW02230
      TERM3 = TZFAC*HHXYM*SUM                                           FLW02240
      IDXZ = -TWO*XMDLX*LXI*IDZ + TZFDZ*TERM2 + TERM3                   FLW02250
C                                                                       FLW02260
C                                                                       FLW02270
C *** COMPUTE THE QUANTITIES NEEDED FOR IDXX.                           FLW02280
C     T0 = ZERO                                                         FLW02290
C     T1 = ZERO                                                         FLW02300
C     T2 = ZERO                                                         FLW02310
C                                                                       FLW02320
C     TI0 = T0 * AF0                                                    FLW02330
C     TI1 = T1 * AF1                                                    FLW02340
C     TI2 = T2 * AF2                                                    FLW02350
C     SUM = TI0 + TI1 + TI2                                             FLW02360
      SUM = ZERO                                                        FLW02370
C                                                                       FLW02380
C *** COMPUTE THE QUANTITY IDXX.  ....EQN. A-31                         FLW02390
      IDXX = -TWO * LXI2 * (ONE + TWO * XMDLX2) * I  -                  FLW02400
     X       FOUR * XMDLX * LXI * IDX  +  TZFAC * HHXYM * SUM           FLW02410
C                                                                       FLW02420
C                                                                       FLW02430
C                                                                       FLW02440
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IDY.                       FLW02450
C     T0 = ZERO                                                         FLW02460
C     T1 = ZERO                                                         FLW02470
      T2 = -ASTDS2 * GAMLX                                              FLW02480
C                                                                       FLW02490
C     TI0 = T0 * AF0                                                    FLW02500
C     TI1 = T1 * AF1                                                    FLW02510
      TI2 = T2 * AF2                                                    FLW02520
C     SUM = TI0 + TI1 + TI2                                             FLW02530
      SUM = TI2                                                         FLW02540
C                                                                       FLW02550
C *** COMPUTE THE QUANTITY IDY.   ....EQN. A-33                         FLW02560
      IDY = -TWO * LYI * YMDLY * I  +  TZFAC * HHXYM * SUM              FLW02570
C                                                                       FLW02580
C *** COMPUTE THE QUANTITY IDYY.  ....EQN. A-34                         FLW02590
      IDYY = -TWO * LYI2 * (ONE + TWO * YMDLY2) * I  -                  FLW02600
     X       FOUR * YMDLY * LYI * IDY                                   FLW02610
C                                                                       FLW02620
C *** COMPUTE THE QUANTITY ID3Y.  ....EQN. A-35                         FLW02630
      ID3Y = -8.0 * LYI3 * YMDLY * I  -  FOUR * LYI * YMDLY * IDYY  -   FLW02640
     X       TWO * LYI2 * (THREE + TWO * YMDLY2) * IDY                  FLW02650
C                                                                       FLW02660
C                                                                       FLW02670
C *** COMPUTE THE QUANTITIES NEEDED FOR IDXY.                           FLW02680
C     T0 = ZERO                                                         FLW02690
C     T1 = ZERO                                                         FLW02700
C     T2 = ZERO                                                         FLW02710
C                                                                       FLW02720
C     TI0 = T0 * AF0                                                    FLW02730
C     TI1 = T1 * AF1                                                    FLW02740
C     TI2 = T2 * AF2                                                    FLW02750
C     SUM = TI0 + TI1 + TI2                                             FLW02760
      SUM = ZERO                                                        FLW02770
C                                                                       FLW02780
C *** COMPUTE THE QUANTITY IDXY.     ....EQN. A-36                      FLW02790
      IDXY = -TWO * (GAM  +  TWO * XM * YM * LXI2 * LYI2) * I  -        FLW02800
     X       TWO * XMDLX * LXI * IDY  -                                 FLW02810
     X       TWO * YMDLY * LYI * IDX  +  TZFAC * HHXYM * SUM            FLW02820
C                                                                       FLW02830
C                                                                       FLW02840
C ****************************************************************      FLW02850
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IXXDY.                     FLW02860
C     NOTE THAT IXX IS ALSO NEEDED FOR THIS.                            FLW02870
C                                                                       FLW02880
C --- COMPUTE THE GNX AND GNXX FACTORS.                                 FLW02890
C $$$ G0X = HALF * rtpi * ( ONE + ERF(XMDLX) )                          FLW02900
C --- INSERT THE FOLLOWING FIX TO KILL LAT. DEFL. GROWTH. 10/1/86       FLW02910
      G0X = HALF * rtpi * ( ONE - ERF( ABS(XMDLX) )  )                  FLW02920
C                                                                       FLW02930
      IF(XMDLX2 .GT.30.) XMDLX2 = 30.                                   FLW02940
      G1X = -HALF * EXP(-XMDLX2)                                        FLW02950
      G0XX = XMDLX * G0X - G1X                                          FLW02960
      G1XX = -HALF * G0X                                                FLW02970
C                                                                       FLW02980
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IXX.                       FLW02990
      T0 = G0XX                                                         FLW03000
      T1 = -G0XX                                                        FLW03010
      T1 = AST * T1                                                     FLW03020
      T2 = -ASTDS2*G1XX                                                 FLW03030
C                                                                       FLW03040
      TI0 = T0 * AF0                                                    FLW03050
      TI1 = T1 * AF1                                                    FLW03060
      TI2 = T2 * AF2                                                    FLW03070
      SUM = TI0 + TI1 + TI2                                             FLW03080
C                                                                       FLW03090
C *** COMPUTE THE QUANTITY IXX.      ....EQN. A-42                      FLW03100
C     QX = YDLY2 - GAMLX2 * Y * Y                                       FLW03110
      QX = YDLY2 * GAMP                                                 FLW03120
      IF(QX .GT.30.) QX = 30.                                           FLW03130
      EFAC = EXP(-QX)                                                   FLW03140
      HHLX2E = HHM * LX * LX * EFAC                                     FLW03150
      IXX = TZFAC * HHLX2E * SUM                                        FLW03160
C                                                                       FLW03170
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IXXDY.                     FLW03180
      T0 = GAMLX*G0X                                                    FLW03190
      T1 = -GAMLX*G0X                                                   FLW03200
      T1 = AST * T1                                                     FLW03210
      T2 = -ASTDS2*GAMLX*G1X                                            FLW03220
C                                                                       FLW03230
      TI0 = T0 * AF0                                                    FLW03240
      TI1 = T1 * AF1                                                    FLW03250
      TI2 = T2 * AF2                                                    FLW03260
      SUM = TI0 + TI1 + TI2                                             FLW03270
C                                                                       FLW03280
C *** COMPUTE THE QUANTITY IXXDY.     ....EQN. A-44                     FLW03290
      IXXDY = -TWO * LYI2 * Y * GAMP * IXX  +  TZFAC * HHLX2E * SUM     FLW03300
C                                                                       FLW03310
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IX.                        FLW03320
      T0 = +G0X                                                         FLW03330
      T1 = -G0X                                                         FLW03340
      T1 = AST * T1                                                     FLW03350
      T2 = -ASTDS2*G1X                                                  FLW03360
C                                                                       FLW03370
      TI0 = T0 * AF0                                                    FLW03380
      TI1 = T1 * AF1                                                    FLW03390
      TI2 = T2 * AF2                                                    FLW03400
      SUM = TI0 + TI1 + TI2                                             FLW03410
C                                                                       FLW03420
C *** COMPUTE THE QUANTITY IX.     ....EQN. A-41                        FLW03430
      IX = TZFAC * HHLX2E * LXI * SUM                                   FLW03440
C                                                                       FLW03450
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IXDY.                      FLW03460
C     HHJ = GAMLX * EXP(-XMDLX2) * XMDLX**J  BUT SEE G1X                FLW03470
      HH0 = -TWO * G1X * GAMLX                                          FLW03480
      HH1 = HH0 * XMDLX                                                 FLW03490
      HH2 = HH1 * XMDLX                                                 FLW03500
      T0 = HH0                                                          FLW03510
      T1 = -HH0                                                         FLW03520
      T1 = AST * T1                                                     FLW03530
      T2 = -ASTDS2*HH1                                                  FLW03540
C                                                                       FLW03550
      TI0 = T0 * AF0                                                    FLW03560
      TI1 = T1 * AF1                                                    FLW03570
      TI2 = T2 * AF2                                                    FLW03580
      SUM = TI0 + TI1 + TI2                                             FLW03590
C                                                                       FLW03600
C *** COMPUTE THE QUANTITY IXDY.        ....EQN. A-45                   FLW03610
      IXDY = -TWO * LYI2 * Y * GAMP * IX  +  TZFAC * HHLX2E * LXI * SUM FLW03620
C                                                                       FLW03630
C                                                                       FLW03640
C *** COMPUTE THE QUANTITY IXXDYY       ....EQN. A-46                   FLW03650
C     (NOTE THAT IXXDYY USES THE SAME SUM AS IXDY)                      FLW03660
      IXXDYY = -TWO * LYI2 * GAMP * IXX * (ONE + TWO*GAMP*YDLY2) -      FLW03670
     X          FOUR * LYI2 * Y * GAMP * IXXDY  +                       FLW03680
     X          TZFAC * HHLX2E * GAMLX * SUM                            FLW03690
C                                                                       FLW03700
C                                                                       FLW03710
C *** COMPUTE THE VARIOUS INTEGRAL TERMS FOR IXXD3Y.                    FLW03720
      T0 = -TWO * HH1                                                   FLW03730
      T1 = +TWO * HH1                                                   FLW03740
      T1 = AST * T1                                                     FLW03750
      T2 = -ASTDS2 * (HH0 - TWO*HH2)                                    FLW03760
C                                                                       FLW03770
      TI0 = T0 * AF0                                                    FLW03780
      TI1 = T1 * AF1                                                    FLW03790
      TI2 = T2 * AF2                                                    FLW03800
      SUM = TI0 + TI1 + TI2                                             FLW03810
C                                                                       FLW03820
C *** COMPUTE THE QUANTITY IXXD3Y.        ....EQN. A-47                 FLW03830
      IXXD3Y = -FOUR*LYI3*GAMP2*IXX*YDLY*(THREE+TWO*GAMP*YDLY2) -       FLW03840
     X          6.0 * LYI2 * GAMP * IXXDY * (ONE+TWO*GAMP*YDLY2)  -     FLW03850
     X          6.0 * LYI * GAMP * YDLY * IXXDYY  +                     FLW03860
     X          TZFAC * HHLX2E * GAMLX2 * SUM                           FLW03870
C                                                                       FLW03880
C ************************************************************          FLW03890
C *** COMPUTE THE STREAMLINE DEFLECTIONS.                               FLW03900
C *** COMPUTE THE VERTICAL DEFLECTION AS -(D/DZ) I.  ....EQN. A-22A     FLW03910
      ETA = -IDZ                                                        FLW03920
C *** NOW COMPUTE THE LATERAL DEFLECTION AS          ....EQN. A-22E     FLW03930
C     DEL = -(D/DY)(IDY+BVUI2*IXX) = -(IDY + BVUI2*IXXDY)               FLW03940
C *** AND COMPUTE ITS FIRST AND SECOND DERIVATIVES                      FLW03950
      TERM3 = BVUI2 * IXXDY                                             FLW03960
      DEL = -(IDY + TERM3)                                              FLW03970
      DELDY = -IDYY - BVUI2*IXXDYY                                      FLW03980
      DELDYY = -ID3Y - BVUI2*IXXD3Y                                     FLW03990
C *** COMPUTE CORRECTION FACTOR FOR LATERAL DEFLECTIONS                 FLW04000
      DELC = ONE + ABS(DELDY)                                           FLW04010
      DELCOR = DELC                                                     FLW04020
      IF(ABS(DEL).LT.0.001*LY) THEN                                     FLW04030
         DELCOR = ONE                                                   FLW04040
      ELSEIF(ABS(DELDYY*LY) .GT. 0.001) THEN                            FLW04050
         EPS = WTB*DELDYY*DEL                                           FLW04060
         ARGRT = DELC*DELC-TWO*EPS                                      FLW04070
         RTDELC = 0.                                                    FLW04080
         IF(ARGRT .GE. 0.) RTDELC = SQRT(ARGRT)                         FLW04090
         IF(RTDELC .NE. DELC) DELCOR = EPS/(DELC-RTDELC)                FLW04100
      ENDIF                                                             FLW04110
C *** APPLY CORRECTION FACTOR                                           FLW04120
      DEL = DEL / DELCOR                                                FLW04130
C                                                                       FLW04140
C *** COMPUTE THE RECIPROCAL OF THE T FACTORS      ....EQNS. A-22F,G    FLW04150
C *** NOTE THAT THE T FACTORS COULD GO TO INFINITY.                     FLW04160
      TLI = ONE - DELDY/DELCOR                                          FLW04170
      THI = ONE + IDZZ                                                  FLW04180
C                                                                       FLW04190
C ****************************************************************      FLW04200
C                                                                       FLW04210
C *** COMPUTE THE PERTURBATION VELOCITIES.   ...EQNS. A-22B,C,D         FLW04220
C                                                                       FLW04230
C *** NOW COMPUTE THE ALONG-WIND VELOCITY PERTURBATION AS               FLW04240
C     UP/U = -(IDXX + (BV*UI)**2 * I )                                  FLW04250
C     NOTE THAT THIS IS JUST THE NEGATIVE OF THE PERTURBATION           FLW04260
C     PRESSURE DIVIDED BY RHO(0)*U**2.                                  FLW04270
      TERM3 = BVUI2 * I                                                 FLW04280
      UP = -(IDXX + TERM3)                                              FLW04290
C *** COMPUTE THE NON-LINEAR PERTURBATION ALA HUNT ET AL.               FLW04300
C!!!!!UPNL = ( -ONE + SQRT( ABS(ONE + TWO*UP) )  ) * U                  FLW04310
      UP = UP * U                                                       FLW04320
C                                                                       FLW04330
C *** NOW COMPUTE THE LATERAL VELOCITY PERTURBATION AS                  FLW04340
C     VP/U = -(IDXY + (BV*UI)**2 * IXDY)                                FLW04350
      TERM3 = BVUI2 * IXDY                                              FLW04360
      VP = -(IDXY + TERM3) * U                                          FLW04370
C                                                                       FLW04380
C *** NOW COMPUTE THE VERTICAL VELOCITY PERTURBATION AS -(D/DZ) IDX.    FLW04390
      WP = -IDXZ * U                                                    FLW04400
C                                                                       FLW04410
C ***********************************************************           FLW04420
C                                                                       FLW04430
C *** COMPUTE THE "SPEED-UP" FACTOR TU                                  FLW04440
      UTOT=SQRT( (U+UP)*(U+UP) + VP*VP + WP*WP )                        FLW04450
      TU = UTOT*UI                                                      FLW04460
C                                                                       FLW04470
C ***********************************************************           FLW04480
C                                                                       FLW04490
      RETURN                                                            FLW04500
      END                                                               FLW04510
c-----------------------------------------------------------------------
c      subroutine getprfm(ihill,umet,vmet,tmet,zgpt,nears,tempss,lcalgrd,
c     &                   istab,ptg,nx,ny,nz,xorig,yorig,dgrid)
      subroutine getprfm(ihill,umet,vmet,tmet,zgpt,nears,tempss,lcalgrd,
     &                   istab,ptg,nx,ny,nz,xorig,yorig,dgrid,
     &                   i2dmet,temp2d)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                 GETPRFM
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Passes vertical profiles of wind speed and the Brunt-
c               Vaisala Frequency into common for use by CTSG-related
c               routines. Uses MET arrays.
c
c UPDATE:
c
c --- V5.5-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c
c ARGUMENTS:
c    PASSED:    ihill   hill index number                           [i]
c               umet    wind field array of u-components (m/s)     [ra]
c               vmet    wind field array of v-components (m/s)     [ra]
c               tmet    temperature array (K)                      [ra]
c               zgpt    heights of data levels above surface (m)   [ra]
c               nears   array for met station nearest grid pt.     [ia]
c               tempss  temperatures at surface stations           [ra]
c               lcalgrd indicates temp profile available (T)        [l]
c               istab   stability class field                      [ia]
c               ptg     default pot. temp gradient (K/m) for the   [ra]
c                       two stable classes (E,F)
c               nx      number of grid-points in x-dir.             [i]
c               ny      number of grid-points in y-dir.             [i]
c               nz      number of grid-points in vertical           [i]
c               xorig   x-coordinate of the origin of met grid (m)  [r]
c               yorig   y-coordinate of the origin of met grid (m)  [r]
c               dgrid   spacing of grid-cells in met grid (m)       [r]
c               temp2d  temperatures at CALMET gridpoints          [ra]
c               i2dmet  2D CALMET surface arrays                    [i]
c                        0 = 2d sfc met NOT available
c                        1 = 2d sfc met available
c  RETURNED:    none
c
c CALLING ROUTINES:     COMP
c
c EXTERNAL ROUTINES:    NEARS
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

      real umet(mxnx,mxny,mxnz),vmet(mxnx,mxny,mxnz),
     1     tmet(mxnx,mxny,mxnz),zgpt(mxnz),tempss(mxss),ptg(2)
      integer istab(mxnx,mxny),nears(mxnx,mxny)
      logical lcalgrd
c frr(09/01)
      real temp2d(mxnx,mxny)

c  Obtain met data at the grid-point nearest the center of the hill.
c  Find the grid-point indices (ig,jg) of the cell in which the
c  center of the hill is located.  The minimum value of each index
c  should be 1, and the maximum value should be either nx or ny.
      xhill=xc(ihill)-xorig
      yhill=yc(ihill)-yorig
      ig=xhill/dgrid+1.0
      ig=MAX0(1,ig)
      ig=MIN0(nx,ig)
      jg=yhill/dgrid+1.0
      jg=MAX0(1,jg)
      jg=MIN0(ny,jg)


c  BVF default is determined from stability class and near-surface T
      if(istab(ig,jg) .LE. 4) then
         ptgrad=0.0
      elseif(istab(ig,jg) .EQ. 5) then
         ptgrad=ptg(1)
      else
         ptgrad=ptg(2)
      endif
c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
         temp=temp2d(ig,jg)
      elseif(i2dmet.EQ.0) then
c        Temperature at surface met station nearest hill
         issta=nears(ig,jg)
         temp=tempss(issta)
      else
         write(*,*)'Subr. GETPRFM:  Invalid I2DMET = ',i2dmet
         stop
      endif

      dfault=SQRT(9.80665*ptgrad/temp)

c  Assign variables to common.  Note that the B-V frequency is set
c  to zero if the temperature structure in a layer is not stably
c  stratified.
      nlev=nz
      do nl=1,nlev
         z(nl)=zgpt(nl)
c  Special case of nz=1:  met data may be from ISC-type input, so use
c  the wind speed as measured, not as scaled to zgpt.  The measured
c  speed was saved as "level 2".
         nlws=nl
         if(nz.EQ.1) nlws=nlws+1
         ws(nl)=SQRT(umet(ig,jg,nlws)**2+vmet(ig,jg,nlws)**2)
         if(LCALGRD) then
            abvf(nl)=0.
            if(nl .GT. 1) then
               sbvf=(9.80665/tmet(ig,jg,nl-1))
     1              *((tmet(ig,jg,nl)-tmet(ig,jg,nl-1))
     2              /(zgpt(nl)-zgpt(nl-1))+.0098)
               if(sbvf .GT. 0.) abvf(nl)=SQRT(sbvf)
            endif
         else
            abvf(nl)=dfault
         endif
      enddo

c  Set the B-V freq of the lowest layer equal to that in the adjacent
c  layer just above it (LCALGRD only)
      if(LCALGRD) abvf(1)=abvf(2)

      return
      end
c-----------------------------------------------------------------------
      subroutine getprfp(ssprf,tprf,zprf,nears,tempss,lcalgrd,
     &                   istab,dpbl,el,z0m,ptg,nzprf)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                 GETPRFP
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Passes vertical profiles of wind speed and the Brunt-
c               Vaisala Frequency into common for use by CTSG-related
c               routines. Uses PROFILE.DAT arrays. (METFM=4)
c
c --- UPDATE
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V4.0-V5.0     971107  (DGS): check PROBLEM returned by XTPRF
c
c ARGUMENTS:
c    PASSED:   ssprf    scalar wind speed profile (m/s)            [ra]
c               tprf    temperature profile (K)                    [ra]
c               zprf    heights of data levels above surface (m)   [ra]
c               nears   array for met station nearest grid pt.     [ia]
c               tempss  temperatures at surface stations           [ra]
c               lcalgrd indicates temp profile available (T)        [l]
c               istab   stability class                            [ia]
c               dpbl    Boundary layer depth (m)                    [r]
c               el      Monin-Obukhov length (m)                    [r]
c               z0m     surface roughness length (m)                [r]
c               ptg     default pot. temp gradient (K/m) for the   [ra]
c                       two stable classes (E,F)
c               nzprf   number of profile levels in vertical        [i]
c  RETURNED:    none
c
c CALLING ROUTINES:     COMP
c
c EXTERNAL ROUTINES:    NEARS
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

      real ssprf(mxprfz),tprf(mxprfz),zprf(mxprfz),t(mxprfz),
     1     tempss(mxss),ptg(2)
      integer nears(mxnx,mxny)
      logical lcalgrd,problem

c  Obtain met data at the grid-point nearest the center of the hill.
c  Because METFM=4 provides data at one location, draw fields from (1,1)
      ig=1
      jg=1

c  Surface met station nearest hill
      issta=nears(ig,jg)

c  BVF default is determined from stability class and near-surface T
      if(istab .LE. 4) then
         ptgrad=0.0
      elseif(istab .EQ. 5) then
         ptgrad=ptg(1)
      else
         ptgrad=ptg(2)
      endif
      dfault=SQRT(9.80665*ptgrad/tempss(issta))

c  Assign variables to common.  Note that the B-V frequency is set
c  to zero if the temperature structure in a layer is not stably
c  stratified.
      problem=.FALSE.
      nlev=nzprf
      do nl=1,nlev
         z(nl)=zprf(nl)
         call XTPRF(nzprf,ssprf,zprf,z(nl),'spd',z0m,el,
     &              dpbl,istab,ptg,ws(nl),problem)
         call XTPRF(nzprf,tprf,zprf,z(nl),'tmp',z0m,el,
     &              dpbl,istab,ptg,t(nl),problem)
         if(LCALGRD) then
            abvf(nl)=0.
            if(nl .GT. 1) then
               sbvf=(9.80665/t(nl-1))*((t(nl)-t(nl-1))
     &              /(zprf(nl)-zprf(nl-1))+.0098)
               if(sbvf .GT. 0.) abvf(nl)=SQRT(sbvf)
            endif
         else
            abvf(nl)=dfault
         endif
      enddo

c --- Results are invalid if XTPRF reported PROBLEM=TRUE
      if(PROBLEM) then
         write(io6,*) 'GETPRFP:  FATAL ERROR reported when ',
     &                'extracting temp from PROFILE ---'
         write(io6,*) 'There are no valid data'
         write(*,*)
         stop 'Halted in GETPRFP -- see list file.'
      endif

c  Set the B-V freq of the lowest layer equal to that in the adjacent
c  layer just above it (LCALGRD only)
      if(LCALGRD) abvf(1)=abvf(2)

      return
      end
c-----------------------------------------------------------------------
      subroutine hdun(ihill)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                    HDUN
c ---            D. Strimaitis, SRC
c
c --- UPDATES
c --- V5.2-V5.4    000602  (DGS): add message to "stop"
c --- V5.1-V5.2    991104  (JSS): Error messages written to list
c                                 file as well as to screen
c
c PURPOSE:      Compute dividing-streamline height (Hd) and U/N above Hd.
c               Note that Hd is height above the grid-plane (m).
c
c ARGUMENTS:
c    PASSED:    ihill           hill ID number                       [i]
c  RETURNED:    none
c
c CALLING ROUTINES:     (main)
c
c EXTERNAL ROUTINES:    none
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'
      real lhs(mxlev),rhs(mxlev)

c  Identify height of hill above the grid-plane elevation
      h=relief(ihill)

c  Treat case of a single layer first (Hd = H - U/N)
      if(nlev .EQ. 1) then
         if(abvf(1) .EQ. zero) then
            hda(ihill)=zero
            ubyna(ihill)=999.
            return
         else
            ubyna(ihill)=ws(1)/abvf(1)
            hda(ihill)=AMAX1(zero,h-ubyna(ihill))
            return
         endif
      endif

c  Initialize working arrays
      do nl=1,nlev
         lhs(nl)=0.0
         rhs(nl)=0.0
      enddo

c  Find the first level whose elevation exceeds the top of the hill
      do nl=nlev,1,-1
         if(z(nl) .GT. h) ilev=nl
      enddo

c  Set up array of left-hand-side values of eqn. for hd
c  and check for neutral/unstable lapse rates throughout profile,
c  or "zero" wind speeds
      bvfsum=zero
      sumlhs=0.0
      do nl=1,ilev-1
         lhs(nl)=half*ws(nl)*ws(nl)
         sumlhs=sumlhs+lhs(nl)
         bvfsum=bvfsum+abvf(nl+1)
      enddo
      sumlhs=sumlhs+lhs(ilev)
      if(bvfsum .LE. zero) then
         hda(ihill)=zero
         ubyna(ihill)=999.
         return
      elseif(sumlhs.LE.0.0) then
         hda(ihill)=h
         ubyna(ihill)=zero
         return
      endif

c  Set up array of right-hand-side values of eqn. for hd
      zm=half*(z(ilev-1)+h)
      rhs(ilev-1)=abvf(ilev)*abvf(ilev)*((h-zm)*
     &            (h-z(ilev-1)))

      do nl=ilev-2,1,-1
         zm=half*(z(nl+1)+z(nl))
         rhs(nl)=rhs(nl+1)+
     &           abvf(nl+1)*abvf(nl+1)*((h-zm)*(z(nl+1)-z(nl)))
      enddo

c  Identify top of layer that contains hd
      it=ilev
      do nl=ilev-1,1,-1
         if(lhs(nl) .GE. rhs(nl)) it=nl
      enddo

c  Compute hd
      ib=it-1
      if(ib.EQ.0) then
         b=ws(it)/z(it)
         a=zero
      else
         b=(ws(it)-ws(ib))/(z(it)-z(ib))
         a=ws(it)-b*z(it)
      endif
      b2=b*b
      bvf2=abvf(it)*abvf(it)

c  Top of the layer containing Hd is the lesser of z(it) and H
      TOP=AMIN1(h,z(it))
      qa=b2-bvf2
      qb=two*(a*b+bvf2*h)
      qc=a*a-two*rhs(it)-bvf2*TOP*(two*h-TOP)

      qb2=qb*qb
      qac4=4.*qa*qc
      if(qac4 .LE. qb2) then
         deter=SQRT(qb2-qac4)
         hda(ihill)=(-qb+deter)/(two*qa)
         hda(ihill)=AMAX1(one,hda(ihill))
      else
         write(io6,*)'HDUN: Fatal Problem - IMAGINARY SOLUTION'
         write(io6,*)'Hill Ht                    = ',h
         write(io6,*)'Top of layer containing Hd = ',top
         write(io6,*)'b^2, 4ac                   = ',qb2,qac4
         write(io6,*)'Profile of Speed and B-V Freq.'
         do i=1,nlev
            write(io6,*)'z, ws, |BVF| = ',z(i),ws(i),abvf(i)
            write(io6,*)'z, LHS, RHS  = ',z(i),lhs(i),rhs(i)
         enddo
         write(*,*)
         stop 'Halted in HDUN -- see list file.'
      endif

c  Compute weighted speed and Brunt-Vaisala freq above top of layer
      ubar=zero
      bvfbar=zero
      do nl=it+1,ilev
         wt=z(nl)-z(nl-1)
         ubar=ubar+half*(ws(nl)+ws(nl-1))*wt
         bvfbar=bvfbar+abvf(nl)*wt
      enddo

c  Add contribution from layer between hd and z(it)
      wt=z(it)-hda(ihill)
      ubar=ubar+half*(ws(it)+a+b*hda(ihill))*wt
      bvfbar=bvfbar+abvf(it)*wt

c  Compute U/N
      ubyna(ihill)=ubar/bvfbar

      return
      end
c-----------------------------------------------------------------------
      real function hilhgt(x,y)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                  HILHGT
c ---            R. Yamartino, SRC
c
C PURPOSE:      (adapted from CTDM)
C               COMPUTES THE FRACTIONAL HILL HEIGHT AT
C               THE POSITION (X,Y) FOR A ROTATED GAUSSIAN HILL.
C
C ARGUMENTS:
C    PASSED:    X,Y     LOCATION AT WHICH HEIGHT IS NEEDED  (M)      [r]
C
C CALLING ROUTINES: PATH
C
C EXTERNAL ROUTINES: NONE
C-----------------------------------------------------------------------

      INCLUDE 'flvar.puf'
C                                                                       HHT00260
C       DEFINE ARGUMENTS                                                HHT00270
      REAL      X, Y                                                    HHT00280
C                                                                       HHT00290
C       DEFINE LOCAL VARIABLES                                          HHT00300
      REAL      Q, XDLX, YDLY                                           HHT00310
C                                                                       HHT00320
      XDLX = X * LXI                                                    HHT00340
      YDLY = Y * LYI                                                    HHT00350
      Q = XDLX*XDLX + YDLY*YDLY + 2.0*GAM*X*Y                           HHT00360
C  NOTE THAT HILROT PROVIDES CROSSTERM GAM FOR A ROTATED HILL           HHT00370
      IF(Q .GT. 30.) Q = 30.                                            HHT00380
      HILHGT = EXP(-Q)                                                  HHT00390
C                                                                       HHT00400
      RETURN                                                            HHT00410
      END                                                               HHT00420
c-----------------------------------------------------------------------
      subroutine hilrot(ah,bh,psi)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                  HILROT
c ---            R. Yamartino, SRC
c
C PURPOSE:      (adapted from CTDM)
C     COMPUTES THE NEEDED LENGTH SCALES LX AND LY AND THE
C     FACTOR GAM FOR A GAUSSIAN HILL HAVING MAJOR AXIS AH, MINOR AXIS
C     BH, AND ROTATED CCW BY AN ANGLE PSI.
C     WHEN PSI=0 THE MINOR AXIS IS ORIENTED ALONG THE X-AXIS (OR FLOW
C     DIRECTION) AND THE MAJOR AXIS LIES ALONG THE Y-AXIS.
C
C ARGUMENTS:
C    PASSED:    AH,BH   MAJOR AND MINOR HILL SEMI-AXIS LENGTHS (M)   [r]
C               PSI     ANGLE OF ROTATION (RADIANS)                  [r]
C  RETURNED:    NONE
C
C CALLING ROUTINES: CTPAR
C
C EXTERNAL ROUTINES: NONE
C----------------------------------------------------------------------

      real lai2,lbi2
      INCLUDE 'flvar.puf'

C                                                                       HRT00370
      CPSI = COS(PSI)                                                   HRT00390
      CPSI2 = CPSI*CPSI                                                 HRT00400
      SPSI = SIN(PSI)                                                   HRT00410
      SPSI2 = SPSI*SPSI                                                 HRT00420
      LAI2 = 1.0 / (AH*AH)                                              HRT00430
      LBI2 = 1.0 / (BH*BH)                                              HRT00440
C                                                                       HRT00450
      GAM = (LBI2-LAI2)*CPSI*SPSI                                       HRT00460
      LXI2 = CPSI2*LBI2 + SPSI2*LAI2                                    HRT00470
      lxi=SQRT(lxi2)
      lx=1.0/lxi
      LYI2 = CPSI2*LAI2 + SPSI2*LBI2                                    HRT00490
      lyi=SQRT(lyi2)
      ly=1.0/lyi
      lyi3=lyi2*lyi
C                                                                       HRT00510
      RETURN                                                            HRT00520
      END                                                               HRT00530
C-----------------------------------------------------------------------
        subroutine inprec
C-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                  INPREC
c
c HISTORY: This subroutine is adapted from the CTDMPLUS model with
c          modifications to allow its use within CALPUFF.  Data needed
c          for CTSG are extracted from CTDM arrays.
c
C PURPOSE: THIS ROUTINE IS RESPONSIBLE FOR READING THE RECEPTOR DATA
C
C LIMITATIONS:
C       A MAXIMUM OF 'mxrect' RECEPTORS
C
C ARGUMENTS
c   PASSED:     none
c   Common block /PARAMS/ variables:
c               mxrect          maximum number of CTSG receptors     [r]
c   Common block /CTSGDAT/ variables:
c               xhill2m         convert user lengths to meters       [r]
c               zhill2m         convert user heights to meters       [r]
c               xctdmkm         x-origin(km) of CTDM in CALPUFF sys  [r]
c               yctdmkm         y-origin(km) of CTDM in CALPUFF sys  [r]
c               xmetct0m        x-origin(m) of CTDM from SW MET grid [r]
c               ymetct0m        y-origin(m) of CTDM from SW MET grid [r]
c
c   RETURNED:   none
c               (Data arrays are loaded into /CTPASS/ and /CTSGDAT/)
c   Common block /CTSGDAT/ variables:
c               ihill(mxrect)   Hill number associated with each    [ia]
c                               complex terrain receptor
c               elrect(mxrect)  Ground elevation (m MSL) of each    [ra]
c                               complex terrain receptor
c               nctrec          number of CTSG receptors             [i]
c   Common block /CTPASS/ variables:
c                xrctm(mxrect)  CTSG receptor coordinates in meters [ra]
c                yrctm(mxrect)  CTSG receptor coordinates in meters [ra]
c
C I/O:
C
C       LINE  VARIABLE  COLUMNS FORMAT  DESCRIPTION
C
C         1      NAME      1-16   A16   RECEPTOR NAME
C                   X     21-30   F10.0 X-COORD (USER HORIZONTAL UNITS)
C                   Y     31-40   F10.0 Y-COORD (USER HORIZONTAL UNITS)
C                  zZ     41-50   F10.0 HT ABOVE GROUND (USER VERTICAL
C                                               UNITS)
C                  GE     51-60   F10.0 GROUND ELEVATION (USER VERTICAL
C                                               UNITS)
C                  NH     61-65     I5  HILL NUMBER FOR THIS RECEPTOR
C
C
C CALLING ROUTINES: CTINIT
C
C-----------------------------------------------------------------------
C
      include   'params.puf'
      include   'ctpass.puf'
      include   'ctsgdat.puf'
C
C       DEFINE LOCAL VARIABLES
        REAL    X, Y, zZ, GE
        INTEGER NH, NR, NO, YES, FLAT
        CHARACTER*16    NAME
        DATA    NO/0/, YES/1/, FLAT/0/
C
        NR = 0
        NRFLAT = NO
c ---   'Use' nrflat (compiler warning)
        nrflat=nrflat
c
c  Set local i/o unit variables
        inrec=io29
        iout=io6
c  Write initial header to the list-file
        write(iout,5020)
        WRITE(IOUT,6000)

C       LOOP ON RECEPTOR INPUT LINES, TERMINATE ON EOF
100     CONTINUE
            READ(INREC, 1010, END=900) NAME,X,Y,zZ,GE,NH

C           RECEPTORS ON FLAT TERRAIN FLAG
            IF(NH .EQ. FLAT) then
               NRFLAT = YES
            else
               NR = NR + 1
               IF(NR .GT. mxrect) GO TO 991
               WRITE(IOUT, 6020) NR,NAME,X,Y,zZ,GE,NH
c ---          Set receptor data in /CTSGDAT/
               elrect(NR)=ge*zhill2m
               ihill(NR) = NH
c ---          Compute receptor location as meters in MET grid
c ---          for /CTPASS/
               xrctm(NR)=X*xhill2m + xmetct0m
               yrctm(NR)=Y*xhill2m + ymetct0m
            endif

        GO TO 100
C       END RECEPTOR INPUT LOOP
900     nctrec = NR
C       FOOTNOTE
        WRITE(IOUT,6030) xhill2m,zhill2m
        write(iout,6040) xctdmkm,yctdmkm
        write(iout,*)'   NOTE:  All receptors are placed on the ground!'
        RETURN
C
C       ERROR SECTION
C
991     WRITE(IOUT,9910) nr,mxrect
        write(*,*)
        stop 'Halted in INPREC -- see list file.'
C       FORMAT SECTION
1010    FORMAT(A16,4X,4F10.0,I5)
c
5020  format(1x,//'INFORMATION PROVIDED IN CTDM RECEPTOR FILE'//)
c
6000    FORMAT(/,27X,'      RECEPTOR INFORMATION',//,
     &  ' REC   IDENTIFICATION    EAST      NORTH  HEIGHT  ABOVE   ',
     &  'GRD LVL',/,
     &  ' NO.                     COORD     COORD  LOCAL GRD LVL  ',
     &  'ELEVATION     HILL',/,
     &  '                           (USER UNITS)    (USER UNITS) ',
     &  '(USER UNITS)  NUMBER',/,
     &  ' ---  ----------------  -------- -------- -------------  ',
     &  '----------   ------')
6010    FORMAT(' ')
6020    FORMAT(I4,2X,A16,1X,F9.2,F9.2,5X,F7.1,5X,F7.1,7X,I2)
6030    FORMAT(' ---------------------------------------------',/,
     1  '   MULTIPLY HORIZONTAL USER UNITS BY:',1PE10.3,' TO CONVERT ',
     2          'TO METERS',/,
     3  '   MULTIPLY VERTICAL USER UNITS BY:',1PE10.3,' TO CONVERT ',
     4          'TO METERS')
6040    FORMAT(/,
     1  '   ADD  ',1PE10.3,' KILOMETERS to reference X-Coordinate ',
     2          'to CALPUFF coordinate system',/,
     3  '   ADD  ',1PE10.3,' KILOMETERS to reference Y-Coordinate ',
     4          'to CALPUFF coordinate system')
9910    FORMAT(//' ***** RECEPTOR INPUT ERROR *****'/' INVALID ',
     1  ' NUMBER OF RECEPTORS FOUND   : nr     =',I4,/'         ',
     2  ' NUMBER OF RECEPTORS ALLOWED : mxrect =',I4)
        END
C-----------------------------------------------------------------------
        subroutine inpter
C-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                  INPTER
c
c HISTORY: This subroutine is taken from the CTDMPLUS model with few
c          modifications to allow its use within CALPUFF.  Data needed
c          for CTSG are extracted from CTDM arrays.
c
C PURPOSE: THIS ROUTINE IS RESPONSIBLE FOR READING THE TERRAIN
C          INFORMATION FOR EACH HILL.
C
C ASSUMPTIONS: THIS FIRST CONTOUR HEIGHT IS LESS THAN OR EQUAL TO THE
C               LOWEST STACK BASE ELEVATION
C
C LIMITATIONS:
C       A MAXIMUM OF 'MXHILL' HILLS
C       A MAXIMUM OF 'MXCNTR HEIGHTS FOR HILL SHAPE INFORMATION
C
C ARGUMENTS:
c   PASSED:     none
c   Common block /CTSGDAT/ variables:
c               xhill2m         convert user lengths to meters       [r]
c               zhill2m         convert user heights to meters       [r]
c               xctdmkm         x-origin(km) of CTDM in CALPUFF sys  [r]
c               yctdmkm         y-origin(km) of CTDM in CALPUFF sys  [r]
c               xmetct0m        x-origin(m) of CTDM from SW MET grid [r]
c               ymetct0m        y-origin(m) of CTDM from SW MET grid [r]
c               nhill           number of hills stated in input file [i]
c
c   RETURNED:   none
c               (Data arrays are loaded into /CTPASS/ and /CTSGDAT/)
c
C
C I/O:
C  INPUT: UNIT=INTERR
C
C       THE FOLLOWING INDICATE THE GROUP OF INPUT LINES EXPECTED
C       FOR EACH HILL.
C
C       LINE  VARIABLE  COLUMNS FORMAT  DESCRIPTION
C         1      NH        6- 7   I2    HILL NUMBER
C                                         FOR THIS RECEPTOR GROUP
C                NZ        9-10   I2    NUMBER OF HEIGHTS FOR WHICH
C                                         CONTOUR AND CUTOFF HILL SHAPE
C                                         INFORMATION IS GIVEN
C                HTP      21-30  F10.0  HEIGHT OF TOP OF HILL
C                                         ABOVE GRID ZERO, USER UNITS
C                HILNAM   41-80   A40   DESCRIPTION FOR THIS HILL
C
C       NEXT NZH LINES, ONE FOR EACH BEST-FIT ELLIPSE
C
C                  ZH      1-10  F10.0  ELEVATION OF BEST-FIT ELLIPSE,
C                                       USER COORDINATES
C                 XHW     11-20  F10.0  X-COORD (USER HORIZONTAL UNITS)
C                                       OF ELLIPSE CENTER
C                 YHW     21-30  F10.0  Y-COORD (USER HORIZONTAL UNITS)
C                                       OF ELLIPSE CENTER
C              MAJORW     31-40  F10.0  ORIENTATION OF MAJOR AXIS OF
C                                       ELLIPSE (DEGREES CLOCKWISE FROM
C                                       NORTH)
C              MAJAXW     41-50  F10.0  LENGTH OF MAJOR SEMIAXIS, USER
C                                       COORDINATES
C              MINAXW     51-60  F10.0  LENGTH OF MINOR SEMIAXIS, USER
C                                       COORDINATES
C
C       NEXT NZH LINES, ONE FOR EACH CUT-OFF HILL
C
C                  ZH      1-10  F10.0  ELEVATION OF BASE OF CUT-OFF
C                                       HILL, USER COORDINATES
C                 XHL     11-20  F10.0  X-COORD (USER HORIZONTAL UNITS)
C                                       OF CENTER OF CUT-OFF HILL
C                 YHL     21-30  F10.0  Y-COORD (USER HORIZONTAL UNITS)
C                                       OF CENTER OF CUT-OFF HILL
C              MAJORL     31-40  F10.0  ORIENTATION OF MAJOR AXIS OF
C                                       CUT-OFF HILL (DEGREES CLOCKWISE
C                                       FROM NORTH)
C              EXPOMA     41-50  F10.0  EXPONENT IN INVERSE POLYNOMIAL
C                                       FUNCTION FOR CUT-OFF HILL SHAPE
C                                       FOR MAJOR AXIS CROSS SECTION
C              EXPOMI     51-60  F10.0  EXPONENT IN INVERSE POLYNOMIAL
C                                       FUNCTION FOR CUT-OFF HILL SHAPE
C                                       FOR MINOR AXIS CROSS SECTION
C              SCALMA     61-70  F10.0  SCALE LENGTH IN INVERSE
C                                       POLYNOMIAL FUNCTION FOR CUT-OFF
C                                       HILL SHAPE FOR MAJOR AXIS CROSS
C                                       SECTION
C              SCALMI     71-80  F10.0  SCALE LENGTH IN INVERSE
C                                       POLYNOMIAL FUNCTION FOR CUT-OFF
C                                       HILL SHAPE FOR MINOR AXIS CROSS
C                                       SECTION
C
C
C       THIS GROUP OF INPUT LINES SHOULD BE REPEATED FOR EACH HILL.
C
C
C CALLING ROUTINES:  CTINIT
C
C EXTERNAL ROUTINES: none
C
C-----------------------------------------------------------------------
C
      include   'params.puf'
      include   'ctpass.puf'
      include   'ctsgdat.puf'
C
C       DEFINE LOCAL VARIABLES
        REAL    EL, HTP, SMALL
        INTEGER NH, NZ, I
C
        INTEGER         NHILLS, HILNAM(10,MXHILL)

        REAL            THS(MXHILL),
     *                  XHW(MXCNTR,MXHILL), YHW(MXCNTR,MXHILL),
     *                  MAJORW(MXCNTR,MXHILL),
     *                  XHL(MXCNTR,MXHILL), YHL(MXCNTR,MXHILL),
     *                  MAJORL(MXCNTR,MXHILL),
     *                  EXPOMA(MXCNTR,MXHILL), EXPOMI(MXCNTR,MXHILL),
     *                  SCALMA(MXCNTR,MXHILL), SCALMI(MXCNTR,MXHILL)

c      (CTPASS contains the remaining CTDM variables ---
c                       NZH(MXHILL), ZH(MXCNTR,MXHILL),
c                       MAJAXW(MXCNTR,MXHILL), MINAXW(MXCNTR,MXHILL)  )

C
        DATA    SMALL/0.00001/
C
        NHILLS = 0
c
c  Set local i/o unit variables
      interr=io28
      iout=io6
c  Write initial header to the list-file
      write(iout,5020)
C

c --- Add test for number of hills greater than MXHILL
100   if(nhills.EQ.mxhill) then
c ---   This read should find an end-of-file (and transfer to 500)
        READ( INTERR, 1010, ERR=500, END=500) NH
c ---   Oops... too many hills in this file
        nhills=nhills+1
        write(iout,1100) nhills,mxhill
1100    format(//,10x,'NUMBER OF HILLS = ',i4,
     1      '; EXCEEDS MAXIMUM ALLOWABLE (MXHILL) = ',i4)
        write(*,*)
        stop 'Halted in INPTER -- see list file.'
      else

        READ( INTERR, 1010, ERR=9000, END=500) NH, NZ, HTP,
     $                          (HILNAM(I,NHILLS+1),I=1,10)
1010    FORMAT(5X,I2,1X,I2,10X,F10.0,10X,10A4)
        NHILLS = NHILLS + 1
C       CHECK FOR OUT OF SEQUENCE
        IF( NH .NE. NHILLS ) THEN
            WRITE( IOUT, 1110) NHILLS, NH
1110    FORMAT(//,10X,'HILL NUMBER OF OUT SEQUENCE--',I2,' WAS ',
     1  'EXPECTED; ',I2,' WAS READ')
            write(*,*)
            stop 'Halted in INPTER -- see list file.'
        ENDIF
C       CHECK FOR ARRAY OUT OF BOUNDS
        IF( NZ .GT. mxcntr ) THEN
            WRITE(IOUT,1120) NZ,mxcntr
1120    FORMAT(//,10X,'NUMBER OF CONTOURS/CUT-OFF HILLS = ',I4,
     1      '; EXCEEDS MAXIMUM ALLOWABLE (MXCNTR) = ',i4)
            write(*,*)
            stop 'Halted in INPTER -- see list file.'
        ENDIF
C
        WRITE( IOUT, 6020 ) NH, (HILNAM(I,NH),I=1,10), HTP
        WRITE( IOUT, 6030 ) (HILNAM(I,NH),I=1,10)
      endif
C
C       READ VARIABLES FOR WRAP: ELLIPSE INFORMATION
C
        DO 200 I = 1,NZ
            READ(INTERR,1040,ERR=9000) ZH(I,nh),XHW(I,NH),YHW(I,NH),
     *                          MAJORW(I,NH),MAJAXW(I,NH),MINAXW(I,NH)
1040        FORMAT(6F10.0)
            WRITE(IOUT,6040) ZH(I,nh),XHW(I,NH),YHW(I,NH),MAJORW(I,NH),
     *                          MAJAXW(I,NH),MINAXW(I,NH)
200     CONTINUE
C
C       READ VARIABLES FOR LIFT: CUT-OFF HILL INFORMATION
C
        WRITE(IOUT,6050) (HILNAM(I,NH),I=1,10)
        DO 300 I = 1,NZ
            READ(INTERR,1050,ERR=9000) EL,XHL(I,NH),YHL(I,NH),MAJORL(I,
     1          NH),EXPOMA(I,NH),EXPOMI(I,NH),SCALMA(I,NH),SCALMI(I,NH)
1050        FORMAT(8F10.0)
            IF(ABS(EL-ZH(I,nh)).GT.SMALL) THEN
                WRITE(IOUT,1140) I,EL,I,ZH(I,nh)
1140            FORMAT(//,10X,'CUT-OFF HILL BASE # ',I2,' = ',F7.2,
     *                  '; DOES NOT AGREE WITH THE CORRESPONDING ',
     *                  'CONTOUR # ',I2,' HEIGHT OF ',F7.2)
                write(*,*)
                stop 'Halted in INPTER -- see list file.'
            ENDIF
            WRITE(IOUT,6060) EL,XHL(I,NH),YHL(I,NH),MAJORL(I,NH),
     *                          EXPOMA(I,NH),EXPOMI(I,NH),
     *                          SCALMA(I,NH),SCALMI(I,NH)
300     CONTINUE
C
C       CONVERT TO METERS USING xhill2m AND zhill2m, and shift origin
c       to place hill in CALPUFF MET GRID system
C
        NZH(NH) = NZ
        THS(NH) = HTP * zhill2m
        DO 400 I = 1,NZ
            ZH(I,NH) = ZH(I,NH) * zhill2m
            XHW(I,NH) = XHW(I,NH) * xhill2m + xmetct0m
            YHW(I,NH) = YHW(I,NH) * xhill2m + ymetct0m
            XHL(I,NH) = XHL(I,NH) * xhill2m + xmetct0m
            YHL(I,NH) = YHL(I,NH) * xhill2m + ymetct0m
            MAJAXW(I,NH) = MAJAXW(I,NH) * xhill2m
            MINAXW(I,NH) = MINAXW(I,NH) * xhill2m
            SCALMA(I,NH) = SCALMA(I,NH) * xhill2m
            SCALMI(I,NH) = SCALMI(I,NH) * xhill2m
400     CONTINUE
C       READ NEXT HILL INFO
        GO TO 100
C       END OF TERRAIN INPUT
500     CONTINUE
        WRITE(IOUT,6100) xhill2m,zhill2m
        write(iout,6110) xctdmkm,yctdmkm
        WRITE (IOUT,6091)
C

c --- CTSG Section for "LIFT" description ---
c  Transfer hill information to common/CTPASS/.  Note that the hill
c  description parameters for the polynomial hill are those for the
c  entire hill.  The ellipse information selected later for the flow
c  below Hd will depend on the hourly value of the dividing streamline.
c  The array index for the contour at the base of the hill is found
c  by calling KLOSE with a third argument equal to zero.

c --- Set the number of hills (in /CTSGDAT/) to that found(nhills)
      nhill=nhills

      do i=1,nhill
         klow=KLOSE(zh(1,i),nzh(i),zero)
         if(klow .EQ. 0) klow=1
         xc(i)=xhl(klow,i)
         yc(i)=yhl(klow,i)
         thetah(i)=majorl(klow,i)
         expo(1,i)=expoma(klow,i)
         expo(2,i)=expomi(klow,i)
         scale(1,i)=scalma(klow,i)
         scale(2,i)=scalmi(klow,i)
         axmax(1,i)=1000.*scale(1,i)
         axmax(2,i)=1000.*scale(1,i)
c ---    Set zgrid equal to the base contour elevation
         zgrid(i)=zh(klow,i)
c ---    Change height reference from m (MSL) to m above hill base
         relief(i)=ths(i)-zgrid(i)
c
c ---    Swap selected data to arrays in Subgroup 6b from input file
         hilldat(3,i) = thetah(i)
         hilldat(4,i) = zgrid(i)
         hilldat(5,i) = relief(i)
         hilldat(6,i) = expo(1,i)
         hilldat(7,i) = expo(2,i)
         hilldat(8,i) = scale(1,i)
         hilldat(9,i) = scale(2,i)
         hilldat(10,i) = axmax(1,i)
         hilldat(11,i) = axmax(2,i)
c
      enddo
c  Note that axmax is set to a number that is large compared to the
c  scale of the major axis of the hill (scale(1,i)).  This makes the
c  specification of the inverse polynomial hill consistent between
c  the CTDM and the CTSG formulations.

        RETURN
C
C       TERMINAL ERROR
9000    WRITE(IOUT,9005)
9005    FORMAT(//,10X,'ERROR IN DATA READ IN HILL INPUT')
        GO TO 9999
9999    write(*,*)
        stop 'Halted in INPTER -- see list file.'
c
5020  format(1x,//'INFORMATION PROVIDED IN THE CTDM HILL FILE'//)
C
6020    FORMAT(/' HILL #',I2,'  ',10A4,'HILL TOP:',F7.1,
     *          ' (USER UNITS)')
6030    FORMAT(/' BEST FIT ELLIPSE INFORMATION FOR WRAP: ',10A4,/
     *  '  CONTOUR  X-COORD   Y-COORD   MAJOR  AXIS   ELLIPSE AXIS ',
     *  'LENGTHS',/,
     *  '   HEIGHT    (HILL CENTER)     AZIM. FROM N    MAJOR      ',
     *  'MINOR',/,
     *  '  -------  --------  --------  ------------  --------   ',
     *  '--------')
6040    FORMAT(F9.1,2F10.3,F11.1,2X,2F11.3)
6050    FORMAT(/' Hc CUT-OFF HILL INFORMATION FOR LIFT:  ',10A4,/,
     *  '  CONTOUR  X-COORD  Y-COORD  MAJOR  AXIS  <--- INVERSE ',
     *  'POLYNOMIAL VARIABLES --->',/,
     *  '   HEIGHT    (HILL CENTER)  AZIM. FROM N  MAJ EXP MIN EXP   ',
     *  'MAJ SCALE  MIN SCALE',/,
     *  '  -------  -------- ------- ------------  ------- -------   ',
     *  '---------  ---------')
6060    FORMAT(F9.1,F10.3,F9.3,F10.1,F11.3,F8.3,F12.3,F11.3)
6091    FORMAT(/)
6100    FORMAT(' ---------------------------------------------',/,
     1  '   MULTIPLY HORIZONTAL USER UNITS BY:',1PE10.3,' TO CONVERT ',
     2          'TO METERS',/,
     3  '   MULTIPLY VERTICAL USER UNITS BY:',1PE10.3,' TO CONVERT ',
     4          'TO METERS')
6110    FORMAT(/,
     1  '   ADD  ',1PE10.3,' KILOMETERS to reference X-Coordinate ',
     2          'to CALPUFF coordinate system',/,
     3  '   ADD  ',1PE10.3,' KILOMETERS to reference Y-Coordinate ',
     4          'to CALPUFF coordinate system')
        END
c-----------------------------------------------------------------------
      integer function ireg(x,x12,x23)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                    IREG
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Determines position of a point relative to boundaries
c               of the CTSG modeling regions.
c
c ARGUMENTS:
c    PASSED:    x       position (coordinate normal to regions)      [r]
c               x12     boundary upwind of hill                      [r]
c               x23     boundary downwind of hill                    [r]
c  RETURNED:    ireg    region (1, 2, or 3)                          [i]
c
c CALLING ROUTINES:     CTREC, CTPAR
c
c EXTERNAL ROUTINES:    none
c-----------------------------------------------------------------------

      ireg=2
      if(x .LT. x12) then
         ireg=1
      elseif(x .GT. x23) then
         ireg=3
      endif
      return
      end
c-----------------------------------------------------------------------
      integer function klose(XA,NA,X)
C-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940831                   KLOSE
c ---            Adopted from CTDMPLUS without modification
c
C PURPOSE: THIS FUNCTION RETURNS THE POSITION OF THE DATA VALUE IN ARRAY
C               XA WHICH IS NEAREST TO THE VALUE X BUT LESS THAN X
C
C ASSUMPTIONS:
C       ARRAY XA IS SORTED IN ASCENDING ORDER
C
C LIMITATIONS:  IF XA ARE ALL > X, SET KLOSE = 0
C
C ARGUMENTS
C  PASSED:
C       XA      REAL    ARRAY OF VALUES TO BE SEARCHED
C       NA      INT     DIMENSION OF XA
C       X       REAL    VALUE TO BE SEARCHED FOR
C  RETURNED FUNCTION VALUE:
C       KLOSE   INT     ARRAY SUBSCRIPT OF NEAREST VALUE TO X
C
C I/O: NONE
C
C CALLING ROUTINES: INPTER, CTPAR
C
C EXTERNAL ROUTINES: NONE
C
C INTRINSIC FUNCTIONS: ABS
C
C COMMON BLOCKS: NONE
C
C-----------------------------------------------------------------------
C
C       DEFINE ARGUMENTS
        INTEGER NA
        REAL    XA(NA), X
C
C       IF NO XA VALUES ARE LESS THAN X, SET KLOSE = 0
C
        IF( XA(1) .GT. X ) THEN
                KLOSE = 0
        ELSE IF( XA(1) .EQ. X ) THEN
                KLOSE = 1
        ELSE
                DO  10  KLOSE = NA, 1, -1
                        IF( XA(KLOSE) .LT. X ) RETURN
10              CONTINUE
        ENDIF
        RETURN
        END
c-----------------------------------------------------------------------
      subroutine lower(c)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                   LOWER
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes concentrations due to puff material in lower
c               segment of the flow (below Hd).
c
c ARGUMENTS:
c    PASSED:    none
c  RETURNED:    c               concentration  (g/m**3)              [r]
c
c CALLING ROUTINES:     CTSG
c
c EXTERNAL ROUTINES:    MUNU, SIGMA, ERF
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

c  Initialize concentration that is returned
      c=zero

c  Determine if puff travels along the same or opposite side of the hill
c       from the receptor
      call MUNU(1,xre*baxi,yre*baxi,r,rmu,rnu)
      side=SIGN(one,SIN(rnu+alfw))

c  Compute the age of puff at the receptor (tup)
      tup=timpg+t12rl

c  If the age of the puff at the receptor is not positive, concentration
c  is zero!
      if(tup .LE. 0.) return

c  Set receptor-specific sigmas; note that these sigmas are constrained
c  by the puff-sigmas at the start and end of the step
c  Receptor may be shifted below Hd, so compute estimate here
c     sz=szr
c     sy=syr
c old sz=SIGMA(tup,sz1,tstart,sz2,tstep,szr,frac)
      sz=SIGMA(2,zpuff,u,tup,sz1,tstart,sz2,tstep,szr,frac)
      sz=AMAX1(sz1,sz)
      sz=AMIN1(sz2,sz)
c old sy=SIGMA(tup,sy1,tstart,sy2,tstep,syr,frac)
      sy=SIGMA(1,zpuff,u,tup,sy1,tstart,sy2,tstep,syr,frac)
      sy=AMAX1(sy1,sy)
      sy=AMIN1(sy2,sy)
      szsq=sz*sz
      sysq=sy*sy
c  Assign sigmas at the impingement point
      szo=szimpg
      szosq=szo*szo
      syo=syimpg
      syosq=syo*syo
c  Compute sigma-prime squared (both y and z)
      szpsq=szsq-szosq
      sypsq=sysq-syosq
c  Reset impingement sigmas if they exceed receptor-specific values --
c  this turns off hill-effects as the puff has not yet reached the hill
      if(szpsq.LE.zero) then
         szo=sz
         szosq=szsq
         szpsq=zero
         szp=zero
      else
         szp=SQRT(szpsq)
      endif
      if(sypsq.LE.zero) then
         syo=sy
         syosq=sysq
         sypsq=zero
         syp=zero
      else
         syp=SQRT(sypsq)
      endif

c  Puff is mixed in the vertical if sigmaz upwind of the hill (szo)
c  exceeds 1.6 times the mixing height (zmix).  Set mixing flag to 1.
      imix=0
      if(szo .GE. 1.6*zlid) imix=1

c  Compute the concentration on the trajectory ("centerline")
      t1mtr=-(t12p+t12rl)
      t2mtr=tstep+t1mtr
      dum=u/(rt2*sy)
      co=q*(ERF(t2mtr*dum)-ERF(t1mtr*dum))/(tstep*four*pi*u*sy*sz)
      if(co.LE.zero) return

c  Compute the horizontal distribution factor
      argy1=half*(d*d/sysq)
      if(argy1 .LT. expmax) then
         argy2=(d*syp)/(rt2*syo*sy)
         fy=EXP(-argy1)*(one+side*ERF(argy2))

c  Compute the vertical distribution factor
c  - If puff is mixed in the vertical, set fz to rt2pi*sz/zlid and
c    calculate concentration.
         if(imix .EQ. 1) then
            fz=rt2pi*sz/zlid
            c=co*fy*fz
            return
         endif
         twofz=zero
         if(szp .GT. small) then
            ak=one/(rt2*sz*szo*szp)
            b1=hd*szsq
c  - First term (no reflections from mixing lid); i=1, j=1:
            ejp=zrec
            eoip=zpuff
            call BJIL(ak,b1,ejp,eoip,bj)
            twofz=bj
c  - Skip reflections when contribution without reflections is zero
            if(twofz .EQ. zero) goto 501
c  - Reflections just from lid upwind of hill; j=1, i>1:
            ejp=zrec
            do 100, i=2,mxrefl
               eoip=two*(i-1)*zlid+zpuff
               eoim=eoip-two*zpuff
               call BJIL(ak,b1,ejp,eoip,bjp)
               call BJIL(ak,b1,ejp,eoim,bjm)
               add=bjp+bjm
               twofz=twofz+add
               if(add/twofz .LT. epsrefl) goto 101
100         continue
c  - Reflections just from lid over and downwind of hill; i=1, j>1:
101         eoip=zpuff
            do 200, j=2,mxrefl
               ejp=two*(j-1)*zlid+zrec
               ejm=ejp-two*zrec
               call BJIL(ak,b1,ejp,eoip,bjp)
               call BJIL(ak,b1,ejm,eoip,bjm)
               add=bjp+bjm
               twofz=twofz+add
               if(add/twofz .LT. epsrefl) goto 201
200         continue
c  - Reflections throughout; i>1, j>1:
c  - Loop on i>1:
201         do 400 i=2,mxrefl
               eoip=two*(i-1)*zlid+zpuff
               eoim=eoip-two*zpuff
c  - Loop on j>1:
               do 300 j=1,mxrefl
                  ejp=two*(j-1)*zlid+zrec
                  ejm=ejp-two*zrec
                  call BJIL(ak,b1,ejp,eoip,bjpp)
                  call BJIL(ak,b1,ejm,eoip,bjmp)
                  call BJIL(ak,b1,ejp,eoim,bjpm)
                  call BJIL(ak,b1,ejm,eoim,bjmm)
                  add=bjpp+bjmp+bjpm+bjmm
                  twofz=twofz+add
                  if(add/twofz .LT. epsrefl) then
                     if(j .GT. 1) goto 400
                     goto 501
                  endif
300            continue
400         continue
         else
c  - Sigma-z is not growing, szp is very small and equations simplify
c  - Only j=1 terms contribute (no reflection from lid over hill)
c  - 2Fz is zero for all receptors above Hd
            if(zrec .LE. hd) then
               ak=half/szsq
               ejp=zrec
               eoip=zpuff
               eoipmj=eoip-ejp
               eoippj=eoip+ejp
               call BI(ak,eoipmj,eoippj,twofz)
               if(twofz.EQ.zero) goto 501
c  - Reflections from lid upwind of hill; i>1:
               do 500 i=2,mxrefl
                  eoip=two*(i-1)*zlid+zpuff
                  eoim=eoip-two*zpuff
                  eoipmj=eoip-ejp
                  eoippj=eoip+ejp
                  eoimmj=eoim-ejp
                  eoimpj=eoim+ejp
                  call BI(ak,eoipmj,eoippj,bip)
                  call BI(ak,eoimmj,eoimpj,bim)
                  add=bip+bim
                  twofz=twofz+add
                  if(add/twofz .LE. epsrefl) goto 501
500            continue
            endif
         endif

501      fz=half*twofz

c  Compute concentration
         c=co*fy*fz
      endif
c
      if(ldb) then
         write(idebug,*)
         write(idebug,*)'LOWER: co,fy,fz =',co,fy,fz
         write(idebug,*)'(START) syo,szo =',syimpg,szimpg
         write(idebug,*)'(USED)  syo,szo =',syo,szo
         write(idebug,*)'(START) syr,szr =',syr,szr
         write(idebug,*)'(USED)  syr,szr =',sy,sz
         write(idebug,*)'       co,fy,fz =',co,fy,fz
         write(idebug,*)'t12p,t12rl,tstep=',t12p,t12rl,tstep
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine munu(muflag,xbi,ybi,r,mu,nu)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 910620                   MUNU
c ---            D. Strimaitis, SRC
c
c  PURPOSE:     Computes the elliptical coordinates of a point that is
c               referenced to the system centered on the ellipse, with
c               x-axis along the major axis.
c
c  ARGUMENTS:
c     PASSED:   muflag          flag signalling no mu calculation    [i]
c                               (1: do not calculate mu)
c               (xbi,ybi)       scaled coord (x/bax,y/bax)           [r]
c               r               ratio of axes aax/bax                [r]
c   RETURNED:   (mu,nu)         elliptical coordinates               [r]
c
c  CALLING ROUTINES:    CTPAR, LOWER
c
c  EXTERNAL ROUTINES:   none
c----------------------------------------------------------------------

      INCLUDE 'const.puf'
      real mu,nu
c
      absx=ABS(xbi)
      absy=ABS(ybi)
      xsq=xbi*xbi
      ysq=ybi*ybi

c  If point lies very near an axis, place it on the axis
      if(absx .LT. small) then
         xbi=zero
         absx=zero
      endif
      if(absy .LT. small) then
         ybi=zero
         absy=zero
      endif

c  If axes are nearly equal, treat hill as a symmetric hill
      rsq=r*r
      rp1=r+one
      rsqm1=rsq-one
      if(rsqm1 .LT. small) then
         rsqm1=zero
         rp1=two
      endif

      rdsq=xsq+ysq
c     rd=SQRT(rdsq)

c  ---- Compute nu -----------

c  Special cases
      if(xbi .EQ. zero) then
         nu=piby2
         if(ybi .LT. zero) nu=three*piby2
      elseif(ybi .EQ. zero) then
         nu=zero
         if(xbi .LT. zero) nu=pi
      elseif(rsqm1 .EQ. zero) then
         nu=ATAN2(ybi,xbi)
      else
c  General case
         capb=rdsq/rsqm1-one
         ac=-ybi*ybi/rsqm1
         twoa=two
         snusq=(-capb+SQRT(capb*capb-four*ac))/twoa
         if(snusq .LT. small) then
            nu=zero
         else
            arg=SQRT(snusq)
            if((one-arg) .LT. zero) arg=one
            nu=ASIN(arg)
            if(xbi .LT. zero) nu=pi-nu
            if(ybi .LT. zero) nu=-nu
         endif
      endif
      cosnu=COS(nu)
      sinnu=SIN(nu)

      if(muflag .NE. 1) then

c  ---- Compute mu -----------

c  Special cases
         if(ybi .EQ. zero .AND. xbi .EQ. zero) then
            mu=zero
         elseif(abs(sinnu) .LE. small) then
            mu=ALOG((absx+SQRT(xsq-rsqm1))/rp1)
         elseif(abs(cosnu) .LE. small) then
            mu=ALOG((absy+SQRT(ysq+rsqm1))/rp1)
         else
c  General case
            mu=ALOG((xbi/cosnu+ybi/sinnu)/rp1)
         endif
      else
         mu=0.
      endif

      return
      end
C-----------------------------------------------------------------------
      subroutine path(th,tl,tu,x,yi,zi,delx,y3,z3)
C-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                    PATH
c ---            D. Strimaitis, SRC
c
C PURPOSE:     (adapted from CTDM)
C     COMPUTES THE POSITION OF THE STREAMLINE THAT PASSES THROUGH THE
C     POINT AT (-INFINITY,YI,ZI) FOR ANY X ASSUMING A GAUSSIAN HILL
C     FUNCTION H(a,b)=HH*EXP(-(a/AH)**2-(b/BH)**2).  LOCAL DEFORMATION
C     FACTORS Th,Tl,Tu ARE COMPUTED AT (X,Y,Z).
C     NOTE THAT THE X-AXIS IS ALIGNED WITH THE INCIDENT FLOW.
C
C     MODIFICATION:  A root solver from the SLATEC package is called if
C                    the simple linear iteration is slow or fails
C
C ARGUMENTS:
C    PASSED:    X               DISTANCE ALONG FLOW AT WHICH         [r]
C                               STREAMLINE COORDINATES ARE FOUND (M)
C               YI,ZI           STREAMLINE COORD. FAR FROM HILL (M)  [r]
C               DELX            INCREMENT FOR STREAMLINE TRACE (M)   [r]
C  RETURNED:    TH,TL,TU        LOCAL DEFORMATION OR STRAIN FACTORS  [r]
C               Y3,Z3           STREAMLINE COORD. AT X (M)           [r]
C
C CALLING ROUTINES:     CTPAR
C
C EXTERNAL ROUTINES:    FLOPUFF, HILHGT
c                       PATH0, XSTF, SNSQE, R1MACH
C-----------------------------------------------------------------------
C
      INCLUDE 'const.puf'
      INCLUDE 'flvar.puf'

c --- Local common to pass current 'constants' from PATH to PATH0
      common /flvar2/ xx,yyi,zzi
c         xx:  along-flow coordinate where streamline is sampled
c        yyi:  lateral position of streamline far from hill
c        zzi:  vertical position of streamline far from hill

c --- Set up variables for root solver
      real yz(2),fvec(2),wa(20)
      real xgd(2),ygd(2),zgd(2)
      external PATH0
      data ijac/2/, ndim/2/, nprint/6/, lwa/20/
c     - ijac=2      compute Jacobian internally
c     - ndim=2      number of dimensions
c     - nprint=6
c     - lwa=20      dimension for work array  (wa)
c                   lwa=1+(3*ndim*ndim+13*ndim)/2
c --- Set TOL to the square root of the machine precision.
      tol=SQRT(R1MACH(4))
      xx=x
      yyi=yi
      zzi=zi

c --- Set up variables for linear solver
      DATA CRIT/0.005/                                                  PTH00380
      DSMALL=.01*HH                                                     PTH00390
      YSTEP=0.5*LY                                                      PTH00400
      ZSTEP=0.5*HH                                                      PTH00410
      NITER=0                                                           PTH00580
      mxiter=4

c --- Save values from last call
      zlast=z3
      ylast=y3

c --- Use original position and the values from last call to path for
c --- for the 2 initial guesses for the linear iteration
      y1=y3
      z1=z3
      y2=yi
      z2=zi
      if(y1 .EQ. y2) y2=dsmall+y2
      if(z1 .EQ. z2) z2=dsmall+z2
      if(z1.LT.zero) z1=zero
      if(z2.LT.zero) z2=zero

C *** COMPUTE THE STREAMLINE DEFLECTIONS FOR THE FIRST GUESSES          PTH00500
C       ETA IS THE VERTICAL DEFLECTION, DEL IS THE LATERAL DEFLECTION   PTH00510
C       H1 IS ELEVATION OF SURFACE BENEATH THE FIRST-GUESS POSITION     PTH00520
C       H2 IS ELEVATION OF SURFACE BENEATH THE SECOND-GUESS POSITION    PTH00530
      CALL FLOPUFF(X,Y1,Z1,ETA1,DEL1,THI,TLI,TU)                        PTH00540
      H1=HH*HILHGT(X,Y1)                                                PTH00550
      CALL FLOPUFF(X,Y2,Z2,ETA2,DEL2,THI,TLI,TU)                        PTH00560
      H2=HH*HILHGT(X,Y2)                                                PTH00570

c --- Compute the scaled errors
      er1=ABS((y1-del1-yi)/ly)+ABS((z1+h1-eta1-zi)/hh)
      er2=ABS((y2-del2-yi)/ly)+ABS((z2+h2-eta2-zi)/hh)

C                                                                       PTH00620
C *** ITERATE UNTIL THE STREAMLINE IS FOUND TO WITHIN CRIT * HH         PTH00630
C *** NEW GUESS                                                         PTH00640
C                                                                       PTH00650
c ---------------------------------------------------
c --- Section for call to linear solver
c ---------------------------------------------------
c --- Compute new estimate: y3,z3
10    DENY=Y1-Y2+DEL2-DEL1                                              PTH00660
      if(ABS(y2-y1) .LE. small .OR. ABS(deny) .LT. small) then
c ---    Go right to non-linear root solver
         goto 40
      ELSE                                                              PTH00690
         Y3=(Y1*(YI+DEL2)-Y2*(YI+DEL1))/DENY                            PTH00700
c *** RESTRICT RATE OF CHANGE OF POSITION ESTIMATE                      PTH00710
         STEP=Y3-Y2                                                     PTH00720
         IF(ABS(STEP) .GT. YSTEP) Y3=Y2+SIGN(YSTEP,STEP)                PTH00730
      ENDIF                                                             PTH00740
      DENZ=Z1+H1-ETA1+ETA2-Z2-H2                                        PTH00750
      if(ABS(z2-z1) .LE. small .OR. ABS(denz) .LT. small) then
c ---    Go right to non-linear root solver
         goto 40
      ELSE                                                              PTH00780
         Z3=(Z1*(ZI+ETA2-H2)-Z2*(ZI+ETA1-H1))/DENZ                      PTH00790
c --- Do not allow a streamline height below surface of hill
         z3=AMAX1(zero,z3)
C *** RESTRICT RATE OF CHANGE OF POSITION ESTIMATE                      PTH00800
         STEP=Z3-Z2                                                     PTH00810
         IF(ABS(STEP) .GT. ZSTEP) Z3=Z2+SIGN(ZSTEP,STEP)                PTH00820
      ENDIF                                                             PTH00830
      NITER=NITER+1                                                     PTH00840
C                                                                       PTH00880
C     COMPUTE QUANTITIES NOW FOR THE NEW GUESS.                         PTH00970
      CALL FLOPUFF(X,Y3,Z3,ETA3,DEL3,THI,TLI,TU)                        PTH00980
      H3=HH*HILHGT(X,Y3)                                                PTH00990
C *** COMPUTE THE ERROR IN THE SOLUTION SCALED BY HH                    PTH01000
      ERRY=ABS((Y3-DEL3-YI)/LY)                                         PTH01010
      ERRZ=ABS((Z3+H3-ETA3-ZI)/HH)                                      PTH01020
C                                                                       PTH01030
C *** QUIT IF ERROR CRITERIA SATISFIED.                                 PTH01040
      IF(ERRY .LT. CRIT .AND. ERRZ .LT. CRIT) GO TO 50                  PTH01050

c --- Update last estimate (keep previous best estimate in '1')
      if(er1.GT.er2) then
      Y1=Y2                                                             PTH01060
      Z1=Z2                                                             PTH01070
      H1=H2                                                             PTH01080
      ETA1=ETA2                                                         PTH01090
      DEL1=DEL2                                                         PTH01100
      endif

      Y2=Y3                                                             PTH01110
      Z2=Z3                                                             PTH01120
      H2=H3                                                             PTH01130
      ETA2=ETA3                                                         PTH01140
      DEL2=DEL3                                                         PTH01150
      er2=errz+erry

c --- Quit linear iteration approach if convergence is too slow
      if(niter.GT.mxiter) goto 40
      GO TO 10                                                          PTH01160
                                                                        PTH01170
40    continue
c ----------------------------------------------------
c --- Section for call to non-linear root solver SNSQE
c ----------------------------------------------------
c --- Set control variable to allow recovery from convergence errors
      call XSETF(0)
c --- Pass last value of (y,z) to solver as first guess; could use
c --- best result from linear solver, but this could pose problem
c --- since method failed
      yz(1)=ylast
      yz(2)=zlast
      call SNSQE(path0,jac,ijac,ndim,yz,fvec,tol,nprint,info,wa,lwa)

c --- Transfer solution to output variables, and call FLOPUFF again
c --- to obtain deflections and strain data
      y3=yz(1)
      z3=yz(2)
      call flopuff(x,y3,z3,eta3,del3,thi,tli,tu)
      h3=hh*hilhgt(x,y3)

c --- Interrogate INFO to see if this solution is valid
      if(info.EQ.2 .OR. info.EQ.4) then
c ---    PROBLEM!  Test against convergence criteria above
         yii=y3-del3
         zii=z3-eta3+h3
         erry=ABS((yii-yi)/ly)
         errz=ABS((zii-zi)/hh)
         if(erry.GT.crit .OR. errz.GT.crit) then
c ---       Recovery for failed procedure:
c ---       Search for 2 "good" points in the vicinity of x, and
c ---       interpolate y,z at x.
c ---       Shift x in increments of .1 DELX (10% of the increment
c ---       used to map streamline along the flow)
            delshft=0.1*delx
            ngood=0
c ---       First, get 1 point further downwind (search out to 3 DELX)
            do ishft=1,30
               shft=ishft*delshft
               xx=x+shft
               yz(1)=ylast
               yz(2)=zlast
               call SNSQE(path0,jac,ijac,ndim,yz,fvec,tol,nprint,
     &                    info,wa,lwa)
               if(info.EQ.1) then
                  ngood=ngood+1
                  xgd(ngood)=xx
                  ygd(ngood)=yz(1)
                  zgd(ngood)=yz(2)
                  if(ngood.EQ.1) goto 45
               endif
            enddo
c ---       Now, get needed points further upwind (up to 3 DELX)
45          do ishft=1,30
               shft=ishft*delshft
               xx=x-shft
               yz(1)=ylast
               yz(2)=zlast
               call SNSQE(path0,jac,ijac,ndim,yz,fvec,tol,nprint,
     &                    info,wa,lwa)
               if(info.EQ.1) then
                  ngood=ngood+1
                  xgd(ngood)=xx
                  ygd(ngood)=yz(1)
                  zgd(ngood)=yz(2)
                  if(ngood.EQ.2) goto 46
               endif
            enddo
c ---       Code should not reach this point!!
            write(*,*)
            stop 'PATH: convergence procedures failed'

c ---       Interpolate from nearest 2 points along streamline
46          xfac=(x-xgd(1))/(xgd(1)-xgd(2))
            y3=ygd(1)+(ygd(1)-ygd(2))*xfac
            z3=zgd(1)+(zgd(1)-zgd(2))*xfac
c ---       Call FLOPUFF again to obtain deflections and strain data
            call flopuff(x,y3,z3,eta3,del3,thi,tli,tu)
            h3=hh*hilhgt(x,y3)
         endif
      endif

   50 CONTINUE                                                          PTH01180
C                                                                       PTH01200
C *** COMPUTE T-FACTORS: IN MOST CASES, TL IS A RESIDUAL                PTH01210
C                                                                       PTH01220
      TH=1./THI                                                         PTH01230
      TL=THI/TU                                                         PTH01240
C                                                                       PTH01250
C     IF A LONG RIDGE, CONSIDER CALCULATED VALUE OF TL.  IF ASPECT RATIOPTH01260
C     IS 3 OR LESS, KEEP TL AS A RESIDUAL.  IF ASPECT RATIO EXCEEDS 3,  PTH01270
C     USE A COMBINATION OF RESIDUAL VALUE AND CALCULATED VALUE AS A     PTH01280
C     FUNCTION OF ASPECT RATIO                                          PTH01290
C                                                                       PTH01300
      ASPECT = LY/LX                                                    PTH01310
      IF(ASPECT.GT.3.0 .AND. ABS(1.0 - TLI) .LT. 0.1) THEN              PTH01320
          TLRES = TL                                                    PTH01330
          TLCALC = 1.0/TLI                                              PTH01340
          WEIGHT = ((ASPECT - 3.0)/ASPECT) ** 0.25                      PTH01350
          TL = TLCALC * WEIGHT + TLRES * (1.0 - WEIGHT)                 PTH01360
          TU = THI/TL                                                   PTH01370
      ENDIF                                                             PTH01380
      RETURN                                                            PTH01390
      END                                                               PTH01400
c-----------------------------------------------------------------------
      subroutine path0(n,yz,fvec,iflag)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980430                   PATH0
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes difference between actual upstream location
c               of streamline in the y-z plane, and corresponding
c               position of approximated streamline.  When the right
c               estimate of (y,z) at a given x is chosen (this is the
c               vector yz), the difference between the location of the
c               actual streamline and the estimated streamline is zero.
c
c --- UPDATE
c --- V5.0-V5.0     980430  (DGS): assign iflag (compiler warning)
c
c ARGUMENTS:
c   PASSED:     n       number of elements in input vector (yz)      [i]
c               yz      (y,z) guess for streamline location at x    [ra]
c               iflag   control flag for SNSQ (not modified here)    [i]
c   RETURNED:   fvec    corresponding difference from actual        [ra]
c                       streamline location far upwind
c               iflag   control flag for SNSQ (not modified here)    [i]
c
c CALLING ROUTINES:     SNSQ
c
c EXTERNAL ROUTINES:    FLOPUFF, HILHGT
c-----------------------------------------------------------------------

      INCLUDE 'flvar.puf'

c --- Local common to pass current 'constants' from PATH to PATH0
      common /flvar2/ xx,yyi,zzi
c       xx:  along-flow coordinate at point where streamline is sampled
c      yyi:  lateral position of streamline far from hill
c      zzi:  vertical position of streamline far from hill

      real yz(n),fvec(n)

c --- Retain iflag value
      iflag=iflag

c --- Compute streamline deflections eta(vertical) and del(lateral) to
c --- bring streamline from (inf,yi',zi') to (x,yz(1),yz(2))
c --- Do not allow streamline height below hill surface
      if(yz(2).LT.0.0) yz(2)=0.0
      call flopuff(xx,yz(1),yz(2),eta,del,thi,tli,tu)

c --- Compute the inferred upwind location (yi',zi')
      h=hh*hilhgt(xx,yz(1))
      yip=yz(1)-del
      zip=yz(2)-eta+h

c --- Functions to be zeroed are differences yi-yi' and zi-zi'
      fvec(1)=yyi-yip
      fvec(2)=zzi-zip

      return
      end
c-----------------------------------------------------------------------
      subroutine puffc(imode,zpole,dpole,c)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                   PUFFC
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes concentrations for those receptors that are
c               modeled as a "receptor-on-a-pole" (including cases in
c               which terrain effects are negligible)
c
c ARGUMENTS:
c   PASSED:     imode   mode of operation; 0 = flat, 1 = pole calc,  [i]
c                       2 = pole calc plus stagnation streamline offset
c               zpole   height of "pole" (m)                         [r]
c               dpole   lateral offset from stagnation streamline (m)[r]
c   RETURNED:   c       concentration (g/m**3)                       [r]
c
c CALLING ROUTINES:     CTSG
c
c EXTERNAL ROUTINES:    ERF
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

c  Initialize concentration that is returned
      c=zero

c  Make sure that receptor height is consistent with mode selection
      if(imode .EQ. 0) zpole=0.0

c  Compute elapsed time from when the puff was emitted to when it
c  reaches the recepter (the age of the puff when centered at the
c  receptor ("tup")
      tup=timpg+t12rl

c  If the age of the puff at the recepter is not positive, concentration
c  is zero!
      if(tup .LE. 0.) return

c  Compute needed sigmas
      sz=szr
      sy=syr
      szsq=sz*sz
      sysq=sy*sy

c  Puff is mixed in the vertical if sigma-z exceeds 1.6 times the
c  mixing height (zlid).  Set mixing flag to 1.
      imix=0
      if(sz .GE. 1.6*zlid) imix=1

c  Compute the concentration on the trajectory ("centerline")
      t1mtr=-(t12p+t12rl)
      t2mtr=tstep+t1mtr
      dum=u/(rt2*sy)
c     co=q*(ERF(t2mtr*dum)-ERF(t1mtr*dum))/(tstep*four*pi*u*sy*sz)
      co=q*(ERFDIF((t2mtr*dum),(t1mtr*dum)))/(tstep*four*pi*u*sy*sz)
      if(co .EQ. 0.0) then
         c=0.0
         return
      endif

c  Compute the horizontal distribution factor
      dely=yrf-ypf
      if(imode .EQ. 2) dely=dpole
      delysq=dely*dely
      argy=half*(delysq/sysq)
      if(argy .LT. expmax) then
         fy=EXP(-argy)

c  Compute the vertical distribution factor
c  - If puff is mixed in the vertical, set fz equal to rt2pi*sz/zlid
c    and compute concentration.
         if(imix .EQ. 1) then
            fz=rt2pi*sz/zlid
            c=co*fy*fz
            return
         endif
c  - Section for no mixing lid
         zplus=zpuff+zpole
         zminus=zpuff-zpole
         dum=half/szsq
         argz1=dum*zminus**2
         argz2=dum*zplus**2
         term1=zero
         term2=zero
         if(argz1 .LT. expmax) term1=EXP(-argz1)
         if(argz2 .LT. expmax) term2=EXP(-argz2)
         fz=term1+term2
c  - Section for reflections from lid
         if(fz .GT. 0.) then
            do 10 i=1,mxrefl
               twoizl=two*i*zlid
               argz1=dum*(twoizl-zminus)**2
               argz2=dum*(twoizl-zplus)**2
               argz3=dum*(twoizl+zminus)**2
               argz4=dum*(twoizl+zplus)**2
               term1=zero
               term2=zero
               term3=zero
               term4=zero
               if(argz1 .LT. expmax) term1=EXP(-argz1)
               if(argz2 .LT. expmax) term2=EXP(-argz2)
               if(argz3 .LT. expmax) term3=EXP(-argz3)
               if(argz4 .LT. expmax) term4=EXP(-argz4)
               fzo=fz
               fz=fz+term1+term2+term3+term4
               test=(fz-fzo)/fz
               if(test .LT. epsrefl) goto 11
10          continue
         endif

c  Compute concentration
11       c=co*fy*fz
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine qatr(xl,xu,eps,ndim,fct,y,ier,aux)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                    QATR
c
c PURPOSE:      Integration routine adapted from the IBM SSP program
c               DQATR.  Modified for single precision.
c
c ARGUMENTS:
c    PASSED:    xl,xu   lower and upper limits of integration        [r]
c               eps     fractional error used to define convergence  [r]
c               ndim    dimension of array aux                       [i]
c               fct     external function (integrand)
c               aux     working array, passed to allow variable dim. [r]
c  RETURNED:    y       value of integral                            [r]
c               ier     status flag at termination                   [i]
c
c CALLING ROUTINES:     UPPER
c
c EXTERNAL ROUTINES:    none
c-----------------------------------------------------------------------

c  NOTES: status flags denote the following --
c               ier=0   value of integral converged to within eps
c               ier=1   value of integral is diverging
c               ier=2   value of integral did not converge to within
c                       eps before ndim limit was reached

      EXTERNAL fct
      dimension aux(1)
      integer*2 i,ii,ji,j,jj
      half=0.5

c  Preparations for Romberg loop
      aux(1)=half*(fct(xl)+fct(xu))
      h=xu-xl
      y=h*aux(1)
      if(ndim .LE. 1) then
         ier=2
         return
      elseif(h .EQ. 0.) then
         ier=0
         return
      endif

      hh=h
      delt2=0.
      p=1.
      jj=1

c  Initialize flag for integer*2 limit: jj cannot exceed 32,000
      lstop=0

      do 7 i=2,ndim
         y=aux(1)
         delt1=delt2
         hd=hh
         hh=half*hh
         p=half*p
         x=xl+hh
         sm=0.

c  Integer*2 limit: jj cannot exceed 32,000
         if(lstop .EQ. 1) then
            write(6,1010)
1010        format(2X,'ERROR FROM QATR - VARIABLE jj EXCEEDED 32,000')
            write(*,*)
            stop 'Halted in QATR -- see list file.'
         endif
         if(jj .GT. 16000) lstop=1

         do 3 j=1,jj
            sm=sm+fct(x)
            x=x+hd
3        continue
         aux(i)=half*aux(i-1)+p*sm

c  A new approximation to the integral is computed by means
c       of the trapezoidal rule

c  Start of Rombergs extrapolation method

         q=1.
         ji=i-1
         do 4 j=1,ji
            ii=i-j
            q=q+q
            q=q+q
            aux(ii)=aux(ii+1)+(aux(ii+1)-aux(ii))/(q-1.)
4        continue

c  End of Romberg step

         delt2=ABS(y-aux(1))
         if(i .GE. 5) then
c  Modification for cases in which function = 0 over interval
            if(y .EQ. 0.) then
               ier=0
               return
            elseif(delt2/y .LE. eps) then
               ier=0
               y=h*aux(1)
               return
            elseif(delt2 .GE. delt1)then
               ier=1
               y=h*y
               return
            endif
         endif
7     jj=jj+jj
      ier=2
      y=h*aux(1)

      return
      end
c-----------------------------------------------------------------------
      subroutine rotate(x,y,ang,xp,yp)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 901015                  ROTATE
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Rotate coordinate system through angle "ang"
c               to map point (x,y) into point (xp,yp).
c
c ARGUMENTS:
c    PASSED:    x,y     coordinates before rotation                  [r]
c               ang     rotation angle (radians)                     [r]
c  RETURNED:    xp,yp   coordinates after rotation                   [r]
c
c CALLING ROUTINES:     CTPAR, CTREC
c
c EXTERNAL ROUTINES:    none
c-----------------------------------------------------------------------

c  Note: ang is the angle measured CCW from the x-axis to the xp-axis

      s=SIN(ang)
      c=COS(ang)
      xp=x*c+y*s
      yp=-x*s+y*c

      return
      end
c-----------------------------------------------------------------------
      function sigma(itype,zpuff,ws,t,s1,tstart,s2,tstep,sr,frac)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                   SIGMA
c ---            D. Strimaitis, SRC
c
c --- UPDATES
c --- V5.2-V5.4    000602  (DGS): add message to "stop"
c --- V5.1-V5.2    991104  (JSS): Error messages written to list
c                                 file as well as to screen
c
c PURPOSE:      Computes a value of sigma for a given travel-time,
c               using the CALPUFF sigma subroutines, starting from
c               the nearest of three known values.  The effect of
c               buoyancy-induced growth is treated as a virtual time,
c               as in CTDM.
c
c ARGUMENTS:
c    PASSED:    itype   1:sigma-y  2:sigma-z                         [i]
c               zpuff   puff height above ground (m)                 [r]
c               ws      puff advection speed (m/s)                   [r]
c               t       puff age (s)                                 [r]
c               s1      sigma at start of time-step (m)              [r]
c               tstart  puff age at start of time-step (s)           [r]
c               s2      sigma at end of time-step (m)                [r]
c               tstep   duration of time-step (s)                    [r]
c               sr      sigma at some intermediate point (m)         [r]
c               frac    fraction of tstep to intermediate point      [r]
c    Parameters: IO6
c  RETURNED:    sigma   sigma at time t (m)                          [r]
c
c CALLING ROUTINES:     UPPER, LOWER
c
c EXTERNAL ROUTINES:    SIGTY, SIGTZ
c-----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Declare arrays for sorted age(time) and sigmas
      real a(3),s(3)
      data zero/0.0/

c --- When sigma does not grow, just return the value at start of step
      if(s1 .EQ. s2) then
         sigma=s1
      else
c ---    Find age nearest time t
         a(1)=tstart+frac*tstep
         s(1)=sr
         a(2)=tstart
         s(2)=s1
         a(3)=tstart+tstep
         s(3)=s2
         index=1
         adelt=ABS(t-a(1))
         do i=2,3
            if(ABS(t-a(i)).LT.adelt) then
               index=i
               adelt=ABS(t-a(i))
            endif
         enddo
c
c ---    Set advection speed to km/s
         wskps=0.001*ws
c
c ---    Convert corresponding sigma to a virtual time, and then
c ---    compute the sigma at t via 'forward' call to sigma routine
         if(itype.EQ.1) then
c ---       Sigma-y
            call sigty(s(index),zero,zero,sy,vty,vdy)
            tsec=AMAX1(zero,vty+(t-a(index)))
            dkm=AMAX1(zero,vdy+(t-a(index))*wskps)
            if(tsec.GT.zero) then
               call sigty(zero,dkm,tsec,sigma,dum1,dum2)
            else
               sigma=zero
            endif
         elseif(itype.EQ.2) then
c ---       Sigma-z
            call sigtz(s(index),zero,zero,zpuff,sz,vtz,vdz)
            tsec=AMAX1(zero,vtz+(t-a(index)))
            dkm=AMAX1(zero,vdz+(t-a(index))*wskps)
            if(tsec.GT.zero) then
               call sigtz(zero,vdz,vtz,zpuff,sigma,dum1,dum2)
            else
               sigma=zero
            endif
         else
            write(io6,*) 'SIGMA:  itype not valid --  ',itype
            write(*,*)
            stop 'Halted in SIGMA -- see list file.'
         endif

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine slg2puf(x1,x2,y1,y2,sy1,sy2,npuff,qfac,xfac)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                 SLG2PUF
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Subroutine determines the number of puffs required to
c               simulate GLC's due to a slug (prepares for CTSG call).
c               Assumes that separation between puffs is fixed, and is
c               set by a mean sigma-y along the slug.
c
c ARGUMENTS:
c   PASSED:     x1,x2           x-coord. of old(1) and new(2) ends   [r]
c                               of slug
c               y1,y2           y-coord. of old(1) and new(2) ends   [r]
c                               of slug
c               sy1,sy2         sigma-y at the old(1) and new(2) ends[r]
c                               of the slug
c   RETURNED:   npuff           number of surrogate puffs            [i]
c               qfac            fraction of slug mass in each puff   [r]
c               xfac            puff separation, expressed as a      [r]
c                               fraction of the length of the slug
c
c CALLING ROUTINES:     COMP
c
c EXTERNAL ROUTINES:    none
c-----------------------------------------------------------------------
c Note: Assume that slug is partitioned into N puffs, so that there are
c       N-1 segments between the puffs.  Set the separation between the
c       puffs equal to the "mean" sigma-y
c-----------------------------------------------------------------------

      data half/0.5/, one/1.0/

c --- Compute the distance between the two "ends" of the slug
      slen=SQRT((x1-x2)**2+(y1-y2)**2)

c --- Set a min. sigma-y of "1" for the younger end ...
      sy22=AMAX1(sy2,one)

c --- Compute the mean sigma-y
c --- Arithmetic mean
      sy=half*(sy1+sy22)
c --- Geometric mean
c     sy=SQRT(sy1*sy22)

c --- Assume N equally-spaced puffs, where N is at least 2
      npuff=NINT(slen/sy)+1
      if(npuff.LT.2) npuff=2
      nseg=npuff-1
      qfac=one/FLOAT(npuff)
      xfac=one/FLOAT(nseg)

      return
      end
c-----------------------------------------------------------------------
      function speed(htmhd)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                   SPEED
c ---            D. Strimaitis, SRC
c
c
c PURPOSE:      Computes wind speed at the height provided
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): Minimum speed returned is ws(1)
c
c ARGUMENTS:
c    PASSED: htmhd      height at which speed is needed  (m)         [r]
c                       minus the height of dividing streamline
c
c CALLING ROUTINES: CTPAR, FLOPUFF
c
c EXTERNAL ROUTINES: NONE
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'ctpass.puf'

c  Treat single layer first
      if(nlev .EQ. 1) then
         speed=ws(1)
         return
      endif

c  Add Hd to get height consistent with profile array
      ht=htmhd+hd

c  Find the layer that contains ht
      do i=1,nlev
         iztop=i
         if(ht .LE. z(i)) goto 11
      enddo
11    if(iztop.EQ.1) then
         h1=0.0
         u1=0.0
      else
         h1=z(iztop-1)
         u1=ws(iztop-1)
      endif
      h2=z(iztop)
      u2=ws(iztop)

c  Use linear interpolation to find speed at ht
      a=(u2-u1)/(h2-h1)
      b=u1-a*h1
      speed=a*ht+b

c  Do not allow speeds less than value for layer 1
      speed=AMAX1(speed,ws(1))

      return
      end
c-----------------------------------------------------------------------
      subroutine tfac(x,th,tl,tu)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                    TFAC
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Interpolates flow distortion factors at position x along
c               the trajectory of the puff.
c
c ARGUMENTS:
c    PASSED:    x       position along the flow (puff trajectory);   [r]
c                       the origin lies at the center of the hill (m)
c  RETURNED: th,tl,tu   terrain-induced flow distortion factors      [r]
c
c CALLING ROUTINES:     FCTZ, FCTY
c
c EXTERNAL ROUTINES:    none
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

      if(x.GT.xbegin .AND. x.LT.xend) then

c  Find array index just upwind of x    (npos)
         nposm1=INT((x-xbegin)/xspace)
         npos=nposm1+1
         nposp1=npos+1

c  Find value of x at npos
         xnpos=xbegin+xspace*nposm1

c  Find distortion factors at x
         xfac=(x-xnpos)/xspace
         th=xfac*(at(1,nposp1)-at(1,npos))+at(1,npos)
         tl=xfac*(at(2,nposp1)-at(2,npos))+at(2,npos)
         tu=one/(th*tl)

      else

         tu=one
         tl=one
         th=one

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine upper(c)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                   UPPER
c ---            D. Strimaitis, SRC
c
c PURPOSE:      Computes concentrations due to puff material in the
c               upper sgment of the flow (above Hd).
c
c ARGUMENTS:
c    PASSED:    none
c  RETURNED:    c               concentration (g/m**3)               [r]
c
c CALLING ROUTINES:     CTSG
c
c EXTERNAL ROUTINES:    FLOPUFF, QATR, FCTZ, FCTY, SIGMA, ERF,
c                       BJI, BI
c-----------------------------------------------------------------------

      INCLUDE 'params.puf'
      INCLUDE 'const.puf'
      INCLUDE 'ctpass.puf'

c  Set up for call to QATR:
      real aux(300)
      EXTERNAL fctz,fcty
      ndim=300
      eps=.01

c  Initialize concentration that is returned
      c=zero

c  Compute the age of puff at the receptor (tup)
      tup=timpg+t12ru

c  If the age of the puff at the recepter is not positive, concentration
c  is zero!
      if(tup .LE. zero) return

c  Puff age at start of time-integration is not negative
      tlow=AMAX1(timpg,zero)

c  Assign sigmas at impingement point
      szo=szimpg
      szosq=szo*szo
      syo=syimpg
      syosq=syo*syo
c  Reset impingement sigmas if they exceed receptor-specific values --
c  this turns off hill-effects as the puff has not yet reached the hill
      szsq=szr*szr
      sysq=syr*syr
      if(szosq.GE.szsq .OR. syosq.GE.sysq) then
         szo=szr
         szosq=szsq
         syo=syr
         syosq=sysq
      endif

c  Puff is mixed in the vertical if sigmaz upwind of the hill (szo)
c  exceeds 1.6 times the mixed layer height (zlid).  Set mixing
c  flag to 1.
      imix=0
      if(szo .GE. 1.6*zlid) imix=1

c  Compute (sigz**2-sigzo**2)/Tz**2, denoted as szptsq and
c       also (sigy**2-sigyo**2)/Ty**2, denoted as syptsq
c  Assume no growth if growth is less than "small"
      szptsq=zero
      szpt=zero
      syptsq=zero
      zdif=szr-szo
c  - set zdif equal to zero to avoid line integral evaluation when
c    puff is mixed in the vertical
      if(imix .EQ. 1) zdif=zero
      ydif=syr-syo
      if(zdif .GT. small) then
         call QATR(tlow,tup,eps,ndim,fctz,szptsq,ier,aux)
         szpt=SQRT(szptsq)
      endif
      if(ydif .GT. small) then
         call QATR(tlow,tup,eps,ndim,fcty,syptsq,ier,aux)
      endif
      szesq=szosq+szptsq
      sze=SQRT(szesq)
      syesq=syosq+syptsq
      sye=SQRT(syesq)

c  Compute the concentration on the trajectory ("centerline")
      t1mtr=-(t12p+t12ru)
      t2mtr=tstep+t1mtr
      dum=u/(rt2*sye)
c     co=q*(ERF(t2mtr*dum)-ERF(t1mtr*dum))/(tstep*four*pi*u*sye*sze)
      co=q*(ERFDIF((t2mtr*dum),(t1mtr*dum)))/(tstep*four*pi*u*sye*sze)
      if(co.LE.zero) return

c  Compute the horizontal distribution factor
      call FLOPUFF(xrf,yrf,0.0,zeta,ydel,dum1,dum2,dum3)
      del=yrf-ydel-ypf
      argy=half*(del*del/syesq)
      if(argy .LT. expmax) then
         fy=EXP(-argy)

c  Compute the vertical distribution factor

c  - If puff is mixed in the vertical, set fz equal to rt2pi*sze/zlid
c    and calculate concentration
         if(imix .EQ. 1) then
            fz=rt2pi*sze/zlid
            c=co*fy*fz
            return
         endif
         twofz=zero
         zlmhd=zlid-hd
         ak=half/szesq
         if(szpt .GT. zero) then
            ak=one/(rt2*sze*szo*szpt)
            d0=ak*szesq*zlmhd
         endif
c  - First sum, i=1:
         eoip=zpuff
         eoipmh=eoip-hd
         eoipph=eoip+hd
c  When plume doesn't grow, loop over j is not needed
         if(szpt .EQ. zero) then
            call BI(ak,eoipmh,eoipph,bp)
            twofz=twofz+bp
c  - No impact on i=1 means that plume does not reach receptor!
            if(twofz.EQ.0.0) return
         else
            dpm=eoipmh*szptsq
            dpp=eoipph*szptsq
c  - Loop on j:
            do 200 j=1,mxrefl
               aj=AMIN0(2,j)
               ej=two*(j-1)*zlmhd
               call BJI(ak,dpm,dpp,d0,eoipmh,eoipph,ej,bjp)
               add=aj*bjp
               twofz=twofz+add
c  - No impact on i=j=1 means that plume does not reach receptor!
               if(twofz.EQ.0.0) return
               if(add/twofz .LT. epsrefl) goto 201
200         continue
         endif
c  - Loop on i>1:
201      do 400 i=2,mxrefl
            eoip=zpuff+two*zlid*(i-1)
            eoipmh=eoip-hd
            eoipph=eoip+hd
            eoim=-zpuff+two*zlid*(i-1)
            eoimmh=eoim-hd
            eoimph=eoim+hd
c  When plume doesn't grow, loop over j is not needed
            if(szpt .EQ. zero) then
               call BI(ak,eoipmh,eoipph,bp)
               call BI(ak,eoimmh,eoimph,bm)
               add=(bp+bm)
               twofz=twofz+add
               if(add/twofz .LT. epsrefl) goto 401
            else
               dmm=eoimmh*szptsq
               dpm=eoipmh*szptsq
               dpp=eoipph*szptsq
               dmp=eoimph*szptsq
c  - Loop on j:
               do 300 j=1,mxrefl
                  aj=AMIN0(2,j)
                  ej=two*(j-1)*zlmhd
                  call BJI(ak,dpm,dpp,d0,eoipmh,eoipph,ej,bjp)
                  call BJI(ak,dmm,dmp,d0,eoimmh,eoimph,ej,bjm)
                  add=(aj*(bjp+bjm))
                  twofz=twofz+add
                  if(add/twofz .LT. epsrefl) then
                     if(j .GT. 1) goto 400
                     goto 401
                  endif
300            continue
            endif
400      continue

401      fz=half*twofz

c  Compute concentration
         c=co*fy*fz
      endif

      return
      end
c-----------------------------------------------------------------------
      real function xintrp(x1,x2,x,y1,y2)
C-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940831                  XINTRP
c ---            Adopted from CTDMPLUS without modification
c
C FUNCTION: XINTRP
C
C PURPOSE: THIS FUNCTION LINEARLY INTERPOLATES BETWEEN TWO POINTS
C               (Y1,Y2) GIVEN THREE OTHER POINTS (X1,X2,X) WHERE
C               X1 AND X2 ARE ENDPOINTS AND X IS BETWEEN X1 AND X2
C
C ASSUMPTIONS: X IS BETWEEN X1 AND X2
C
C REMARKS: IF X1 = X2 THEN THE MIDPOINT BETWEEN Y1 AND Y2 IS RETURNED
C
C ARGUMENTS:
C  PASSED:
C       X1,X2   REAL    ENDPOINTS OF FIRST LINE
C       X       REAL    POINT BETWEEN X1 AND X2
C       Y1,Y2   REAL    ENDPOINTS OF LINE TO BE INTERPOLATED
C
C FUNCTION VALUE:
C       XINTER  REAL    INTERPOLATED VALUE BETWEEN Y1 AND Y2
C
C CALLING ROUTINES: ctpar
C
C EXTERNAL ROUTINES: NONE
C
C INTRINSIC FUNCTIONS: NONE
C
C COMMON BLOCKS: NONE
C
C-----------------------------------------------------------------------
C
C       DEFINE ARGUMENTS
        REAL X1, X2, X, Y1, Y2
C       DEFINE LOCAL VARIABLES
        REAL DX
C       START
        DX = X2 - X1
        IF( DX .NE. 0.0 ) THEN
                XINTRP = Y1 + (Y2-Y1) * (X-X1)/DX
         ELSE
                XINTRP = (Y1+Y2) * 0.5
        ENDIF
        RETURN
        END
c----------------------------------------------------------------------
      subroutine dry(icode,ix,iy,nhrind,tsamp,jp,dpbl,hlid,tempk,qsw,
     1               ppcoef,ldbhr,
     1               vd,vdpvd,fracdry)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                    DRY
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Compute dry deposition velocities for each modeled
c               species using a resistance model or user-specified
c               diurnally varying values.  Also compute mass removed
c               during step.
c
c --- UPDATES:
c --- V5.0 950715 - V6.22 070921
c                   (DGS): Explicitly set LCALM in call to VCBAR to
c                          false to disable single-point sampling
c                          (LCALM was not previously assigned so this
c                          perpetuates the current treatment)
c
c --- INPUTS:
c
c             ICODE - integer - Puff status code (1,2 = Puff within
c                               mixed layer and [Gaussian, uniform] in
c                               vertical; 3,4 = Puff above mixed layer
c                               and [Gaussian, uniform]; 5,6 = Same as
c                               3, 4 except puff was previously within
c                               mixed layer; 11-16 = Same as 1-6 except
c                               applies slugs; 99 = Off comp. grid)
c                IX - integer - X index of closest grid point to
c                               puff/slug center
c                IY - integer - Y index of closest grid point to
c                               puff/slug center
c            NHRIND - integer - Current hour (01-24)
c             TSAMP - real    - Sampling step (s)
c                JP - integer - Puff number of current puff
c              DPBL - real    - Current depth of the boundary layer (m)
c                               (mixing height at nearest grid point)
c              HLID - real    - Current reflecting lid height (m) used
c                               to calculate the vertical distribution
c             TEMPK - real    - Air temperature (deg. K)
c               QSW - real    - Short-wave radiation (W/m**2)
c            PPCOEF - real    - Plume Path Coefficient for partial
c                               height correction (MCTADJ = 3)
c             LDBHR - logical - Variable controlling debug write
c                               statements
c
c     Common Block /DISPDAT/ variables:
c        CONK1, CONK2
c     Common Block /DRYDEP/ variables:
c        IDRYFLG(mxspec), ZREF, IVEG, VDUSER(24,mxspec)
c     Common Block /GEN/ variables:
c        NSPEC
c     Common Block /GRID/ variables:
c        NX, NY
c     Common Block /METHD/ variables:
c        Z0(mxnx,mxny), ILANDU(mxnx,mxny), XLAI(mxnx,mxny),
c        IWAT1, IWAT2
c     Common Block /METHR/ variables:
c        UMET(mxnx,mxny,mxnz), VMET(mxnx,mxny,mxnz), USTAR(mxnx,mxny),
c        XMONIN(mxnx,mxny)
c     Common Block /PUFF/ variables:
c        QM(mxspec,mxpuff)
c     Parameters:
c        MXNX, MXNY, MXNZ, MXPUFF, MXSPEC, MXNZP1, MXSS,
c        MXUS, MXPS, IO6
c
c --- OUTPUT:
c         VD(nspec) - real    - Deposition velocities (m/s) before
c                               considering overall boundary layer
c                               resistance
c      VDPVD(nspec) - real    - Ratio of vd'/vd, where vd' is the
c                               deposition velocity after applying
c                               the overall boundary layer resistance
c    FRACDRY(nspec) - real    - Fraction of puff mass remaining after
c                               consideration of dry removal effects
c     Common Block /PUFF/ variables:
c        QM(mxspec,mxpuff)
c
c --- DRY called by:  COMP
c --- DRY calls:      VDCOMP, VCBAR
c----------------------------------------------------------------------
c --- Note:  Mass depletion requires the evaluation of the vertical
c            coupling coefficient.  Make sure that the use of the
c            mixing height is consistent with CALCPF and CALCSL!
c----------------------------------------------------------------------
c
c --- Include PARAMETERS
      include 'params.puf'
c
c --- Include common blocks
      include 'dispdat.puf'
      include 'drydep.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'puff.puf'
c
      real vd(nspec),vdpvd(nspec),fracdry(nspec)
      logical ldbhr,ldb2
      logical lcalmf

c --- Explicitly disable single-point VCBAR sampling by setting local
c --- variable to false ("calm" sampling was never fully implemented)
      lcalmf=.false.

c ***
      ldb2=.false.
      if(ldb2)then
         write(io6,*)
         write(io6,*)'SUBR. DRY -- Inputs and local variables'
         write(io6,*)'IX        = ',ix,'  IY = ',iy
         write(io6,*)'ICODE     = ',icode
         write(io6,*)'NHRIND    = ',nhrind
         write(io6,*)'VDUSER    = ',(vduser(nhrind,n),n=1,nspec)
         write(io6,*)'UMET      = ',umet(ix,iy,1)
         write(io6,*)'VMET      = ',vmet(ix,iy,1)
         write(io6,*)'Z0        = ',z0(ix,iy)
         write(io6,*)'USTAR     = ',ustar(ix,iy)
         write(io6,*)'WSTAR     = ',wstar(ix,iy)
         write(io6,*)'DPBL      = ',dpbl
         write(io6,*)'HLID      = ',hlid
         write(io6,*)'XMONIN    = ',xmonin(ix,iy)
         write(io6,*)'ILANDU    = ',ilandu(ix,iy)
         write(io6,*)'IWAT1     = ',iwat1,'  IWAT2 = ',iwat2
         write(io6,*)'XLAI      = ',xlai(ix,iy)
         write(io6,*)'QSW       = ',qsw
         write(io6,*)'PPCOEF    = ',ppcoef
         write(io6,*)'TEMPK     = ',tempk
      endif
c ***
c
c --- Initialize output variables
      diffk=0.0
      do i=1,nspec
         vd(i)=0.0
         vdpvd(i)=1.0
         fracdry(i)=1.0
      enddo
c
c --- Extract puff distribution code
c --- (IICODE is 1-6 or 99)
      if(icode.EQ.99) goto 100
      iicode=icode
      if(iicode.ge.11.and.iicode.le.16) iicode=iicode-10
c
c --- Skip vd calculations if puff is above mixed layer and uniform
      if(iicode.eq.4) goto 100
c
c --- Determine state of the vegetation -- NOTE: negative land use
c --- indicates irrigated land
      if(ilandu(ix,iy).lt.0.or.
     1  (ilandu(ix,iy).ge.iwat1.and.ilandu(ix,iy).le.iwat2))then
c ---    IRRIGATED or WATER-- assume vegetation is active and unstressed
         ivegij=1
      else
c ---    UNIRRIGATED -- use user-specified vegetation state
         ivegij=iveg
      endif
c
c --- Compute deposition velocities using the resistance model or
c     user-specified, diurnally-varying values
      ldb2=.false.
      call vdcomp(idryflg,nspec,zref,ivegij,umet(ix,iy,1),
     1 vmet(ix,iy,1),ilandu(ix,iy),iwat1,iwat2,z0(ix,iy),tempk,
     2 ustar(ix,iy),xmonin(ix,iy),xlai(ix,iy),qsw,vduser,nhrind,
     3 ldb2,vd)
c
c --- Compute ratio of vd'/vd to account for overall boundary layer
c --- resistance if puff/slug is or was below mixed layer height AND
c --- is uniformly mixed in the vertical (use current mixing height)
      if(iicode.eq.2.or.iicode.eq.6) then
c
         eustar=ustar(ix,iy)
         ewstar=wstar(ix,iy)
c
c ---    Compute boundary layer diffusivity
         if(ewstar.gt.0.0)then
c
c ---       Unstable conditions -- diffusivity is maximum of
c ---       stable/unstable values
            diffk=amax1(conk2*ewstar*dpbl,conk1*eustar*dpbl)
         else
c
c ---       Neutral/stable
            diffk=conk1*eustar*dpbl
         endif
c
c ---    Minimum value of dz to prevent numerical problems
         dz=amax1(dpbl-zref,0.00001)
c
         do 95 j=1,nspec
c ---    Compute vd'/vd ratio only for species using resistance model
c ---    (User-specified deposition velocities are NOT modified)
         if(idryflg(j).eq.1.or.idryflg(j).eq.2)then
            vdpvd(j)=diffk/(diffk+vd(j)*dz)
         endif
95       continue
      endif
c
c --- Compute fraction remaining and adjust puff mass

      if(iicode.eq.2.or.iicode.eq.6)then
c
c ---    Puff is uniform in the vertical
         const=tsamp/hlid
c
      else
c
c ---    Puff is Gaussian in the vertical
         mfact0=icode-iicode
         f1=vcbar(jp,mfact0,hlid,ppcoef,lcalmf)
         const=tsamp*f1
      endif
c
c --- Determine the fraction of pollutant mass remaining after
c --- dry removal
      do 97 j=1,nspec
      fracdry(j)=exp(-vdpvd(j)*vd(j)*const)
      qm(j,jp)=fracdry(j)*qm(j,jp)
97    continue

c*****
100   if(ldbhr)then
         write(io6,111)diffk,(vd(n),n=1,nspec)
         write(io6,112)(vdpvd(n),n=1,nspec)
         write(io6,113)(fracdry(n),n=1,nspec)
111      format(15x,'DRY REMOVAL -- diffk = ',f10.3/
     1          17x,'vd (m/s)      = ',2x,5(f11.6,1x))
112      format(17x,'vdpvd         = ',2x,5(f11.6,1x))
113      format(17x,'Fraction left = ',2x,5(f11.3,1x))
      endif
c*****
c
      return
      end
c----------------------------------------------------------------------
      subroutine vdcomp(idryflg,nspec,zref,iveg,u10,v10,ilu,iwat1,
     1 iwat2,z0,tdegk,ustar,el,xlai,qsw,vduser,nhrind,ldb,vd)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040611                 VDCOMP
c                J. Scire, SRC
c
c --- PURPOSE:  Compute deposition velocities for each species
c               deposited for a single grid cell
c
c --- UPDATE
c --- V5.0 980304 - V5.73 040611
c                   (DGS): Rename NINT to NPSINT
c --- V5.0 960521 - V5.0 980304
c                   (DGS): Set minimum calculated z0 over water as in
c                          CALMET
c
c --- INPUTS:
c
c
c    IDRYFLG(nspec) - integer - Dry deposition method flags
c                                    0=not deposited,
c                                    1=resistance model - gas,
c                                    2=resistance model - particle,
c                                    3=user specified dep. velocities
c             NSPEC - integer - Total number of species
c                               (deposited + non-deposited species)
c              ZREF - real    - Reference height (m) for computing
c                               the atmospheric resistance
c              IVEG - integer - State of the vegetation in current cell
c                                    1 = vegetation active & unstressed
c                                    2 = vegetation active & stressed
c                                    3 = vegetation inactive
c               U10 - real    - U-component (m/s) of winds at 10 m
c                               height (Used only if in water cells)
c               V10 - real    - V-component (m/s) of winds at 10 m
c                               height (Used only if in water cells)
c               ILU - integer - Land use category for current grid cell
c      IWAT1, IWAT2 - integer - Range of land use categories defining
c                               water (IWAT1 to IWAT2)
c                Z0 - real    - Surface roughness length (m)
c             TDEGK - real    - Air temperature (deg. K)
c             USTAR - real    - Surface friction velocity (m/s)
c                EL - real    - Monin-Obukhov length (m)
c              XLAI - real    - Leaf area index
c               QSW - real    - Short-wave radiation at ground (W/m**2)
c VDUSER(24,mxspec) - real    - Diurnal cycle of user-specified
c                               deposition velocities (m/s) for hour
c                               ending 1-24
c            NHRIND - integer - Current hour index (1-24)
c               LDB - logical - Flag determining if debug write
c                               statements are activated
c     Common Block /DRYGAS/ variables:
c        PDIFF(mxspec),RM(mxspec),RGG(mxspec),RGW1(mxspec),
c        RCUT(mxspec),RD1(mxspec),BMIN,BMAX,QSWMAX,PCONST
c     Common Block /DRYPART/ variables:
c        SC23(mxint,mxpdep),VGRAV(mxint,mxpdep),TSTOP(mxint,mxpdep),
c        FRACT(mxint,mxpdep),VAIRMS
c     Parameters:
c        MXSPEC, MXPDEP, MXINT, IO6
c
c --- OUTPUT:
c         VD(nspec) - real    - Deposition velocities (m/s)
c
c --- VDCOMP called by:  DRY
c --- VDCOMP calls:      VDP
c----------------------------------------------------------------------
c
c --- Include PARAMETERS
      include 'params.puf'
c
c --- Include common block /DRYGAS/  -- Gas Deposition
      include 'drygas.puf'
c
c --- Include common block /DRYPART/ -- Particle Deposition
      include 'drypart.puf'
c
      real vd(nspec),vduser(24,mxspec)
      integer idryflg(nspec)
      logical lwater,ldb
c
      data vk/0.4/,usmin/1.e-5/,ramin/1.0/

c --- Minimum z0(m) over water is 2.0e-06, which corresponds to a 10m
c --- wind speed minimum of 1m/s
      data ws0/1.0/

c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. VDCOMP -- INPUTS'
         write(io6,*)'NSPEC   = ',nspec
         write(io6,*)'IDRYFLG = ',(idryflg(n),n=1,nspec)
         write(io6,*)'IVEG    = ',iveg
         write(io6,*)'U10     = ',u10,' v10 = ',v10
         write(io6,*)'ILU     = ',ilu,' IWAT1 = ',iwat1,' IWAT2 = ',
     1    iwat2
         write(io6,*)'Z0      = ',z0,' XLAI = ',xlai
         write(io6,*)'TDEGK   = ',tdegk,' USTAR = ',ustar,' EL = ',el,
     1    ' QSW = ',qsw
         write(io6,*)'NHRIND  = ',nhrind
         write(io6,*)'VDUSER  = ',(vduser(nhrind,n),n=1,nspec)
      endif
c ***
c
c --- Pass user-supplied deposition velocities to VD array and exit
c --- if no computations are needed
c --- LOOP OVER SPECIES
      numsp=0
      do j=1,nspec
         if(idryflg(j).eq.0)then
c ---       NO DEPOSITION
            vd(j)=0.0
            numsp=numsp+1
         elseif(idryflg(j).eq.3)then
c ---       USER-SPECIFIED DEPOSITION
            vd(j)=vduser(nhrind,j)
            numsp=numsp+1
         endif
      enddo
      if(numsp.eq.nspec) return
c
c --- Continue on if computations are needed for some species
c
c --- Determine if this grid cell is a water or land cell
      if(ilu.ge.iwat1.and.ilu.le.iwat2)then
         lwater=.true.
c ---    Compute wind-driven roughness length
         z0m=2.0e-6
         wstest=ABS(u10)+ABS(v10)
         if(wstest.GT.ws0) then
            ws=sqrt(u10**2+v10**2)
            if(ws.GT.ws0) z0m=2.0e-6*ws**2.5
         endif
      else
         lwater=.false.
         z0m=z0
      endif
c
c --- Compute atmospheric resistance
c --- Stability-dependent psi function (heat)
      elabs=abs(el)
      if(el.lt.0.0.and.elabs.lt.9990.)then
         ratio=-zref/el
         if(ratio.gt.1.0)ratio=1.0
         zmel=alog(ratio)
         psih=exp(0.598+0.39*zmel-0.090*zmel*zmel)
      else if(elabs.ge.9990.)then
         psih=0.0
      else
         ratio=zref/el
         if(ratio.gt.1.0)ratio=1.0
         psih=-5.*ratio
      endif
c
c --- Use minimum value of USTAR to avoid numerical problems
c     when USTAR near zero
      ustarr=amax1(ustar,usmin)
c
c --- Calculate atmospheric resistance
      ra=(alog(zref/z0m)-psih)/(vk*ustarr)
      ra=amax1(ra,ramin)
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'LWATER = ',lwater
         write(io6,*)'Z0M    = ',z0m
         write(io6,*)'PSIH   = ',psih
         write(io6,*)'USTARR = ',ustarr
         write(io6,*)'RA     = ',ra
      endif
c ***
c
c --- LOOP OVER SPECIES
      nsp=0
      do 100 j=1,nspec
c
c --- Compute deposition velocity for species deposited
      if(idryflg(j).eq.0 .OR. idryflg(j).eq.3)then
c ---    DEPOSITION ALREADY ASSIGNED
         go to 100
      elseif(idryflg(j).eq.2)then
c ---    PARTICLE DEPOSITION
         nsp=nsp+1
         call vdp(sc23(1,nsp),vgrav(1,nsp),tstop(1,nsp),fract(1,nsp),
     1   npsint,ra,vairms,ustarr,ldb,vd(j))
         go to 100
      endif
c
c --- GAS DEPOSITION
c
c --- Compute the deposition layer resistance, RD
c --- (RD1 is d1*SC**d2/vk -- computed in setup routine)
      RD=RD1(j)/ustarr
c
c --- Compute resistance directly to ground or water, RG
      if(lwater)then
c
c ---    Water cell (RGW1 computed in setup routine as
c ---                RGW1 = HENRY/(ALPHAS * D3 * USTAR)
         RG=RGW1(j)/ustarr
      else
c
c ---    Land cell (RG computed in setup routine)
         RG=RGG(j)
      endif
c
c --- Stomatal pore resistance (RS)
      if(iveg.eq.1)then
c
c ---    Vegetation is active & unstressed (IVEG=1)
c        (B = stomatal pore opening (m), BMIN = minimum stomatal
c        opening, BMAX = maximum stomatal opening, fr is the approx.
c        fraction of peak short-wave solar radiation available for a
c        particular hour)
c
c ---    Temperature effects -- If T > 35 deg. C, stomata fully
c ---    open to allow evaporative cooling -- but only if unstressed --
c ---    If T < 10 deg. C, stomata closed due to decreased metabolic
c ---    activity)
         if(tdegk.gt.308.)then
c ---       T > 35 deg. C
            B=BMAX
         else if(tdegk.lt.283.)then
c ---       T < 10 deg. C
            B=BMIN
         else
            fr=qsw/qswmax
            fr=amax1(0.0,fr)
            fr=amin1(1.0,fr)
            B=BMAX*fr+BMIN*(1.-fr)
         endif
c
         RS=pconst/(B*pdiff(j))
      else if(iveg.eq.2)then
c
c ---    Vegetation is active and stressed (IVEG=2)
c        (Stomatal opening is at its minimum size)
         RS=pconst/(BMIN*pdiff(j))
      else
c
c ---    Vegetation is inactive (IVEG=3)
         RS=9.9e9
      endif
c
c --- Internal foliage resistance (RF)
c     (RM is the mesophyll resistance)
      RF=RS+RM(j)
c
c --- Compute canopy resistance
      RC=1.0/(XLAI/RF+XLAI/RCUT(j)+1.0/RG)
c
c --- Deposition velocity is the inverse of the sum of the
c --- atmospheric, deposition layer, and canopy resistances
      vd(j)=1.0/(ra+rd+rc)
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. VDCOMP -- OUTPUT'
         write(io6,*)'SPECIES (J) = ',j
         write(io6,*)'RD          = ',rd
         write(io6,*)'RC          = ',rc
         write(io6,*)'VD(j)       = ',vd(j)
         write(io6,*)'RS          = ',rs
         write(io6,*)'RF          = ',rf
         write(io6,*)'RG          = ',rg
         write(io6,*)'B           = ',b
      endif
c
100   continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine vdp(sc23,vgrav,tstop,fract,npsint,ra,vairms,ustar,
     1 ldb,vd)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040611                    VDP
c                J. Scire, SRC
c
c --- UPDATE
c --- V5.0 960628 - V5.73 040611
c                   (DGS): Rename NINT to NPSINT
c
c --- MODIFICATION  6/26/96 (DGS): all mass is in first size when gsig
c                                  is less than or equal to 1.0 um, so
c                                  only do first interval if
c                                  fract(1) = 1.0
c
c --- PURPOSE:  Compute a mass-weighted particle deposition
c               velocity for a single size distribution
c
c --- INPUTS:
c
c      SC23(npsint) - real    - Schmidt number ** DCONST4
c     VGRAV(npsint) - real    - Gravitational settling velocity (m/s)
c     TSTOP(npsint) - real    - Stopping time (s)
c     FRACT(npsint) - real    - Mass fraction in each size interval
c            NPSINT - integer - Number of size intervals used to
c                               evaluate the effective deposition
c                               velocity
c                RA - real    - Atmospheric resistance (s/m)
c            VAIRMS - real    - Viscosity of air (m**2/s)
c             USTAR - real    - Friction velocity (m/s)
c               LDB - logical - Flag determining if debug write
c                               statements are activated
c     Parameters:
c        IO6
c
c --- OUTPUT:
c                VD - real    - Mass-weighted deposition velocity (m/s)
c
c --- VDP called by:  VDCOMP
c --- VDP calls:      none
c----------------------------------------------------------------------
c
c --- Include PARAMETERS
      include 'params.puf'
c
      real sc23(npsint),vgrav(npsint),tstop(npsint),fract(npsint)
      logical ldb
c
      save xmin
      data xmin/-37./
c
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. VDP -- Inputs'
         write(io6,*)'SC23    = ',sc23
         write(io6,*)'VGRAV   = ',vgrav
         write(io6,*)'TSTOP   = ',tstop
         write(io6,*)'FRACT   = ',fract
         write(io6,*)'NPSINT  = ',npsint
         write(io6,*)'RA      = ',ra
         write(io6,*)'VAIRMS  = ',vairms
         write(io6,*)'USTAR   = ',ustar
      endif
c ***
      vd=0.0
      t1=ustar*ustar/vairms
c
c --- Reset number of intervals to 1 if all mass is in first interval
      if(fract(1).EQ.1.0) then
         intrvl=1
      else
         intrvl=npsint
      endif
c
c --- LOOP OVER SIZE INTERVALS
      do 10 i=1,intrvl
c
      st=tstop(i)*t1
c
c --- prevent underflows (min. 10. ** (-37.)
c *** xinert=10.**(-3./st)
      xpon=-3./st
      if(xpon.lt.xmin)then
         xinert=10.**(xmin)
      else
         xinert=10.**(xpon)
      endif
c
c --- Deposition layer resistance (s/m)
      rd=1.0/(ustar*(sc23(i)+xinert))
c
c --- Deposition velocity for this current interval
      vdi=1.0/(ra+rd+ra*rd*vgrav(i))+vgrav(i)
c
c --- Effective deposition velocity is weighted average of value
c --- in each size interval
      vd=vd+vdi*fract(i)
c ***
      if(ldb)then
         write(io6,*)'I       = ',i,' RD = ',rd,' VDI = ',vdi
      endif
c ***
c
10    continue
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'VD      = ',vd
      endif
c ***
c
      return
      end
c----------------------------------------------------------------------
      subroutine rdvd
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                  RDVD
c                J. Scire, SRC
c
c --- PURPOSE:  Read a file containing a diurnal cycle of 24 hourly
c               deposition velocities (m/s) for selected species
c
c --- UPDATE
c --- V5.5-V5.7
c        000602_7 - 030402  (DGS): MXVAR relocated to PARAMS.CAL
c --- V5.5          000602_7 (JSS): Fix call to READIN to allow
c                                   up to MXSPEC species to have
c                                   user-specified dep. velocities
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c     Common block /GEN/ variables
c           NSPEC, CSPEC(mxspec)
c     Common block /DRYDEP/ variables
c           IDRYFLG(mxspec), NVDUSER
c     Parameters: MXVAR, MXSPEC, IO6, IO20
c
c --- OUTPUT:
c     Common block /DRYDEP/ variables
c           VDUSER(24,mxspec)
c
c --- RDVD called by: DRYI
c --- RDVD calls:     READIN
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
      include 'params.cal'
c
      integer ivleng(mxvar),ivtype(mxvar)
      character*12 cvdic(mxvar)
      logical lecho
c
      include 'gen.puf'
      include 'drydep.puf'
c
      data cvdic/mxvar*' '/,ivleng/mxvar*0/,ivtype/mxvar*0/
      data lecho/.true./
c
c --- Initialize user-specified vd array with missing value
c --- indicators
      do 10 j=1,mxspec
      do 10 i=1,24
      vduser(i,j)=-9.
10    continue
c
      if(nvduser.eq.0)go to 999
c
c --- Set up the variable dictionary and array length vector
      do 20 i=1,nspec
      if(idryflg(i).eq.3)then
         cvdic(i)=cspec(i)
         ivleng(i)=24
         ivtype(i)=1
      endif
20    continue
c
c --- read the formatted file
      write(io6,32)
32    format(///1x,13('----------')//5x,'USER-SPECIFIED DEPOSITION ',
     1 'VELOCITY FILE (VD.DAT)'//)
c
c --- The following call is set for MXSPEC=35
c *** call readin(cvdic,ivleng,ivtype,io20,io6,lecho,
c ***1 vduser(1,1),vduser(1,2),vduser(1,3),vduser(1,4),vduser(1,5),
c ***2 vduser(1,6),vduser(1,7),vduser(1,8),vduser(1,9),vduser(1,10),
c ***3 vduser(1,11),vduser(1,12),vduser(1,13),vduser(1,14),vduser(1,15),
c ***4 vduser(1,16),vduser(1,17),vduser(1,18),vduser(1,19),vduser(1,20),
c ***5 vduser(1,21),vduser(1,22),vduser(1,23),vduser(1,24),vduser(1,25),
c ***6 vduser(1,26),vduser(1,27),vduser(1,28),vduser(1,29),vduser(1,30),
c ***7 vduser(1,31),vduser(1,32),vduser(1,33),vduser(1,34),vduser(1,35),
c ***8 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***a idum)
c
c --- The following call is set for MXSPEC=20
      call readin(cvdic,ivleng,ivtype,io20,io6,lecho,
     1 vduser(1,1),vduser(1,2),vduser(1,3),vduser(1,4),vduser(1,5),
     2 vduser(1,6),vduser(1,7),vduser(1,8),vduser(1,9),vduser(1,10),
     3 vduser(1,11),vduser(1,12),vduser(1,13),vduser(1,14),vduser(1,15),
     4 vduser(1,16),vduser(1,17),vduser(1,18),vduser(1,19),vduser(1,20),
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=5
c *** call readin(cvdic,ivleng,ivtype,io20,io6,lecho,
c ***1 vduser(1,1),vduser(1,2),vduser(1,3),vduser(1,4),vduser(1,5),
c ***2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6 idum,idum,idum,idum,idum,idum,idum)
c
c --- check that values for every required species have been read
      ierr=0
      do 50 j=1,nspec
c
      isperr=0
      if(idryflg(j).eq.3)then
         do 45 i=1,24
         if(vduser(i,j).lt.0.0)then
            ierr=1
            isperr=1
         endif
45       continue
c
c ---    Error if any hour for this deposited species is missing
         if(isperr.eq.1)then
            write(io6,47)cspec(j),(vduser(n,j),n=1,24)
47          format(/1x,'ERROR in subr. RDVD -- VD values not found ',
     1      'for species: ',a12,/1x,'VDUSER = ',12f10.5/10x,12f10.5/)
         endif
      endif
50    continue
c
      if(ierr.eq.1) then
         write(*,*)
         stop 'Halted in RDVD -- see list file.'
      endif
c
999   continue
      return
      end
c----------------------------------------------------------------------
      subroutine dryi(zgrid1,ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040611                   DRYI
c                J. Scire, SRC
c
c --- PURPOSE:  Setup routine for dry deposition module.
c               Initialization and time-invariant calculations
c               performed.
c
c --- UPDATE
c --- V5.4 000602 - V5.73 040611
c                   (DGS): Rename NINT to NPSINT
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c --- MODIFICATION  6/26/96 (DGS): place an upper limit of 10 m on zref
c
c --- INPUTS:
c
c            ZGRID1 - real    - Height (m) of the lowest grid point
c                               (i.e., approx. 10 m)
c               LDB - logical - Flag determining if debug write
c                               statements are activated
c     Common Block /DRYGAS/ variables:
c        PDIFF(mxspec),ALPHAS(mxspec),REACT(mxspec),RM(mxspec),
c        HENRY(mxspec),RCUTR,RGR,REACTR,DCONST1,DCONST2,DCONST3
c     Common Block /DRYPART/ variables:
c        GDIAM(mxpdep),GSIG(mxpdep),RHO(mxpdep),NPSINT,DCONST4
c     Common Block /DRYDEP/ variables:
c        IDRYFLG(mxspec),ZREF
c     Common block /GEN/ variables
c           NSPEC, CSPEC(mxspec), NSDD
c     Parameters:
c        MXSPEC, MXPDEP, MXINT, IO6
c
c --- OUTPUT:
c     Common Block /DRYGAS/ variables:
c        PDIFF(mxspec),RM(mxspec),RCUTR,RGR,RGG(mxspec),RGW1(mxspec),
c        RCUT(mxspec),RD1(mxspec)
c     Common Block /DRYPART/ variables:
c        NSPART,PDIAM(mxint,mxpdep),SC23(mxint,mxpdep),
c        VGRAV(mxint,mxpdep),TSTOP(mxint,mxpdep),FRACT(mxint,mxpdep),
c        VAIRMS
c     Common Block /DRYDEP/ variables:
c        VDUSER(24,mxspec),NVDUSER
c
c --- DRYI called by:  SETUP
c --- DRYI calls:      VDP1, RDVD
c----------------------------------------------------------------------
c
c --- Include PARAMETERS
      include 'params.puf'
c
c --- Include common block /DRYGAS/  -- Gas Deposition
      include 'drygas.puf'
c
c --- Include common block /DRYPART/ -- Particle Deposition
      include 'drypart.puf'
c
c --- Include common block /DRYDEP/ -- Deposition mode flags
      include 'drydep.puf'
c
c --- Include common block /GEN/    -- General run flags
      include 'gen.puf'
c
      logical ldb
c
      data vair/0.15e-4/,vk/0.4/
c
      if(nspec.gt.mxspec)then
         write(io6,*)'ERROR in SUBR. VD1 -- NSPEC is too large -- ',
     1  'NSPEC = ',nspec,' MXSPEC = ',mxspec
         write(*,*)
         stop 'Halted in VD1 -- see list file.'
      endif
c
      if(npsint.gt.mxint)then
         write(io6,*)'ERROR in SUBR. VD1 -- NPSINT is too large -- ',
     1  'NPSINT = ',npsint,' MXINT = ',mxint
         write(*,*)
         stop 'Halted in VD1 -- see list file.'
      endif
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. VD1 -- INPUTS'
         write(io6,*)'IDRYFLG          = ',(idryflg(n),n=1,nspec)
         write(io6,*)'NSPEC            = ',nspec
         write(io6,*)'PDIFF (cm**2/s)  = ',(pdiff(n),n=1,nspec)
         write(io6,*)'ALPHAS           = ',(alphas(n),n=1,nspec)
         write(io6,*)'REACT            = ',(react(n),n=1,nspec)
         write(io6,*)'RM (s/cm)        = ',(rm(n),n=1,nspec)
         write(io6,*)'HENRY            = ',(henry(n),n=1,nspec)
         write(io6,*)'RCUTR (s/cm)     = ',rcutr,' RGR = ',rgr,
     1   ' REACTR = ',reactr
         write(io6,*)'DCONST1 = ',dconst1,' DCONST2 = ',dconst2,
     1   ' DCONST3 = ',dconst3
      endif
c ***
c
c --- Count the number of deposited species
      LL=0
      do 15 i=1,nspec
      if(idryflg(i).ge.1)then
         LL=LL+1
      endif
15    continue
c
c --- Number of deposited species must be <= total no. species
      if(LL.ne.nsdd)then
         write(io6,17)LL,nsdd,(idryflg(n),n=1,nspec)
17       format(/1x,'ERROR in subr. VD1 -- LL .NE. NSDD -- LL = ',i5,
     1   3x,'NSDD = ',i5,3x,'IDRYFLG = ',100i2)
         write(*,*)
         stop 'Halted in VD1 -- see list file.'
      endif
c
c --- Count the number of species with user-specified deposition
c --- velocities
      nvduser=0
      do 20 i=1,nspec
      if(idryflg(i).eq.3)then
         nvduser=nvduser+1
      endif
20    continue
c
c --- Read diurnal cycles of user-specified deposition velocities
c --- for pollutants flagged with IDRYFLG(i)=3
      call rdvd
c
      if(ldb)then
         write(io6,*)
         write(io6,*)'NVDUSER = ',nvduser
         do 133 i=1,nspec
         write(io6,132)i,cspec(i),(vduser(n,i),n=1,24)
132      format(1x,'NO.: ',i3,' Species: ',a12,2x,12f8.5/
     1                                        33x,12f8.5)
133      continue
      endif
c
c --- Convert length units of input deposition variables from cm to m
c
      do 10 i=1,nspec
c
c --- IDRYFLG -  Flags indicating which species are deposited
c                (0=no, 1=yes-gas, 2=yes-particle, 3=yes-user specified
c                deposition velocities)
      if(idryflg(i).eq.0.or.idryflg(i).eq.3)go to 10
c
c --- Pollutant diffusivity (cm**2/s to m**2/s)
      pdiff(i)=pdiff(i)*1.e-4
c
c --- Mesophyll resistance from s/cm to s/m
      rm(i)=rm(i)*1.e2
10    continue
c
c --- Reference cuticle resistance (s/cm to s/m)
      rcutr=rcutr*1.e2
c
c --- Reference ground resistance (s/cm to s/m)
      rgr=rgr*1.e2
c
c --- Set reference height to height of the
c --- lowest grid point
      zref=AMIN1(zgrid1,10.)
c
c --- Compute time-invariant parameters
      nspart=0
      do 110 i=1,nspec
      if(idryflg(i).eq.0.or.idryflg(i).eq.3)then
         go to 110
      else if(idryflg(i).eq.2)then
c
c ---    PARTICLE DEPOSITION
         nspart=nspart+1
         if(nspart.gt.mxpdep)then
            write(io6,*)'ERROR IN SUBR. VD1 -- Too many particle ',
     1      'species -- NSPART = ',nspart,' MXPDEP = ',mxpdep
            write(*,*)
            stop 'Halted in VD1 -- see list file.'
         endif
c
         call vdp1(gdiam(nspart),gsig(nspart),rho(nspart),npsint,
     1   dconst4,ldb,pdiam(1,nspart),sc23(1,nspart),vgrav(1,nspart),
     2   tstop(1,nspart),fract(1,nspart),vairms)
         go to 110
      endif
c
c --- GAS DEPOSITION
c
c --- Schmidt number = viscosity of air/(diffusivity of the pollutant)
c     (vair = viscosity of air at 20 deg. C = 0.15e-4 m**2/s)
      sc=vair/pdiff(i)
c
c --- Time-invariant term of deposition layer resistance
      rd1(i)=dconst1*sc**dconst2/vk
c
c --- Cuticle resistance
      ratio=reactr/react(i)
      rcut(i)=rcutr*ratio
c
c --- Ground resistance
      rgg(i)=rgr*ratio
c
c --- Time-invariant term of "ground" resistance to water
      rgw1(i)=henry(i)/(alphas(i)*dconst3)
110   continue
c
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. VD1 -- OUTPUT'
         write(io6,*)'PDIFF (m**2/s)  = ',(pdiff(n),n=1,nspec)
         write(io6,*)'RM (s/m)        = ',(rm(n),n=1,nspec)
         write(io6,*)'RCUTR (s/m)     = ',rcutr,' RGR = ',rgr
         write(io6,*)'RGG (s/m)       = ',(rgg(n),n=1,nspec)
         write(io6,*)'RGW1 (s/m)      = ',(rgw1(n),n=1,nspec)
         write(io6,*)'RCUT (s/m)      = ',(rcut(n),n=1,nspec)
         write(io6,*)'RD1 (s/m)       = ',(rd1(n),n=1,nspec)
         write(io6,*)'ZREF (m)        = ',zref
      endif
c ***
      return
      end
c----------------------------------------------------------------------
      subroutine vdp1(gdiam,gsig,rho,npsint,dconst4,ldb,pdiam,sc23,
     1 vgrav,tstop,fract,vairms)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040611                   VDP1
c                J. Scire, SRC
c
c --- PURPOSE:  Setup routine for PARTICLE dry deposition.
c               Initialization and time-invariant calculations
c               performed.
c
c --- UPDATE
c --- V5.4 000602 - V5.73 040611
c                   (DGS): Rename NINT to NPSINT
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- MODIFICATION  6/26/96 (DGS): put all mass into first size when
c                                  gsig is less than or equal to 1.0 um
c
c --- INPUTS:
c
c             GDIAM - real    - Geometric mass mean diameter (microns)
c              GSIG - real    - Geometric standard deviation of the
c                               distribution (microns)
c               RHO - real    - Particle density (g/cm**3)
c            NPSINT - integer - Number of size intervals used to
c                               evaluate the effective deposition
c                               velocity
c           DCONST4 - real    - Empirical constant in particle
c                               deposition layer resistance eqn.
c               LDB - logical - Flag determining if debug write
c                               statements are activated
c     Parameters:
c        IO6
c
c --- OUTPUT:
c       PDIAM(npsint) - real    - Geometric mean diameter (microns)
c                               of each interval
c      SC23(npsint) - real    - Schmidt number ** DCONST4
c     VGRAV(npsint) - real    - Gravitational settling velocity (m/s)
c     TSTOP(npsint) - real    - Stopping time (s)
c     FRACT(npsint) - real    - Mass fraction in each size interval
c            VAIRMS - real    - Viscosity of air (m**2/s)
c
c --- VDP1 called by:  DRYI
c --- VDP1 calls:      ERF
c----------------------------------------------------------------------
c
c --- Include PARAMETERS
      include 'params.puf'
c
      real pdiam(npsint),sc23(npsint),vgrav(npsint),tstop(npsint),
     &     fract(npsint)
      logical ldb
c
      save a1,a2,a3,xmfp,pi,vcon,xk,temp,vair,g
c
      data a1/1.257/,a2/0.4/,a3/0.55/,xmfp/6.5e-6/
      data pi/3.1415927/,vcon/1.81e-4/,xk/1.38e-16/
      data temp/293.15/
      data vair/0.15/,g/981./
c
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. VDP1 -- INPUTS'
         write(io6,*)'GDIAM (um)       = ',gdiam
         write(io6,*)'GSIG (um)        = ',gsig
         write(io6,*)'RHO (g/cm**3)    = ',rho
         write(io6,*)'DCONST4          = ',dconst4
         write(io6,*)'NPSINT           = ',npsint
      endif
c ***
      if(npsint.gt.1 .AND. gsig.GT.1.0)then
c
c ---    Setup size intervals from -4*sigma to +4*sigma from mean
         xincr=8.0/float(npsint)
c
c ---    Constant 1.414214 = sqrt(2)
         xtmp1=1.414214*alog(gsig)
c
c ---    DLOW is the diameter of the lower end of the interval
c        (set equal to DHIGH within loop)
         dhigh=gdiam*gsig**(-4)
      endif
c
c --- LOOP over "NPSINT" size intervals
      do 10 i=1,npsint
c
      if(npsint.gt.1 .AND. gsig.GT.1.0)then
         dlow=dhigh
c
c ---    DHIGH is the diameter of the high end of the interval
         dhigh=gdiam*gsig**(-4.+xincr*float(i))
c
c ---    Compute the area under the normal curve within this interval
         fract(i)=0.5*(erf(alog(dhigh/gdiam)/xtmp1)-
     1                 erf(alog(dlow/gdiam)/xtmp1))
c
c ---    Compute the geometric mean diameter (microns) of the interval
         pdiam(i)=exp(0.5*alog(dlow*dhigh))
c
      else if(npsint.eq.1)then
c
c ---    Only one size interval
         fract(i)=1.0
         pdiam(i)=gdiam
c
      else if(gsig.le.1.0)then
c ---    Only one effective particle size; put all mass in first
         fract(i)=0.0
         if(i.eq.1) fract(i)=1.0
         pdiam(i)=gdiam
c
      else
         write(io6,*)'ERROR in Subr. VDP1 -- Invalid value of NPSINT ',
     1   '-- NPSINT = ',npsint
         write(*,*)
         stop 'Halted in VDP1 -- see list file.'
      endif
c
c --- Slip correction factor
      diamcm=1.e-4*pdiam(i)
      scf=1.+2.0*xmfp*(a1+a2*exp(-a3*diamcm/xmfp))/diamcm
c
c --- Stokes friction coefficient
      sfc=3.*pi*vcon*diamcm/scf
c
c --- Diffusivity (cm**2/s)
      diff=xk*temp/sfc
c ***
      if(ldb)then
         write(io6,*)'i = ',i,' diamcm = ',diamcm,' scf = ',scf,
     1   ' sfc = ',sfc,' diff = ',diff
      endif
c ***
c
c --- schmidt number
c --- (vair = viscosity of air at 20 deg. c = 0.15 cm**2/s)
      sc23(i)=(vair/diff)**(-dconst4)
c
c --- gravitational settling velocity (m/s)
      vgrav(i)=0.01*rho*g*diamcm**2*scf/(18.*vcon)
c
c --- stopping times
      tstop(i)=vgrav(i)/(0.01*g)
10    continue
c
c --- convert viscosity of air (at 20. deg. c) from cm**2/s to m**2/s
      vairms=1.e-4*vair
c ***
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. VDP1 -- Outputs'
         write(io6,*)'PDIAM  = ',pdiam
         write(io6,*)'SC23   = ',sc23
         write(io6,*)'VGRAV  = ',vgrav
         write(io6,*)'TSTOP  = ',tstop
         write(io6,*)'FRACT  = ',fract
         write(io6,*)'VAIRMS = ',vairms
      endif
c ***
c
      return
      end
c----------------------------------------------------------------------
      subroutine exmet(iflag,ixs,iys,dgrid,tempk,qsw,irh,rhoair,
     &                 cc,czen)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                  EXMET
c                J. Scire, SRC
c
c --- PURPOSE:  Find the closest non-missing value of air temperature,
c               short-wave radiation, relative humidity, and air
c               density, cloud cover, and cosine of solar angle
c               to a particular grid point.
c               NOTE: if IFLAG = 1, only temperature is returned
c                     if IFLAG = 2, values for all six variables
c                                   are returned
c
c --- UPDATE
c --- V5.4-V5.7     030402  (FRR): Add 2D met arrays (i2dmet) of
c                                  RHO,QSW,RH,TEMP if
c                                  available in CALMET 
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.0     980304  (DGS): add clouds & sun angle
c
c --- INPUTS:
c            IFLAG - integer - Flag determining which variables are
c                              computed ( 1 ==> TEMPK only,
c                              2 ==> TEMP, QSW, IRH, RHOAIR)
c              IXS - integer - X index of the closest met. grid point
c                              to the puff/slug center
c              IYS - integer - Y index of the closest met. grid point
c                              to the puff/slug center
c            DGRID - real    - Grid spacing (m)
c
c     Common block /METHD/ variables:
c           NXM, NYM, NEARS(mxnx,mxny), XSSTA(mxss), YSSTA(mxss),
c           NSSTA, LCALGRD, I2DMET
c     Common block /METHR/ variables:
c           TMET(mxnx,mxny,mxnz), TEMPSS(mxss), RHOSS(mxss),
c           QSWSS(mxss), IRHSS(mxss), CCSS(mxss),CZENSS(mxss)
c frr (09/01)
c           TEMP2D(mxnx,mxny), RHO2D(mxnx,mxny),
c           QSW2D(mxnx,mxny), IRH2D(mxnx,mxny), CC2D(mxnx,mxny),
c           CZEN2D(mxnx,mxny)
c     Parameters:
c           MXNX, MXNY, MXNZ, MXSS, MXUS, MXPS, IO6
c
c --- OUTPUT:
c            TEMPK - real    - Air temperature (deg. K)
c              QSW - real    - Short-wave solar radiation (W/m**2)
c              IRH - integer - Relative humidity (percent)
c           RHOAIR - real    - Air density (kg/m**3)
c               CC - real    - Cloud cover (tenths)
c             CZEN - real    - Cosine of solar zenith angle
c
c --- EXMET called by:  COMP
c --- EXMET calls:      FINDR, FINDI
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      logical ldb2
c
      include 'methd.puf'
      include 'methr.puf'
c
c --- Missing value indicators for integer, real variables
      data imiss/9999/,xmiss/9999./
c
c --- Compute grid point coordinates (m) relative to met. grid origin
      xgrd=(float(ixs)-0.5)*dgrid
      ygrd=(float(iys)-0.5)*dgrid
c
c
c frr (09/01)- Use 2D arrays if available in CALMET
       if(i2dmet.EQ.1) then

          tempk=temp2d(ixs,iys)
          if(iflag.eq.2)then
            qsw=qsw2d(ixs,iys)
            irh=irh2d(ixs,iys)
            rhoair=rho2d(ixs,iys)
            cc=cc2d(ixs,iys)
            czen=czen2d(ixs,iys)
          else
c ---       Flag variables other than temperature as missing
            qsw=xmiss
            irh=imiss
            rhoair=xmiss
            cc=xmiss
            czen=xmiss
         endif

       elseif(i2dmet.EQ.0) then

c ---    ISTA is the surface met. stations closest to grid point (IXS,IYS)
         ista=nears(ixs,iys)
c
c ---    AIR TEMPERATURE (deg. K)
         if(lcalgrd)then
c ---    Use gridded temp. data, if available
            tempk=tmet(ixs,iys,1)
         else
c ---       Use air temp. at closest surface station
            tempk=tempss(ista)
c ---       Find temp. at nearest station with non-missing data
            if(tempk.ge.xmiss)then
               call findr(xssta,yssta,nssta,tempss,xgrd,ygrd,
     1          ista,tempk,ierr)
c
               if(ierr.eq.1)then
                  write(io6,*)'ERROR in subr. EXMET -- All surface ',
     1            'temp. data missing -- IERR = ',ierr
                  write(io6,*)'TEMPSS = ',(tempss(n),n=1,nssta)
                  write(*,*)
                  stop 'Halted in EXMET -- see list file.'
               endif
            endif
         endif
c
         if(iflag.eq.2)then
c
c ---       SHORT-WAVE RADIATION (W/m**2)
            qsw=qswss(ista)
            if(qsw.ge.xmiss)then
               call findr(xssta,yssta,nssta,qswss,xgrd,ygrd,
     1          ista,qsw,ierr)
c
               if(ierr.eq.1)then
                  write(io6,*)'ERROR in subr. EXMET -- All surface ',
     1            'short-wave radiation data missing -- IERR = ',ierr
                  write(io6,*)'QSWSS = ',(qswss(n),n=1,nssta)
                  write(*,*)
                  stop 'Halted in EXMET -- see list file.'
               endif
            endif
c
c ---       RELATIVE HUMIDITY (percent)
            irh=irhss(ista)
            if(irh.ge.imiss)then
               call findi(xssta,yssta,nssta,irhss,xgrd,ygrd,
     1          ista,irh,ierr)
c
               if(ierr.eq.1)then
                  write(io6,*)'ERROR in subr. EXMET -- All surface ',
     1            'relative humidity data missing -- IERR = ',ierr
                  write(io6,*)'IRHSS = ',(irhss(n),n=1,nssta)
                  write(*,*)
                  stop 'Halted in EXMET -- see list file.'
               endif
            endif
c
c ---       AIR DENSITY (kg/m**3)
            rhoair=rhoss(ista)
            if(rhoair.ge.xmiss)then
               call findr(xssta,yssta,nssta,rhoss,xgrd,ygrd,
     1          ista,rhoair,ierr)
c
               if(ierr.eq.1)then
                  write(io6,*)'ERROR in subr. EXMET -- All surface ',
     1            'air density data missing -- IERR = ',ierr
                  write(io6,*)'RHOSS = ',(rhoss(n),n=1,nssta)
                  write(*,*)
                  stop 'Halted in EXMET -- see list file.'
               endif
            endif
c
c ---       CLOUD COVER (tenths)
            cc=ccss(ista)
            if(cc.ge.xmiss)then
               call findr(xssta,yssta,nssta,ccss,xgrd,ygrd,
     1          ista,cc,ierr)
c
               if(ierr.eq.1)then
                  write(io6,*)'ERROR in subr. EXMET -- All surface ',
     1            'cloud cover data missing -- IERR = ',ierr
                  write(io6,*)'CCSS = ',(ccss(n),n=1,nssta)
                  write(*,*)
                  stop 'Halted in EXMET -- see list file.'
               endif
            endif
c
c ---       Cosine of solar zenith angle
            czen=czenss(ista)
            if(czen.ge.xmiss)then
               call findr(xssta,yssta,nssta,czenss,xgrd,ygrd,
     1              ista,czen,ierr)
c
               if(ierr.eq.1)then
                  write(io6,*)'ERROR in subr. EXMET -- All surface ',
     1            'solar zenth data missing -- IERR = ',ierr
                  write(io6,*)'CZENSS = ',(czenss(n),n=1,nssta)
                  write(*,*)
                  stop 'Halted in EXMET -- see list file.'                   
               endif
            endif
c
         else
c
c ---       Flag variables other than temperature as missing
            qsw=xmiss
            irh=imiss
            rhoair=xmiss
            cc=xmiss
            czen=xmiss
         endif
c
c*****
         ldb2=.false.
         if(ldb2)then
            write(io6,*)
            write(io6,*)'SUBR. EXMET -- iflag = ',iflag,' ixs = ',ixs,
     1      ' iys = ',iys,' dgrid = ',dgrid,' ista = ',ista
           write(io6,*)'tempk = ',tempk,' qsw = ',qsw,' irh = ',irh,
     1      ' rhoair = ',rhoair
            write(io6,*)'cc = ',cc,' czen = ',czen
         endif
c*****
      else
         write(*,*)'Subr. EXMET:  Invalid I2DMET = ',i2dmet
         stop
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine findr(xsta,ysta,nsta,dat,x,y,ista,value,ierr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900228                  FINDR
c                J. Scire, SRC
c
c --- PURPOSE:  Find the closest station to a specified (X,Y)
c               coordinate that has non-missing data and pass
c               the real variable at that station back to the
c               calling routine
c
c --- INPUTS:
c       XSTA(nsta) - real    - Array of X coordinates (m) for each
c                              station relative to the met. grid origin
c                              at (0., 0.)
c       YSTA(nsta) - real    - Array of Y coordinates (m) for each
c                              station relative to the met. grid origin
c                              at (0., 0.)
c             NSTA - integer - Number of stations
c        DAT(nsta) - real    - Values of the variable at each station
c                              (NOTE: 9999. used as a missing value
c                              indicator)
c                X - real    - Reference X coordinate (m)
c                Y - real    - Reference Y coordinate (m)
c
c --- OUTPUT:
c             ISTA - integer - Station number of closest station
c            VALUE - real    - Value of from DAT array for closest
c                              station "ISTA"
c             IERR - integer - Error code (0=no error, 1=all data
c                              missing, so VALUE = missing value
c                              indicator
c
c --- FINDR called by:  EXMET, GETOZ
c --- FINDR calls:      none
c----------------------------------------------------------------------
c
      real xsta(nsta),ysta(nsta),dat(nsta)
      data xmax/1.e38/,xmiss/9999./
c
      ista=0
      value=xmiss
      dmin2=xmax
c
      do 10 i=1,nsta
c
c --- Compute the (distance)**2 to each station with non-missing data
      if(dat(i).lt.xmiss)then
         dist2=(xsta(i)-x)**2+(ysta(i)-y)**2
c
c ---    Keep track of the closest station to the reference point
         if(dist2.lt.dmin2)then
            dmin2=dist2
            ista=i
         endif
      endif
10    continue
c
      if(ista.eq.0)then
         ierr=1
         go to 999
      endif
c
c --- Extract the value at closest station from the data array
      value=dat(ista)
      ierr=0
c
999   continue
      return
      end
c----------------------------------------------------------------------
      subroutine findi(xsta,ysta,nsta,idat,x,y,ista,ivalue,ierr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900228                  FINDI
c                J. Scire, SRC
c
c --- PURPOSE:  Find the closest station to a specified (X,Y)
c               coordinate that has non-missing data and pass
c               the integer variable at that station back to the
c               calling routine
c
c --- INPUTS:
c       XSTA(nsta) - real    - Array of X coordinates (m) for each
c                              station relative to the met. grid origin
c                              at (0., 0.)
c       YSTA(nsta) - real    - Array of Y coordinates (m) for each
c                              station relative to the met. grid origin
c                              at (0., 0.)
c             NSTA - integer - Number of stations
c       IDAT(nsta) - integer - Values of the variable at each station
c                              (NOTE: 9999 used as a missing value
c                              indicator)
c                X - real    - Reference X coordinate (m)
c                Y - real    - Reference Y coordinate (m)
c
c --- OUTPUT:
c             ISTA - integer - Station number of closest station
c           IVALUE - real    - Value of from IDAT array for closest
c                              station "ISTA"
c             IERR - integer - Error code (0=no error, 1=all data
c                              missing, so VALUE = missing value
c                              indicator
c
c --- FINDI called by:  EXMET
c --- FINDI calls:      none
c----------------------------------------------------------------------
c
      real xsta(nsta),ysta(nsta)
      integer idat(nsta)
      data xmax/1.e38/,imiss/9999/
c
      ista=0
      ivalue=imiss
c
      dmin2=xmax
c
      do 10 i=1,nsta
c
c --- Compute the (distance)**2 to each station with non-missing data
      if(idat(i).lt.imiss)then
         dist2=(xsta(i)-x)**2+(ysta(i)-y)**2
c
c ---    Keep track of the closest station to the reference point
         if(dist2.lt.dmin2)then
            dmin2=dist2
            ista=i
         endif
      endif
10    continue
c
      if(ista.eq.0)then
         ierr=1
         go to 999
      endif
c
c --- Extract the value at closest station from the data array
      ivalue=idat(ista)
      ierr=1
c
999   continue
      return
      end
c----------------------------------------------------------------------
      subroutine fin(itest)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 060329                    FIN
c ---            J. Scire, SRC
c
c --- PURPOSE:  Run termination routine -- compute runtime,
c               write last day processed
c
c --- UPDATE
c --- V6.1-V6.111   060329  (DGS): Revise text for last period time
c --- V5.721-V6.1   050915  (DGS): resolve times to the second and use
c                                  explicit begin-time/end-time format
c --- V5.7-V5.721   040503  (DGS): Add warning function (call WARN)
c --- V5.5-V5.7     030402  (DGS): Add list file unit to JULDAY call
c                                  Change rdate, rdate2 to include
c                                  YYYY format for year (MM-DD-YYYY)
c --- V5.0-V5.2     991104  (DGS): YYYY year format
c
c --- INPUTS:
c          ITEST - integer - Flag indicating if execution is to
c                            include COMPUTATIONAL phase
c                            (ITEST = 1 to STOP program and skip
c                                       the COMPUTATIONAL phase
c                             ITEST = 2 to CONTINUE execution to
c                                       include computations)
c       Common block /DATEHR/
c          nyrb, nmob, ndayb, njulb, nhrb, nsecb
c          nyre, nmoe, ndaye, njule, nhre, nsece
c       Common block /QA/
c          rdate, rtime, rcpu
c       Common block /OUTPT/
c          imesg
c       Parameters: IO6, IOMESG
c
c --- OUTPUT:  none
c
c --- FIN called by:  MAIN
c --- FIN calls:      DATETM, JULDAY, DELTT, YR4C, WARN
c----------------------------------------------------------------------
c
c --- include parameters
      include 'params.puf'
c
      character*8 rtime2
      character*10 rdate2
c
      include 'datehr.puf'
      include 'qa.puf'
      include 'outpt.puf'

c --- Process any warnings collected during the run
      call WARN('FIN         ',0.)
c
      write(iomesg,*)'TERMINATION PHASE'
c
c --- Write last day/hour processed
      if(ITEST.eq.2)then
         write(io6,5)nyre,nmoe,ndaye,njule,nhre,nsece
5        format(//2x,'LAST PERIOD PROCESSED ENDS AT:'/5x,
     1          '  Year: ',i4,2x,'Month: ',i2,3x,'Day: ',i2,3x,
     2          'Julian day: ',i3,3x,'Hour: ',i2,3x,'Second: ',i4)
      else
c
c ---    TEST mode -- COMPUTATIONAL phase skipped
         write(io6,12)
12       format(/1x,13('----------')//1x,
     1   'Completion of CALPUFF test mode run -- run terminating ',
     2   'normally'//1x,13('----------'))
      endif
c
c --- get system date & time at end of run
      call datetm(rdate2,rtime2,rcpu)
c
c --- compute runtime
      read(rtime(1:2),10)ihr1
      read(rtime(4:5),10)imin1
      read(rtime(7:8),10)isec1
10    format(i2)
      t1=ihr1*3600.+imin1*60.+isec1
c
      read(rtime2(1:2),10)ihr2
      read(rtime2(4:5),10)imin2
      read(rtime2(7:8),10)isec2
      t2=ihr2*3600.+imin2*60.+isec2
c
      if(rdate.eq.rdate2)then
         delt=t2-t1
      else
         read(rdate(1:2),10)imo1
         read(rdate(4:5),10)iday1
         read(rdate(7:10),'(i4)')iyr1
         call julday(io6,iyr1,imo1,iday1,ijul1)
c
         read(rdate2(1:2),10)imo2
         read(rdate2(4:5),10)iday2
         read(rdate2(7:10),'(i4)')iyr2
         call julday(io6,iyr2,imo2,iday2,ijul2)
c
c ---    compute no. hours from beg. of first hour of run to
c ---    ending hour of ending day of the run
         call deltt(iyr1,ijul1,ihr1,iyr2,ijul2,ihr2,idelhr)
c
c ---    adjust for minutes and seconds
         delt=idelhr*3600.-imin1*60.-isec1+imin2*60.+isec2
      endif

c --- On the PC, the runtime and CPU time are the same
c --- (DATETM provides RCPU = 0.0 on the PC)
      if(rcpu.EQ.0.0)rcpu=delt

c --- Report current date
      write(io6,1402)rtime2,rdate2,delt,rcpu
1402  format(//2x,'End of run -- Clock time: ',a8/
     1         2x,'                    Date: ',a10//
     2         2x,'      Elapsed Clock Time: ',f10.1,' (seconds)'//
     3         2x,'                CPU Time: ',f10.1,' (seconds)')
c
      return
      end
c----------------------------------------------------------------------
      subroutine met1(nx,ny,lecho,wrk1,nwork)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                   MET1
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Read header records of the CALMET meteorological
c               data file
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): Add 'dataset 2.1' file format, and
c                                  use c*16 variable VERCMET in new
c                                  /DATASET/ common to identify version.
c                                  (DVERSM not used).  Implement full
c                                  begin/end time processing.
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4 call
c                   030402  (DGS): Change (f6) to (f6.0)
c                   030402  (DGS): Add echo of CALMET control file (new
c                                  header format)
c                   030402  (DGS): Add DVERSM (dataset version) to 
c                                  /METHD/ and use throughout code to
c                                  identify CALMET.DAT format, and
c                                  compute I2DMET here
c --- V5.4-V5.5     010730  (JSS): include IWAT2 on list file output
c --- V5.4-V5.4     000602_4(DGS): pass base time zone into /METHD/
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c                   000602  (DGS): add version check for record '2a'
c --- V5.0-V5.2     991104  (DGS): YYYY year format
c --- V5.0-V5.0     990228a (DGS): add IEOF to RDR2D arguments
c --- V5.0-V5.0     980304  (DGS): accept new/old CALMET headers
c --- V4.0-V5.0     971107  (DGS): pass start-time from met file
c                                  for use if METRUN=1
c
c --- INPUTS:
c            NX - integer       - Number of X cells in meteorological
c                                 grid
c            NY - integer       - Number of Y cells in meteorological
c                                 grid
c         LECHO - logical       - Control variable for output of header
c                                 record information
c   WRK1(nwork) - real array    - Work array of length "NWORK" words
c         NWORK - integer       - Dimension of work arrays -- NOTE:
c                                 NWORK must be at least as large as
c                                 nx*ny
c
c     Common block /DATASET/ variables:
c           VERCMET
c     Parameters:
c           MXNZP1, MXSS, MXUS, MXPS, IO6
c
c --- OUTPUT:
c     Common block /METHD/ variables:
c           NXM, NYM, NZM, XGRIDM, XORIGM, YORIGM, XBTZM,
c           NSSTA, NPSTA, NLU, IWAT1, IWAT2, ZFACEM(mxnzp1),
c           XSSTA(mxss),YSSTA(mxss),XUSTA(mxus),YUSTA(mxus),
c           XPSTA(mxps),YPSTA(mxps),Z0(mxnx,mxny),ILANDU(mxnx,mxny),
c           ELEV(mxnx,mxny),XLAI(mxnx,mxny),NEARS(mxnx,mxny),
c           LCALGRD,
c           i2dmet, itimes
c           ibymet,ibmmet,ibdmet,ibjdmet,ibhmet,ibsmet
c           ieymet,iemmet,iedmet,iejdmet,iehmet,iesmet
c           levmet, llconfm, xlat1m, xlat2m, rlat0m, rlon0m
c           iutmznm,feastm,fnorthm,pmapm,datumm,datenm,utmhemm
c
c --- MET1 called by:  SETUP
c --- MET1 calls:      RDR1D, RDR2D, RDI2D, METQA, OUT, YR4
c                      INCR, GRDAY, JULDAY
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common block /METHD/ -- CALMET header record data
      include 'methd.puf'
c --- Include common block /DATASET/  -- Input file dataset version
      include 'dataset.puf'
c
      real wrk1(nwork)
      character*80 title(3)
      character*70 messag
      character*8 vermet,clab1,clab2
      character*8 clabexp,clabex1,clabex2
      logical ldate,lecho

c --- Control for printing entire CALMET control file
      logical lmetcf

c --- Local Variables
      character*8 axbtzm
      character*16 dataset,dataver
      character*33 blank33
      character*64 datamod
      character*80 doc1
      character*132 comment1,blank

      data ldate/.false./
      data lmetcf/.false./
      data blank33/'                                 '/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

      if(lecho) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'CALMET Control file information:'
         write(io6,*)'--------------------------------'
         write(io6,*)
      endif

c --- Set dataset version as a real  (not currently used)
      read(vercmet,'(f16.0)') dversm

c --- Read records
c ----------------
c
      if(vercmet.EQ.'2.1') then
c ---   Dataset 2.1 with comment records and begin/end times
c ----------------------------------------------------------
        itimes=1
        i2dmet=1
c
c ---   Record #1 - File Declaration -- 24 words
        read(io7) dataset,dataver,datamod
        if(lecho) write(io6,'(2a16,a64)') dataset,dataver,datamod
c
c ---   Record #2 - Number of comment lines -- 1 word
        read(io7) ncom
c ---   Loop over comment records
        do i=1,ncom
          comment1=blank
          read(io7) comment1
          if(i.EQ.1) then
c ---       Save model version line
            doc1=comment1(1:80)
          elseif(i.LE.4) then
c ---       Save 3 title lines
            title(i-1)=comment1(1:80)
          endif
          if(lmetcf) write(io6,*) comment1
        enddo
        if(lecho .AND. .NOT.lmetcf) then
           write(io6,*)
           write(io6,*) doc1
           write(io6,*) title(1)
           write(io6,*) title(2)
           write(io6,*) title(3)
           write(io6,*)
        endif
c
c ---   record #NCOM+3 - run control parameters -- 39 words
        read(io7) ibymet,ibmmet,ibdmet,ibhmet,ibsmet,
     1            ieymet,iemmet,iedmet,iehmet,iesmet,
     2            axbtzm,irlgmet,irtype,
     3   nxm, nym, nzm, xgridm, xorigm, yorigm, iwfcod, nssta,
     4   nusta, npsta, nowsta, nlu, iwat1, iwat2, lcalgrd,
     5   pmapm,datumm,datenm,feastm,fnorthm,utmhemm,iutmznm,
     6   rnlat0m,relon0m,xlat1m,xlat2m

        call YR4(io6,ibymet,ierrb)
        call YR4(io6,ieymet,ierre)
        if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in MET1'

        call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
        call JULDAY(io6,ieymet,iemmet,iedmet,iejdmet)

c ---   Process character AXBTZM into real XBTZM
        call UTCBASR(axbtzm,xbtzm)

        rlat0m=rnlat0m
        rlon0m=-relon0m

      elseif(vercmet.EQ.'2.0') then
c ---   Dataset 2.0 with comment records
c --------------------------------------
        itimes=0
        i2dmet=1
c
c ---   Record #1 - File Declaration -- 24 words
        read(io7) dataset,dataver,datamod
        if(lecho) write(io6,'(2a16,a64)') dataset,dataver,datamod
c
c ---   Record #2 - Number of comment lines -- 1 word
        read(io7) ncom
c ---   Loop over comment records
        do i=1,ncom
          comment1=blank
          read(io7) comment1
          if(i.EQ.1) then
c ---       Save model version line
            doc1=comment1(1:80)
          elseif(i.LE.4) then
c ---       Save 3 title lines
            title(i-1)=comment1(1:80)
          endif
          if(lmetcf) write(io6,*) comment1
        enddo
        if(lecho .AND. .NOT.lmetcf) then
           write(io6,*)
           write(io6,*) doc1
           write(io6,*) title(1)
           write(io6,*) title(2)
           write(io6,*) title(3)
           write(io6,*)
        endif
c
c ---   record #NCOM+3 - run control parameters -- 37 words
        read(io7) ibymet,ibmmet,ibdmet,ibhmet,ibtzm,irlgmet,irtype,
     1   nxm, nym, nzm, xgridm, xorigm, yorigm, iwfcod, nssta,
     2   nusta, npsta, nowsta, nlu, iwat1, iwat2, lcalgrd,
     3   pmapm,datumm,datenm,feastm,fnorthm,utmhemm,iutmznm,
     4   rnlat0m,relon0m,xlat1m,xlat2m

        call YR4(io6,ibymet,ierrb)
        if(ierrb.NE.0) stop 'Halted in MET1'

c ---   Place integer IBTZM into real XBTZM
        xbtzm=FLOAT(ibtzm)

        rlat0m=rnlat0m
        rlon0m=-relon0m

c ---   Convert start time from end to beginning of first hour
        call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
        call INCR(io6,ibymet,ibjdmet,ibhmet,-1)
        call GRDAY(io6,ibymet,ibjdmet,ibmmet,ibdmet)
        ibsmet=0
c ---   Find end of run (irlgmet is integer hours)
        ieymet=ibymet
        iemmet=ibmmet
        iedmet=ibdmet
        iejdmet=ibjdmet
        iehmet=ibhmet
        call INCR(io6,ieymet,iejdmet,iehmet,irlgmet)
        call GRDAY(io6,ieymet,iejdmet,iemmet,iedmet)
        iesmet=0

      else
c ---   Read older CALMET header records
c --------------------------------------
        itimes=0
        i2dmet=0
c
c ---   record #1 - run title -- 60 words
        read(io7)title
c
c ---   record #2 - run control parameters -- 26 words
c ---   (vermet, levmet are both 8 bytes)
        read(io7)vermet,levmet,ibymet,ibmmet,ibdmet,ibhmet,ibtzm,
     1   irlgmet,irtype,nxm, nym, nzm, xgridm, xorigm, yorigm,
     2   iutmznm, iwfcod, nssta, nusta, npsta, nowsta, nlu, iwat1,
     3   iwat2, lcalgrd

        if(lecho) then
           write(io6,104)vermet,levmet
104        format(1x,'CALMET Version: ',a8,3x,'Level: ',a8)
        endif

c ---   Place integer IBTZM into real XBTZM
        xbtzm=FLOAT(ibtzm)

c ---   Enforce YYYY format
        call YR4(io6,ibymet,ierrb)
        if(ierrb.NE.0) then
           write(*,*)
           stop 'Halted in MET1'
        endif
c
c ---   New record -- #3 - additional run control data -- 8 words
c ---   Null values are assigned in block data
c ---   This record was introduced in CALMET Version 5.0 (980304)
        if(vercmet.EQ.'1.5') then
           read(io7)xlat0m,xlon0m,llconfm,conecm,xlat1m,xlat2m,
     &              rlat0m,rlon0m
        endif
c
c ---   Recast map projection information
        if(LLCONFM) then
           pmapm='LCC     '
        else
           pmapm='UTM     '
           UTMHEMM='N   '
           if(xlat0m.LT.0.) UTMHEMM='S   '
        endif
c ---   Set datum to unknown
        datumm='unknown'

c ---   Convert start time from end to beginning of first hour
        call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
        call INCR(io6,ibymet,ibjdmet,ibhmet,-1)
        call GRDAY(io6,ibymet,ibjdmet,ibmmet,ibdmet)
        ibsmet=0
c ---   Find end of run (irlgmet is integer hours)
        ieymet=ibymet
        iemmet=ibmmet
        iedmet=ibdmet
        iejdmet=ibjdmet
        iehmet=ibhmet
        call INCR(io6,ieymet,iejdmet,iehmet,irlgmet)
        call GRDAY(io6,ieymet,iejdmet,iemmet,iedmet)
        iesmet=0

      endif
c
      if(LECHO)then
         write(io6,*)
         write(io6,*)
         write(io6,*)'-- Data begin at:'
         write(io6,*)' IBYR    = ',ibymet
         write(io6,*)' IBMO    = ',ibmmet
         write(io6,*)' IBDY    = ',ibdmet
         write(io6,*)' IBHR    = ',ibhmet
         write(io6,*)' IBSEC   = ',ibsmet
         write(io6,*)'-- Data end at:'
         write(io6,*)' IEYR    = ',ieymet
         write(io6,*)' IEMO    = ',iemmet
         write(io6,*)' IEDY    = ',iedmet
         write(io6,*)' IEHR    = ',iehmet
         write(io6,*)' IESEC   = ',iesmet
         write(io6,*)
         write(io6,*)' XBTZM   = ',xbtzm
         write(io6,*)' IRLG    = ',irlgmet
         write(io6,*)' IRTYPE  = ',irtype
         write(io6,*)' LCALGRD = ',lcalgrd
         write(io6,*)' PMAP    = ',pmapm
         write(io6,*)' DATUM   = ',datumm
         write(io6,*)' NIMADATE= ',datenm
         write(io6,*)' FEASTM  = ',feastm
         write(io6,*)' FNORTHM = ',fnorthm
         if(PMAPM.EQ.'UTM     ') then
            write(io6,*)' IUTMZN  = ',iutmznm
            write(io6,*)' UTMHEM  = ',utmhemm
         else
            write(io6,*)' XLAT1M  = ',xlat1m
            write(io6,*)' XLAT2M  = ',xlat2m
            write(io6,*)' RLAT0M  = ',rlat0m
            write(io6,*)' RLON0M  = ',rlon0m
         endif
         write(io6,*)' NXM     = ',nxm
         write(io6,*)' NYM     = ',nym
         write(io6,*)' NZM     = ',nzm
         write(io6,*)' XGRIDM  = ',xgridm
         write(io6,*)' XORIGM  = ',xorigm
         write(io6,*)' YORIGM  = ',yorigm
         write(io6,*)' IWFCOD  = ',iwfcod
         write(io6,*)' NSSTA   = ',nssta
         write(io6,*)' NUSTA   = ',nusta
         write(io6,*)' NPSTA   = ',npsta
         write(io6,*)' NOWSTA  = ',nowsta
         write(io6,*)' NLU     = ',nlu
         write(io6,*)' IWAT1   = ',iwat1
         write(io6,*)' IWAT2   = ',iwat2

      endif
c
c --- Check that enough workspace has been allocated
      nec=nxm*nym
      if(nwork.lt.nec)then
         write(io6,*)'ERROR in subr. MET1 -- insufficient workspace ',
     1   'allocated to work arrays -- Allocated (NWORK) = ',nwork,
     2   '   Required (NEC) = ',nec
         write(*,*)
         stop 'Halted in MET1 -- see list file.'
      endif
c
      nzmp1=nzm+1
      if(mxnzp1.lt.nzmp1)then
         write(io6,*)'ERROR in subr. MET1 -- dimension of ZFACEM ',
     1   'array is too small for no. layers in MET file'
         write(io6,*)'MXNZP1 = ',mxnzp1,' NZMP1 = ',nzmp1
         write(*,*)
         stop 'Halted in MET1 -- see list file.'
      endif

c -------------------------------------
c
c --- record #NCOM+4 - cell face heights (NZ + 1 words)
      call rdr1d(io7,itimes,zfacem,nzmp1,clab1,idum,idum,idum,idum)
c
      if(LECHO)then
         write(io6,203)(zfacem(n),n=1,nzmp1)
203      format(1x,'ZFACEM  = ',10(f9.3,', ')/)
      endif
c
c --- Check that record label matches expected label
      if(clab1.ne.'ZFACE')then
         clabexp='ZFACE'
         go to 999
      endif
c -------------------------------------
c
c ************************************************
c --- Perform QA checks on header record variables
c ************************************************
      call metqa

      nums=nssta+nusta+npsta
      if(lecho .AND. nums.GT.0) then
         write(io6,*)'Met Station Locations (Met Grid meters)'
      endif
c
c --- records #NCOM+5 & 6 - x, y coordinates of surface stations
c --- (NSSTA words each record)
      if(nssta.gt.0)then
         call rdr1d(io7,itimes,xssta,nssta,clab1,idum,idum,idum,idum)
         call rdr1d(io7,itimes,yssta,nssta,clab2,idum,idum,idum,idum)
         if(LECHO)then
            write(io6,*)clab1,' = ',(xssta(n),n=1,nssta)
            write(io6,*)clab2,' = ',(yssta(n),n=1,nssta)
         endif
c
c ---    Check that record labels matches expected labels
         if(clab1.ne.'XSSTA'.or.clab2.ne.'YSSTA')then
            clabex1='XSSTA'
            clabex2='YSSTA'
            go to 1999
         endif
      endif
c -------------------------------------
c
c --- records #NCOM+7 & 8 - x, y coordinates of upper air stations
c --- (NUSTA words each record)
      if(nusta.gt.0)then
         call rdr1d(io7,itimes,xusta,nusta,clab1,idum,idum,idum,idum)
         call rdr1d(io7,itimes,yusta,nusta,clab2,idum,idum,idum,idum)
         if(LECHO)then
            write(io6,*)clab1,' = ',(xusta(n),n=1,nusta)
            write(io6,*)clab2,' = ',(yusta(n),n=1,nusta)
         endif
c
c ---    Check that record labels matches expected labels
         if(clab1.ne.'XUSTA'.or.clab2.ne.'YUSTA')then
            clabex1='XUSTA'
            clabex2='YUSTA'
            go to 1999
         endif
      endif
c -------------------------------------
c
c --- records #NCOM+9 & 10 - x, y coordinates of precipitation stations
c --- (NPSTA words each record)
      if(npsta.gt.0)then
         call rdr1d(io7,itimes,xpsta,npsta,clab1,idum,idum,idum,idum)
         call rdr1d(io7,itimes,ypsta,npsta,clab2,idum,idum,idum,idum)
         if(LECHO)then
            write(io6,*)clab1,' = ',(xpsta(n),n=1,npsta)
            write(io6,*)clab2,' = ',(ypsta(n),n=1,npsta)
         endif
c
c ---    Check that record labels matches expected labels
         if(clab1.ne.'XPSTA'.or.clab2.ne.'YPSTA')then
            clabex1='XPSTA'
            clabex2='YPSTA'
            go to 1999
         endif
      endif
c -------------------------------------
c
c --- record #NCOM+11 - surface roughness lengths (NX * NY words)
      call rdr2d(io7,itimes,z0,wrk1,mxnx,mxny,nx,ny,clab1,
     &           idum,idum,idum,idum,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'MET1: Unexpected EOF in CALMET header'
      endif
      if(LECHO)then
         messag='Surface roughness lengths (m)'
         messag(63:70)=clab1
         call out(z0,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- Check that record label matches expected label
      if(clab1.ne.'Z0')then
         clabexp='Z0'
         go to 999
      endif
c -------------------------------------
c
c --- record #NCOM+12 - land use categories (NX * NY words)
      call rdi2d(io7,itimes,ilandu,wrk1,mxnx,mxny,nx,ny,clab1,
     &           idum,idum,idum,idum)
      if(LECHO)then
         messag='Land use categories'
         messag(63:70)=clab1
         call out(xdum,ilandu,2,5,ldate,messag,nx,ny)
      endif
c
c --- Check that record label matches expected label
      if(clab1.ne.'ILANDU')then
         clabexp='ILANDU'
         go to 999
      endif
c -------------------------------------
c
c --- record #NCOM+13 - elevations (NX * NY words)
      call rdr2d(io7,itimes,elev,wrk1,mxnx,mxny,nx,ny,clab1,
     &          idum,idum,idum,idum,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'MET1: Unexpected EOF in CALMET header'
      endif
      if(LECHO)then
         messag='Terrain heights (m)'
         messag(63:70)=clab1
         call out(elev,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- Check that record label matches expected label
      if(clab1.ne.'ELEV')then
         clabexp='ELEV'
         go to 999
      endif
c -------------------------------------
c
c --- record #NCOM+14 - leaf area index (NX * NY words)
      call rdr2d(io7,itimes,xlai,wrk1,mxnx,mxny,nx,ny,clab1,
     &           idum,idum,idum,idum,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'MET1: Unexpected EOF in CALMET header'
      endif
      if(LECHO)then
         messag='Leaf area index'
         messag(63:70)=clab1
         call out(xlai,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- Check that record label matches expected label
      if(clab1.ne.'XLAI')then
         clabexp='XLAI'
         go to 999
      endif
c -------------------------------------
c
c --- record #NCOM+15 - nearest surface station to each grid point
c                  (NX * NY words)
c frr (09/01)
      if (nssta.ge.1) then
         call rdi2d(io7,itimes,nears,wrk1,mxnx,mxny,nx,ny,clab1,
     &              idum,idum,idum,idum)
         if(LECHO)then
           messag='Nearest surface station no. to each grid point'
           messag(63:70)=clab1
           call out(xdum,nears,2,5,ldate,messag,nx,ny)
         endif
c
c ---    Check that record label matches expected label
         if(clab1.ne.'NEARS')then
            clabexp='NEARS'
            go to 999
         endif

      endif

c -------------------------------------
c
      return
c
c --- Write error messages -- incorrect record label read
999   continue
      write(io6,1001)clab1,clabexp
1001  format(/1x,'ERROR in subr. MET1 -- incorrect record label ',
     1 'read from MET data file'//1x,'Label read     = ',a8/
     2                               1x,'Label expected = ',a8)
      write(*,*)
      stop 'Halted in MET1 -- see list file.'
1999  continue
      write(io6,2001)clab1,clab2,clabex1,clabex2
2001  format(/1x,'ERROR in subr. MET1 -- incorrect record label ',
     1 'read from MET data file'//
     2 1x,'Labels read     = ',a8,2x,a8/
     3 1x,'Labels expected = ',a8,2x,a8)
      write(*,*)
      stop 'Halted in MET1 -- see list file.'
c
      end
c----------------------------------------------------------------------
      subroutine metqa
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 060412                  METQA
c                J. Scire, SRC
c
c --- PURPOSE:  Perform consistency checks of data read from the
c               CALMET header records with control file inputs
c
c --- UPDATE
c --- V6.1-V6.112   060412  (DGS): remove check on time that improperly
c                                  stopped run with multiple CALMET
c                                  files
c --- V5.71-V6.1    050915  (DGS): add time begin/end checks
c                                  resolved to seconds
c --- V5.7-V5.71    030528  (DGS): remove old UTM check that does
c                                  not screen out PMAP.NE.UTM cases
c --- V5.4-V5.7     030402  (DGS): add map projection and datum
c --- V5.4-V5.4     000602_4(DGS): add base time zone check
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c     Common block /DATEHR/ variables:
c           XBTZ
c     Common block /GEN/ variables:
c           IBDATHR, IBSEC, IEDATHR, IESEC, METFM, METRUN
c     Common block /GRID/ variables:
c           NX, NY, NZ, DGRID, XORIG, YORIG, ZFACE(mxnzp1)
c     Common block /MAP/ variables:
c           lutm,llcc,lps,lem,llaza,lttm,
c           iutmzn,feast,fnorth,
c           rlat0,rlon0,xlat1,xlat2,
c           pmap,utmhem,datum,daten
c     Common block /METHD/ variables:
c           NXM, NYM, NZM, XGRIDM, XORIGM, YORIGM, XBTZM,
c           NSSTA, NUSTA, NPSTA, ZFACEM(mxnzmp1)
c           iutmznm,feastm,fnorthm,
c           rlat0m,rlon0m,xlat1m,xlat2m,
c           pmapm,utmhemm,datumm,
c           dversm
c     Parameters:
c           MXNZP1, MXNZMP1, MXSS, MXUS, MXPS, IO6
c
c --- OUTPUT:
c         none
c
c --- METQA called by:  MET1, MET2, MET3, MET4
c --- METQA calls:      LRSAME, TPERIOD
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'datehr.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'map.puf'
      include 'methd.puf'

      logical lrsame

c --- Initialize error flags
      ierr=0
      iwarn=0

c --- Check for missing base time zone (met file) and replace with
c --- CALPUFF base time zone
      if(xbtzm.LT.-900.) then
         xbtzm=xbtz
         iwarn=1
         write(io6,*)
         write(io6,*)'WARNING  subr. METQA -- Unknown Time Zone'
         write(io6,*)'  Met file does not indicate time zone of data'
         write(io6,*)'  CALPUFF assumes met data are Time Zone ',xbtz
         write(io6,*)
      endif

c --- No. X, Y grid cells
      if(nx.ne.nxm)then
         write(io6,102)
102      format(/1x,'ERROR in subr. METQA -- MET header record ',
     1   'data is inconsistent with the control file input')
         write(io6,*)'NX = ',nx,' NXM = ',nxm
         ierr=1
      endif
      if(ny.ne.nym)then
         write(io6,102)
         write(io6,*)'NY = ',ny,' NYM = ',nym
         ierr=1
      endif
      if(nz.ne.nzm)then
         write(io6,102)
         write(io6,*)'NZ = ',nz,' NZM = ',nzm
         ierr=1
      endif
c
c --- Vertical face heights
      nzp1=nz+1
      do 35 i=1,nzp1
      if(abs(zface(i)-zfacem(i)).gt.0.1)then
         write(io6,102)
         write(io6,*)'I         = ',i
         write(io6,*)'ZFACE(i)  = ',zface(i)
         write(io6,*)'ZFACEM(i) = ',zfacem(i)
         ierr=1
      endif
35    continue
c
c --- Grid size
      if(abs(xgridm-dgrid).gt.0.1)then
         write(io6,102)
         write(io6,*)'DGRID = ',dgrid,' XGRIDM = ',xgridm
         ierr=1
      endif
c
c --- Grid reference coordinates
      if(abs(xorigm-xorig).gt.1.0)then
         write(io6,102)
         write(io6,*)'XORIG = ',xorig,' XORIGM = ',xorigm
         ierr=1
      endif
      if(abs(yorigm-yorig).gt.1.0)then
         write(io6,102)
         write(io6,*)'YORIG = ',yorig,' YORIGM = ',yorigm
         ierr=1
      endif
c
c --- MXSS in CALPUFF parameter file must be at least as large as
c     the number of surface stations used in the CALMET run
      if(nssta.gt.mxss)then
         write(io6,106)nssta,mxss
106      format(/1x,'ERROR in subr. METQA -- NSSTA read from ',
     1   'MET header record is greater than MXSS in the CALPUFF ',
     2   'parameter file'/1x,'NSSTA = ',i6,3x,'MXSS = ',i6)
         ierr=1
      endif
      if(nusta.gt.mxus)then
         write(io6,116)nusta,mxus
116      format(/1x,'ERROR in subr. METQA -- NUSTA read from ',
     1   'MET header record is greater than MXUS in the CALPUFF ',
     2   'parameter file'/1x,'NUSTA = ',i6,3x,'MXUS = ',i6)
         ierr=1
      endif
      if(npsta.gt.mxps)then
         write(io6,126)npsta,mxps
126      format(/1x,'ERROR in subr. METQA -- NPSTA read from ',
     1   'MET header record is greater than MXPS in the CALPUFF ',
     2   'parameter file'/1x,'NPSTA = ',i6,3x,'MXPS = ',i6)
         ierr=1
      endif
c
c --- Base time zone
      if(xbtzm.ne.xbtz)then
         write(io6,102)
         write(io6,*)'XBTZ(control file) = ',xbtz
         write(io6,*)'IBTZM(Met file)    = ',xbtzm
         ierr=1
      endif

c --- Projection checks
      if(pmapm.NE.pmap) then
         write(io6,102)
         write(io6,*)'         Map projection PMAP does not match'
         write(io6,*)'         Met file    : ',pmapm
         write(io6,*)'         Control file: ',pmap
         ierr=1
      endif
      if(LUTM) then
         if(iutmznm.NE.iutmzn)then
            write(io6,102)
            write(io6,*)'         UTM zone does not match'
            write(io6,*)'         Met file    : ',iutmznm
            write(io6,*)'         Control file: ',iutmzn
            ierr=1
         endif
         if(utmhemm.NE.utmhem)then
            write(io6,102)
            write(io6,*)'         UTM Hemisphere does not match'
            write(io6,*)'         Met file    : ',utmhemm
            write(io6,*)'         Control file: ',utmhem
            ierr=1
         endif
      else
c ---    Check false origin variables
         if(.not.LRSAME(0.0001,feastm,feast))then
            write(io6,102)
            write(io6,*)'         FEAST does not match'
            write(io6,*)'         Met file    : ',feastm
            write(io6,*)'         Control file: ',feast
            ierr=1
         endif
         if(.not.LRSAME(0.0001,fnorthm,fnorth))then
            write(io6,102)
            write(io6,*)'         FNORTH does not match'
            write(io6,*)'         Met file    : ',fnorthm
            write(io6,*)'         Control file: ',fnorth
            ierr=1
         endif
c ---    Check lat/lon variables
         if(.not.LRSAME(0.0001,rlat0m,rlat0))then
            write(io6,102)
            write(io6,*)'         RLAT0 does not match'
            write(io6,*)'         Met file    : ',rlat0m
            write(io6,*)'         Control file: ',rlat0
            ierr=1
         endif
         if(.not.LRSAME(0.0001,rlon0m,rlon0))then
            write(io6,102)
            write(io6,*)'         RLON0 does not match'
            write(io6,*)'         Met file    : ',rlon0m
            write(io6,*)'         Control file: ',rlon0
            ierr=1
         endif
         if(LLCC) then
            if(.not.LRSAME(0.0001,xlat1m,xlat1))then
               write(io6,102)
               write(io6,*)'         XLAT1 does not match'
               write(io6,*)'         Met file    : ',xlat1m
               write(io6,*)'         Control file: ',xlat1
               ierr=1
            endif
            if(.not.LRSAME(0.0001,xlat2m,xlat2))then
               write(io6,102)
               write(io6,*)'         XLAT2 does not match'
               write(io6,*)'         Met file    : ',xlat2m
               write(io6,*)'         Control file: ',xlat2
               ierr=1
            endif
         endif
      endif

c --- DATUM
      if(dversm.LT.1.) then
c ---    Assign CALPUFF datum to met datumm
         datumm=datum
         iwarn=1
         write(io6,*)
         write(io6,*)'WARNING  subr. METQA -- Unknown DATUM'
         write(io6,*)'  Met file does not indicate DATUM of data'
         write(io6,*)'  CALPUFF assumes met DATUM is ',datum
         write(io6,*)
      elseif(datumm.NE.datum)then
         write(io6,102)
         write(io6,*)'         DATUM does not match'
         write(io6,*)'         Met file    : ',datumm
         write(io6,*)'         Control file: ',datum
         ierr=1
      endif

c --- 060412:  remove this check as it is not configured for multiple
c ---          met files, and check made on data records should catch
c ---          problems
cc --- Met data must not start after beginning of simulation
c      if(metrun.EQ.0) then
c         kdathr=ibymet*100000+ibjdmet*100+ibhmet
c         call TPERIOD(1,kdathr,ibsmet,ibdathr,ibsec,iedathr,iesec,iloc)
c         if(iloc.NE.-1) then
c            ierr=1
c            write(io6,*)
c            write(io6,*)'ERROR in subr. METQA -- Met data begin late'
c            write(io6,*)'     Start of simulation: ',ibdathr,ibsec
c            write(io6,*)'     Start of met data  : ',kdathr,ibsmet
c         endif
c      endif
c
cc --- Check end of met data when ITIMES.NE.0, or when using CALMET data
c      if(metrun.EQ.0 .AND. (itimes.NE.0 .OR. metfm.EQ.1)) then
c         kdathr=ieymet*100000+iejdmet*100+iehmet
c         call TPERIOD(-1,kdathr,iesmet,ibdathr,ibsec,iedathr,iesec,iloc)
c         if(iloc.NE.1) then
c            write(io6,*)
c            write(io6,*)'WARNING  subr. METQA -- Met data end early'
c            write(io6,*)'     End of simulation: ',iedathr,iesec
c            write(io6,*)'     End of met data  : ',kdathr,iesmet
c            write(io6,*)
c         endif
c      endif

c --- Warning notice
      if(iwarn.eq.1) then
         write(*,*)
         write(*,*)'METQA WARNINGS are generated!'
         write(*,*)'Review messages written to the list file'
         write(*,*)
      endif

c --- Stop execution if any errors encountered
      if(ierr.eq.1) then
         write(*,*)
         stop 'Halted in METQA -- see list file.'
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine rdmet(idathrm,isecm,wrk1,nwork,lecho,umet,vmet,tmet,
     1 ipgt,htmix,ustar,xmonin,wstar,rmm,tempss,rhoss,qswss,irhss,
     2 ipcode,temp2d,rho2d,qsw2d,irh2d,ipcode2d,kdathre,ksece,kdathrb,
     3 ksecb,wdiv)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 060412                  RDMET
c                J. Scire, SRC
c
c --- PURPOSE:  Read CALMET meteorological data for one hour
c
c --- UPDATE
c --- V6.1-V6.112   060412  (DGS): add message to "stop" when checking
c                                  for expected time period
c --- V5.7-V6.1     050915  (DGS): allow for begin/end time format
c                                  resolved to seconds, and YYYY
c                                  format used for year (retain
c                                  compatibility with older CALMET)
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4 call
c                   030119  (FRR): bug fix to make sure ipcode2d data
c                                  is read in when npsta=-1
c
c ---               090101  (FRR): read CALMET records V5.3, level 010901
c frr (09/01)
c ---  Different format after CALMET version V5.3 - Level 010901
c ---  NOOBS mode allowed (no upper and possibly no surface stations)
c ---  2D records of sf Temp, RH, IPCODE, RHO, QS (previously 1-D)
c ---  Precipitation data if NPSTA>0 or NPSTA=-1 (prognostic rain data)
c ---
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): YYYY format used for year
c --- V5.0-V5.0     990228a (DGS): add IEOF to RDR2D arguments and add
c                                  NEXTFIL to open next CALMET file
c --- V5.0-V5.0     990228  (DGS): correct dimension in call to RDR2D
c                                  for w-field
c --- V4.0-V5.0     971107  (DGS): store w for vertical divergence field
c                   971107  (DGS): add record-skip logic from COMP to
c                                  find current date-time
c
c --- INPUTS:
c       IDATHRM - integer       - Mid-pt date/hour of required
c                                 data (YYYYJJJHH)
c         ISECM - integer       - Mid-pt second of required data (SSSS)
c   WRK1(nwork) - real array    - Work array of length "NWORK" words
c         NWORK - integer       - Dimension of work array -- NOTE:
c                                 NWORK must be at least as large as
c                                 the max. of (NXM * NYM or NSSTA)
c         LECHO - logical       - Flag controlling printing of input
c                                 meteorological data fields
c    Common block /METHD/ variables:
c         NXM, NYM, NZM, NSSTA, NPSTA, LCALGRD, I2DMET, ITIMES
c    Parameters:
c         MXNZMP1, IO6
c
c --- OUTPUT:
c
c   UMET(mxnx,mxny,mxnz) - real    - U component of the wind (m/s)
c                                    at each grid point
c   VMET(mxnx,mxny,mxnz) - real    - V-component of the wind (m/s)
c   TMET(mxnx,mxny,mxnz) - real    - 3-D temperature field (deg. K)
c        IPGT(mxnx,mxny) - integer - PGT stability class
c       HTMIX(mxnx,mxny) - real    - Mixing height (m)
c       USTAR(mxnx,mxny) - real    - Surface friction velocity (m/s)
c      XMONIN(mxnx,mxny) - real    - Monin-Obukhov length (m)
c       WSTAR(mxnx,mxny) - real    - Convective velocity scale (m/s)
c         RMM(mxnx,mxny) - real    - Precipitation rate (mm/hr)
c          TEMPSS(mxss) - real    - Air temperature (deg. K) at
c                                    each surface met. station
c           RHOSS(mxss) - real    - Air density (kg/m**3)
c           QSWSS(mxss) - real    - Short wave solar radiation
c                                    (W/m**2)
c           IRHSS(mxss) - integer - Relative humidity (percent)
c          IPCODE(mxss) - integer - Precipitation code at each surface
c                                    station
c      TEMP2D(mxnx,mxny) - real    - Air temperature (deg. K)
c       RHO2D(mxnx,mxny) - real    - Air density (kg/m**3)
c       QSW2D(mxnx,mxny) - real    - Short wave solar radiation
c                                    (W/m**2)
c       IRH2D(mxnx,mxny) - integer - Relative humidity (percent)
c    IPCODE2D(mxnx,mxny) - integer - Precipitation code 
c                 KDATHR - integer - Date of hour of data (YYYYJJJHH)
c                 KDATHR - integer - Date of hour of data (YYYYJJJHH)
c                KDATHRE - integer - End date/hour of data (YYYYJJJHH)
c                  KSECE - integer - End second of data (SSSS)
c                KDATHRB - integer - Begin date/hour of data (YYYYJJJHH)
c                  KSECB - integer - Begin second of data (SSSS)
c   WDIV(mxnx,mxny,mxnz) - real    - Vertical divergence dw/dz; this
c                                    array holds the w-data here
c
c --- RDMET called by:  COMP
c --- RDMET calls:      RDR1D, RDR2D, RDI1D, RDI2D, INCR, OUT,
c                       NEXTFIL, TPERIOD, YR4
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common /METHD/ -- met. data parameters
      include 'methd.puf'
c
      real umet(mxnx,mxny,mxnz),vmet(mxnx,mxny,mxnz)
      real tmet(mxnx,mxny,mxnz)
      real htmix(mxnx,mxny),ustar(mxnx,mxny),xmonin(mxnx,mxny)
      real wstar(mxnx,mxny),rmm(mxnx,mxny)
      real wrk1(nwork)
c frr (09/01)in noobs mode, nssta can be = 0 => dimension with mxss
c     real tempss(nssta),rhoss(nssta),qswss(nssta)
      real tempss(mxss),rhoss(mxss),qswss(mxss)
      real wdiv(mxnx,mxny,mxnz)
c
c frr (09/01) - additional 2D arrays for temp,rh,rho,ipcode,qsw
      real    temp2d(mxnx,mxny),rho2d(mxnx,mxny),qsw2d(mxnx,mxny)
      integer irh2d (mxnx,mxny),ipcode2d(mxnx,mxny)
      real    rdum(mxnx,mxny)

c frr (09/01)in noobs mode, nssta can be = 0 => dimension with mxss
c     integer ipgt(mxnx,mxny),irhss(nssta),ipcode(nssta)
      integer ipgt(mxnx,mxny),irhss(mxss),ipcode(mxss)
c
      character*70 messag
      character*8 clabel
      character*8 clabexp
c
      logical lecho,ldate
c
      data ldate/.false./
c
c --- Check that enough workspace has been allocated
      nec=max0(nxm*nym,nssta)
      if(nwork.lt.nec)then
         write(io6,*)'ERROR in subr. RDMET -- insufficient workspace ',
     1   'allocated to work arrays -- Allocated (NWORK) = ',nwork,
     2   '   Required (NEC) = ',nec
         write(*,*)
         stop 'Halted in RDMET -- see list file.'
      endif

c --- Begin reading data records for one time period
1     continue

c
c --- Track date-hr of end of this period to check for problems in file
      kdathre=0
      ksece=0
c
c --- read the U, V wind components
      do 10 iz=1,nzm
      call rdr2d(io7,itimes,umet(1,1,iz),wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb1,nsecb1,ndathre1,nsece1,ieof)
      if(ieof.EQ.1) then
c ---    Reached end of CALMET.DAT file; check for another file
         call NEXTFIL(nxm,nym,ifound)
         if(ifound.EQ.1) then
            goto 1
         else
            write(*,*)
            write(*,*)'RDMET: Unexpected EOF in CALMET records'
            write(*,*)'Target  Date-time: ',idathrm,isecm
            write(*,*)'Reading Date-time: ',ndathrb1,nsecb1
            write(*,*)'               to: ',ndathre1,nsece1
            stop 
         endif
      endif
c
c --- Check that record label matches expected label
      clabexp='U-LEV'
      write(clabexp(6:8),'(i3)')iz
      if(clabel.ne.clabexp)go to 999
c

      call rdr2d(io7,itimes,vmet(1,1,iz),wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb2,nsecb2,ndathre2,nsece2,ioef)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'RDMET: Unexpected EOF in CALMET records'
      endif
      clabexp(1:1)='V'
      if(clabel.ne.clabexp)go to 999
c

c --- Use the W wind component (conditional) for w-divergence
      if(lcalgrd)then
         call rdr2d(io7,itimes,wdiv(1,1,iz),wrk1,mxnx,mxny,nxm,nym,
     &              clabel,ndathrb3,nsecb3,ndathre3,nsece3,ieof)
         if(ieof.EQ.1) then
            write(*,*)
            stop 'RDMET: Unexpected EOF in CALMET records'
         endif
         clabexp(1:5)='WFACE'
         if(clabel.ne.clabexp)go to 999
         if(ndathre2.ne.ndathre3 .OR. nsece2.ne.nsece3)go to 2999
      endif
c

c --- Check for consistency of date/time at end of period
      if(ndathre1.ne.ndathre2 .OR. nsece1.ne.nsece2)go to 2999
      if(kdathre.eq.0)then
c ---    first vertical level
         kdathre=ndathre1
         ksece=nsece1
      else if(ndathre1.ne.kdathre .OR. nsece1.ne.ksece)then
c ---    date/time does not match value for previous layer
         ndathre=ndathre1
         nsece=nsece1
         go to 3999
      endif
10    continue
c
c --- Read the 3-D temperature field
      if(lcalgrd)then
         clabexp='T-LEV'
         do 12 iz=1,nzm
         call rdr2d(io7,itimes,tmet(1,1,iz),wrk1,mxnx,mxny,nxm,nym,
     &              clabel,ndathrb,nsecb,ndathre,nsece,ieof)
         if(ieof.EQ.1) then
            write(*,*)
            stop 'RDMET: Unexpected EOF in CALMET records'
         endif
c
         write(clabexp(6:8),'(i3)')iz
         if(clabel.ne.clabexp)go to 999
         if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
12       continue
      endif
c

c --- read other 2-D meteorological fields
c
c --- PGT stability class
      call rdi2d(io7,itimes,ipgt,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece)
      clabexp='IPGT'
      if(clabel.ne.clabexp)go to 999
      if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c --- FRICTION VELOCITY
      call rdr2d(io7,itimes,ustar,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'RDMET: Unexpected EOF in CALMET records'
      endif
      clabexp='USTAR'
      if(clabel.ne.clabexp)go to 999
      if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c --- MIXING HEIGHT
      call rdr2d(io7,itimes,htmix,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'RDMET: Unexpected EOF in CALMET records'
      endif
      clabexp='ZI'
      if(clabel.ne.clabexp)go to 999
      if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c --- MONIN-OBUKHOV LENGTH
      call rdr2d(io7,itimes,xmonin,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'RDMET: Unexpected EOF in CALMET records'
      endif
      clabexp='EL'
      if(clabel.ne.clabexp)go to 999
      if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c --- CONVECTIVE VELOCITY SCALE
      call rdr2d(io7,itimes,wstar,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'RDMET: Unexpected EOF in CALMET records'
      endif
      clabexp='WSTAR'
      if(clabel.ne.clabexp)go to 999
      if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c --- PRECIPITATION DATA
c frr (09/01) - Additional option: if NPSTA=-1, prognostic gridded rain data
c      if(npsta.gt.0)then
      if(npsta.ne.0)then
         call rdr2d(io7,itimes,rmm,wrk1,mxnx,mxny,nxm,nym,clabel,
     &              ndathrb,nsecb,ndathre,nsece,ieof)
         if(ieof.EQ.1) then
            write(*,*)
            stop 'RDMET: Unexpected EOF in CALMET records'
         endif
      endif

c
c frr (09/01)
c --- NOOBS CALMET: full 2-D fields of the following variables instead
c --- of 1-D fields (values at the surface stations only)
c           - Air temperature (deg. K),
c           - Air density (kg/m**3),
c           - Short-wave solar radiation (W/m**2),
c           - Relative humidity (percent),
c           - Precipitation code

      if(i2dmet.EQ.1) then

c ---   New CALMET output format - 2D arrays -
c       call rdr1d(io7,tempss,nssta,clabel,ndathr)
        call rdr2d(io7,itimes,temp2d,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece,ieof)
        if(ieof.EQ.1) then
           write(*,*)
           stop 'RDMET: Unexpected EOF in CALMET records'
        endif
        clabexp='TEMPK'
        if(clabel.ne.clabexp)go to 999
        if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c       call rdr1d(io7,rhoss,nssta,clabel,ndathr)
        call rdr2d(io7,itimes,rho2d,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece,ieof)
        if(ieof.EQ.1) then
           write(*,*)
           stop 'RDMET: Unexpected EOF in CALMET records'
        endif
        clabexp='RHO'
        if(clabel.ne.clabexp)go to 999
        if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c       call rdr1d(io7,qswss,nssta,clabel,ndathr)
        call rdr2d(io7,itimes,qsw2d,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece,ieof)
        if(ieof.EQ.1) then
           write(*,*)
           stop 'RDMET: Unexpected EOF in CALMET records'
        endif
        clabexp='QSW'
        if(clabel.ne.clabexp)go to 999
        if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c       call rdi1d(io7,irhss,nssta,clabel,ndathr)
        call rdi2d(io7,itimes,irh2d,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece)
        clabexp='IRH'
        if(clabel.ne.clabexp)go to 999
        if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c ---   Precipitation code at surface stations
c        if(npsta.gt.0)then
c frr 030119 - bug fix: also precipitation code if prognostic rain
c       (i.e npsta,eq.-1)
        if(npsta.ne.0)then
c         call rdi1d(io7,ipcode,nssta,clabel,ndathr)
          call rdi2d(io7,itimes,ipcode2d,wrk1,mxnx,mxny,nxm,nym,clabel,
     &           ndathrb,nsecb,ndathre,nsece)
          clabexp='IPCODE'
          if(clabel.ne.clabexp)go to 999
          if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
       endif


      elseif(i2dmet.EQ.0) then
c ---    read 1-D meteorological fields:
c           Air temp. (deg. K),
c           Air density (kg/m**3),
c           Short-wave solar radiation (W/m**2),
c           Relative humidity (percent),
c           Precipitation code
         call rdr1d(io7,itimes,tempss,nssta,clabel,
     &           ndathrb,nsecb,ndathre,nsece)
         clabexp='TEMPK'
         if(clabel.ne.clabexp)go to 999
         if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
         call rdr1d(io7,itimes,rhoss,nssta,clabel,
     &           ndathrb,nsecb,ndathre,nsece)
         clabexp='RHO'
         if(clabel.ne.clabexp)go to 999
         if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
         call rdr1d(io7,itimes,qswss,nssta,clabel,
     &           ndathrb,nsecb,ndathre,nsece)
         clabexp='QSW'
         if(clabel.ne.clabexp)go to 999
         if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
         call rdi1d(io7,itimes,irhss,nssta,clabel,
     &           ndathrb,nsecb,ndathre,nsece)
         clabexp='IRH'
         if(clabel.ne.clabexp)go to 999
         if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
c
c ---    Precipitation code at surface stations
         if(npsta.gt.0)then
            call rdi1d(io7,itimes,ipcode,nssta,clabel,
     &              ndathrb,nsecb,ndathre,nsece)
            clabexp='IPCODE'
            if(clabel.ne.clabexp)go to 999
            if(ndathre.ne.kdathre .OR. nsece.ne.ksece)go to 3999
         endif

      else
         write(*,*)'Subr. RDMET:  Invalid I2DMET = ',i2dmet
         stop
      endif
c
c --- Set date-time for period
c ---------------------------------
      kdathre=ndathre
      ksece=nsece
      if(itimes.EQ.0) then
c ---    Construct beginning time for older CALMET data
         iyy=kdathre/100000
         iyyddd=kdathre/100
         iddd=iyyddd-iyy*1000
         ihh=kdathre-iyyddd*100
         call INCR(io6,iyy,iddd,ihh,-1)
         kdathrb=iyy*100000+iddd*100+ihh
         ksecb=0
      else
         kdathrb=ndathrb
         ksecb=nsecb
      endif

c --- Enforce YYYY format for year
      ibyr=kdathrb/100000
      ibdyhr=kdathrb-ibyr*100000
      ieyr=kdathre/100000
      iedyhr=kdathre-ieyr*100000
      call YR4(io6,ibyr,ierrb)
      call YR4(io6,ieyr,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDMET'
      kdathrb=ibyr*100000+ibdyhr
      kdathre=ieyr*100000+iedyhr

c --- Check to see if required date-time has been read
      call TPERIOD(0,idathrm,isecm,kdathrb,ksecb,kdathre,
     &             ksece,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in MET file
         go to 1
      elseif(ilocate.EQ.-1) then
         write(io6,*)'ERROR in subr. RDMET -- current time not found',
     1   ' in the MET data file'
         write(io6,*)' -- Current date/hour,sec = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksecb
         write(io6,*)'                           to ',kdathre,ksece
         stop 'ERROR in subr. RDMET -- current time not found'
      endif
c
c --- Write the input fields, if requested
      if(LECHO)then
c
c ---    Date and time
         write(io6,*)
         write(io6,*)'------ MET. FIELDS BEGINNING: ',kdathrb,ksecb
         write(io6,*)'------            AND ENDING: ',kdathre,ksece
         write(io6,*)
c
c ---    3-D fields
         do 101 iz=1,nzm
         messag='U-component (m/s) -- Level: '
         write(messag(29:31),'(i3)')iz
         call out(umet(1,1,iz),idum,1,5,ldate,messag,nxm,nym)
         messag(1:1)='V'
         call out(vmet(1,1,iz),idum,1,5,ldate,messag,nxm,nym)
         messag(1:1)='W'
         call out(wdiv(1,1,iz),idum,1,5,ldate,messag,nxm,nym)
101      continue
c
c ---    2-D fields
         messag='PGT stability class'
         call out(xdum,ipgt,2,1,ldate,messag,nxm,nym)
         messag='Friction velocity (m/s)'
         call out(ustar,idum,1,5,ldate,messag,nxm,nym)
         messag='Mixing height (m)'
         call out(htmix,idum,1,5,ldate,messag,nxm,nym)
         messag='Monin-Obukhov length (m)'
         call out(xmonin,idum,1,5,ldate,messag,nxm,nym)
         messag='Convective velocity scale (m/s)'
         call out(wstar,idum,1,5,ldate,messag,nxm,nym)
         if(npsta.gt.0)then
            messag='Precipitation rate (mm/hr)'
            call out(rmm,idum,1,5,ldate,messag,nxm,nym)
         endif
c
c ---    1-D fields
c frr (09/01) after level 010901, 2D CALMET fields-  Before, 1D
         if(i2dmet.EQ.1) then
            messag='Surface Air Temperature (deg. K)'
            call out(temp2d,idum,1,5,ldate,messag,nxm,nym)
            messag='Surface Air Density (Kg/m**3)'
            call out(rho2d,idum,1,5,ldate,messag,nxm,nym)
            messag='Short Wave Radiation (W/m**2)'
            call out(qsw2d,idum,1,5,ldate,messag,nxm,nym)
            messag='Surface Relative Humidity (%)'
            call out(rdum,irh2d,2,5,ldate,messag,nxm,nym)
            if(npsta.ne.0)then
               messag='Precipitation code'
               call out(rdum,ipcode2d,2,5,ldate,messag,nxm,nym)
            endif
         elseif(i2dmet.EQ.0) then
            write(io6,*)'TEMPSS (deg. K) = ',(tempss(n),n=1,nssta)
            write(io6,*)'RHOSS (kg/m**3)  = ',(rhoss(n),n=1,nssta)
            write(io6,*)'QSWSS (W/m**2)   = ',(qswss(n),n=1,nssta)
            write(io6,*)'IRHSS (percent)  = ',(irhss(n),n=1,nssta)
            if(npsta.gt.0)write(io6,*)'IPCODE           = ',
     1       (ipcode(n),n=1,nssta)
         else
            write(*,*)'Subr. RDMET:  Invalid I2DMET = ',i2dmet
            stop
         endif
      endif
c
      return
c
c --- Write error messages -- incorrect record label read
999   continue
      write(io6,1001)clabel,clabexp
1001  format(/1x,'ERROR in subr. RDMET -- incorrect record label ',
     1 'read from MET data file'//1x,'Label read     = ',a8/
     2                               1x,'Label expected = ',a8)
      write(*,*)
      stop 'Halted in RDMET -- see list file.'

c --- date/time variables do not match
2999  continue
      write(io6,*)'ERROR in subr. RDMET -- date/time variables for',
     & ' wind components do not match --  '
      write(io6,*)'   NDATHRE1,NSECE1= ',ndathre1,nsece1
      write(io6,*)'   NDATHRE2,NSECE2= ',ndathre2,nsece2
      write(io6,*)'   NDATHRE3,NSECE3= ',ndathre3,nsece3
      stop 'Halted in RDMET -- see list file.'
3999  continue
      write(io6,*)'ERROR in subr. RDMET -- date/time variables ',
     1 'do not match -- '
      write(io6,*)'   NDATHRE ,NSECE = ',ndathre,nsece
      write(io6,*)'   KDATHRE ,KSECE = ',kdathre,ksece
      stop 'Halted in RDMET -- see list file.'
      end
c----------------------------------------------------------------------
      subroutine rdprof(idathrm,isecm,lecho,izp,wsprf,wdprf,tprf,
     &                  zprf,ssprf,swprf,svprf,dptinvo,
     &                  kdathre,kse,kdathrb,ksb,leof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                 RDPROF
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read meteorological data for one hour from CTDM
c               PROFILE file
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): allow for begin/end time format
c                                  resolved to seconds
c                                  (retain compatibility with older
c                                  PROFILE versions)
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4, JULDAY,
c                                  GRDAY, INCR
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): YYYY format used for year
c --- V4.0-V5.0     971107  (DGS): add EOF recovery
c                           (DGS): add record-skip logic from COMP to
c                                  find current date-time
c                           (DGS): skip blank records
c                           (DGS): allow inversion strength in PROFILE
c
c --- INPUTS:
c       IDATHRM - integer - Mid-pt date/hour of required data (YYYYJJJHH)
c         ISECM - integer - Mid-pt second of required data (SSSS)
c         LECHO - logical - Flag controlling printing of input
c                           meteorological data fields
c        PTG(2) - real    - Default potential temperature grad.
c                           for stable classes (deg. K/m)
c
c    Common block /METHD/ variables:
c         NXM, NYM, NZM, NSSTA, NPSTA, ZFACEM(mxnzp1), LCALGRD,
c         IMIXCTDM, ISIGMAV, ITIMEPRF
c    Parameters:
c         MXNX, MXNY, MXNZ, MXNZP1, MXPRFZ, IO6
c
c --- OUTPUT:
c
c                    IZP - integer - Number of profile levels
c          WSPRF(mxprfz) - real    - 1-D vector wind speed profile (m/s)
c          WDPRF(mxprfz) - real    - 1-D vector wind dir. profile (deg)
c           TPRF(mxprfz) - real    - Temperature profile (deg. K)
c           ZPRF(mxprfz) - real    - Heights for data in profile (m)
c          SSPRF(mxprfz) - real    - 1-D scalar speed profile (m/s)
c          SWPRF(mxprfz) - real    - 1-D sigma-w profile (m/s)
c          SVPRF(mxprfz) - real    - 1-D sigma-v profile (m/s)
c                DPTINVO - real    - Inversion strength at top of CBL
c                                    (jump in potential temperature K)
c                KDATHRE - integer - End date/hour of data (YYYYJJJHH)
c                    KSE - integer - End second of data (SSSS)
c                KDATHRB - integer - Begin date/hour of data (YYYYJJJHH)
c                    KSB - integer - Begin second of data (SSSS)
c                   LEOF - logical - End-Of-File flag
c
c --- RDPROF called by:  COMP, RDMET4
c --- RDPROF calls:      JULDAY, INCR, GRDAY, INITAR,
c                        INITAI, OUT, INITR2D, INITI2D,
c                        LSTAB, XTPRF, TPERIOD, YR4, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'methd.puf'
c
c --- Profile data arrays

      real wsprf(mxprfz),wdprf(mxprfz),tprf(mxprfz),zprf(mxprfz)
      real ssprf(mxprfz),swprf(mxprfz),svprf(mxprfz)
c
      character aline*132
c
      logical lecho,problem,leof
c
      data dtor/.0174533/

c --- Set logical to halt program if problem is found
1     problem=.FALSE.

c -------------------------------------------------------------------
c  -- Read records for this hour from CTDM PROFILE file
c -------------------------------------------------------------------
2     izp=0
10    izp=izp+1
c --- Do not let profile levels exceed MXPRFZ; discard extra levels
      if(izp.GT.mxprfz) izp=mxprfz

c --- First level of profile may contain the strength of inversion
c --- at top of CBL, so read first line as character variable and
c --- try to extract DPTINVO using internal read
      if(izp.EQ.1) then
         read(io31,'(a132)',end=999) aline
         if(itimeprf.EQ.1) then
            read(aline,*,end=15) iy,im,id,ih,ksb,iey,iem,ied,ieh,kse,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp),wsprf(izp),dptinvo
         else
            read(aline,*,end=15) iy,im,id,ih,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp),wsprf(izp),dptinvo
         endif
         goto 16
c ---    Inversion strength is not provided; return missing value
15       dptinvo=-999.
16       continue
      else
         if(itimeprf.EQ.1) then
            read(io31,*,end=999) iy,im,id,ih,ksb,iey,iem,ied,ieh,kse,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp),wsprf(izp)
         else
            read(io31,*,end=999) iy,im,id,ih,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp),wsprf(izp)
         endif
      endif
c
c --- Convert svprf to sigma-v (m/s) if given in degrees
      if(isigmav.EQ.0) then
         if(svprf(izp).GT.0.0) then
            if(wsprf(izp).GT.0.0) then
c ---          Definition!
               svprf(izp)=svprf(izp)*dtor*wsprf(izp)
            elseif(ssprf(izp).GT.0.0) then
c ---          Approximation!
               svprf(izp)=svprf(izp)*dtor*ssprf(izp)
            else
               svprf(izp)=-999.
            endif
         endif
      endif
c
c --- Construct vector/scalar average wind, as in CTDM, if needed
      if(wsprf(izp).LE.0.0) then
         if(ssprf(izp).GT.0.0) then
c ---       Estimate vector mean from scalar mean speed
            if(svprf(izp).GT.0) then
               sigth=svprf(izp)/ssprf(izp)
c ---          Sigma-theta cannot exceed 103.9 degrees (1.81334 radians)
               sigth=AMIN1(sigth,1.81334)
               e=SIN(sigth)*(1.0-0.073864*sigth)
               wsprf(izp)=ssprf(izp)*SQRT(1.0-e*e)
            else
               wsprf(izp)=ssprf(izp)
            endif
         endif
      elseif(ssprf(izp).LE.0.0) then
c ---    Estimate scalar mean from vector mean speed
         sigth=svprf(izp)/wsprf(izp)
c ---    Sigma-theta cannot exceed 103.9 degrees (1.81334 radians)
         sigth=AMIN1(sigth,1.81334)
         if(sigth.GT.0) then
            e=SIN(sigth)*(1.0-0.073864*sigth)
            ssprf(izp)=wsprf(izp)/SQRT(1.0-e*e)
         else
            ssprf(izp)=wsprf(izp)
         endif
      endif
c
c --- Are there more levels in this profile? (go to 10 if yes)
      if(izp.EQ.1) then
         itest1=iy+im+id+ih
         itest2=itest1
         if(ilast.NE.1) goto 10
      elseif(ilast.EQ.1) then
         itest2=iy+im+id+ih
      else
         goto 10
      endif
c -------------------------------------------------------------------

c --- Enforce YYYY format for year
      call YR4(io6,iy,ierrb)
      call YR4(io6,iey,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDPROF'

c --- Form date-time variable for last record read from PROFILE file
c --- Assign proper time period variables (augment old format)
c --- PROFILE.DAT used a 1-24 clock (hour ending).
      if(itimeprf.EQ.1) then
         call julday(io6,iy,im,id,ijul)
         call julday(io6,iey,iem,ied,iejul)
      else
         ksb=0
         kse=0
c ---    Set time at the beginning of the hour (subtract 1 hour)
         ih=ih-1
         call julday(io6,iy,im,id,ijul)
c ---    Increment time 1 hour to get end time (0-23 convention)
         iey=iy
         iem=im
         ied=id
         ieh=ih
         call julday(io6,iey,iem,ied,iejul)
         call incr(io6,iey,iejul,ieh,1)
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,kdathrb,idum,idum,idum,ksb)
      call TCLOCK(io6,kdathre,idum,idum,idum,kse)

c --- Form date-time variables
      kdathrb=iy*100000+ijul*100+ih
      kdathre=iey*100000+iejul*100+ieh

c --- Check to see if required date-time has been read
      call TPERIOD(0,idathrm,isecm,kdathrb,ksb,kdathre,kse,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in MET file
         goto 1
      elseif(ilocate.EQ.-1)then
         write(io6,*)'ERROR in subr. RDPROF -- current time not found',
     &   ' in the PROFILE data file'
         write(io6,*)' -- Current date/hour,sec = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksb
         write(io6,*)'                           to ',kdathre,kse
         problem=.TRUE.
      endif

c --- Check for consistent date-time for hour among records
      if(itest1.NE.itest2) then
         write(io6,*)'RDPROF: date-time of PROFILE levels do not match'
         problem=.TRUE.
      endif

c --- Halt program now if problem was found with PROFILE
      if(PROBLEM) then
         write(io6,*)' PROFILE per. = ',kdathrb,ksb,kdathre,kse
         stop 'Halted in RDPROF -- see list file'
      endif

c --- Write the input fields, if requested
      if(LECHO)then
c
c ---    Date and time
         write(io6,*)
         write(io6,*)'------ PROFILE Data- BEGINNING: ',kdathrb,ksb
         write(io6,*)'------              AND ENDING: ',kdathre,kse
         write(io6,*)
c
c ---    Profile fields
         write(io6,*)'Height(m),  Scalar Speed,  Sigma-W,  Sigma-V:'
         do iz=1,izp
            write(io6,*) zprf(iz),ssprf(iz),swprf(iz),svprf(iz)
         enddo
         write(io6,*)
         write(io6,*)'Height(m), Vector Speed, Direction, Temperature:'
         do iz=1,izp
            write(io6,*) zprf(iz),wsprf(iz),wdprf(iz),tprf(iz)
         enddo
         write(io6,*)
c ---    Also report inversion strength here
         write(io6,*)'Inversion Strength in file (K) = ',dptinvo
         write(io6,*)
      endif
c
      return

999   write(io6,*)'RDPROF: End-Of-File found in PROFILE file'
      leof=.TRUE.
      return

      end
c----------------------------------------------------------------------
      subroutine rdprof5(idathrm,isecm,lecho,izp,wsprf,wdprf,tprf,
     &                  zprf,ssprf,swprf,svprf,dptinvo,
     &                  kdathre,kse,kdathrb,ksb,leof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                RDPROF5
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read meteorological data for one hour from AERMET
c               PROFILE file.  This is RDPROF with the following
c               changes:
c               1.  Retain extended data records even though none are
c                   currently expected
c               2.  Wind speed in record is assumed to be the scalar
c                   average
c               3.  Temperature is read as degrees C.
c
c --- UPDATE
c --- V5.74-V6.1    050915  (DGS): allow for begin/end time format
c                                  resolved to seconds
c                                  (retain compatibility with older
c                                  PROFILE versions)
c
c --- INPUTS:
c       IDATHRM - integer - Mid-pt date/hour of required data (YYYYJJJHH)
c         ISECM - integer - Mid-pt second of required data (SSSS)
c         LECHO - logical - Flag controlling printing of input
c                           meteorological data fields
c        PTG(2) - real    - Default potential temperature grad.
c                           for stable classes (deg. K/m)
c
c    Common block /METHD/ variables:
c         NXM, NYM, NZM, NSSTA, NPSTA, ZFACEM(mxnzp1), LCALGRD,
c         IMIXCTDM, ISIGMAV, ITIMEPRF
c    Parameters:
c         MXNX, MXNY, MXNZ, MXNZP1, MXPRFZ, IO6
c
c --- OUTPUT:
c
c                    IZP - integer - Number of profile levels
c          WSPRF(mxprfz) - real    - 1-D vector wind speed profile (m/s)
c          WDPRF(mxprfz) - real    - 1-D vector wind dir. profile (deg)
c           TPRF(mxprfz) - real    - Temperature profile (deg. K)
c           ZPRF(mxprfz) - real    - Heights for data in profile (m)
c          SSPRF(mxprfz) - real    - 1-D scalar speed profile (m/s)
c          SWPRF(mxprfz) - real    - 1-D sigma-w profile (m/s)
c          SVPRF(mxprfz) - real    - 1-D sigma-v profile (m/s)
c                DPTINVO - real    - Inversion strength at top of CBL
c                                    (jump in potential temperature K)
c                KDATHRE - integer - End date/hour of data (YYYYJJJHH)
c                    KSE - integer - End second of data (SSSS)
c                KDATHRB - integer - Begin date/hour of data (YYYYJJJHH)
c                    KSB - integer - Begin second of data (SSSS)
c                   LEOF - logical - End-Of-File flag
c
c --- RDPROF5 called by:  COMP, RDMET5
c --- RDPROF5 calls:      JULDAY, INCR, GRDAY, INITAR,
c                         INITAI, OUT, INITR2D, INITI2D,
c                         LSTAB, XTPRF, TPERIOD, YR4, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'methd.puf'
c
c --- Profile data arrays

      real wsprf(mxprfz),wdprf(mxprfz),tprf(mxprfz),zprf(mxprfz)
      real ssprf(mxprfz),swprf(mxprfz),svprf(mxprfz)
c
      character aline*132
c
      logical lecho,problem,leof
c
      data dtor/.0174533/

c --- Set logical to halt program if problem is found
1     problem=.FALSE.

c -------------------------------------------------------------------
c  -- Read records for this hour from AERMET PROFILE file
c -------------------------------------------------------------------
2     izp=0
10    izp=izp+1
c --- Do not let profile levels exceed MXPRFZ; discard extra levels
      if(izp.GT.mxprfz) izp=mxprfz

c --- First level of profile may contain the strength of inversion
c --- at top of CBL, so read first line as character variable and
c --- try to extract DPTINVO using internal read
      if(izp.EQ.1) then
         read(io31,'(a132)',end=999) aline
         if(itimeprf.EQ.1) then
            read(aline,*,end=15) iy,im,id,ih,ksb,iey,iem,ied,ieh,kse,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp),dptinvo
         else
            read(aline,*,end=15) iy,im,id,ih,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp),dptinvo
         endif
         goto 16
c ---    Inversion strength is not provided; return missing value
15       dptinvo=-999.
16       continue
      else
         if(itimeprf.EQ.1) then
            read(io31,*,end=999) iy,im,id,ih,ksb,iey,iem,ied,ieh,kse,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp)
         else
            read(io31,*,end=999) iy,im,id,ih,
     &                           zprf(izp),ilast,wdprf(izp),
     &                           ssprf(izp),tprf(izp),svprf(izp),
     &                           swprf(izp)
         endif
      endif

c --- Trap AERMET missings
      if(ssprf(izp).LT.0.0 .OR. ssprf(izp).GT.90.) ssprf(izp)=-999.
      if(wdprf(izp).LT.0.0 .OR. wdprf(izp).GT.900.) wdprf(izp)=-999.
      if(tprf(izp).LT.-90. .OR. tprf(izp).GT.90.) tprf(izp)=-999.
      if(svprf(izp).LT.0.0 .OR. svprf(izp).GT.90.) svprf(izp)=-99.9
      if(swprf(izp).LT.0.0 .OR. swprf(izp).GT.90.) swprf(izp)=-99.9

c --- Set vector mean speed equal to missing
      wsprf(izp)=-999.

c --- Convert temperature from degrees C to degrees K
      if(tprf(izp).GT.-900.) tprf(izp)=tprf(izp)+273.16

c --- Convert svprf to sigma-v (m/s) if given in degrees
      if(isigmav.EQ.0) then
         if(svprf(izp).GT.0.0) then
            if(wsprf(izp).GT.0.0) then
c ---          Definition!
               svprf(izp)=svprf(izp)*dtor*wsprf(izp)
            elseif(ssprf(izp).GT.0.0) then
c ---          Approximation!
               svprf(izp)=svprf(izp)*dtor*ssprf(izp)
            else
               svprf(izp)=-999.
            endif
         endif
      endif
c
c --- Construct vector/scalar average wind, as in CTDM, if needed
      if(wsprf(izp).LE.0.0) then
         if(ssprf(izp).GT.0.0) then
c ---       Estimate vector mean from scalar mean speed
            if(svprf(izp).GT.0) then
               sigth=svprf(izp)/ssprf(izp)
c ---          Sigma-theta cannot exceed 103.9 degrees (1.81334 radians)
               sigth=AMIN1(sigth,1.81334)
               e=SIN(sigth)*(1.0-0.073864*sigth)
               wsprf(izp)=ssprf(izp)*SQRT(1.0-e*e)
            else
               wsprf(izp)=ssprf(izp)
            endif
         endif
      elseif(ssprf(izp).LE.0.0) then
c ---    Estimate scalar mean from vector mean speed
         sigth=svprf(izp)/wsprf(izp)
c ---    Sigma-theta cannot exceed 103.9 degrees (1.81334 radians)
         sigth=AMIN1(sigth,1.81334)
         if(sigth.GT.0) then
            e=SIN(sigth)*(1.0-0.073864*sigth)
            ssprf(izp)=wsprf(izp)/SQRT(1.0-e*e)
         else
            ssprf(izp)=wsprf(izp)
         endif
      endif
c
c --- Are there more levels in this profile? (go to 10 if yes)
      if(izp.EQ.1) then
         itest1=iy+im+id+ih
         itest2=itest1
         if(ilast.NE.1) goto 10
      elseif(ilast.EQ.1) then
         itest2=iy+im+id+ih
      else
         goto 10
      endif
c -------------------------------------------------------------------


c --- Enforce YYYY format for year
      call YR4(io6,iy,ierrb)
      call YR4(io6,iey,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDPROF5'

c --- Form date-time variable for last record read from PROFILE file
c --- Assign proper time period variables (augment old format)
c --- PROFILE.DAT used a 1-24 clock (hour ending).
      if(itimeprf.EQ.1) then
         call julday(io6,iy,im,id,ijul)
         call julday(io6,iey,iem,ied,iejul)
      else
         ksb=0
         kse=0
c ---    Set time at the beginning of the hour (subtract 1 hour)
         ih=ih-1
         call julday(io6,iy,im,id,ijul)
c ---    Increment time 1 hour to get end time (0-23 convention)
         iey=iy
         iem=im
         ied=id
         ieh=ih
         call julday(io6,iey,iem,ied,iejul)
         call incr(io6,iey,iejul,ieh,1)
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,kdathrb,idum,idum,idum,ksb)
      call TCLOCK(io6,kdathre,idum,idum,idum,kse)

c --- Form date-time variables
      kdathrb=iy*100000+ijul*100+ih
      kdathre=iey*100000+iejul*100+ieh

c --- Check to see if required date-time has been read
      call TPERIOD(0,idathrm,isecm,kdathrb,ksb,kdathre,kse,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in MET file
         goto 1
      elseif(ilocate.EQ.-1)then
         write(io6,*)'ERROR in subr. RDPROF5 -- current time not found',
     &   ' in the PROFILE data file'
         write(io6,*)' -- Current date/hour,sec = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksb
         write(io6,*)'                           to ',kdathre,kse
         problem=.TRUE.
      endif

c --- Check for consistent date-time for hour among records
      if(itest1.NE.itest2) then
         write(io6,*)'RDPROF5: date-time of PROFILE levels do not match'
         problem=.TRUE.
      endif

c --- Halt program now if problem was found with PROFILE
      if(PROBLEM) then
         write(io6,*)' PROFILE per. = ',kdathrb,ksb,kdathre,kse
         stop 'Halted in RDPROF5 -- see list file'
      endif

c --- Write the input fields, if requested
      if(LECHO)then
c
c ---    Date and time
         write(io6,*)
         write(io6,*)'------ PROFILE Data- BEGINNING: ',kdathrb,ksb
         write(io6,*)'------              AND ENDING: ',kdathre,kse
         write(io6,*)
c
c ---    Profile fields
         write(io6,*)'Height(m),  Scalar Speed,  Sigma-W,  Sigma-V:'
         do iz=1,izp
            write(io6,*) zprf(iz),ssprf(iz),swprf(iz),svprf(iz)
         enddo
         write(io6,*)
         write(io6,*)'Height(m), Vector Speed, Direction, Temperature:'
         do iz=1,izp
            write(io6,*) zprf(iz),wsprf(iz),wdprf(iz),tprf(iz)
         enddo
         write(io6,*)
c ---    Also report inversion strength here
         write(io6,*)'Inversion Strength in file (K) = ',dptinvo
         write(io6,*)
      endif
c
      return

999   write(io6,*)'RDPROF5: End-Of-File found in PROFILE file'
      leof=.TRUE.
      return

      end
c----------------------------------------------------------------------
      subroutine met2(lecho)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                   MET2
c                J. Scire, D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Create the header information normally contained
c               in the CALMET file (using ISCMET file).
c               Also, set the wind profile power-law exponents if
c               not provided in control file.
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): Add 'dataset 2.1' file format, and
c                                  use c*16 variable VERISC in new
c                                  /DATASET/ common to identify version.
c                                  Implement full begin/end time
c                                  processing.
c                                  Add METQA call.
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4, JULDAY,
c                                  GRDAY, INCR
c                   030402  (DGS): add map projection, datum
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c --- V5.0-V5.0     980430  (DGS): remove plrur,plurb (compiler warning)
c --- V5.0-V5.0     980304  (DGS): add station elevation,lat,lon
c --- V4.0-V5.0     971107  (DGS): pass start-time from met file
c                                  for use if METRUN=1
c
c --- INPUTS:
c         LECHO - logical       - Control variable for output of header
c                                 record information
c     Common block /COMPARM/ variables:
c           PLX0
c     Common block /DATASET/ variables:
c           VERISC
c     Common block /DISPDAT/ variables:
c           IURB1, IURB2
c     Common block /GRID/ variables:
c           NX, NY, NZ, DGRID, XORIG, YORIG, ZFACE(mxnzp1)
c     Common block /MAP/ variables:
c           iutmzn,feast,fnorth,
c           rlat0,rlon0,xlat1,xlat2,
c           pmap,utmhem,datum,daten
c     Common block /METHD/ variables:
c           ANEMHT, ILANDUIN, Z0IN, XLAIIN, ELEVIN, XLATIN, XLONIN
c     Parameters:
c           MXNZP1, MXSS, MXUS, MXPS, IO6
c
c --- OUTPUT:
c     Common block /COMPARM/ variables:
c           PLX0
c     Common block /METHD/ variables:
c           NXM, NYM, NZM, XGRIDM, XORIGM, YORIGM, XBTZM,
c           NSSTA, NPSTA, NLU, IWAT1, IWAT2, ZFACEM(mxnzp1),
c           XSSTA(mxss),YSSTA(mxss),XUSTA(mxus),YUSTA(mxus),
c           XLATSS(mxss),XLONSS(mxss),
c           XPSTA(mxps),YPSTA(mxps),Z0(mxnx,mxny),ILANDU(mxnx,mxny),
c           ELEV(mxnx,mxny),XLAI(mxnx,mxny),NEARS(mxnx,mxny),
c           LCALGRD, itimes
c           ibymet,ibmmet,ibdmet,ibjdmet,ibhmet,ibsmet
c           ieymet,iemmet,iedmet,iejdmet,iehmet,iesmet
c           xlat1m, xlat2m, rlat0m, rlon0m
c           iutmznm,feastm,fnorthm,pmapm,datumm,datenm,utmhemm
c
c --- MET2 called by:  SETUP
c --- MET2 calls:      JULDAY, INCR, GRDAY, INITR2D, OUT, INITI2D, YR4
c                      METQA, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      character*80 title(3)
      character*70 messag
      character*3 abegin,aend
      character*4 MAP
      character*8 axbtzm
      character*8 clab1,clab2
      logical ldate,lecho
c
c --- Include common block /COMPARM/ -- Computation parameters
      include 'comparm.puf'
c --- Include common block /DATASET/  -- Input file dataset version
      include 'dataset.puf'
c --- Include common block /DISPDAT/ -- Dispersion-related data
      include 'dispdat.puf'
c --- Include common block /METHD/ -- CALMET header record data
      include 'methd.puf'
c --- Include common block /GRID/  -- Grid data from control file
      include 'grid.puf'
c --- Include common block /MAP/  -- Projection data from control file
      include 'map.puf'
c
      data ldate/.false./
c
c --- Initialize the time zone to an invalid number (will be replaced
c --- starting with dataset 2.1)
      xbtzm=-999.9

c --- Set first 2 title-lines
      title(1)='Constant Meteorological Fields'
      title(2)='Created for ISCMET.DAT'

c --- Process HEADER records (or extract info from data record)
      if(verisc.EQ.'2.1') then
c ---    Full version 2.1 with beginning & ending times (non-standard)
         itimes=1
         read(io7,'(a80)') title(1)
         read(io7,*) ncomm
c ---    Keep first comment record
         read(io7,'(a80)') title(2)
c ---    Skip other comment records
         do k=2,ncomm
            read(io7,*) 
         enddo
c ---    Allow map projection of 'NONE'
         read(io7,'(a4)') map
         if(map.NE.'NONE') then
            write(io6,*)'FATAL Error in MET2 -- Unsupported Map Proj.'
            write(io6,*)'Expected NONE, Found map = ',map
            stop 'Halted in MET2 -- see list file'
         endif
c ---    Time zone (hours only)
         read(io7,'(a8)') axbtzm
         if(axbtzm(7:8).NE.'00') then
            write(io6,*)'FATAL Error in MET2 -- Unsupported Time Zone'
            write(io6,*)'Expected whole hour, Found: ',axbtzm
            stop 'Halted in MET2 -- see list file'
         endif
         read(axbtzm(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in MET2 -- Unsupported Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axbtzm
            stop 'Halted in MET2 -- see list file'
         endif
         xbtzm=-FLOAT(ibtzhh)
c ---    Time period
         read(io7,*) ibymet,ibmmet,ibdmet,ibhmet,ibsmet,
     &               ieymet,iemmet,iedmet,iehmet,iesmet
c ---    Enforce YYYY format for year
         call YR4(io6,ibymet,ierrb)
         call YR4(io6,ieymet,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in MET2'
         call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
         call JULDAY(io6,ieymet,iemmet,iedmet,iejdmet)
c ---    Get standard ISC header record, or other comments
         read(io7,'(a80)') title(3)

      elseif(verisc.EQ.'1.6') then
c ---    Beginning & ending times are provided (non-standard)
         itimes=1
         read(io7,'(a80)') title(1)
         read(title(1),*) abegin,ibymet,ibmmet,ibdmet,ibhmet,ibsmet,
     &                    aend,ieymet,iemmet,iedmet,iehmet,iesmet
c ---    Enforce YYYY format for year
         call YR4(io6,ibymet,ierrb)
         call YR4(io6,ieymet,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in MET2'
         call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
         call JULDAY(io6,ieymet,iemmet,iedmet,iejdmet)
c ---    Get standard ISC header record, or other comments
         read(io7,'(a80)') title(3)

      else
         itimes=0
c ---    Read ISC header record (station, year for surface and upper)
         read(io7,'(a80)') title(3)
c ---    Read date-time from first data record
         read(io7,'(4i2)') ibymet,ibmmet,ibdmet,ibhmet
c ---    Rewind file and skip over header record
         rewind(io7)
         read(io7,*)
c ---    Enforce YYYY format for year
         call YR4(io6,ibymet,ierr)
         if(ierr.NE.0) then
            write(*,*)
            stop 'Halted in MET2'
         endif
c ---    ISCMET.DAT uses a 1-24 clock (hour ending).  Convert to time
c ---    beginning by subtracting 1 from the hour (0-23)
         ibhmet=ibhmet-1
         call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
         ibsmet=0
c ---    Use "default" run length (hours) to mark the end of data
c ---    Assume this will be 5 years, so set IRLG=43848 hours
         irlgmet=43848
         ieymet=ibymet
         iemmet=ibmmet
         iedmet=ibdmet
         iejdmet=ibjdmet
         iehmet=ibhmet
         call INCR(io6,ieymet,iejdmet,iehmet,irlgmet)
         iesmet=0
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibymet,ibjdmet,ibhmet,ibsmet)
      call TCLOCK(io6,idum,ieymet,iejdmet,iehmet,iesmet)
      call GRDAY(io6,ibymet,ibjdmet,ibmmet,ibdmet)
      call GRDAY(io6,ieymet,iejdmet,iemmet,iedmet)

c
c ---------------------------------------------------------------------
c --- record #1 - run title --
c
c --- record #2 - run control parameters --
c --- (vermet, levmet are both 8 bytes):
c ---  vermet,levmet,ibyr,ibmo,ibdy,ibhr,irtype,
c ---  nxm, nym, nzm, xgridm, xorigm, yorigm, iutmznm, iwfcod, nssta,
c ---  nusta, npsta, nowsta, nlu, iwat1, iwat2, lcalgrd
c
c --- Fill in most first
      irtype=1
      nxm=nx
      nym=ny
      nzm=nz
      xgridm=dgrid
      xorigm=xorig
      yorigm=yorig
      pmapm=pmap
      datumm=datum
      datenm=daten
      iutmznm=iutmzn
      utmhemm=utmhem
      rlat0m=rlat0
      rlon0m=rlon0
      xlat1m=xlat1
      xlat2m=xlat2
      feastm=feast
      fnorthm=fnorth
      iwfcod=1
      nssta=1
      nusta=1
      npsta=1
      nowsta=0
      nlu=10
      iwat1=500
      iwat2=599
      lcalgrd=.FALSE.

      if(LECHO)then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*) title(1)
         write(io6,*) title(2)
         write(io6,*) title(3)
         write(io6,*)
         write(io6,*)'-- Data begin at:'
         write(io6,*)' IBYR    = ',ibymet
         write(io6,*)' IBMO    = ',ibmmet
         write(io6,*)' IBDY    = ',ibdmet
         write(io6,*)' IBJUL   = ',ibjdmet
         write(io6,*)' IBHR    = ',ibhmet
         write(io6,*)' IBSEC   = ',ibsmet
         if(verisc.EQ.'1.0') then
            write(io6,*)'-- Data end at:  ?'
         else
            write(io6,*)'-- Data end at:'
         endif
         write(io6,*)' IEYR    = ',ieymet
         write(io6,*)' IEMO    = ',iemmet
         write(io6,*)' IEDY    = ',iedmet
         write(io6,*)' IEJUL   = ',iejdmet
         write(io6,*)' IEHR    = ',iehmet
         write(io6,*)' IESEC   = ',iesmet
         write(io6,*)
         write(io6,*)' IRTYPE  = ',irtype
         write(io6,*)' LCALGRD = ',lcalgrd
         write(io6,*)' NXM     = ',nxm
         write(io6,*)' NYM     = ',nym
         write(io6,*)' NZM     = ',nzm
         write(io6,*)' XGRIDM  = ',xgridm
         write(io6,*)' XORIGM  = ',xorigm
         write(io6,*)' YORIGM  = ',yorigm

         write(io6,*)' PMAPM   = ',pmapm
         write(io6,*)' DATUMM  = ',datumm
         write(io6,*)' DATENM  = ',datenm
         write(io6,*)' IUTMZNM = ',iutmznm
         write(io6,*)' UTMHEMM = ',utmhemm
         write(io6,*)' XLAT1M  = ',xlat1m
         write(io6,*)' XLAT2M  = ',xlat2m
         write(io6,*)' RLAT0M  = ',rlat0m
         write(io6,*)' RLON0M  = ',rlon0m
         write(io6,*)' FEASTM  = ',feastm
         write(io6,*)' FNORTHM = ',fnorthm

         write(io6,*)' IWFCOD  = ',iwfcod
         write(io6,*)' NSSTA   = ',nssta
         write(io6,*)' NUSTA   = ',nusta
         write(io6,*)' NPSTA   = ',npsta
         write(io6,*)' NOWSTA  = ',nowsta
         write(io6,*)' NLU     = ',nlu
         write(io6,*)' IWAT1   = ',iwat1
         write(io6,*)' IWAT2   = ',iwat2
         write(io6,*)' ANEMHT  = ',anemht
      endif
c
      nzmp1=nzm+1
      if(mxnzp1.lt.nzmp1)then
         write(io6,*)'ERROR in subr. MET2 -- dimension of ZFACEM ',
     1   'array is too small for no. layers in ISCMET file'
         write(io6,*)'MXNZP1 = ',mxnzp1,' NZMP1 = ',nzmp1
         write(*,*)
         stop 'Halted in MET2 -- see list file.'
      endif
c
c --- record #3 - cell face heights (NZ + 1 words)
c
c --- Grab the face heights from the control file
      do i=1,nzmp1
         zfacem(i)=zface(i)
      enddo
c
      if(LECHO)then
         write(io6,203)(zfacem(n),n=1,nzmp1)
203      format(1x,'ZFACEM  = ',10(f9.3,', ')/)
      endif

c --- Perform QA checks on header record variables
      call METQA
c
c --- records #4 & 5 - x, y coordinates of surface stations
c --- (NSSTA words each record)
      if(nssta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xssta(1)=xorig
         yssta(1)=yorig
         if(LECHO)then
            clab1='XSSTA'
            clab2='YSSTA'
            write(io6,*)clab1,' = ',(xssta(n),n=1,nssta)
            write(io6,*)clab2,' = ',(yssta(n),n=1,nssta)
         endif
      endif
c
c --- records #4a & 5a - lat, lon coordinates of surface stations
c --- (NSSTA words each record)
      if(nssta.gt.0)then
c ---    Grab the lat,lon from control file inputs
         xlatss(1)=xlatin
         xlonss(1)=xlonin
         if(LECHO)then
            clab1='XLATSS'
            clab2='YLONSS'
            write(io6,*)clab1,' = ',(xlatss(n),n=1,nssta)
            write(io6,*)clab2,' = ',(xlonss(n),n=1,nssta)
         endif
      endif
c
c --- records #6 & 7 - x, y coordinates of upper air stations
c --- (NUSTA words each record)
      if(nusta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xusta(1)=xorig
         yusta(1)=yorig
         if(LECHO)then
            clab1='XUSTA'
            clab2='YUSTA'
            write(io6,*)clab1,' = ',(xusta(n),n=1,nusta)
            write(io6,*)clab2,' = ',(yusta(n),n=1,nusta)
         endif
      endif
c
c --- records #8 & 9 - x, y coordinates of precipitation stations
c --- (NPSTA words each record)
      if(npsta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xpsta(1)=xorig
         ypsta(1)=yorig
         if(LECHO)then
            clab1='XPSTA'
            clab2='YPSTA'
            write(io6,*)clab1,' = ',(xpsta(n),n=1,npsta)
            write(io6,*)clab2,' = ',(ypsta(n),n=1,npsta)
         endif
      endif
c
c --- Fill the corresponding arrays:
c
c --- record #10 - surface roughness lengths (NX * NY words)
      call initr2d(z0in,mxnx,mxny,nxm,nym,z0)
      if(LECHO)then
         messag='Surface roughness lengths (m)'
         messag(63:70)='z0'
         call out(z0,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #11 - land use categories (NX * NY words)
      call initi2d(ilanduin,mxnx,mxny,nxm,nym,ilandu)
      if(LECHO)then
         messag='Land use categories'
         messag(63:70)='ILANDU'
         call out(xdum,ilandu,2,5,ldate,messag,nx,ny)
      endif
c
c --- record #12 - elevations (NX * NY words)
c --- Set grid elevation to ELEVIN from control file
      call initr2d(elevin,mxnx,mxny,nxm,nym,elev)
      if(LECHO)then
         messag='Terrain heights (m)'
         messag(63:70)='TERR'
         call out(elev,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #13 - leaf area index (NX * NY words)
      call initr2d(xlaiin,mxnx,mxny,nxm,nym,xlai)
      if(LECHO)then
         messag='Leaf area index'
         messag(63:70)='XLAI'
         call out(xlai,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #14 - nearest surface station to each grid point
c                  (NX * NY words)
      call initi2d(1,mxnx,mxny,nxm,nym,nears)
      if(LECHO)then
         messag='Nearest surface station no. to each grid point'
         messag(63:70)='NEARS'
         call out(xdum,nears,2,5,ldate,messag,nx,ny)
      endif

c
      return
      end
c----------------------------------------------------------------------
      subroutine rdisc(idathrm,isecm,lecho,umet,vmet,ipgt,htmix,ustar,
     1                 xmonin,wstar,rmm,tempss,rhoss,qswss,irhss,
     2                 ipcode,ptgdf,plexp,leof,kdathre,kse,kdathrb,ksb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDISC
c                J. Scire, D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read ISCMET.DAT meteorological data for one hour
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): allow for begin/end time format
c                                  resolved to seconds
c                                  (retain compatibility with
c                                  standard "ISCMET" versions)
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4, JULDAY,
c                                  GRDAY, INCR
c --- V5.4-V5.4     000602_4(DGS): add QAHRISC call
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c --- V4.0-V5.0     971107  (DGS): add EOF recovery
c                   971107  (DGS): add record-skip logic from COMP to
c                                  find current date-time
c                   971107  (DGS): skip blank records
c
c --- INPUTS:
c       IDATHRM - integer       - Mid-pt date/hour of required
c                                 data (YYYYJJJHH)
c         ISECM - integer       - Mid-pt second of required data (SSSS)
c         LECHO - logical       - Flag controlling printing of input
c                                 meteorological data fields
c    Common block /COMPARM/ variables:
c         PLX0, PTG0, WSCALM
c    Common block /METHD/ variables:
c         NXM, NYM, NZM, NSSTA, NPSTA, LCALGRD, ANEMHT, ITIMES
c    Common block /DISPDAT/ variables:
c         IURB1, IURB2
c    Common block /GRID/ variables:
c         ZGPT
c    Parameters:
c         MXNZMP1, IO6, IO7
c
c --- OUTPUT:
c
c   UMET(mxnx,mxny,mxnz) - real    - U component of the wind (m/s)
c                                    at each grid point
c   VMET(mxnx,mxny,mxnz) - real    - V-component of the wind (m/s)
c        IPGT(mxnx,mxny) - integer - PGT stability class
c       HTMIX(mxnx,mxny) - real    - Mixing height (m)
c       USTAR(mxnx,mxny) - real    - Surface friction velocity (m/s)
c      XMONIN(mxnx,mxny) - real    - Monin-Obukhov length (m)
c       WSTAR(mxnx,mxny) - real    - Convective velocity scale (m/s)
c         RMM(mxnx,mxny) - real    - Precipitation rate (mm/hr)
c          TEMPSS(nssta) - real    - Air temperature (deg. K) at
c                                    each surface met. station
c           RHOSS(nssta) - real    - Air density (kg/m**3)
c           QSWSS(nssta) - real    - Short wave solar radiation
c                                    (W/m**2)
c           IRHSS(nssta) - integer - Relative humidity (percent)
c          IPCODE(nssta) - integer - Precipitation code at each surface
c                                    station
c               PTGDF(2) - real    - Default potential temperature grad.
c                                    for stable classes (deg. K/m)
c                  PLEXP - real    - Power law exponent for wind profile
c                                    (used with single-point met file)
c                   LEOF - logical - End-Of-File flag
c                KDATHRE - integer - End date/hour of data (YYYYJJJHH)
c                    KSE - integer - End second of data (SSSS)
c                KDATHRB - integer - Begin date/hour of data (YYYYJJJHH)
c                    KSB - integer - Begin second of data (SSSS)
c
c --- RDISC called by:  COMP
c --- RDISC calls:      JULDAY, INCR, GRDAY, POWLAW, INITAR,
c                       INITAI, OUT, INITR2D, INITI2D, TPERIOD, YR4
c                       QAHRISC, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'methd.puf'
      include 'comparm.puf'
      include 'dispdat.puf'
      include 'grid.puf'
c
      real umet(mxnx,mxny,mxnz),vmet(mxnx,mxny,mxnz)
      real htmix(mxnx,mxny),ustar(mxnx,mxny),xmonin(mxnx,mxny)
      real wstar(mxnx,mxny),rmm(mxnx,mxny)
      real tempss(nssta),rhoss(nssta),qswss(nssta)
      real ptgdf(2),plexp
c
      integer ipgt(mxnx,mxny),irhss(nssta),ipcode(nssta)
      character*70 messag
      character plfield*5,swfield*9,rhfield*3
      logical lecho,ldate,leof
c
      data ldate/.false./
      data vonk/0.4/
c
c --- Determine IRU value (rural=0, urban=1) from header data
      iru=0
      if(ilandu(1,1) .GE. iurb1 .AND.
     &   ilandu(1,1) .LE. iurb2) iru=1

1     if(itimes.EQ.1) then
c ---    ISC file with beginning & ending times
c -------------------------------------------------------------------
c  --    Read one record of met data in modified ISC format (ASCII)
         read(io7,4,end=999) iby,ibm,ibd,ibh,ksb,iey,iem,ied,ieh,kse,
     &                       fvec,wspd,tmpk,kst,rmix,
     &                       umix,ustr,xmon,z0m,ipc,pmmhr,dthdz,
     &                       plfield,swfield,rhfield
4        format(2(4i2,i4),2f9.4,f6.1,i2,2f7.1,f9.4,f10.1,f8.4,i4,f7.2,
     &          f10.5,a5,a9,a3)
c ---    Skip blank lines
         if(ibm.EQ.0 .OR. ibd.EQ.0) goto 1
c -------------------------------------------------------------------
c ---    Enforce YYYY format for year
         call YR4(io6,iby,ierrb)
         call YR4(io6,iey,ierre)
         if(ierrb.NE.0 .OR. ierrb.NE.0) stop 'Halted in RDISC'

         call julday(io6,iby,ibm,ibd,ijul)
         kdathrb=iby*100000+ijul*100+ibh
         call julday(io6,iey,iem,ied,ijul)
         kdathre=iey*100000+ijul*100+ieh
      else
c ---    Standard/extended ISC file
c -------------------------------------------------------------------
c  --    Read one record of met data in extended ISC format (ASCII)
         read(io7,5,end=999) iy,im,id,ih,fvec,wspd,tmpk,kst,rmix,
     &                       umix,ustr,xmon,z0m,ipc,pmmhr,dthdz,
     &                       plfield,swfield,rhfield
5        format(4i2,2f9.4,f6.1,i2,2f7.1,f9.4,f10.1,f8.4,i4,f7.2,
     &          f10.5,a5,a9,a3)
c ---    Skip blank lines
         if(im.EQ.0 .OR. id.EQ.0) goto 1
c -------------------------------------------------------------------
c ---    Enforce YYYY format for year
         call YR4(io6,iy,ierrb)
         if(ierrb.NE.0) stop 'Halted in RDISC'

c ---    ISCMET.DAT uses a 1-24 clock (hour ending).  Change start
c ---    time to the beginning of the hour (subtract 1 hour)
         ih=ih-1
         call julday(io6,iy,im,id,ijul)
         kdathrb=iy*100000+ijul*100+ih
         ksb=0
c ---    Increment time 1 hour to get end time
         call incr(io6,iy,ijul,ih,1)
         kdathre=iy*100000+ijul*100+ih
         kse=0
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,kdathrb,idum,idum,idum,ksb)
      call TCLOCK(io6,kdathre,idum,idum,idum,kse)

c --- Check period of met data with mid-point of step
      call TPERIOD(0,idathrm,isecm,kdathrb,ksb,kdathre,
     &             kse,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in MET file
         go to 1
      elseif(ilocate.EQ.-1) then
         write(io6,*)'ERROR in subr. RDISC -- current time not found',
     1   ' in the MET data file'
         write(io6,*)' -- Current date/hour,sec = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksb
         write(io6,*)'                           to ',kdathre,kse
         stop
      endif

c --- Apply QA rules to data from file
      call QAHRISC(fvec,wspd,tmpk,kst,rmix,umix,ustr,xmon,
     &             ipc,pmmhr,swfield,rhfield,ierr)
      if(ierr.NE.0) then
         write(io6,*)'ERROR in subr. RDISC -- Data are not complete ',
     1   'in the ISCMET data file'
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksb
         write(io6,*)'                           to ',kdathre,kse
         write(*,*)
         stop 'Halted in RDISC -- see list file.'
      endif

c --- Set current mixing height for land use type (IRU)
      if(iru.EQ.0) then
         zmix=rmix
      else
         zmix=umix
      endif

c --- Check current value of roughness with value in /METHD/
      if(z0m.LE.0.0) then
c ---    Roughness length missing, keep previous value
         z0m=z0(1,1)
      elseif(z0m.NE.z0(1,1)) then
c ---    Valid roughness length changed, update array
c !!!    write(io6,*)'RDISC :  Roughness length changed'
c !!!    write(io6,*)'         Date-Hour      - ',kdathr
c !!!    write(io6,*)'         old,new z0(m)  - ',z0(1,1),z0m
         call initr2d(z0m,mxnx,mxny,nxm,nym,z0)
      endif

c --- Recover from zero u*, L provided during CALM conditions by
c --- assuming no flow (u*=0.0), and virtually no shear layer
c --- (M-O length small).
      if(ustr.LE.0.0) then
         ustr=0.0
         xmon=1.
         if(kst.LE.4) xmon=-1.
      endif

c --- Compute w* from u*,L,zmix
      wstr=0.
      if(xmon.LT.0.) then
         wstr=ustr*(-zmix/(vonk*xmon))**0.33333
      endif

c --- Get potential temperature gradient for stable conditions
      if(dthdz.LE.0.0) then
c ---    Use default potential temperature gradients from control file
         ptgdf(1)=ptg0(1)
         ptgdf(2)=ptg0(2)
      else
         ptgdf(1)=dthdz
         ptgdf(2)=ptgdf(1)
      endif

c --- Set the U, V wind component factors
      rad=fvec*.0174533
      ufac=sin(rad)
      vfac=cos(rad)

c --- Get power law exponent
      if(plfield.EQ.' ') then
c ---    Set power law value for current stability class
         if(kst.GE.7) then
            plexp=plx0(6)
         else
            plexp=plx0(kst)
         endif
      else
         read(plfield,'(bn,f5.0)') plexp
      endif

c --- Get short-wave radiation
      if(swfield.EQ.' ') then
c ---    Blank field; just set to zero
         qswrad=0.0
      else
         read(swfield,'(bn,f9.0)') qswrad
      endif

c --- Get relative humidity
      if(rhfield.EQ.' ') then
c ---    Blank field; just set to 85%
         irelhum=85
      else
         read(rhfield,'(bn,i3)') irelhum
      endif

c --- Pass to 3-D arrays
c --- Profile section
      if(wspd.GE.wscalm) then
c ---    Scale using power law (power law imposes lower speed of wscalm)
         do iz=1,nzm
            call powlaw(zgpt(iz),anemht,wspd,plexp,wsz)
            u=wsz*ufac
            call initr2d(u,mxnx,mxny,nxm,nym,umet(1,1,iz))
            v=wsz*vfac
            call initr2d(v,mxnx,mxny,nxm,nym,vmet(1,1,iz))
         enddo
      else
c ---    Pass the data without scaling and interpret "calms" later
         u=wspd*ufac
         v=wspd*vfac
         do iz=1,nzm
            call initr2d(u,mxnx,mxny,nxm,nym,umet(1,1,iz))
            call initr2d(v,mxnx,mxny,nxm,nym,vmet(1,1,iz))
         enddo
       endif

c --- Place original wind speed (without scaling) into "layer 2" for
c --- possible use;  this applies only if nzm=1
      if(nzm.EQ.1) then
         do iz=2,2
            u=wspd*ufac
            call initr2d(u,mxnx,mxny,nxm,nym,umet(1,1,iz))
            v=wspd*vfac
            call initr2d(v,mxnx,mxny,nxm,nym,vmet(1,1,iz))
         enddo
      endif

c --- Set the 2-D fields
      call initi2d(kst,mxnx,mxny,nxm,nym,ipgt)
      call initr2d(ustr,mxnx,mxny,nxm,nym,ustar)
      call initr2d(zmix,mxnx,mxny,nxm,nym,htmix)
      call initr2d(xmon,mxnx,mxny,nxm,nym,xmonin)
      call initr2d(wstr,mxnx,mxny,nxm,nym,wstar)
      call initr2d(pmmhr,mxnx,mxny,nxm,nym,rmm)

c --- Set the 1-D fields
      call initar(tmpk,nssta,tempss)
      call initar(1.28,nssta,rhoss)
      call initar(qswrad,nssta,qswss)
      call initai(irelhum,nssta,irhss)
      call initai(ipc,nssta,ipcode)

c --- Write the input fields, if requested
      if(LECHO)then
c
c ---    Date and time
         write(io6,*)
         write(io6,*)'------ MET. FIELDS BEGINNING: ',kdathrb,ksb
         write(io6,*)'------            AND ENDING: ',kdathre,kse
         write(io6,*)
c
c ---    3-D fields
         do 101 iz=1,nzm
         messag='U-component (m/s) -- Level: '
         write(messag(29:31),'(i3)')iz
         call out(umet(1,1,iz),idum,1,5,ldate,messag,nxm,nym)
         messag(1:1)='V'
         call out(vmet(1,1,iz),idum,1,5,ldate,messag,nxm,nym)
101      continue
c
c ---    2-D fields
         messag='PGT stability class'
         call out(xdum,ipgt,2,1,ldate,messag,nxm,nym)
         messag='Friction velocity (m/s)'
         call out(ustar,idum,1,5,ldate,messag,nxm,nym)
         messag='Mixing height (m)'
         call out(htmix,idum,1,5,ldate,messag,nxm,nym)
         messag='Monin-Obukhov length (m)'
         call out(xmonin,idum,1,5,ldate,messag,nxm,nym)
         messag='Convective velocity scale (m/s)'
         call out(wstar,idum,1,5,ldate,messag,nxm,nym)
         if(npsta.gt.0)then
            messag='Precipitation rate (mm/hr)'
            call out(rmm,idum,1,5,ldate,messag,nxm,nym)
         endif
c
c ---    1-D fields
         write(io6,*)'TEMPSS (deg. K) = ',(tempss(n),n=1,nssta)
         write(io6,*)'RHOSS (kg/m**3)  = ',(rhoss(n),n=1,nssta)
         write(io6,*)'QSWSS (W/m**2)   = ',(qswss(n),n=1,nssta)
         write(io6,*)'IRHSS (percent)  = ',(irhss(n),n=1,nssta)
         if(npsta.gt.0)write(io6,*)'IPCODE           = ',
     1    (ipcode(n),n=1,nssta)
      endif
c
      return

999   write(io6,*)'RDISC: End-Of-File found in ISCMET file'
      leof=.TRUE.
      return

      end
c----------------------------------------------------------------------
      subroutine qahrisc(fvec,wspd,tmpk,kst,rmix,umix,ustr,xmon,
     &                   ipc,pmmhr,swfield,rhfield,ierr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_4              QAHRISC
c                D. Strimaitis,   Earth Tech
c
c --- PURPOSE:  QA ISCMET.DAT meteorological data for one hour
c
c --- INPUTS:
c          FVEC - real          - Flow vector (degrees CW from N)
c          WSPD - real          - Wind speed (m/s)
c          TMPK - real          - Temperature (K)
c           KST - integer       - Stability class
c          RMIX - real          - Rural mixing ht. (m)
c          UMIX - real          - Urban mixing ht. (m)
c          USTR - real          - Friction velocity (m/s)
c          XMON - real          - Monin-Obukhov length (m)
c           IPC - integer       - Precipitation type code (0-45)
c         PMMHR - real          - Precipitation rate (mm/hr)
c       SWFIELD - character     - Short-wave solar radiation (W/m^2)
c       RHFIELD - character     - Relative humidity (%)
c
c    Common block /FLAGS/ variables:
c         MCHEM, MWET, MDRY, MFOG
c    Parameters:
c         IO6
c
c --- OUTPUT:
c
c          IERR - integer       - Error flag (0: no errors)
c
c --- QAHRISC called by:  RDISC
c --- QAHRISC calls:      none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'flags.puf'
      character swfield*9,rhfield*3

      ierr=0

c --- Check primary fields
      if(fvec.GE.360.1 .OR. fvec.LE.-360.1) then
         write(io6,*) 'QAHRISC --- Invalid Flow Vector (deg): ',fvec
         ierr=1
         return
      endif
      if(wspd.GE.99. .OR. wspd.LT.0.) then
         write(io6,*) 'QAHRISC --- Invalid Wind Speed (m/s): ',wspd
         ierr=1
         return
      endif
      if(tmpk.GE.375. .OR. tmpk.LE.200.) then
         write(io6,*) 'QAHRISC --- Invalid Temperature (K): ',tmpk
         ierr=1
         return
      endif
      if(kst.GT.7 .OR. kst.LE.0) then
         write(io6,*) 'QAHRISC --- Invalid Stability Class: ',kst
         ierr=1
         return
      endif
      if(rmix.LT.0. .OR. umix.LT.0.) then
         write(io6,*) 'QAHRISC --- Invalid Mixing Hts (m): ',rmix,umix
         ierr=1
         return
      endif

c --- U_star may be zero for a CALM, but always must be positive
      if(ustr.LT.0.) then
         write(io6,*) 'QAHRISC --- Invalid U_star (m/s): ',ustr
         ierr=1
         return
      elseif(ustr.EQ.0. .AND. wspd.GE.1.0 .AND. MDRY.GT.0) then
         write(io6,*) 'QAHRISC --- Invalid U_star (m/s): ',ustr
         ierr=1
         return
      endif

c --- Precip type is used for frozen/non-frozen choice, and zero is
c --- a valid value, so merely check range
      if(ipc.LT.0 .OR. ipc.GT.45) then
         write(io6,*) 'QAHRISC --- Invalid Precip Type Code: ',ipc
         ierr=1
         return
      endif

c --- Precip rate cannot be negative, and should not exceed 500mm/hr
      if(pmmhr.GE.500. .OR. pmmhr.LT.0.) then
         write(io6,*) 'QAHRISC --- Invalid Precip (mm/hr): ',pmmhr
         ierr=1
         return
      endif

c --- Extract and test short-wave radiation
      if(swfield.EQ.'         ' .AND. mchem.GT.0) then
c ---    Blank field is not acceptable for chem transformation
         write(io6,*) 'QAHRISC --- SW Radiation is blank '
         ierr=1
         return
      else
         read(swfield,'(bn,f9.0)') qswrad
         if(qswrad.LT.0. .OR. qswrad.GT.1500.) then
            write(io6,*) 'QAHRISC --- Invalid SW Rad (W/m^2): ',qswrad
            ierr=1
            return
         endif
      endif

c --- Extract and test Relative Humidity
      if(rhfield.EQ.'   ' .AND. (mchem.GT.0 .OR. mfog.GT.0)) then
c ---    Blank field is not acceptable for chem transformation
         write(io6,*) 'QAHRISC --- Relative Humidity is blank '
         ierr=1
         return
      else
         read(rhfield,'(bn,i3)') irelhum
         if(irelhum.LT.0. .OR. irelhum.GT.100.) then
            write(io6,*) 'QAHRISC --- Invalid Humidity (%): ',irelhum
            ierr=1
            return
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine met3(lecho)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                   MET3
c                J. Scire, D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Set the header records normally contained in the
c               CALMET file (using PLMMET data file).
c               Also, set the wind profile power-law exponents if
c               not provided in control file.
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): Use c*16 variable VERPLM in new
c                                  /DATASET/ common to identify version.
c                                  Implement full begin/end time
c                                  processing.
c                                  Add METQA call.
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4, JULDAY,
c                                  GRDAY, INCR
c                   030402  (DGS): add map projection, datum
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c --- V5.0-V5.0     980304  (DGS): add station elevation,lat,lon
c --- V4.0-V5.0     971107  (DGS): pass start-time from met file
c                                  for use if METRUN=1
c
c --- INPUTS:
c         LECHO - logical       - Control variable for output of header
c                                 record information
c
c     Common block /DATASET/ variables:
c           VERPLM
c     Common block /GRID/ variables:
c           NX, NY, NZ, DGRID, XORIG, YORIG, ZFACE(mxnzp1)
c     Common block /MAP/ variables:
c           iutmzn,feast,fnorth,
c           rlat0,rlon0,xlat1,xlat2,
c           pmap,utmhem,datum,daten
c     Common block /METHD/ variables:
c           ANEMHT, ILANDUIN, Z0IN, XLAIIN
c     Parameters:
c           MXNZP1, MXSS, MXUS, MXPS, IO6
c
c --- OUTPUT:
c     Common block /COMPARM/ variables:
c           PLX0
c     Common block /METHD/ variables:
c           NXM, NYM, NZM, XGRIDM, XORIGM, YORIGM,
c           NSSTA, NPSTA, NLU, IWAT1, IWAT2, ZFACEM(mxnzp1),
c           XSSTA(mxss),YSSTA(mxss),XUSTA(mxus),YUSTA(mxus),
c           XPSTA(mxps),YPSTA(mxps),Z0(mxnx,mxny),ILANDU(mxnx,mxny),
c           ELEV(mxnx,mxny),XLAI(mxnx,mxny),NEARS(mxnx,mxny),
c           LCALGRD, itimes
c           ibymet,ibmmet,ibdmet,ibjdmet,ibhmet,ibsmet
c           ieymet,iemmet,iedmet,iejdmet,iehmet,iesmet
c           xlat1m, xlat2m, rlat0m, rlon0m
c           iutmznm,feastm,fnorthm,pmapm,datumm,datenm,utmhemm
c
c --- MET3 called by:  SETUP
c --- MET3 calls:      JULDAY, INCR, GRDAY, INITR2D, OUT, INITI2D, YR4
c                      METQA
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      character*80 title(3)
      character*70 messag
      character*8 clab1,clab2
      logical ldate,lecho
c
c --- Include common block /COMPARM/ -- Computation parameters
      include 'comparm.puf'
c --- Include common block /DATASET/  -- Input file dataset version
      include 'dataset.puf'
c --- Include common block /DISPDAT/ -- Dispersion-related data
      include 'dispdat.puf'
c --- Include common block /METHD/ -- CALMET header record data
      include 'methd.puf'
c --- Include common block /GRID/  -- Grid data from control file
      include 'grid.puf'
c --- Include common block /MAP/  -- Projection data from control file
      include 'map.puf'
c
      data ldate/.false./
c
c --- Present code recognizes only 1 dataset version (1.0)
      itimes=0
      if(verplm.NE.'1.0') then
         write(io6,*)'FATAL Error in MET3 -- bad dataset version'
         write(io6,*)'Expected PLMMET dataset version 1.0'
         write(io6,*)'Found PLMMET dataset version ',verplm
         stop 'Halted in MET3 -- see list file'
      endif
c
c --- Read PLMMET header record
c ---------------------------------------------------------------------
      read(io7,'(a80)') title(3)
c                                                              RECORD 1
c ---------------------------------------------------------------------
c --- record #1 - run title --
c --- Set three title-lines
      title(1)='Constant Meteorological Fields'
      title(2)='Created from PLMMET.DAT'
c
c --- record #2 - run control parameters --
c --- (vermet, levmet are both 8 bytes):
c ---  vermet,levmet,ibyr,ibmo,ibdy,ibhr,irtype,
c ---  nxm, nym, nzm, xgridm, xorigm, yorigm, iutmznm, iwfcod, nssta,
c ---  nusta, npsta, nowsta, nlu, iwat1, iwat2, lcalgrd
c
c --- Fill in most first
      irtype=1
      nxm=nx
      nym=ny
      nzm=nz
      xgridm=dgrid
      xorigm=xorig
      yorigm=yorig
      pmapm=pmap
      datumm=datum
      datenm=daten
      iutmznm=iutmzn
      utmhemm=utmhem
      rlat0m=rlat0
      rlon0m=rlon0
      xlat1m=xlat1
      xlat2m=xlat2
      feastm=feast
      fnorthm=fnorth
      iwfcod=1
      nssta=1
      nusta=1
      npsta=1
      nowsta=0
      nlu=10
      iwat1=500
      iwat2=599
      lcalgrd=.FALSE.
c --- Now read date-time from first data record (must rewind!)
c ---------------------------------------------------------------------
      read(io7,'(4i2)') ibymet,ibmmet,ibdmet,ibhmet
      rewind(io7)
      read(io7,'(a80)') title(3)
c                                                              RECORD 2
c ---------------------------------------------------------------------
c --- Enforce YYYY format for year
      call YR4(io6,ibymet,ierr)
      if(ierr.NE.0) then
         write(*,*)
         stop 'Halted in MET3'
      endif

c --- PLMMET.DAT uses a 1-24 clock (hour ending).  Convert to time
c --- beginning by subtracting 1 from the hour (0-23)
      ibhmet=ibhmet-1
      call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
      ibsmet=0
c --- Use "default" run length (hours) to mark the end of data
c --- Assume this will be 5 years, so set IRLG=43848 hours
      irlgmet=43848
      ieymet=ibymet
      iemmet=ibmmet
      iedmet=ibdmet
      iejdmet=ibjdmet
      iehmet=ibhmet
      call INCR(io6,ieymet,iejdmet,iehmet,irlgmet)
      call GRDAY(io6,ieymet,iejdmet,iemmet,iedmet)
      iesmet=0

      if(LECHO)then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*) title(1)
         write(io6,*) title(2)
         write(io6,*) title(3)
         write(io6,*)
         write(io6,*)'-- Data begin at:'
         write(io6,*)' IBYR    = ',ibymet
         write(io6,*)' IBMO    = ',ibmmet
         write(io6,*)' IBDY    = ',ibdmet
         write(io6,*)' IBJUL   = ',ibjdmet
         write(io6,*)' IBHR    = ',ibhmet
         write(io6,*)' IBSEC   = ',ibsmet
         if(verplm.EQ.'1.0') then
            write(io6,*)'-- Data end at:  ?'
         else
            write(io6,*)'-- Data end at:'
         endif
         write(io6,*)' IEYR    = ',ieymet
         write(io6,*)' IEMO    = ',iemmet
         write(io6,*)' IEDY    = ',iedmet
         write(io6,*)' IEJUL   = ',iejdmet
         write(io6,*)' IEHR    = ',iehmet
         write(io6,*)' IESEC   = ',iesmet
         write(io6,*)
         write(io6,*)' IRTYPE  = ',irtype
         write(io6,*)' LCALGRD = ',lcalgrd
         write(io6,*)' NXM     = ',nxm
         write(io6,*)' NYM     = ',nym
         write(io6,*)' NZM     = ',nzm
         write(io6,*)' XGRIDM  = ',xgridm
         write(io6,*)' XORIGM  = ',xorigm
         write(io6,*)' YORIGM  = ',yorigm

         write(io6,*)' PMAPM   = ',pmapm
         write(io6,*)' DATUMM  = ',datumm
         write(io6,*)' DATENM  = ',datenm
         write(io6,*)' IUTMZNM = ',iutmznm
         write(io6,*)' UTMHEMM = ',utmhemm
         write(io6,*)' XLAT1M  = ',xlat1m
         write(io6,*)' XLAT2M  = ',xlat2m
         write(io6,*)' RLAT0M  = ',rlat0m
         write(io6,*)' RLON0M  = ',rlon0m
         write(io6,*)' FEASTM  = ',feastm
         write(io6,*)' FNORTHM = ',fnorthm

         write(io6,*)' IWFCOD  = ',iwfcod
         write(io6,*)' NSSTA   = ',nssta
         write(io6,*)' NUSTA   = ',nusta
         write(io6,*)' NPSTA   = ',npsta
         write(io6,*)' NOWSTA  = ',nowsta
         write(io6,*)' NLU     = ',nlu
         write(io6,*)' IWAT1   = ',iwat1
         write(io6,*)' IWAT2   = ',iwat2
         write(io6,*)' ANEMHT  = ',anemht
      endif
c
      nzmp1=nzm+1
      if(mxnzp1.lt.nzmp1)then
         write(io6,*)'ERROR in subr. MET3 -- dimension of ZFACEM ',
     1   'array is too small for no. layers in ISCMET file'
         write(io6,*)'MXNZP1 = ',mxnzp1,' NZMP1 = ',nzmp1
         write(*,*)
         stop 'Halted in MET3 -- see list file.'
      endif

c
c --- record #3 - cell face heights (NZ + 1 words)
c
c --- Grab the face heights from the control file
      do i=1,nzmp1
         zfacem(i)=zface(i)
      enddo
c
      if(LECHO)then
         write(io6,203)(zfacem(n),n=1,nzmp1)
203      format(1x,'ZFACEM  = ',10(f9.3,', ')/)
      endif

c --- Perform QA checks on header record variables
      call METQA
c
c --- records #4 & 5 - x, y coordinates of surface stations
c --- (NSSTA words each record)
      if(nssta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xssta(1)=xorig
         yssta(1)=yorig
         if(LECHO)then
            clab1='XSSTA'
            clab2='YSSTA'
            write(io6,*)clab1,' = ',(xssta(n),n=1,nssta)
            write(io6,*)clab2,' = ',(yssta(n),n=1,nssta)
         endif
      endif
c
c --- records #4a & 5a - lat, lon coordinates of surface stations
c --- (NSSTA words each record)
      if(nssta.gt.0)then
c ---    Grab the lat,lon from control file inputs
         xlatss(1)=xlatin
         xlonss(1)=xlonin
         if(LECHO)then
            clab1='XLATSS'
            clab2='YLONSS'
            write(io6,*)clab1,' = ',(xlatss(n),n=1,nssta)
            write(io6,*)clab2,' = ',(xlonss(n),n=1,nssta)
         endif
      endif
c
c --- records #6 & 7 - x, y coordinates of upper air stations
c --- (NUSTA words each record)
      if(nusta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xusta(1)=xorig
         yusta(1)=yorig
         if(LECHO)then
            clab1='XUSTA'
            clab2='YUSTA'
            write(io6,*)clab1,' = ',(xusta(n),n=1,nusta)
            write(io6,*)clab2,' = ',(yusta(n),n=1,nusta)
         endif
      endif
c
c --- records #8 & 9 - x, y coordinates of precipitation stations
c --- (NPSTA words each record)
      if(npsta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xpsta(1)=xorig
         ypsta(1)=yorig
         if(LECHO)then
            clab1='XPSTA'
            clab2='YPSTA'
            write(io6,*)clab1,' = ',(xpsta(n),n=1,npsta)
            write(io6,*)clab2,' = ',(ypsta(n),n=1,npsta)
         endif
      endif
c
c --- Fill the corresponding arrays:
c
c --- record #10 - surface roughness lengths (NX * NY words)
      call initr2d(z0in,mxnx,mxny,nxm,nym,z0)
      if(LECHO)then
         messag='Surface roughness lengths (m)'
         messag(63:70)='z0'
         call out(z0,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #11 - land use categories (NX * NY words)
      call initi2d(ilanduin,mxnx,mxny,nxm,nym,ilandu)
      if(LECHO)then
         messag='Land use categories'
         messag(63:70)='ILANDU'
         call out(xdum,ilandu,2,5,ldate,messag,nx,ny)
      endif
c
c --- record #12 - elevations (NX * NY words)
c --- Set grid elevation to ELEVIN from control file
      call initr2d(elevin,mxnx,mxny,nxm,nym,elev)
      if(LECHO)then
         messag='Terrain heights (m)'
         messag(63:70)='TERR'
         call out(elev,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #13 - leaf area index (NX * NY words)
      call initr2d(xlaiin,mxnx,mxny,nxm,nym,xlai)
      if(LECHO)then
         messag='Leaf area index'
         messag(63:70)='XLAI'
         call out(xlai,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #14 - nearest surface station to each grid point
c                  (NX * NY words)
      call initi2d(1,mxnx,mxny,nxm,nym,nears)
      if(LECHO)then
         messag='Nearest surface station no. to each grid point'
         messag(63:70)='NEARS'
         call out(xdum,nears,2,5,ldate,messag,nx,ny)
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine rdplm(idathrm,isecm,lecho,umet,vmet,svprf,ipgt,htmix,
     1                 ustar,xmonin,wstar,rmm,tempss,rhoss,qswss,
     2                 irhss,ipcode,ptgdf,plexp,leof,
     3                 kdathre,kse,kdathrb,ksb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDPLM
c                J. Scire, D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read PLMMET.DAT meteorological data for one hour
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): add start/end times resolved to
c                                  seconds (end time is not contained
c                                  in PLMMET)
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4, JULDAY,
c                                  GRDAY, INCR
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c --- V5.2-V5.3     991222a (DGS): Pass data to SVPRF only if MTURBVW=4
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c --- V5.0-V5.0     980430  (DGS): 'use' DFIELD (compiler warning)
c --- V4.0-V5.0     971107  (DGS): add EOF recovery
c                   971107  (DGS): add record-skip logic from COMP to
c                                  find current date-time
c                   971107  (DGS): skip blank records
c
c --- INPUTS:
c       IDATHRM - integer       - Mid-pt date/hour of required
c                                 data (YYYYJJJHH)
c         ISECM - integer       - Mid-pt second of required data (SSSS)
c         LECHO - logical       - Flag controlling printing of input
c                                 meteorological data fields
c    Common block /COMPARM/ variables:
c         PLX0, PTG0, WSCALM
c    Common block /METHD/ variables:
c         NXM, NYM, NZM, NSSTA, NPSTA, LCALGRD, ANEMHT
c    Common block /DISPDAT/ variables:
c         IURB1, IURB2
c    Common block /FLAGS/ variables:
c         MTURBVW
c    Common block /GRID/ variables:
c         ZGPT
c    Parameters:
c         MXNX, MXNY, MXNZ, MXNZMP1, MXPRFZ, IO6, IO7
c
c --- OUTPUT:
c
c   UMET(mxnx,mxny,mxnz) - real    - U component of the wind (m/s)
c                                    at each grid point
c   VMET(mxnx,mxny,mxnz) - real    - V-component of the wind (m/s)
c   TMET(mxnx,mxny,mxnz) - real    - 3-D temperature field (deg. K)
c          SVPRF(mxprfz) - real    - 1-D sigma-v profile (m/s) (NZM
c                                    levels filled with 1 level read)
c        IPGT(mxnx,mxny) - integer - PGT stability class
c       HTMIX(mxnx,mxny) - real    - Mixing height (m)
c       USTAR(mxnx,mxny) - real    - Surface friction velocity (m/s)
c      XMONIN(mxnx,mxny) - real    - Monin-Obukhov length (m)
c       WSTAR(mxnx,mxny) - real    - Convective velocity scale (m/s)
c         RMM(mxnx,mxny) - real    - Precipitation rate (mm/hr)
c          TEMPSS(nssta) - real    - Air temperature (deg. K) at
c                                    each surface met. station
c           RHOSS(nssta) - real    - Air density (kg/m**3)
c           QSWSS(nssta) - real    - Short wave solar radiation
c                                    (W/m**2)
c           IRHSS(nssta) - integer - Relative humidity (percent)
c          IPCODE(nssta) - integer - Precipitation code at each surface
c                                    station
c               PTGDF(2) - real    - Default potential temperature grad.
c                                    for stable classes (deg. K/m)
c                  PLEXP - real    - Power law exponent for wind profile
c                                    (used with single-point met file)
c                   LEOF - logical - End-Of-File flag
c                KDATHRE - integer - End date/hour of data (YYYYJJJHH)
c                    KSE - integer - End second of data (SSSS)
c                KDATHRB - integer - Begin date/hour of data (YYYYJJJHH)
c                    KSB - integer - Begin second of data (SSSS)
c
c --- RDPLM called by:  COMP
c --- RDPLM calls:      JULDAY, INCR, GRDAY, STAB2L, POWLAW, INITAR,
c                       INITAI,OUT, INITR2D, INITI2D, TPERIOD, YR4,
c                       TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'methd.puf'
      include 'comparm.puf'
      include 'dispdat.puf'
      include 'flags.puf'
      include 'grid.puf'
c
      real umet(mxnx,mxny,mxnz),vmet(mxnx,mxny,mxnz)
      real svprf(mxprfz)
      real htmix(mxnx,mxny),ustar(mxnx,mxny),xmonin(mxnx,mxny)
      real wstar(mxnx,mxny),rmm(mxnx,mxny)
      real tempss(nssta),rhoss(nssta),qswss(nssta)
      real ptgdf(2),plexp
c
      integer ipgt(mxnx,mxny),irhss(nssta),ipcode(nssta)
c
      character*70 messag
      character buff(2),class(6),pfield*5,tfield*5,dfield*10
c --- Set character variables for "extended" data (p-code, p-rate,
c --- qswrad, relhum)
      character pcfield*3,prfield*9,swfield*9,rhfield*3
c
      logical lecho,ldate,leof
c
      data ldate/.false./
      data vonk/0.4/,dtor/0.0174533/
c
c --- Set stability class matrix
      data class/'A','B','C','D','E','F'/

c --- Set default values for "extended" data
1     qswrad=0.0
      irelhum=0
      pmmhr=0.0
      ipc=0

c -------------------------------------------------------------------
c  -- Read one record of met data in PLMMET format (ASCII)
2     read(io7,5,end=999) iy,im,id,ih,tmpc,wspd,iwd,buff,zmix,
     &                    sigtha,pfield,tfield,dfield,
c --- Extended data section
     &                    pcfield,prfield,swfield,rhfield
5     format(BN,4i2,f3.0,f5.0,i4,2a1,2f5.0,2a5,a10,
c --- Extended format section
     &                    a3,a9,a9,a3)
c
c --- Skip blank lines
      if(im.EQ.0 .OR. id.EQ.0) goto 2
c -------------------------------------------------------------------
c --- Enforce YYYY format for year
      call YR4(io6,iy,ierr)
      if(ierr.NE.0) then
         write(*,*)
         stop 'Halted in RDPLM'
      endif

c --- PLMMET.DAT uses a 1-24 clock (hour ending).  Change start
c --- time to the beginning of the hour (subtract 1 hour)
      ih=ih-1
      call julday(io6,iy,im,id,ijul)
      kdathrb=iy*100000+ijul*100+ih
      ksb=0
c --- Increment time 1 hour to get end time
      call incr(io6,iy,ijul,ih,1)
      kdathre=iy*100000+ijul*100+ih
      kse=0

c --- Condition times
      idum=-999
      call TCLOCK(io6,kdathrb,idum,idum,idum,ksb)
      call TCLOCK(io6,kdathre,idum,idum,idum,kse)

c --- Check period of met data with mid-point of step
      call TPERIOD(0,idathrm,isecm,kdathrb,ksb,kdathre,
     &             kse,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in MET file
         go to 1
      elseif(ilocate.EQ.-1) then
         write(io6,*)'ERROR in subr. RDPLM -- current time not found',
     1   ' in the MET data file'
         write(io6,*)' -- Current date/hour,sec   = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksb
         write(io6,*)'                           to ',kdathre,kse
         stop 'Halted in RDPLM -- see list file'
      endif

c --- Read stability class from buff
      if(buff(1).EQ.' ') buff(1)=buff(2)
      do isc=1,6
        if(buff(1).EQ.class(isc)) kst=isc
      enddo

c --- Estimate Monin-O length from Golder relation
c --- (not available in PLMMET.DAT)
      if(kst.EQ.4) then
         xmon=9990.
      else
         call stab2l(kst,z0(1,1),eli)
         xmon=1./eli
      endif

c --- Estimate u* (not available in PLMMET.DAT)
      ustr=vonk*wspd/(alog(anemht/z0(1,1))-psim(xmon,anemht))

c --- Compute w* from u*,L,zmix
      wstr=0.
      if(xmon.LT.0.) then
         wstr=ustr*(-zmix/(vonk*xmon))**0.33333
      endif

c --- Convert temperature to deg. K
      tmpk=tmpc+273.16

c --- Convert sigtha (deg) to sigma-v (m/s) (note: missing sigtha
c --- corresponds to a blank field, which is read as a zero)
      if(sigtha.GT.0.0 .AND. wspd.GE.0.0) then
         sigv=sigtha*dtor*wspd
      else
         sigv=-999.
      endif

c --- Get power law exponent
      if(pfield.EQ.' ') then
c ---    Set default power law value for current stability class
         plexp=plx0(kst)
      else
         read(pfield,'(bn,f5.0)') plexp
      endif

c --- Get potential temperature gradient for stable conditions
      if(tfield.EQ.' ') then
c ---    Use default potential temperature gradients from control file
         ptgdf(1)=ptg0(1)
         ptgdf(2)=ptg0(2)
      else
         read(tfield,'(bn,f5.0)') ptgdf(1)
         ptgdf(2)=ptgdf(1)
      endif

c --- 'Use' decay field (compiler warning)
      dfield=dfield

c --- Get extended data, when provided
c --- Precipitation code
      if(pcfield.NE.' ') then
         read(pcfield,'(bn,i3)') ipc
      endif
c --- Precipitation rate
      if(prfield.NE.' ') then
         read(prfield,'(bn,f9.0)') pmmhr
      endif
c --- Short-wave radiation
      if(swfield.NE.' ') then
         read(swfield,'(bn,f9.0)') qswrad
      endif
c --- Relative humidity
      if(rhfield.NE.' ') then
         read(rhfield,'(bn,i3)') irelhum
      endif

c --- Set the U, V wind component factors
      rad=(float(iwd)+180.)*.0174533
      ufac=sin(rad)
      vfac=cos(rad)

c --- Pass to 3-D arrays
c --- Profile section
      if(wspd.GE.wscalm) then
c ---    Scale using power law (power law imposes lower speed of wscalm)
         do iz=1,nzm
            call powlaw(zgpt(iz),anemht,wspd,plexp,wsz)
            u=wsz*ufac
            call initr2d(u,mxnx,mxny,nxm,nym,umet(1,1,iz))
            v=wsz*vfac
            call initr2d(v,mxnx,mxny,nxm,nym,vmet(1,1,iz))
         enddo
      else
c ---    Pass the data without scaling, and treat "calms" later
         u=wspd*ufac
         v=wspd*vfac
         do iz=1,nzm
            call initr2d(u,mxnx,mxny,nxm,nym,umet(1,1,iz))
            call initr2d(v,mxnx,mxny,nxm,nym,vmet(1,1,iz))
         enddo
       endif

c --- Set the 2-D fields
      call initi2d(kst,mxnx,mxny,nxm,nym,ipgt)
      call initr2d(ustr,mxnx,mxny,nxm,nym,ustar)
      call initr2d(zmix,mxnx,mxny,nxm,nym,htmix)
      call initr2d(xmon,mxnx,mxny,nxm,nym,xmonin)
      call initr2d(wstr,mxnx,mxny,nxm,nym,wstar)
      call initr2d(pmmhr,mxnx,mxny,nxm,nym,rmm)

c --- Set the 1-D fields
      if(mturbvw.EQ.4) call initar(sigv,nzm,svprf)
      call initar(tmpk,nssta,tempss)
      call initar(1.28,nssta,rhoss)
      call initar(qswrad,nssta,qswss)
      call initai(irelhum,nssta,irhss)
      call initai(ipc,nssta,ipcode)

c --- Write the input fields, if requested
      if(LECHO)then
c
c ---    Date and time
         write(io6,*)
         write(io6,*)'------ MET. FIELDS BEGINNING: ',kdathrb,ksb
         write(io6,*)'------            AND ENDING: ',kdathre,kse
         write(io6,*)
c
c ---    3-D fields
         do 101 iz=1,nzm
         messag='U-component (m/s) -- Level: '
         write(messag(29:31),'(i3)')iz
         call out(umet(1,1,iz),idum,1,5,ldate,messag,nxm,nym)
         messag(1:1)='V'
         call out(vmet(1,1,iz),idum,1,5,ldate,messag,nxm,nym)
101      continue
c
c ---    2-D fields
         messag='PGT stability class'
         call out(xdum,ipgt,2,1,ldate,messag,nxm,nym)
         messag='Friction velocity (m/s)'
         call out(ustar,idum,1,5,ldate,messag,nxm,nym)
         messag='Mixing height (m)'
         call out(htmix,idum,1,5,ldate,messag,nxm,nym)
         messag='Monin-Obukhov length (m)'
         call out(xmonin,idum,1,5,ldate,messag,nxm,nym)
         messag='Convective velocity scale (m/s)'
         call out(wstar,idum,1,5,ldate,messag,nxm,nym)
         if(npsta.gt.0)then
            messag='Precipitation rate (mm/hr)'
            call out(rmm,idum,1,5,ldate,messag,nxm,nym)
         endif
c
c ---    1-D fields
         write(io6,*)'SVPRF (m/s)     = ',(svprf(n),n=1,nzm)
         write(io6,*)'TEMPSS (deg. K) = ',(tempss(n),n=1,nssta)
         write(io6,*)'RHOSS (kg/m**3)  = ',(rhoss(n),n=1,nssta)
         write(io6,*)'QSWSS (W/m**2)   = ',(qswss(n),n=1,nssta)
         write(io6,*)'IRHSS (percent)  = ',(irhss(n),n=1,nssta)
         if(npsta.gt.0)write(io6,*)'IPCODE           = ',
     1    (ipcode(n),n=1,nssta)
      endif
c
      return

999   write(io6,*)'RDPLM: End-Of-File found in PLMMET file'
      leof=.TRUE.
      return

      end
c----------------------------------------------------------------------
      subroutine met4(metfm,lecho)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                   MET4
c                D. Strimaitis,   Earth Tech
c
c --- PURPOSE:  Create the header information normally contained
c               in the CALMET file, using PROFILE file.  Also, skip
c               any header records in the SURFACE file when available.
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): Add 'dataset 2.1' file format, and
c                                  use c*16 variable VERISC in new
c                                  /DATASET/ common to identify version.
c                                  Implement full begin/end time
c                                  processing.
c                                  Add METQA call.
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4, JULDAY,
c                                  GRDAY, INCR
c                   030402  (DGS): add map projection, datum
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c --- V5.0-V5.0     980304  (DGS): add station elevation,lat,lon
c --- V4.0-V5.0     971107  (DGS): pass start-time from met file
c                                  for use if METRUN=1
c
c --- INPUTS:
c         METFM - integer       - Met data file type
c                                 1 = CALMET/AUSMET binary format
c                                     (CALMET.DAT, AUSMET.DAT)
c                                 2 = ISC ASCII file (ISCMET.DAT)
c                                 3 = AUSPLUME ASCII file (PLMMET.DAT)
c                                 4 = CTDM PROFILE & SURFACE files
c                                 5 = AERMET PROFILE & SURFACE files
c         LECHO - logical       - Control variable for output of header
c                                 record information
c     Common block /DATASET/ variables:
c           VERPRF, VERSFC
c     Common block /GRID/ variables:
c           NX, NY, NZ, DGRID, XORIG, YORIG, ZFACE(mxnzp1)
c     Common block /MAP/ variables:
c           iutmzn,feast,fnorth,
c           rlat0,rlon0,xlat1,xlat2,
c           pmap,utmhem,datum,daten
c     Common block /METHD/ variables:
c           ANEMHT, ILANDUIN, Z0IN, XLAIIN
c     Parameters:
c           MXNZP1, MXSS, MXUS, MXPS, IO6, IO31, IO32
c
c --- OUTPUT:
c     Common block /METHD/ variables:
c           NXM, NYM, NZM, XGRIDM, XORIGM, YORIGM, IUTMZNM,
c           NSSTA, NPSTA, NLU, IWAT1, IWAT2, ZFACEM(mxnzp1),
c           XSSTA(mxss),YSSTA(mxss),XUSTA(mxus),YUSTA(mxus),
c           XPSTA(mxps),YPSTA(mxps),Z0(mxnx,mxny),ILANDU(mxnx,mxny),
c           ELEV(mxnx,mxny),XLAI(mxnx,mxny),NEARS(mxnx,mxny),
c           ibymet,ibmmet,ibdmet,ibjdmet,ibhmet,ibsmet,itimes
c           ieymet,iemmet,iedmet,iejdmet,iehmet,iesmet
c           LCALGRD,IMIXCTDM,ISIGMAV
c           xlat1m, xlat2m, rlat0m, rlon0m
c           iutmznm,feastm,fnorthm,pmapm,datumm,datenm,utmhemm
c
c --- MET4 called by:  SETUP
c --- MET4 calls:      JULDAY, INCR, GRDAY, INITR2D, OUT, INITI2D, YR4
c                      METQA, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      character*80 title(3)
      character*70 messag
      character*8 clab1,clab2
      character*3 abegin,aend
      character*4 map
      logical ldate,lecho
c
c --- Include common block /CSIGMA/ -- Dispersion coeff. data
      include 'csigma.puf'
c --- Include common block /DATASET/  -- Input file dataset version
      include 'dataset.puf'
c --- Include common block /METHD/ -- CALMET header record data
      include 'methd.puf'
c --- Include common block /GRID/  -- Grid data from control file
      include 'grid.puf'
c --- Include common block /MAP/  -- Projection data from control file
      include 'map.puf'
c
      data ldate/.false./
c
c --- Position the SURFACE file at the first data record, since
c --- header information from the PROFILE file will be used to fill
c --- the /METHD/ common
      if(versfc.NE.'0.0') then
c ---    SURFACE file has been opened
         if(versfc.EQ.'2.1') then
c ---       Full version 2.1 with beginning & ending times (non-std)
            read(io32,*)
            read(io32,*) ncomm
c ---       Skip comment records
            do k=1,ncomm
               read(io32,*) 
            enddo
c ---       Allow map projection of 'NONE'
            read(io32,'(a4)') map
            if(map.NE.'NONE') then
              write(io6,*)'FATAL Error in MET4 -- Unsupported Map Proj'
              write(io6,*)'in the SURFACE file '
              write(io6,*)'Expected NONE, Found map = ',map
              stop 'Halted in MET4 -- see list file'
            endif
            read(io32,*)
         elseif(versfc.EQ.'1.6') then
c ---       Skip beginning & ending times
            read(io32,*)
         endif
c ---    Discard final header record of AERMET SURFACE.DAT
         if(metfm.EQ.5) read(io32,*)
      endif

c --- record #1 - run title --
c --- Set three title-lines
      title(1)='Constant Meteorological Fields'
      title(2)='Created for PROFILE.DAT'
      title(3)=' '

c --- Process PROFILE HEADER records (or extract info from data record)
      if(verprf.EQ.'2.1') then
c ---    Full version 2.1 with beginning & ending times (non-standard)
         itimes=1
         read(io31,'(a80)') title(1)
         read(io31,*) ncomm
c ---    Keep first comment record
         read(io31,'(a80)') title(2)
c ---    Skip other comment records
         do k=2,ncomm
            read(io31,*) 
         enddo
c ---    Allow map projection of 'NONE'
         read(io31,'(a4)') map
         if(map.NE.'NONE') then
            write(io6,*)'FATAL Error in MET4 -- Unsupported Map Proj'
            write(io6,*)'in the PROFILE file '
            write(io6,*)'Expected NONE, Found map = ',map
            stop 'Halted in MET4 -- see list file'
         endif
         read(io31,*) ibymet,ibmmet,ibdmet,ibhmet,ibsmet,
     &               ieymet,iemmet,iedmet,iehmet,iesmet
c ---    Enforce YYYY format for year
         call YR4(io6,ibymet,ierrb)
         call YR4(io6,ieymet,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in MET4'
         call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
         call JULDAY(io6,ieymet,iemmet,iedmet,iejdmet)

      elseif(verprf.EQ.'1.6') then
c ---    Beginning & ending times are provided (non-standard)
         itimes=1
         read(io31,'(a80)') title(1)
         read(title(1),*) abegin,ibymet,ibmmet,ibdmet,ibhmet,ibsmet,
     &                    aend,ieymet,iemmet,iedmet,iehmet,iesmet
c ---    Enforce YYYY format for year
         call YR4(io6,ibymet,ierrb)
         call YR4(io6,ieymet,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in MET4'
         call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
         call JULDAY(io6,ieymet,iemmet,iedmet,iejdmet)

      else
         itimes=0
c ---    Extract date-time from first record (must rewind)
         read(io31,*) ibymet,ibmmet,ibdmet,ibhmet
         rewind(io31)
c ---    Enforce YYYY format for year
         call YR4(io6,ibymet,ierrb)
         if(ierrb.NE.0) stop 'Halted in MET4'
c ---    PROFILE.DAT uses a 1-24 clock (hour ending).  Convert to time
c ---    beginning by subtracting 1 from the hour (0-23)
         ibhmet=ibhmet-1
         call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
         ibsmet=0
c ---    Use "default" run length (hours) to mark the end of data
c ---    Assume this will be 5 years, so set IRLG=43848
         irlgmet=43848
         ieymet=ibymet
         iemmet=ibmmet
         iedmet=ibdmet
         iejdmet=ibjdmet
         iehmet=ibhmet
         call INCR(io6,ieymet,iejdmet,iehmet,irlgmet)
         call GRDAY(io6,ieymet,iejdmet,iemmet,iedmet)
         iesmet=0
         call JULDAY(io6,ibymet,ibmmet,ibdmet,ibjdmet)
         call JULDAY(io6,ieymet,iemmet,iedmet,iejdmet)
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibymet,ibjdmet,ibhmet,ibsmet)
      call TCLOCK(io6,idum,ieymet,iejdmet,iehmet,iesmet)
      call GRDAY(io6,ibymet,ibjdmet,ibmmet,ibdmet)
      call GRDAY(io6,ieymet,iejdmet,iemmet,iedmet)

c
c --- record #2 - run control parameters --
c --- (vermet, levmet are both 8 bytes):
c ---  vermet,levmet,ibyr,ibmo,ibdy,ibhr,irtype,
c ---  nxm, nym, nzm, xgridm, xorigm, yorigm, iutmznm, iwfcod, nssta,
c ---  nusta, npsta, nowsta, nlu, iwat1, iwat2, lcalgrd
c
c --- Fill in most first
      irtype=1
      nxm=nx
      nym=ny
      nzm=nz
      xgridm=dgrid
      xorigm=xorig
      yorigm=yorig
      pmapm=pmap
      datumm=datum
      datenm=daten
      iutmznm=iutmzn
      utmhemm=utmhem
      rlat0m=rlat0
      rlon0m=rlon0
      xlat1m=xlat1
      xlat2m=xlat2
      feastm=feast
      fnorthm=fnorth
      iwfcod=1
      nssta=1
      nusta=1
      npsta=1
      nowsta=0
      nlu=10
      iwat1=500
      iwat2=599
      lcalgrd=.TRUE.


      if(LECHO)then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*) title(1)
         write(io6,*) title(2)
         write(io6,*) title(3)
         write(io6,*)
         write(io6,*)'-- Data begin at:'
         write(io6,*)' IBYR    = ',ibymet
         write(io6,*)' IBMO    = ',ibmmet
         write(io6,*)' IBDY    = ',ibdmet
         write(io6,*)' IBJUL   = ',ibjdmet
         write(io6,*)' IBHR    = ',ibhmet
         write(io6,*)' IBSEC   = ',ibsmet
         if(verprf.EQ.'1.0') then
            write(io6,*)'-- Data end at:  ?'
         else
            write(io6,*)'-- Data end at:'
         endif
         write(io6,*)' IEYR    = ',ieymet
         write(io6,*)' IEMO    = ',iemmet
         write(io6,*)' IEDY    = ',iedmet
         write(io6,*)' IEJUL   = ',iejdmet
         write(io6,*)' IEHR    = ',iehmet
         write(io6,*)' IESEC   = ',iesmet
         write(io6,*)
         write(io6,*)' ISIGMAV = ',isigmav
         if(isigmav.EQ.0) then
            write(io6,*)'     (read sigma-theta and convert to sigma-v)'
         else
            write(io6,*)'     (read sigma-v)'
         endif
         write(io6,*)' IRTYPE  = ',irtype
         write(io6,*)' LCALGRD = ',lcalgrd
         write(io6,*)' NXM     = ',nxm
         write(io6,*)' NYM     = ',nym
         write(io6,*)' NZM     = ',nzm
         write(io6,*)' XGRIDM  = ',xgridm
         write(io6,*)' XORIGM  = ',xorigm
         write(io6,*)' YORIGM  = ',yorigm

         write(io6,*)' PMAPM   = ',pmapm
         write(io6,*)' DATUMM  = ',datumm
         write(io6,*)' DATENM  = ',datenm
         write(io6,*)' IUTMZNM = ',iutmznm
         write(io6,*)' UTMHEMM = ',utmhemm
         write(io6,*)' XLAT1M  = ',xlat1m
         write(io6,*)' XLAT2M  = ',xlat2m
         write(io6,*)' RLAT0M  = ',rlat0m
         write(io6,*)' RLON0M  = ',rlon0m
         write(io6,*)' FEASTM  = ',feastm
         write(io6,*)' FNORTHM = ',fnorthm

         write(io6,*)' IWFCOD  = ',iwfcod
         write(io6,*)' NSSTA   = ',nssta
         write(io6,*)' NUSTA   = ',nusta
         write(io6,*)' NPSTA   = ',npsta
         write(io6,*)' NOWSTA  = ',nowsta
         write(io6,*)' NLU     = ',nlu
         write(io6,*)' IWAT1   = ',iwat1
         write(io6,*)' IWAT2   = ',iwat2
      endif
c
      nzmp1=nzm+1
c
c --- record #3 - cell face heights (NZ + 1 words)
c
c --- Grab the face heights from the control file
      do i=1,nzmp1
         zfacem(i)=zface(i)
      enddo
c
      if(LECHO)then
         write(io6,203)(zfacem(n),n=1,nzmp1)
203      format(1x,'ZFACEM  = ',10(f9.3,', ')/)
      endif

c --- Perform QA checks on header record variables
      call METQA
c
c --- records #4 & 5 - x, y coordinates of surface stations
c --- (NSSTA words each record)
      if(nssta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xssta(1)=xorig
         yssta(1)=yorig
         if(LECHO)then
            clab1='XSSTA'
            clab2='YSSTA'
            write(io6,*)clab1,' = ',(xssta(n),n=1,nssta)
            write(io6,*)clab2,' = ',(yssta(n),n=1,nssta)
         endif
      endif
c
c --- records #4a & 5a - lat, lon coordinates of surface stations
c --- (NSSTA words each record)
      if(nssta.gt.0)then
c ---    Grab the lat,lon from control file inputs
         xlatss(1)=xlatin
         xlonss(1)=xlonin
         if(LECHO)then
            clab1='XLATSS'
            clab2='YLONSS'
            write(io6,*)clab1,' = ',(xlatss(n),n=1,nssta)
            write(io6,*)clab2,' = ',(xlonss(n),n=1,nssta)
         endif
      endif
c
c --- records #6 & 7 - x, y coordinates of upper air stations
c --- (NUSTA words each record)
      if(nusta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xusta(1)=xorig
         yusta(1)=yorig
         if(LECHO)then
            clab1='XUSTA'
            clab2='YUSTA'
            write(io6,*)clab1,' = ',(xusta(n),n=1,nusta)
            write(io6,*)clab2,' = ',(yusta(n),n=1,nusta)
         endif
      endif
c
c --- records #8 & 9 - x, y coordinates of precipitation stations
c --- (NPSTA words each record)
      if(npsta.gt.0)then
c ---    Grab the UTM (m) coordinates from the grid origin
         xpsta(1)=xorig
         ypsta(1)=yorig
         if(LECHO)then
            clab1='XPSTA'
            clab2='YPSTA'
            write(io6,*)clab1,' = ',(xpsta(n),n=1,npsta)
            write(io6,*)clab2,' = ',(ypsta(n),n=1,npsta)
         endif
      endif
c
c --- Fill the corresponding arrays:
c
c --- record #10 - surface roughness lengths (NX * NY words)
      call initr2d(z0in,mxnx,mxny,nxm,nym,z0)
      if(LECHO)then
         messag='Surface roughness lengths (m)'
         messag(63:70)='z0'
         call out(z0,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #11 - land use categories (NX * NY words)
      call initi2d(ilanduin,mxnx,mxny,nxm,nym,ilandu)
      if(LECHO)then
         messag='Land use categories'
         messag(63:70)='ILANDU'
         call out(xdum,ilandu,2,5,ldate,messag,nx,ny)
      endif
c
c --- record #12 - elevations (NX * NY words)
c --- Set grid elevation to ELEVIN from control file
      call initr2d(elevin,mxnx,mxny,nxm,nym,elev)
      if(LECHO)then
         messag='Terrain heights (m)'
         messag(63:70)='TERR'
         call out(elev,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #13 - leaf area index (NX * NY words)
      call initr2d(xlaiin,mxnx,mxny,nxm,nym,xlai)
      if(LECHO)then
         messag='Leaf area index'
         messag(63:70)='XLAI'
         call out(xlai,idum,1,5,ldate,messag,nx,ny)
      endif
c
c --- record #14 - nearest surface station to each grid point
c                  (NX * NY words)
      call initi2d(1,mxnx,mxny,nxm,nym,nears)
      if(LECHO)then
         messag='Nearest surface station no. to each grid point'
         messag(63:70)='NEARS'
         call out(xdum,nears,2,5,ldate,messag,nx,ny)
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine MET4PROF(lecho)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915               MET4PROF
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read the header information from CTDM/AERMET PROFILE
c               file if present (MET4PROF is needed if PROFILE.DAT
c               is used for turbulence data or inversion strength data
c               only)
c
c --- INPUTS:
c         LECHO - logical       - Control variable for output of header
c                                 record information
c
c     Common block /DATASET/ variables:
c           VERPRF
c     Parameters:
c           IO6, IO31
c
c --- OUTPUT:
c     Common block /METHD/ variables:
c           itimeprf
c
c --- MET4PROF called by:  SETUP
c --- MET4PROF calls:      JULDAY, YR4, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      character*4 map
      character*3 abegin,aend
      logical lecho
c
c --- Include common block /DATASET/  -- Input file dataset version
      include 'dataset.puf'
c --- Include common block /METHD/ -- CALMET header record data
      include 'methd.puf'

c --- Process HEADER records (or extract info from data record)
      if(verprf.EQ.'2.1') then
c ---    Full version 2.1 with beginning & ending times (non-standard)
         itimeprf=1
c ---    Skip dataset record
         read(io31,*)
         read(io31,*) ncomm
c ---    Skip comment records
         do k=1,ncomm
            read(io31,*) 
         enddo
c ---    Allow map projection of 'NONE'
         read(io31,'(a4)') map
         if(map.NE.'NONE') then
            write(io6,*)'FATAL Error in MET4PROF -- ',
     &                  'Unsupported Map Proj'
            write(io6,*)'in the PROFILE file '
            write(io6,*)'Expected NONE, Found map = ',map
            stop 'Halted in MET4PROF -- see list file'
         endif
         read(io31,*) ibyt,ibmt,ibdt,ibht,ibst,
     &                ieyt,iemt,iedt,ieht,iest
c ---    Enforce YYYY format for year
         call YR4(io6,ibyt,ierrb)
         call YR4(io6,ieyt,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in MET4PROF'
         call JULDAY(io6,ibyt,ibmt,ibdt,ibjdt)
         call JULDAY(io6,ieyt,iemt,iedt,iejdt)

      elseif(verprf.EQ.'1.6') then
c ---    Beginning & ending times are provided (non-standard)
         itimeprf=1
         read(io31,*) abegin,ibyt,ibmt,ibdt,ibht,ibst,
     &                aend,ieyt,iemt,iedt,ieht,iest
c ---    Enforce YYYY format for year
         call YR4(io6,ibyt,ierrb)
         call YR4(io6,ieyt,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in MET4PROF'
         call JULDAY(io6,ibyt,ibmt,ibdt,ibjdt)
         call JULDAY(io6,ieyt,iemt,iedt,iejdt)

      else
         itimeprf=0
c ---    Extract date-time from first record (must rewind)
         read(io31,*) ibyt,ibmt,ibdt,ibht
         rewind(io31)
c ---    Enforce YYYY format for year
         call YR4(io6,ibyt,ierrb)
         if(ierrb.NE.0) stop 'Halted in MET4PROF'
c ---    PROFILE.DAT uses a 1-24 clock (hour ending).  Convert to time
c ---    beginning by subtracting 1 from the hour (0-23)
         ibht=ibht-1
         call JULDAY(io6,ibyt,ibmt,ibdt,ibjdt)
         ibst=0
c ---    Use "default" run length (hours) to mark the end of data
c ---    Assume this will be 5 years, so set IRLG=43848
         irlgt=43848
         ieyt=ibyt
         iemt=ibmt
         iedt=ibdt
         iejdt=ibjdt
         ieht=ibht
         call INCR(io6,ieyt,iejdt,ieht,irlgt)
         call GRDAY(io6,ieyt,iejdt,iemt,iedt)
         iest=0
         call JULDAY(io6,ibyt,ibmt,ibdt,ibjdt)
         call JULDAY(io6,ieyt,iemt,iedt,iejdt)
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyt,ibjdt,ibht,ibst)
      call TCLOCK(io6,idum,ieyt,iejdt,ieht,iest)
      call GRDAY(io6,ibyt,ibjdt,ibmt,ibdt)
      call GRDAY(io6,ieyt,iejdt,iemt,iedt)


      if(LECHO)then
         write(io6,*)
         write(io6,*)
         write(io6,*)' -------------------------------------------'
         write(io6,*)' ------- PROFILE HEADER INFORMATION --------'
         write(io6,*)' -------------------------------------------'
         write(io6,*)
         write(io6,*)'-- Data begin at:'
         write(io6,*)' IBYR    = ',ibyt
         write(io6,*)' IBMO    = ',ibmt
         write(io6,*)' IBDY    = ',ibdt
         write(io6,*)' IBJUL   = ',ibjdt
         write(io6,*)' IBHR    = ',ibht
         write(io6,*)' IBSEC   = ',ibst
         if(verprf.NE.'1.0') then
            write(io6,*)'-- Data end at:'
            write(io6,*)' IEYR    = ',ieyt
            write(io6,*)' IEMO    = ',iemt
            write(io6,*)' IEDY    = ',iedt
            write(io6,*)' IEJUL   = ',iejdt
            write(io6,*)' IEHR    = ',ieht
            write(io6,*)' IESEC   = ',iest
         else
            write(io6,*)'-- Data end at:  ?'
         endif
         write(io6,*)
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine rdmet4(idathrm,isecm,lecho,ptg,izp,wsprf,wdprf,tprf,
     &                  zprf,ssprf,swprf,svprf,ipgt,htmix,ustar,xmonin,
     &                  wstar,rmm,tempss,rhoss,qswss,irhss,ipcode,
     &                  dptinvo,leof,kdathre,kse,kdathrb,ksb)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDMET4
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read meteorological data for one hour from CTDM
c               PROFILE and SURFACE files
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): allow for begin/end time format
c                                  resolved to seconds.
c                                  (retain compatibility with standard
c                                  PROFILE and SURFACE version)
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4, JULDAY,
c                                  GRDAY, INCR
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c --- V4.0-V5.0     971107  (DGS): add EOF recovery
c                   971107  (DGS): initialize data as missing for non-
c                                  measurement levels
c                   971107  (DGS): add record-skip logic from COMP to
c                                  find current date-time
c                                  and act on PROBLEMs found in XTPRF
c                                  for records that are not skipped
c                   971107  (DGS): skip blank records
c                   971107  (DGS): allow inversion strength in PROFILE
c                   971107  (DGS): move PROFILE.DAT reads into RDPROF
c
c --- INPUTS:
c       IDATHRM - integer       - Mid-pt date/hour of required
c                                 data (YYYYJJJHH)
c         ISECM - integer       - Mid-pt second of required data (SSSS)
c         LECHO - logical       - Flag controlling printing of input
c                                 meteorological data fields
c        PTG(2) - real          - Default potential temperature grad.
c                                 for stable classes (deg. K/m)
c    Common block /METHD/ variables:
c         NXM, NYM, NZM, NSSTA, NPSTA, ZFACEM(mxnzp1), LCALGRD,
c         IMIXCTDM, ISIGMAV, ITIMES, ITIMEPRF
c    Parameters:
c         MXNX, MXNY, MXNZ, MXNZP1, MXPRFZ, IO6
c
c --- OUTPUT:
c
c                    IZP - integer - Number of profile levels
c          WSPRF(mxprfz) - real    - 1-D vector wind speed profile (m/s)
c          WDPRF(mxprfz) - real    - 1-D vector wind dir. profile (deg)
c           TPRF(mxprfz) - real    - Temperature profile (deg. K)
c           ZPRF(mxprfz) - real    - Heights for data in profile (m)
c          SSPRF(mxprfz) - real    - 1-D scalar speed profile (m/s)
c          SWPRF(mxprfz) - real    - 1-D sigma-w profile (m/s)
c          SVPRF(mxprfz) - real    - 1-D sigma-v profile (m/s)
c        IPGT(mxnx,mxny) - integer - PGT stability class
c       HTMIX(mxnx,mxny) - real    - Mixing height (m)
c       USTAR(mxnx,mxny) - real    - Surface friction velocity (m/s)
c      XMONIN(mxnx,mxny) - real    - Monin-Obukhov length (m)
c       WSTAR(mxnx,mxny) - real    - Convective velocity scale (m/s)
c         RMM(mxnx,mxny) - real    - Precipitation rate (mm/hr)
c          TEMPSS(nssta) - real    - Air temperature (deg. K) at
c                                    each surface met. station
c           RHOSS(nssta) - real    - Air density (kg/m**3)
c           QSWSS(nssta) - real    - Short wave solar radiation
c                                    (W/m**2)
c           IRHSS(nssta) - integer - Relative humidity (percent)
c          IPCODE(nssta) - integer - Precipitation code at each surface
c                                    station
c                DPTINVO - real    - Inversion strength at top of CBL
c                                    (jump in potential temperature K)
c                   LEOF - logical - End-Of-File flag
c                KDATHRE - integer - End date/hour of data (YYYYJJJHH)
c                    KSE - integer - End second of data (SSSS)
c                KDATHRB - integer - Begin date/hour of data (YYYYJJJHH)
c                    KSB - integer - Begin second of data (SSSS)
c
c --- RDMET4 called by:  COMP
c --- RDMET4 calls:      JULDAY, INCR, GRDAY, INITAR,
c                        INITAI, OUT, INITR2D, INITI2D,
c                        LSTAB, XTPRF, RDPROF, TPERIOD, YR4, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'methd.puf'
      include 'comparm.puf'
      include 'dispdat.puf'
      include 'grid.puf'
c
c --- Profile data arrays

      real wsprf(mxprfz),wdprf(mxprfz),tprf(mxprfz),zprf(mxprfz)
      real ssprf(mxprfz),swprf(mxprfz),svprf(mxprfz)
c --- Real 2-D fields
      real htmix(mxnx,mxny),ustar(mxnx,mxny),xmonin(mxnx,mxny)
      real wstar(mxnx,mxny),rmm(mxnx,mxny)
c --- Real 1-D fields
      real tempss(nssta),rhoss(nssta),qswss(nssta)
c
      integer ipgt(mxnx,mxny),irhss(nssta),ipcode(nssta)
c
      character messag*70,aline*132
c
      logical lecho,ldate,problem,leof
c
      data ldate/.false./
      data vonk/0.4/,third/0.3333333/

c --- Set logical to halt program if problem is found
1     problem=.FALSE.

c -------------------------------------------------------------------
c  -- Read one record of met data from CTDM SURFACE file
c -------------------------------------------------------------------
c --- Read entire line as character variable
4     read(io32,'(a132)',end=998) aline
c --- Try to extract fields for an extended record (internal read)
      if(itimes.EQ.1) then
         read(aline,*,end=5) iby,ibm,ibd,ibjul,ibh,ksb,
     &                       iey,iem,ied,iejul,ieh,kse,
     &                       ziobs,zipre,ustr,xmon,z0m,
     &                       ipc,pmmhr,qswrad,irelhum
      else
         read(aline,*,end=5) iey,iem,ied,iejul,ieh,
     &                       ziobs,zipre,ustr,xmon,z0m,
     &                       ipc,pmmhr,qswrad,irelhum
      endif
      goto 6
c --- Extended data are incomplete or missing; use default values
5     qswrad=0.0
      irelhum=85
      pmmhr=0.0
      ipc=0
6     continue
c
c --- Skip blank lines
      if(itimes.EQ.1) then
         if(ibm.EQ.0 .OR. ibd.EQ.0) goto 4
      else
         if(iem.EQ.0 .OR. ied.EQ.0) goto 4
      endif
c -------------------------------------------------------------------

c --- Process date-time information
      if(itimeprf.EQ.1) then
c ---    Enforce YYYY format for year
         call YR4(io6,iby,ierrb)
         call YR4(io6,iey,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDMET4'
         kdathrb=iby*100000+ibjul*100+ibh
         kdathre=iey*100000+iejul*100+ieh
      else
c ---    Enforce YYYY format for year
         call YR4(io6,iey,ierrb)
         if(ierrb.NE.0) stop 'Halted in RDMET4'
c ---    SURFACE.DAT uses a 1-24 clock (hour ending).  Change
c ---    time to the beginning of the hour (subtract 1 hour)
         ih=ieh-1
         call julday(io6,iey,iem,ied,ijul)
         kdathrb=iey*100000+ijul*100+ih
         ksb=0
c ---    Increment time 1 hour to get end time
         call incr(io6,iey,ijul,ih,1)
         kdathre=iey*100000+ijul*100+ih
         kse=0
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,kdathrb,idum,idum,idum,ksb)
      call TCLOCK(io6,kdathre,idum,idum,idum,kse)

c --- Check period of met data with mid-point of step
      call TPERIOD(0,idathrm,isecm,kdathrb,ksb,kdathre,
     &             kse,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in MET file
         go to 1
      elseif(ilocate.EQ.-1) then
         write(io6,*)'ERROR in subr. RDMET4 -- current time not found',
     1   ' in the SURFACE data file'
         write(io6,*)' --   Current date/hour,sec = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksb
         write(io6,*)'                           to ',kdathre,kse
         stop 'Halted in RDMET4 -- see list file.'
      endif

c --- Set current mixing height
      if(imixctdm.EQ.0) then
         zmix=zipre
         if(zmix.LT.0.0) zmix=ziobs
      else
         zmix=ziobs
         if(zmix.LT.0.0) zmix=zipre
      endif

c --- Check current value of roughness with value in /METHD/
      if(z0m.LE.0.0) then
c ---    Roughness length missing, keep previous value
         z0m=z0(1,1)
      elseif(z0m.NE.z0(1,1)) then
c ---    Valid roughness length changed, update array
c !!!    write(io6,*)'RDMET4:  Roughness length changed'
c !!!    write(io6,*)'         Date-Hour      - ',ksdathr
c !!!    write(io6,*)'         old,new z0(m)  - ',z0(1,1),z0m
         call initr2d(z0m,mxnx,mxny,nxm,nym,z0)
      endif

c --- Recover from missing u*, L by assuming that there is no
c --- stability influence, and no flow .... CALM.  This is likely
c --- because METPRO will give non-missing surface layer parameters
c --- for "real" data.  However, if onsite tower data are missing,
c --- and the offsite data are "zero" for speed and possibly direction,
c --- then the period must be treated as a calm.
      if(ustr.LE.0.0) then
         write(io6,*)'RDMET4: U-star missing in SURFACE'
         write(io6,*)'        Period Beginning:',kdathrb,ksb
         write(io6,*)'        Period Ending   :',kdathre,kse
         write(io6,*)'        Assuming CALM condition'
         ustr=0.0
         xmon=9999.
      endif

c --- Compute w* from u*,L,zmix; estimate PG class using Golder(1972)
      if(zmix.LT.0.0) then
         write(io6,*)'RDMET4: Mixing height missing in SURFACE'
         write(io6,*)'        Cannot fill in a computed w-star'
         problem=.TRUE.
      else
         wstr=0.
         if(xmon.LT.0.) then
            wstr=ustr*(-zmix/(vonk*xmon))**third
         endif
         kst=LSTAB(xmon,z0m)
      endif

c -------------------------------------------------------------------
c  -- Read records for this hour from CTDM PROFILE file
c -------------------------------------------------------------------
      call RDPROF(idathrm,isecm,lecho,izp,wsprf,wdprf,tprf,zprf,
     &            ssprf,swprf,svprf,dptinvo,
     &            ldathre,lse,ldathrb,lsb,leof)
      if(leof) return

c --- Check for consistent date-time for period among records
      if(kdathre.NE.ldathre .OR. kse.NE.lse) then
         write(io6,*)'RDMET4: PROFILE does not match SURFACE period'
         problem=.TRUE.
      endif

c --- Halt program now if problem was found with SURFACE or PROFILE
      if(PROBLEM) then
         write(io6,*)' PROFILE per. = ',ldathrb,lsb,ldathre,lse
         write(io6,*)' SURFACE per. = ',kdathrb,ksb,kdathre,kse
         stop 'Halted in RDMET4 -- see list file'
      endif

c --- Add levels at .25, .5, and 1.0 times the mixing height as in
c --- CTDM+, and add level at top of model, if mxprfz will allow it
c --- Do not add CTDM+ levels if mixing height is less than 10 m
      nznew=4
      if(zmix.LT.10.0) nznew=1
      nznew=MIN0(nznew,mxprfz-izp)
      if(nznew.GT.0) then
         do iz=1,nznew
c ---       Set new level
            iznew=izp+iz
            if(iz.EQ.1) then
               zprf(iznew)=zfacem(nz+1)
            elseif(iz.EQ.2) then
               zprf(iznew)=zmix
            else
               zprf(iznew)=.5*zprf(iznew-1)
            endif
c ---       Set initial values to missing
            wsprf(iznew)=-999.
            ssprf(iznew)=-999.
            wdprf(iznew)=-999.
            tprf(iznew)=-999.
            swprf(iznew)=-999.
            svprf(iznew)=-999.
c ---       Reset logical for reporting problems
            problem=.FALSE.
c ---       Extract value at this level, and add to top of profile
            if(izp.EQ.1.AND.wsprf(1).LE.0.0.AND.ssprf(1).LE.0.0) then
c ---          Only speed available is calm from offsite; do not profile
               wsprf(iznew)=AMAX1(wsprf(1),ssprf(1))
               ssprf(iznew)=wsprf(iznew)
            else
               call XTPRF(izp,wsprf,zprf,zprf(iznew),'spd',z0m,xmon,
     &                 zmix,kst,ptg,wsprf(iznew),problem)
               call XTPRF(izp,ssprf,zprf,zprf(iznew),'spd',z0m,xmon,
     &                 zmix,kst,ptg,ssprf(iznew),problem)
            endif
            call XTPRF(izp,wdprf,zprf,zprf(iznew),'dir',z0m,xmon,
     &              zmix,kst,ptg,wdprf(iznew),problem)
            call XTPRF(izp,tprf,zprf,zprf(iznew),'tmp',z0m,xmon,
     &              zmix,kst,ptg,tprf(iznew),problem)

c ---       Need at least 1 valid level of spd, dir, and tmp
            if(PROBLEM) then
               write(io6,*)'ERROR in subr. RDMET4 -- speed, dir, or ',
     1              'temperature missing at all levels in PROFILE'
               write(io6,*)'        Period Beginning:',ldathrb,lsb
               write(io6,*)'        Period Ending   :',ldathre,lse
               write(*,*)
               stop 'Halted in RDMET4 -- see list file.'
            endif

            call XTPRF(izp,swprf,zprf,zprf(iznew),'sig',z0m,xmon,
     &              zmix,kst,ptg,swprf(iznew),problem)
            call XTPRF(izp,svprf,zprf,zprf(iznew),'sig',z0m,xmon,
     &              zmix,kst,ptg,svprf(iznew),problem)
         enddo
c --     Sort profile levels
         izp=iznew
         call STPRF(nznew,izp,zprf,wsprf,wdprf,tprf,swprf,svprf,ssprf)
      endif

c --- Set the 2-D fields
      call initi2d(kst,mxnx,mxny,nxm,nym,ipgt)
      call initr2d(ustr,mxnx,mxny,nxm,nym,ustar)
      call initr2d(zmix,mxnx,mxny,nxm,nym,htmix)
      call initr2d(xmon,mxnx,mxny,nxm,nym,xmonin)
      call initr2d(wstr,mxnx,mxny,nxm,nym,wstar)
      call initr2d(pmmhr,mxnx,mxny,nxm,nym,rmm)

c --- Pass surface temperature to TMPK (assume z=z0m)
      call XTPRF(izp,tprf,zprf,z0m,'tmp',z0m,xmon,zmix,kst,
     &           ptg,tmpk,problem)

c --- Set the 1-D fields
      call initar(tmpk,nssta,tempss)
      call initar(1.28,nssta,rhoss)
      call initar(qswrad,nssta,qswss)
      call initai(irelhum,nssta,irhss)
      call initai(ipc,nssta,ipcode)

c --- Write the input fields, if requested
      if(LECHO)then
c
c ---    Date and time
         write(io6,*)
         write(io6,*)'------ MET. FIELDS BEGINNING: ',kdathrb,ksb
         write(io6,*)'------            AND ENDING: ',kdathre,kse
         write(io6,*)
c
c ---    2-D fields
         messag='PGT stability class'
         call out(xdum,ipgt,2,1,ldate,messag,nxm,nym)
         messag='Friction velocity (m/s)'
         call out(ustar,idum,1,5,ldate,messag,nxm,nym)
         messag='Mixing height (m)'
         call out(htmix,idum,1,5,ldate,messag,nxm,nym)
         messag='Monin-Obukhov length (m)'
         call out(xmonin,idum,1,5,ldate,messag,nxm,nym)
         messag='Convective velocity scale (m/s)'
         call out(wstar,idum,1,5,ldate,messag,nxm,nym)
         if(npsta.gt.0)then
            messag='Precipitation rate (mm/hr)'
            call out(rmm,idum,1,5,ldate,messag,nxm,nym)
         endif
c
c ---    1-D fields
         write(io6,*)'TEMPSS (deg. K) = ',(tempss(n),n=1,nssta)
         write(io6,*)'RHOSS (kg/m**3)  = ',(rhoss(n),n=1,nssta)
         write(io6,*)'QSWSS (W/m**2)   = ',(qswss(n),n=1,nssta)
         write(io6,*)'IRHSS (percent)  = ',(irhss(n),n=1,nssta)
         if(npsta.gt.0)write(io6,*)'IPCODE           = ',
     1    (ipcode(n),n=1,nssta)
      endif
c
      return

998   write(io6,*)'RDMET4: End-Of-File found in SURFACE file'
      leof=.TRUE.
      return

      end
c----------------------------------------------------------------------
      subroutine rdmet5(idathrm,isecm,lecho,ptg,izp,wsprf,wdprf,tprf,
     &                  zprf,ssprf,swprf,svprf,ipgt,htmix,ustar,xmonin,
     &                  wstar,rmm,tempss,rhoss,qswss,irhss,ipcode,
     &                  dptinvo,leof,kdathre,kse,kdathrb,ksb)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDMET5
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read meteorological data for one hour from AERMET
c               PROFILE and SURFACE files (processing follows that
c               in RDMET4)
c
c --- UPDATE
c --- V5.74-V6.1    050915  (DGS): allow for begin/end time format
c                                  resolved to seconds.
c                                  (retain compatibility with standard
c                                  PROFILE and SURFACE version)
c
c --- INPUTS:
c       IDATHRM - integer       - Mid-pt date/hour of required
c                                 data (YYYYJJJHH)
c         ISECM - integer       - Mid-pt second of required data (SSSS)
c         LECHO - logical       - Flag controlling printing of input
c                                 meteorological data fields
c        PTG(2) - real          - Default potential temperature grad.
c                                 for stable classes (deg. K/m)
c    Common block /METHD/ variables:
c         NXM, NYM, NZM, NSSTA, NPSTA, ZFACEM(mxnzp1), LCALGRD,
c         IMIXCTDM, ISIGMAV, ITIMES, ITIMEPRF
c    Parameters:
c         MXNX, MXNY, MXNZ, MXNZP1, MXPRFZ, IO6
c
c --- OUTPUT:
c
c                    IZP - integer - Number of profile levels
c          WSPRF(mxprfz) - real    - 1-D vector wind speed profile (m/s)
c          WDPRF(mxprfz) - real    - 1-D vector wind dir. profile (deg)
c           TPRF(mxprfz) - real    - Temperature profile (deg. K)
c           ZPRF(mxprfz) - real    - Heights for data in profile (m)
c          SSPRF(mxprfz) - real    - 1-D scalar speed profile (m/s)
c          SWPRF(mxprfz) - real    - 1-D sigma-w profile (m/s)
c          SVPRF(mxprfz) - real    - 1-D sigma-v profile (m/s)
c        IPGT(mxnx,mxny) - integer - PGT stability class
c       HTMIX(mxnx,mxny) - real    - Mixing height (m)
c       USTAR(mxnx,mxny) - real    - Surface friction velocity (m/s)
c      XMONIN(mxnx,mxny) - real    - Monin-Obukhov length (m)
c       WSTAR(mxnx,mxny) - real    - Convective velocity scale (m/s)
c         RMM(mxnx,mxny) - real    - Precipitation rate (mm/hr)
c          TEMPSS(nssta) - real    - Air temperature (deg. K) at
c                                    each surface met. station
c           RHOSS(nssta) - real    - Air density (kg/m**3)
c           QSWSS(nssta) - real    - Short wave solar radiation
c                                    (W/m**2)
c           IRHSS(nssta) - integer - Relative humidity (percent)
c          IPCODE(nssta) - integer - Precipitation code at each surface
c                                    station
c                DPTINVO - real    - Inversion strength at top of CBL
c                                    (jump in potential temperature K)
c                   LEOF - logical - End-Of-File flag
c
c --- RDMET5 called by:  COMP
c --- RDMET5 calls:      JULDAY, INCR, GRDAY, INITAR,
c                        INITAI, OUT, INITR2D, INITI2D,
c                        LSTAB, XTPRF, RDPROF5, TPERIOD, YR4, TCLOCK
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'methd.puf'
      include 'comparm.puf'
      include 'dispdat.puf'
      include 'grid.puf'
c
c --- Profile data arrays
      real wsprf(mxprfz),wdprf(mxprfz),tprf(mxprfz),zprf(mxprfz)
      real ssprf(mxprfz),swprf(mxprfz),svprf(mxprfz)
c --- Real 2-D fields
      real htmix(mxnx,mxny),ustar(mxnx,mxny),xmonin(mxnx,mxny)
      real wstar(mxnx,mxny),rmm(mxnx,mxny)
c --- Real 1-D fields
      real tempss(nssta),rhoss(nssta),qswss(nssta)
c
      integer ipgt(mxnx,mxny),irhss(nssta),ipcode(nssta)
c
      character messag*70,aline*132
c
      logical lecho,ldate,problem,leof
c
      data ldate/.false./
      data vonk/0.4/,third/0.3333333/

c --- Set logical to halt program if problem is found
1     problem=.FALSE.

c -------------------------------------------------------------------
c  -- Read one record of met data from AERMET SURFACE file
c -------------------------------------------------------------------
c --- Read entire line as character variable
4     read(io32,'(a132)',end=998) aline
c --- Extract fields for regular record (internal read)
      if(itimes.EQ.1) then
         read(aline,*) iby,ibm,ibd,ibjul,ibh,ksb,
     &                 iey,iem,ied,iejul,ieh,kse,
     &                 hflx,ustr,wstr,vptgup,ziconv,zimech,xmon,z0m,
     &                 brat,alb,wsa,wda,za,tmpk,zt
      else
         read(aline,*) iey,iem,ied,iejul,ieh,
     &                 hflx,ustr,wstr,vptgup,ziconv,zimech,xmon,z0m,
     &                 brat,alb,wsa,wda,za,tmpk,zt
      endif
c --- Use default values for parameters that are not in file
5     qswrad=0.0
      irelhum=85
      pmmhr=0.0
      ipc=0
6     continue
c
c --- Skip blank lines
      if(itimes.EQ.1) then
         if(ibm.EQ.0 .OR. ibd.EQ.0) goto 4
      else
         if(iem.EQ.0 .OR. ied.EQ.0) goto 4
      endif
c -------------------------------------------------------------------

c --- Process date-time information
      if(itimeprf.EQ.1) then
c ---    Enforce YYYY format for year
         call YR4(io6,iby,ierrb)
         call YR4(io6,iey,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDMET5'
         kdathrb=iby*100000+ibjul*100+ibh
         kdathre=iey*100000+iejul*100+ieh
      else
c ---    Enforce YYYY format for year
         call YR4(io6,iey,ierrb)
         if(ierrb.NE.0) stop 'Halted in RDMET5'
c ---    SURFACE.DAT uses a 1-24 clock (hour ending).  Change
c ---    time to the beginning of the hour (subtract 1 hour)
         ih=ieh-1
         call julday(io6,iey,iem,ied,ijul)
         kdathrb=iey*100000+ijul*100+ih
         ksb=0
c ---    Increment time 1 hour to get end time
         call incr(io6,iey,ijul,ih,1)
         kdathre=iey*100000+ijul*100+ih
         kse=0
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,kdathrb,idum,idum,idum,ksb)
      call TCLOCK(io6,kdathre,idum,idum,idum,kse)

c --- Check period of met data with mid-point of step
      call TPERIOD(0,idathrm,isecm,kdathrb,ksb,kdathre,
     &             kse,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in MET file
         go to 1
      elseif(ilocate.EQ.-1) then
         write(io6,*)'ERROR in subr. RDMET5 -- current time not found',
     1   ' in the SURFACE data file'
         write(io6,*)' --   Current date/hour,sec = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',kdathrb,ksb
         write(io6,*)'                           to ',kdathre,kse
         stop 'Halted in RDMET5 -- see list file.'
      endif

c --- Set w-star to 0.0 rather than -9.0 when the heat flux is negative
      if(hflx.LT.0.0) wstr=0.0

c --- Set current mixing height (max of convective and mechanical)
      zmix=AMAX1(ziconv,zimech)

c --- Check current value of roughness with value in /METHD/
      if(z0m.LE.0.0) then
c ---    Roughness length missing, keep previous value
         z0m=z0(1,1)
      elseif(z0m.NE.z0(1,1)) then
c ---    Valid roughness length changed, update array
c !!!    write(io6,*)'RDMET5:  Roughness length changed'
c !!!    write(io6,*)'         Date-Hour      - ',ksdathr
c !!!    write(io6,*)'         old,new z0(m)  - ',z0(1,1),z0m
         call initr2d(z0m,mxnx,mxny,nxm,nym,z0)
      endif

c --- Recover from missing u*, L by assuming that there is no
c --- stability influence, and no flow .... CALM.  This is likely
c --- because METPRO will give non-missing surface layer parameters
c --- for "real" data.  However, if onsite tower data are missing,
c --- and the offsite data are "zero" for speed and possibly direction,
c --- then the period must be treated as a calm.
      if(ustr.LE.0.0) then
         write(io6,*)'RDMET5: U-star missing in SURFACE'
         write(io6,*)'        Period Beginning:',kdathrb,ksb
         write(io6,*)'        Period Ending   :',kdathre,kse
         write(io6,*)'        Assuming CALM condition'
         ustr=0.0
         xmon=9999.
      endif

c --- Estimate PG class using Golder(1972)
      kst=LSTAB(xmon,z0m)

c -------------------------------------------------------------------
c  -- Read records for this hour from AERMET PROFILE file
c -------------------------------------------------------------------
      call RDPROF5(idathrm,isecm,lecho,izp,wsprf,wdprf,tprf,zprf,
     &             ssprf,swprf,svprf,dptinvo,
     &             ldathre,lse,ldathrb,lsb,leof)
      if(leof) return

c --- Check for consistent date-time for period among records
      if(kdathre.NE.ldathre .OR. kse.NE.lse) then
         write(io6,*)'RDMET5: PROFILE does not match SURFACE period'
         problem=.TRUE.
      endif

c --- Halt program now if problem was found with SURFACE or PROFILE
      if(PROBLEM) then
         write(io6,*)' PROFILE per. = ',ldathrb,lsb,ldathre,lse
         write(io6,*)' SURFACE per. = ',kdathrb,ksb,kdathre,kse
         stop 'Halted in RDMET5 -- see list file'
      endif

c --- Add levels at .25, .5, and 1.0 times the mixing height as in
c --- CTDM+, and add level at top of model, if mxprfz will allow it
c --- Do not add CTDM+ levels if mixing height is less than 10 m
      nznew=4
      if(zmix.LT.10.0) nznew=1
      nznew=MIN0(nznew,mxprfz-izp)
      if(nznew.GT.0) then
         do iz=1,nznew
c ---       Set new level
            iznew=izp+iz
            if(iz.EQ.1) then
               zprf(iznew)=zfacem(nz+1)
            elseif(iz.EQ.2) then
               zprf(iznew)=zmix
            else
               zprf(iznew)=.5*zprf(iznew-1)
            endif
c ---       Set initial values to missing
            wsprf(iznew)=-999.
            ssprf(iznew)=-999.
            wdprf(iznew)=-999.
            tprf(iznew)=-999.
            swprf(iznew)=-999.
            svprf(iznew)=-999.
c ---       Reset logical for reporting problems
            problem=.FALSE.
c ---       Extract value at this level, and add to top of profile
            if(izp.EQ.1.AND.wsprf(1).LE.0.0.AND.ssprf(1).LE.0.0) then
c ---          Only speed available is calm from offsite; do not profile
               wsprf(iznew)=AMAX1(wsprf(1),ssprf(1))
               ssprf(iznew)=wsprf(iznew)
            else
               call XTPRF(izp,wsprf,zprf,zprf(iznew),'spd',z0m,xmon,
     &                 zmix,kst,ptg,wsprf(iznew),problem)
               call XTPRF(izp,ssprf,zprf,zprf(iznew),'spd',z0m,xmon,
     &                 zmix,kst,ptg,ssprf(iznew),problem)
            endif
            call XTPRF(izp,wdprf,zprf,zprf(iznew),'dir',z0m,xmon,
     &              zmix,kst,ptg,wdprf(iznew),problem)
            call XTPRF(izp,tprf,zprf,zprf(iznew),'tmp',z0m,xmon,
     &              zmix,kst,ptg,tprf(iznew),problem)

c ---       Need at least 1 valid level of spd, dir, and tmp
            if(PROBLEM) then
               write(io6,*)'ERROR in subr. RDMET5 -- speed, dir, or ',
     1              'temperature missing at all levels in PROFILE'
               write(io6,*)'        Period Beginning:',ldathrb,lsb
               write(io6,*)'        Period Ending   :',ldathre,lse
               write(*,*)
               stop 'Halted in RDMET5 -- see list file.'
            endif

            call XTPRF(izp,swprf,zprf,zprf(iznew),'sig',z0m,xmon,
     &              zmix,kst,ptg,swprf(iznew),problem)
            call XTPRF(izp,svprf,zprf,zprf(iznew),'sig',z0m,xmon,
     &              zmix,kst,ptg,svprf(iznew),problem)
         enddo
c --     Sort profile levels
         izp=iznew
         call STPRF(nznew,izp,zprf,wsprf,wdprf,tprf,swprf,svprf,ssprf)
      endif

c --- Set the 2-D fields
      call initi2d(kst,mxnx,mxny,nxm,nym,ipgt)
      call initr2d(ustr,mxnx,mxny,nxm,nym,ustar)
      call initr2d(zmix,mxnx,mxny,nxm,nym,htmix)
      call initr2d(xmon,mxnx,mxny,nxm,nym,xmonin)
      call initr2d(wstr,mxnx,mxny,nxm,nym,wstar)
      call initr2d(pmmhr,mxnx,mxny,nxm,nym,rmm)

cc --- Pass surface temperature to TMPK (assume z=z0m)
c      call XTPRF(izp,tprf,zprf,z0m,'tmp',z0m,xmon,zmix,kst,
c     &           ptg,tmpk,problem)

c --- Set the 1-D fields
      call initar(tmpk,nssta,tempss)
      call initar(1.28,nssta,rhoss)
      call initar(qswrad,nssta,qswss)
      call initai(irelhum,nssta,irhss)
      call initai(ipc,nssta,ipcode)

c --- Write the input fields, if requested
      if(LECHO)then
c
c ---    Date and time
         write(io6,*)
         write(io6,*)'------ MET. FIELDS BEGINNING: ',kdathrb,ksb
         write(io6,*)'------            AND ENDING: ',kdathre,kse
         write(io6,*)
c
c ---    2-D fields
         messag='PGT stability class'
         call out(xdum,ipgt,2,1,ldate,messag,nxm,nym)
         messag='Friction velocity (m/s)'
         call out(ustar,idum,1,5,ldate,messag,nxm,nym)
         messag='Mixing height (m)'
         call out(htmix,idum,1,5,ldate,messag,nxm,nym)
         messag='Monin-Obukhov length (m)'
         call out(xmonin,idum,1,5,ldate,messag,nxm,nym)
         messag='Convective velocity scale (m/s)'
         call out(wstar,idum,1,5,ldate,messag,nxm,nym)
         if(npsta.gt.0)then
            messag='Precipitation rate (mm/hr)'
            call out(rmm,idum,1,5,ldate,messag,nxm,nym)
         endif
c
c ---    1-D fields
         write(io6,*)'TEMPSS (deg. K) = ',(tempss(n),n=1,nssta)
         write(io6,*)'RHOSS (kg/m**3)  = ',(rhoss(n),n=1,nssta)
         write(io6,*)'QSWSS (W/m**2)   = ',(qswss(n),n=1,nssta)
         write(io6,*)'IRHSS (percent)  = ',(irhss(n),n=1,nssta)
         if(npsta.gt.0)write(io6,*)'IPCODE           = ',
     1    (ipcode(n),n=1,nssta)
      endif
c
      return

998   write(io6,*)'RDMET5: End-Of-File found in SURFACE file'
      leof=.TRUE.
      return

      end
c----------------------------------------------------------------------
      subroutine stprf(n,izp,zprf,wsprf,wdprf,tprf,swprf,svprf,ssprf)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                  STPRF
c                D. Strimaitis   SRC
c
c --- PURPOSE:  Sort arrays of PROFILE data
c
c --- INPUTS:
c             N - integer       - number of new levels at top of
c                                 data arrays
c           IZP - integer       - total number of levels in data arrays
c          ZPRF - real array    - heights above ground for met data
c         WSPRF - real array    - wind speed (m/s)
c         WDPRF - real array    - wind direction (deg)
c          TPRF - real array    - temperature (K)
c         SWPRF - real array    - sigma-w (m/s)
c         SVPRF - real array    - sigma-v (m/s)
c         SSPRF - real array    - scalar avg. wind speed (m/s)
c
c --- OUTPUT:
c           IZP - integer       - total number of levels in data arrays
c          ZPRF - real array    - heights above ground for met data
c         WSPRF - real array    - vector avg. wind speed (m/s)
c         WDPRF - real array    - wind direction (deg)
c          TPRF - real array    - temperature (K)
c         SWPRF - real array    - sigma-w (m/s)
c         SVPRF - real array    - sigma-v (m/s)
c         SSPRF - real array    - scalar avg. wind speed (m/s)
c
c --- STPRF called by:  RDMET4, RDMET5
c --- STPRF calls    :  none
c----------------------------------------------------------------------
c
      real zprf(izp),wsprf(izp),wdprf(izp),tprf(izp)
      real swprf(izp),svprf(izp),ssprf(izp)

c --- Local arrays
      real znew(4),wsnew(4),wdnew(4),tnew(4)
      real swnew(4),svnew(4),ssnew(4)

c --- Set the N new values aside (up to 4)
      itop=izp-n
      do i=1,n
         j=itop+i
         znew(i)=zprf(j)
         tnew(i)=tprf(j)
         wsnew(i)=wsprf(j)
         wdnew(i)=wdprf(j)
         swnew(i)=swprf(j)
         svnew(i)=svprf(j)
         ssnew(i)=ssprf(j)
      enddo

c --- Find places for new values
      do j=1,n
         do i=itop,1,-1
c ---       (Drop any duplicate profile entry ...)
            if(zprf(i).EQ.znew(j)) goto 20
c ---       (Place is found when profile height first becomes less)
            if(zprf(i).LT.znew(j)) then
               insert=i+1
               goto 10
            endif
         enddo
c ---    Current znew is less than all zprf
         insert=1

10       continue
c ---    Shift values above "insert" up in the array
         itop=itop+1
         do i=itop,insert+1,-1
            zprf(i)=zprf(i-1)
            tprf(i)=tprf(i-1)
            wsprf(i)=wsprf(i-1)
            wdprf(i)=wdprf(i-1)
            swprf(i)=swprf(i-1)
            svprf(i)=svprf(i-1)
            ssprf(i)=ssprf(i-1)
         enddo
c ---    Place new values into profile at insert
         zprf(insert)=znew(j)
         tprf(insert)=tnew(j)
         wsprf(insert)=wsnew(j)
         wdprf(insert)=wdnew(j)
         swprf(insert)=swnew(j)
         svprf(insert)=svnew(j)
         ssprf(insert)=ssnew(j)
20       continue
      enddo

c --- Profile arrays now contain ITOP levels
      izp=itop

      return
      end
c----------------------------------------------------------------------
      subroutine xtprf(nzp,array,zarray,zht,ctype,z0m,el,zmix,kst,
     &                 ptg,value,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                  XTPRF
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Extract value from PROFILE at a specified height,
c               using CTDM profiling constructs when needed
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): place lower bound on wind speed
c                                  equal to WSCALM (any elevation),
c                                  provided nearest speeds not less
c                                  than WSCALM; min speed = WSCALM/10
c                   971107  (DGS): separate max/min function calls
c                   971107  (DGS): remove IO unit from arg list
c                   971107  (DGS): alter CTDM temperature extrapolation
c                                  above top of "tower"
c                   971107  (DGS): do not extrapolate turbulence above
c                                  mixing lid for CBL
c
c --- INPUTS:
c           NZP - integer       - number of levels in data arrays
c         ARRAY - real array    - meteorological data array
c        ZARRAY - real array    - heights above ground for met data
c           ZHT - real          - height for retrieval
c         CTYPE - character     - type of data
c                                 sig: sigma-v or sigma-w
c                                 tmp: temperature
c                                 dir: wind direction
c                                 spd: wind speed (vector or scalar avg)
c           Z0M - real          - roughness length (m)
c            EL - real          - Monin-Obukhov length (m)
c          ZMIX - real          - mixing height (m)
c           KST - integer       - stability class
c           PTG - real array    - default potential temperature gradient
c                                 for (1) class E and (2) class F
c         VALUE - real          - default value if unavailable
c       PROBLEM - logical       - trouble flag initialized outside call
c
c    Common block /COMPARM/ variables:
c         WSCALM
c
c --- OUTPUT:
c         VALUE - real          - value at zht
c       PROBLEM - logical       - trouble flag (.TRUE. if problem found)
c
c --- XTPRF called by:  RDMET4,PTLAPS,TURBSET,ADVECT,WINDSET,GETPRFP
c --- XTPRF calls    :  PSIM
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'comparm.puf'
c
      real array(nzp),zarray(nzp),ptg(2)
      character*3 ctype
      logical problem,lctdm

c --- Set switch for extrapolating temperature above sounding like CTDM
      data lctdm/.FALSE./

      data zero/0.0/,drylaps/-.0098/

c --- Find index for valid data above/below zht (valid data are assumed
c --- to be greater than or equal to zero)
      itop=nzp+1
      ibot=0
      itopp1=itop
      ibotm1=ibot
c --- Level above
      do iz=nzp,1,-1
         if(zarray(iz).GT.zht .AND. array(iz).GE.zero) then
            itopp1=itop
            itop=iz
         endif
      enddo
c --- Level below
      do iz=1,itop-1
         if(zarray(iz).LE.zht .AND. array(iz).GE.zero) then
            ibotm1=ibot
            ibot=iz
         endif
      enddo

c --- Set default temperature gradients
      if(ctype.EQ.'tmp') then
c ---    Set gradient in the surface layer
         if(kst.LE.4) then
            tgradsl=drylaps
         else
            tgradsl=ptg(kst-4)+drylaps
         endif
c ---    Set gradient aloft equal to half the dry adiabatic lapse rate
         tgradup=0.5*drylaps
c ---    Reset gradient for CTDM extrapolation above mixing height
         if(LCTDM) tgradup=AMAX1(tgradsl,ptg(1)+drylaps)
      endif

c --- Set surface layer height for CTDM wind speed profiling
c --- For convective case, slht is the larger of 2L or zmix/10,
c --- but no greater than 200 m
      if(ctype.EQ.'spd') then
         if(el.LT.zero .AND. el.GT.-100.) then
            slht=AMAX1(2.*ABS(el),0.1*zmix)
            slht=AMIN1(slht,200.)
         else
            slht=zmix
         endif
      endif

c --- Case 1:  no valid data are found; return initial value
      if(ibot.EQ.0 .AND. itop.GT.nzp) then
         problem=.TRUE.

c --- Case 2:  zht is below first valid level of profile
      elseif(ibot.EQ.0) then
         if(ctype.EQ.'dir' .OR. ctype.EQ.'sig') then
c ---       Use first valid value
            value=array(itop)
         elseif(ctype.EQ.'tmp') then
            if(itopp1.LE.nzp) then
c ---          Use T gradient from first 2 valid levels
               scale=(zht-zarray(itop))/(zarray(itopp1)-zarray(itop))
               diff=array(itopp1)-array(itop)
               value=array(itop)+diff*scale
            else
c ---          Use first valid T and default surface layer T gradient
               value=array(itop)+(zht-zarray(itop))*tgradsl
            endif
         elseif(ctype.EQ.'spd') then
            if(array(itop).LT.wscalm) then
               value=array(itop)
            elseif(zht.GT.slht) then
c ---          Speed is constant above surface layer
               value=array(itop)
            else
c ---          Speed follows similarity theory within surface layer
               ztop=AMIN1(zarray(itop),slht)
               psitop=PSIM(el,ztop)
               ztop0=ALOG(ztop/z0m)
               psiht=PSIM(el,zht)
               zht0=ALOG(AMAX1(1.0,zht/z0m))
               value=array(itop)*(zht0-psiht)/(ztop0-psitop)
c ---          Smallest speed allowed from profiling is WSCALM
               value=AMAX1(value,wscalm)
            endif
         endif

c --- Case 3:  zht is equal to zarray(ibot)
      elseif(zarray(ibot).EQ.zht) then
         value=array(ibot)

c --- Case 4:  zht is above last valid level of profile
      elseif(itop.GT.nzp) then
         if(ctype.EQ.'dir') then
c ---       Use last valid value
            value=array(ibot)
         elseif(ctype.EQ.'sig') then
c ---       Use last valid value unless zht is above the CBL
            if(zht.LE.zmix .OR. el.GE.zero) then
               value=array(ibot)
            else
c ---          Treat as missing as in Case 1
               problem=.TRUE.
            endif
         elseif(ctype.EQ.'tmp') then
            if(ibotm1.LE.0) then
c ---          There is only 1 valid Temp: use with default gradients
c ---          Compute Temp at mixing ht
               if(zarray(ibot).GE.zmix) then
                  dtdz=tgradup
               else
                  dtdz=tgradsl
               endif
               tmix=array(ibot)+(zmix-zarray(ibot))*dtdz
c ---          Use gradient from mixing ht to zht
               if(zht.GE.zmix) then
                  dtdz=tgradup
               else
                  dtdz=tgradsl
               endif
               value=tmix+(zht-zmix)*dtdz
            else
c ---          Extrapolate based on upper T gradient (last 2 T's)
c ---          Compute gradient from last 2 valid levels
               dtdz=(array(ibot)-array(ibotm1))/
     &              (zarray(ibot)-zarray(ibotm1))
               if(LCTDM) then
c ---             Use CTDM extrapolation methods
                  if(dtdz.GT.drylaps) then
c ---                "Stable"
c ---                Extend last gradient to zht regardless of lid
                     value=array(ibot)+dtdz*(zht-zarray(ibot))
                  else
c ---                "Non-stable"
c ---                Use adiabat to mix lid, then stable gradient above
                     dtdz=drylaps
                     value=array(ibot)+dtdz*(zht-zarray(ibot))
                     delzmix=zht-zmix
                     if(zarray(ibot).LE.zmix .AND. delzmix.GT.zero) then
                        value=value+delzmix*(tgradup-dtdz)
                     endif
                  endif
               else
c ---             Use modified extrapolation method
                  dtdz=AMAX1(drylaps,dtdz)
                  if(zht.LE.zmix) then
c ---                Below lid, so use measured gradient
                     value=array(ibot)+dtdz*(zht-zarray(ibot))
                  elseif(zarray(ibot).GT.zmix) then
c ---                Above lid, and dtdz either lies above or straddles
c ---                lid; use dtdz as best estimate of gradient aloft
                     value=array(ibot)+dtdz*(zht-zarray(ibot))
                  else
c ---                Above lid and measurements are below lid
c ---                First extend T to mixing ht using measured dtdz
                     tmix=array(ibot)+dtdz*(zmix-zarray(ibot))
c ---                Now extrapolate using gradient aloft
                     if(el.GT.zero) then
c ---                   Stable SBL: dtdz aloft may be less than default
                        dtdz=AMIN1(dtdz,tgradup)
                     else
                        dtdz=tgradup
                     endif
                     value=tmix+(zht-zmix)*dtdz
                  endif
               endif
            endif
         elseif(ctype.EQ.'spd') then
            if(array(ibot).LT.wscalm) then
               value=array(ibot)
            elseif(zarray(ibot).GT.slht) then
c ---          Speed is constant above surface layer
               value=array(ibot)
            else
c ---          Speed follows similarity theory within surface layer
               psibot=PSIM(el,zarray(ibot))
               zbot0=ALOG(zarray(ibot)/z0m)
               zval=AMIN1(zht,slht)
               psiht=PSIM(el,zval)
               zval0=ALOG(zval/z0m)
               value=array(ibot)*(zval0-psiht)/(zbot0-psibot)
c ---          Smallest speed returned from profiling is WSCALM
               value=AMAX1(wscalm,value)
            endif
         endif

c --- Case 5:  zht is between two valid levels
      else
c ---    Use linear interpolation
         scale=(zht-zarray(ibot))/(zarray(itop)-zarray(ibot))
         diff=array(itop)-array(ibot)
         if(ctype.EQ.'dir') then
c ---       Correct direction difference greater than 180 degrees
            if(diff.GT.180.0) then
               diff=diff-360.0
            elseif(diff.LT.-180.0) then
               diff=diff+360.0
            endif
         endif
         value=array(ibot)+diff*scale
      endif

c --- Final restriction on wind speed: it cannot be zero
      if(ctype.EQ.'spd') value=AMAX1(value,(0.1*wscalm))

c
      return
      end
c----------------------------------------------------------------------
      subroutine powlaw(ht,zmeas,ws,p,wsht)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960628                 POWLAW
c ---            J. Scire, SRC
c
c --- PURPOSE:  Extrapolate wind speed to height HT using a power
c               law profile adjustment factor
c
c --- INPUTS:
c              HT - real         - New height (m)
c           ZMEAS - real         - Old (measurement) height (m)
c              WS - real         - Measured wind speed (m/s)
c               P - real         - Power law exponent
c
c    Common block /COMPARM/ variables:
c         WSCALM
c
c --- OUTPUT:
c            WSHT - real         - Value of wind speed at HT (m/s)
c
c --- POWLAW called by:  RDISC, RDPLM, ADVECT, WINDSET
c --- POWLAW calls:      none
c----------------------------------------------------------------------
      include 'params.puf'
      include 'comparm.puf'
c
c --- Compute the wind speed at HT using the ISC2 convention,
c --- i.e., assume the wind speed is constant below either 10 m OR the
c --- measurement height, whichever is lower
      if(ht.ge.10.0)then
         wsht=ws*(ht/zmeas)**p
      else if(zmeas.gt.10.0)then
         wsht=ws*(10.0/zmeas)**p
      else
         wsht=ws
      endif
c
c --- Wind speed is not allowed to be less than WSCALM m/s
      wsht=amax1(wsht,wscalm)
c
      return
      end
c----------------------------------------------------------------------
      integer function lstab(el,zr0)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                  LSTAB
c
c --- PURPOSE:  Calculate a PG class given the Monin-Obukhov length
c               and the surface roughness from Golder's 1972 curves
c
c --- Taken from CTDMplus subroutine of the same name
c
C ASSUMPTIONS: THE DIVIDING LINES BETWEEN CATEGORIES ARE ASSUMED TO BE
C               LINEAR.
C
C LIMITATIONS: THIS FUNCTION IS ONLY VALID FOR 0.01 <= Z0 <= 0.5(M).
C              HOWEVER, RESULTS ARE EXTENDED TO OTHER VALUES OF Z0 BY
C              USING Z0 = 0.01 IF Z0 < 0.01 M, AND BY USING Z0 = 0.5
C              IF Z0 > 0.5 M.
C
c --- INPUTS:
C       EL      REAL    MONIN-OBUKHOV LENGHT (M)
C       ZR0     REAL    SURFACE ROUGHNESS LENGTH (M)
c
c --- OUTPUT:
C       LSTAB   INT     P-G STABILITY CATEGORY 1=A, 2=B, ETC.
C
C CALLING ROUTINES: SEQMOD
C
C EXTERNAL ROUTINES: NONE
C
C INTERNAL FUNCTIONS:
C       XL - EQUATION OF DIVIDING LINE BETWEEN P-G STABILITY CLASSES
C
C INTRINSIC FUNCTIONS: ALOG
C
C REFERENCES:
C       GOLDER, D. (1972): RELATIONS AMONG STABILITY PARAMETERS IN THE
C                       SURFACE LAYER, BOUNDARY-LAYER METEOROLOGY, 3:56.
C
C-----------------------------------------------------------------------
C
        REAL            EL, XEL, XL, Z0, ZR0
C
C
        XL(Y,XM,B)=XM/(ALOG(Y)-B)
C
        Z0 = ZR0
        IF(Z0 .GT. 0.5) Z0 = 0.5
        IF(Z0 .LT. 0.01) Z0 = 0.01
        IF(EL .LT. 0.0) THEN
            XEL = -EL
            IF(XEL .LE. XL(Z0,-70.0,4.35)) THEN
C               STABILITY A
                LSTAB=1
              ELSE IF(XEL .LE. XL(Z0,-85.2,0.502)) THEN
C               STABILITY B
                LSTAB=2
              ELSE IF(XEL .LE. XL(Z0,-245.,0.050)) THEN
C               STABILITY C
                LSTAB=3
              ELSE
C               STABILITY D
                LSTAB=4
            ENDIF
          ELSE
            IF(EL .GE. XL(Z0,-327.,0.627)) THEN
C               STABILITY D
                LSTAB=4
              ELSE IF(EL .GE. XL(Z0,-70.0,0.295)) THEN
C               STABILITY E
                LSTAB=5
              ELSE
C               STABILITY F
                LSTAB=6
            ENDIF
        ENDIF
C
        RETURN
        END
c----------------------------------------------------------------------
      subroutine stab2l(istab,zr0,eli)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                 STAB2L
c ---            D. Strimaitis
c
c --- PURPOSE:  Calculate a Monin-Obukhov length given the PG class
c               and the surface roughness from Golder's 1972 curves
c               as presented in Seinfeld, 1986 (Atm. Chem. & Phys. of
c               Air Poll.)
c
c LIMITATIONS: THIS FUNCTION IS VALID FOR 0.01 <= Z0 <= 0.5(M).
c              HOWEVER, RESULTS ARE EXTENDED TO OTHER VALUES OF Z0 BY
c              USING Z0 = 0.01 IF Z0 < 0.01 M, AND BY USING Z0 = 0.5
c              IF Z0 > 0.5 M.
c
c --- INPUTS:
c       ISTAB - integer    - P-G stability category 1=A, 2=B, ETC.
c         ZR0 - real       - Surface roughness length (m)
c
c --- OUTPUT:
c         ELI - real       - 1/Monin-Obukhov length (1/m)
c
c --- STAB2L called by:  RDPLM
c --- STAB2L calls:      none
c----------------------------------------------------------------------
      real a(6),b(6)

      data a/-.096,-.037,-.002,0.0,.004,.035/
      data b/.029,.029,.018,0.0,-.018,-.036/

      z0 = zr0
      if(z0.GT.0.5) z0 = 0.5
      if(z0.LT.0.01) z0 = 0.01
      eli=a(istab)+b(istab)*ALOG10(z0)

      return
      end
c----------------------------------------------------------------------
      function psim(el,zref)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 960521                   PSIM
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute the Businger-Dyer surface layer PSI function
c ---           for momentum
c
c --- INPUTS:
c          EL - real       - Monin-Obukhov length (m)
c        ZREF - real       - Reference height (m)
c
c --- OUTPUT:
c        PSIM - real       - Surface layer PSI function for momentum
c
c --- PSIM called by:  RDPLM, XTPRF
c --- PSIM calls:      none
c----------------------------------------------------------------------
      data piby2/1.5707963/

      elabs=abs(el)
      if(el.lt.0.0.and.elabs.lt.9990.) then
c ---    Convective
         ratio=zref/elabs
         if(ratio.gt.1.0) ratio=1.0
         xsq=SQRT(1.+15.*ratio)
         x=SQRT(xsq)
         term1=2.*ALOG(0.5*(1.+x))
         term2=ALOG(0.5*(1.+xsq))
         term3=-2.*ATAN(x)+piby2
         psim=term1+term2+term3
      elseif(elabs.ge.9990.) then
c ---    Neutral
         psim=0.0
      else
c ---    Stable
         ratio=zref/el
         if(ratio.gt.1.0) ratio=1.0
         psim=-4.7*ratio
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine numrise(mprm,ldbhr,h,teff,reff,weff,sigy0,sigz0,ntr,
     &                   xtr,ztr,rtr,htr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                NUMRISE
c                X.(J.) Zhang, J. Scire
c
c --- PURPOSE:  Compute plume rise using a numerical solution to the
c               Non-Boussinesq conservation laws.  Model allows:
c
c               (1) arbitrary ambient temperature stratifications
c               (2) arbitrary uni-directional wind stratification
c               (3) any size of finite emission source
c               (4) is free of the Boussinesq approximation
c               (5) radiative heat loss
c
c --- UPDATE
c --- V6.2-V6.26    080430  (DGS): Add numerical rise output to
c                                  RISE.DAT file
c --- V5.725-V6.2   070629  (DGS): Initialize dzds=0.0 (debug output)
c --- V5.71-V5.725  050128  (DGS): initialize first element of MXNW
c                                  arrays to stack conditions to avoid
c                                  problems with the NN pointer being
c                                  old
c --- V5.7-V5.71    030528  (DGS): modify args of MIN to be integer
c --- V5.4-V5.7     030402  (DGS): add PRIME-related features to model
c                                  vertical streamline deflection near
c                                  buildings, to compute diffusion
c                                  (sigmas) in bldg wake, and to
c                                  determine plume/cavity interaction
c                   030402  (DGS): Revise the plume rise-angle criterion
c                                  for wake effects from 45 degrees to
c                                  20 degrees (default -- actual value
c                                  is set in block data and READ62)
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.1-V5.2     991104  (DGS): revise distance to final momentum rise
c --- V5.0-V5.1     990729  (DGS): allow for zero rise (weff=0) and
c                                  also use W<0 to stop rise instead
c                                  of PHI<0 for stable regime
c --- V4.0-V5.0     971107  (DGS): replace heat flux (KW) with input
c                                  temperature, exit velocity, and
c                                  radius
c
c --- INPUTS:
c          MPRM - integer       - Flag for PRIME building downwash calc
c                                 0 = no PRIME calculations
c                                 1 = PRIME method ACTIVE
c         LDBHR - logical       - Flag for debug write statements
c             H - real          - Release height (m)
c          TEFF - real          - Effective temperature of release (K)
c          REFF - real          - Effective radius of release (m)
c          WEFF - real          - Effective exit velocity (m/s)
c         SIGY0 - real          - Initial sigma-y of the source (m)
c         SIGZ0 - real          - Initial sigma-z of the source (m)
c           NTR - integer       - Number of points in trajectory passed
c                                 back to calling program (final point
c                                 is "final rise")
c
c     Common block /AMBIENT/ variables:
c           NZA,UAMB(mxprfz),RAMB(mxprfz),DEDZ(mxprfp1),TAMB(mxprfz),
c           ZFACEA(mxprfp1),TAMB0,RAMB0
c     Common block /NUMPARM/ variables:
c           ZMIN, DS0, NSTEP, SLAST, GRAVI, PHICHECK
c     Common block /OUTPT/ variables:
c           INRISE
c     Common block /WAKEDAT/ variables:
c           HB, WB, XLB, RB, HR, XLR, XLC, XBADJ, YBADJ
c     Parameters:
c           MXNW, MXPRFZ, MXPRFP1, MXENT, MXENTP1, IO6, IOX
c
c --- OUTPUT:
c        XTR(ntr) - real          - Downwind distance (m)
c        ZTR(ntr) - real          - Plume centerline height (m)
c        RTR(ntr) - real          - Plume radius (m)
c        HTR(ntr) - real          - Plume rise (m) without streamline
c                                   adjustments (for BID when PRIME
c                                   building downwash is used)
c
c --- NUMRISE called by:  AREAS2, POINTS1, POINTS2,
c --- NUMRISE calls:      ZMET,LUMP,RATE,MARCHING,UNLUMP
c                         ZSTREAM, POSITION, WAKE_U
c                         WAKE_DRDX, WAKE_DFSN, WAKE_FQC,
c                         NRISEOUT
c----------------------------------------------------------------------
c --- Notation --- in (KG,M,S) units
c               NN:     Number of points along rise trajectory
c               X:      PLUME LOCATION (downwind)
c               Y:      PLUME LOCATION (crosswind)
c               Z:      PLUME HEIGHT
c               H:      Release height (flame ht., stack ht.)
c               ZE:     PLUME EQUILIBRIUM HEIGHT
c               S:      LENGTH ALONG PLUME CENTERLINE
c               R:      PLUME RADIUS
c               U:      PLUME HORIZONTAL VELOCITY
c               W:      PLUME VERTICAL VELOCITY
c               USC:    VELOCITY ALONG PLUME CENTERLINE
c               PHI:    ANGLE BETWEEN PLUME TRAJECTORY AND GROUND
c              DEN:     PLUME DENSITY
c               TP:     PLUME TEMPERATURE
c               ua:     HORIZONTAL WIND SPEED
c               dudz:   WIND SHEAR
c               ta:     AMBIENT TEMPERATURE
c               dpdz:   AMBIENT POTENTIAL TEMPERATURE GRADIENT
c               ra:     AMBIENT DENSITY
c               zmin:   Minimum plume centerline height (m)
c               ds:     Step size (m) in the numerical plume rise calc.
c               nstep:  Reporting frequency of numerical calc.
c               slast:  Termination distance (m) of plume rise calc.
c               gravi:  Acceleration due to gravity (m/s**2)
c----------------------------------------------------------------------

c --- Include files
      include 'params.puf'
      include 'numparm.puf'
      include 'ambient.puf'
      include 'outpt.puf'
      include 'wakedat.puf'

      COMMON /PLU/ S,X,Y,Z,R,U,V,W,USC,PHI,DEN,TP

      REAL XTR(ntr),ZTR(ntr),RTR(ntr),HTR(ntr)
      REAL XT(mxnw),ZT(mxnw),RT(mxnw)
c --- Array for trajectory height without streamline modifications
      real Z0T(mxnw)
      DIMENSION RHS(7),RHSTEMP(7),F(7),FTEMP(7)
      logical ldbhr,ldb,ldbnn,ldbu,linwake

c --- Use LDB as a local switch for more extensive debug output
c !!! ldb=ldbhr
      ldb=.FALSE.
c !!! ldbu=ldb
      ldbu=.FALSE.

c --- Initial number or output records for RISE.DAT file
      kriseout=0

      X=0.
      Y=0.
      Z=AMAX1(H,ZMIN)
      S=0.
      R=REFF
      RSQ=R*R
      U=0.000002
      tp=teff
      w=weff

c --- Additional variables for PRIME module
c -----------------------------------------
      linwake=.FALSE.
      drdxa=0.0
      ipositn=4
c --- Define the crosswind velocity component = zero
      dyds=0.0
      v=0.0
c --- Introduce ZCUMUL to track change in the vertical coordinate of
c --- the trajectory that arises from streamline inclination from
c --- horizontal. (This adjustment is applied outside of the system of
c --- rise equations out to a distance of 15R from downwind face of
c --- the building)
      zcumul=0.0

c --- Assign initial stepping length
      ds=ds0

c --- INDIRECT VARIABLES
      USC=SQRT(U*U+W*W)
      PHI=ATAN(W/U)

c --- PARAMETERS
      NP=NSTEP
      XNP=FLOAT(NP)
      nnp=1

c --- Initialize first location in rise storage arrays to one step (ds)
c --- and no rise; this should be overwritten with actual rise results.
      NN=1
      XT(NN)=ds
      ZT(NN)=h
      Z0T(NN)=h
      RT(NN)=reff

c --- Get met. variables at release height
      call ZMET(z,ua0,ra,ta,dudz0,dpdz)

c --- Compute initial buoyancy flux (m**4/s**3)
      deltat=amax1(tp-ta,0.0)
      fb=gravi*w*rsq*deltat/tp

c --- Compute momentum flux (m**4/s**2)
      fm=ta*w**2*rsq/tp

      if(mprm.EQ.1) then
c ---    PRIME module
c ---    Apply reduction in wake wind speed
         r15src=xbadj+(xLb+15.*Rb)
         xb=x-xbadj
         yb=y-ybadj
         zb=AMAX1(z,zmin)
         call POSITION(xb,yb,zb,ipositn)
         ufac=1.0
         dufac=0.0
         if(ipositn.LT.4) call WAKE_U(.FALSE.,xb,yb,zb,ufac,dufac)
         ua=ufac*ua0
         dudz=ufac*dudz0+dufac*ua0
      else
         ua=ua0
         dudz=dudz0
      endif
      uam=AMAX1(ua,1.0)

c --- Final neutral rise distance
      if(fb.le.0.0)then

c ---    No buoyancy, momentum only
         if(weff.LE.0.0) then
c ---       No rise for this source
            xmax=0.0
            x=ds
            z=h
            zc=z
            r=reff
            zfin=z
            z0fin=z
            xfin=x
            rfin=r
            nn=1
            XT(NN)=X
            ZT(NN)=Z
            Z0T(NN)=Z
            RT(NN)=R
            goto 97
         else
c ---       Use final rise formula for jets, subject to Briggs (1969)
c ---       constraint that w/u is greater than or equal to 4
            wbyu=w/uam
            wbyu=AMAX1(wbyu,4.0)
            xmax=8.*r*wbyu*(1.+3./wbyu)**2
         endif

      else if(fb.lt.55)then

c ---    Buoyancy flux < 55 m**4/s**3
         wbyu=w/uam
         wbyu=AMAX1(wbyu,4.0)
         xmaxm=8.*r*wbyu*(1.+3./wbyu)**2
         xmaxb=49.*fb**0.625
         xmax=AMAX1(xmaxm,xmaxb)

      else

c ---    Buoyancy flux .GE. 55 m**4/s**3
         xmax=119.*fb**0.4
      endif

      if(mprm.EQ.1) then
c ---    PRIME module
c ---    Use Briggs neutral rise to identify "minimal rise" cases
c ---    Compute Briggs neutral final rise
         if(xmax.EQ.0.0) then
            znf=0.0
         elseif(fb.LE.0.0) then
c ---       No buoyancy, momentum only
            znf=6.*r*w/uam
         elseif(fb.LT.55.) then
c ---       Buoyancy flux < 55 m**4/s**3
            znf=21.425*(fb**0.75)/uam
         else
c ---       Buoyancy flux .GE. 55 m**4/s**3
            znf=38.71*(fb**0.60)/uam
         endif
c ---    Set minimum rise to 0.1 m
         znf0=AMAX1(0.1,znf)
c ---    Guard against step length greater than likely rise
         dmin=0.5*znf0
         if(ds.GT.dmin) then
            ds=dmin
            if(ldb) then
               write(io6,*)'NUMRISE - initial step reset'
               write(io6,*)'znf,ds0,ds  :',znf,ds0,ds
            endif
         endif
      endif

c --- START PLUME RISE MARCHING LOOP
c ----------------------------------------------------
      DEN=RA*TA/tp
      call LUMP(ua,ta,f)

999   continue

c --- Set local debug logical
      if(nnp.LT.150) then
         ldbnn=ldb
      else
         ldbnn=.FALSE.
      endif

      if(mprm.EQ.1) then
c ---    PRIME module
c ---    Define coordinates of plume relative to bldg.-defined origin
         xb=x-xbadj
         yb=y-ybadj
         zb=AMAX1(z+zcumul,zmin)
c ---    Obtain mean streamline slopes here (within 15R of building)
         dxds=0.0
         dzdx=0.0
         dzds=0.0
         dzstrm=0.0
         call POSITION(xb,yb,zb,ipositn)
         if(ipositn.GT.2 .AND. x.LE.r15src) then
            call ZSTREAM(hb,wb,xLb,rb,xLr,hr,xb,yb,zb,dzdx)
            dxds=U/USC
            dzds=dzdx*dxds
            dzstrm=dzds*ds
         endif
      endif

c --- Compute RHS of rate equations for this location
      call RATE(ua,dudz,ra,dpdz,ta,drdxa,rhs)

c --- PREDICTOR MARCHING
c ----------------------------------------------------
      call MARCHING(f,ftemp,rhs,ds)
      call UNLUMP(ua,ta,ra,ftemp)

      if(mprm.EQ.1) then
c ---    PRIME module
c ---    Extract met and apply reduction in wake wind speed
         zb=AMAX1(z+zcumul+dzstrm,zmin)
         call ZMET(zb,ua0,ra,ta,dudz0,dpdz)
         call POSITION(xb,yb,zb,ipositn)
         ufac=1.0
         dufac=0.0
         if(ipositn.LT.4) call WAKE_U(ldbu,xb,yb,zb,ufac,dufac)
         ua=ufac*ua0
         dudz=ufac*dudz0+dufac*ua0
      else
         z=AMAX1(z,zmin)
         call ZMET(z,ua,ra,ta,dudz,dpdz)
      endif
      call RATE(ua,dudz,ra,dpdz,ta,drdxa,rhstemp)

c --- CORRECTOR
c ----------------------------------------------------
c *** DO I=1,7 (location 7 is lateral term which is always zero)
      DO I=1,6
         RHS(I)=0.5*(RHSTEMP(I)-RHS(I))
      ENDDO
      call MARCHING(ftemp,f,rhs,ds)
      call UNLUMP(ua,ta,ra,f)

c --- Process new position
c ----------------------------------------------------
      S=S+DS
      if(mprm.EQ.1) then
c ---    PRIME module
c ---    Compute incremental change in plume height to account for
c ---    streamline ascent/descent, and add to cumulative change
         zcumul=zcumul+dzstrm
c ---    Apply cumulative adjustment to plume height
         zc=AMAX1(z+zcumul,zmin)
c ---    Define coordinates of plume relative to bldg.-defined origin
         xb=x-xbadj
         yb=y-ybadj
         zb=zc
         call POSITION(xb,yb,zb,ipositn)
      else
         z=AMAX1(z,zmin)
c ---    Assign height to PRIME variables (zc,zb) to simplify calls
         zc=z
         zb=z
      endif

c --- RISE.DAT output
      if(inrise.EQ.1) then
         kriseout=kriseout+1
         write(iox,*)s,x,y,zc,r,usc,u,v,w,den,tp,ua,ra,ta,dudz,dpdz
      endif

c --- Numerical procedure may result in small negative downwind
c --- distance:  reset to zero and go to next step
      if(x.LT.0.0) then
         x=0.0
         nnp=nnp-1
         goto 96
      endif

c --- Write debug output if in debug mode
c ---------------------------------------
      if(ldbnn)then
         if(mprm.EQ.1) then
c ---       PRIME module
            if(mod(nnp,1000).eq.1) then
               write(io6,*)'NUMRISE  inputs : '
               write(io6,*)' TEFF,REFF,WEFF = ',teff,reff,weff
               write(io6,112)
            endif
            deltaz=zc-h
            write(io6,114)nnp,x,y,zc,r,u,v,w,usc,phi,den,tp,ua,ra,ta,
     &                    dudz,dpdz,dzds,dyds,ipositn,deltaz
         else
            if(mod(nnp,50).eq.1) then
               write(io6,*)'NUMRISE  inputs : '
               write(io6,*)' TEFF,REFF,WEFF = ',teff,reff,weff
               write(io6,122)
            endif
            deltaz=z-h
            write(io6,124)nnp,x,z,r,u,v,w,usc,phi,den,tp,ua,ra,ta,
     &                    dudz,dpdz,deltaz
         endif
      endif
112   format(1x,2x,'NNP',7x,'X',6x,'Y',6x,'Z',6x,'R',6x,'U',5x,'V',
     1   6x,'W',4x,'USC',5x,'PHI',4x,'DEN',5x,'TP',4x,'UA',5x,'RA',5x,
     2   'TA',4x,'DUDZ',5x,'DPDZ',3x,'DZDS',3x,'DYDS',2x,'IPOS',
     3   1x,'DELTAZ')
114   format(1x,i5,f9.2,3f7.2,4f7.2,
     1    f8.4,f6.3,f7.2,f6.2,f7.3,f7.2,f9.4,
     2    f8.4,2f7.4,i5,f7.3)
122      format(1x,2x,'NNP',8x,'X',7x,'Z',7x,'R',5x,'U',5x,'V',
     1   5x,'W',3x,'USC',5x,'PHI',3x,'DEN',5x,'TP',4x,'UA',5x,'RA',5x,
     2   'TA',4x,'DUDZ',4x,'DPDZ',3x,'DELTAZ')
124      format(1x,i5,f9.2,2f8.3,4f6.3,
     1    f8.5,f6.3,f7.2,f6.2,f7.3,f7.2,f8.5,
     2    f8.5,f7.3)
c ---------------------------------------


      if(mprm.EQ.1) then
c ---    PRIME module
c ---    When trajectory inclination falls below PHICHECK radians,
c ---    ignoring streamline descent, check for wake influence
         if(phi.LE.phicheck .AND. ipositn.LT.4) then
            if(.not.LINWAKE) then
c ---          Plume centerline has just entered wake
               linwake=.TRUE.
               xbi=xb
c ---          Use unadjusted rise for BID
               base=AMAX1(H,ZMIN)
               rise=AMAX1(0.0,z-base)
               bidsq=(rise/3.5)**2
               if(ldbhr) then
                  write(io6,*)'NUMRISE call to WAKE_DFSN'
                  write(io6,*)'x,y,z,z+zcum:',x,y,z,zc
                  write(io6,*)'ds,u,w      :',ds,u,w
                  write(io6,*)'xb,phi,phicheck:',xb,phi,phicheck
                  write(io6,*)'rise,bidsq  :',rise,bidsq
                  write(io6,*)'sz0,sy0     :',sigz0,sigy0
               endif
c ---          Compute table of sigmas and growth rate in wake region
               call WAKE_DFSN(ldbhr,xbi,bidsq,sigz0,sigy0)
            endif
c ---       Select plume radius growth rate for this location
            call WAKE_DRDX(x,drdxa)
         endif
      endif

c --- Store any NNP<NP point in NN=1 array location in case rise ends
c --- too quickly to reach the first scheduled point
      if(nnp.LT.np) then
         NN=1
         XT(NN)=X
         ZT(NN)=zc
         Z0T(NN)=z
         RT(NN)=R
      endif

c --- Update path arrays
      if(float(NNP/NP).eq.float(NNP)/XNP) THEN
         NN=NNP/NP
         if(nn.gt.mxnw)then
            write(io6,*)'Error in Subr. NUMRISE -- NN too large -- ',
     1      'NN = ',nn,' MXNW = ',mxnw
         write(*,*)
         stop 'Halted in NUMRISE -- see list file.'
         endif
         XT(NN)=X
         ZT(NN)=zc
         Z0T(NN)=z
         RT(NN)=R

c --- CHECK FOR PLUME EQUILIBRIUM HEIGHT
         IF(x .ge. xmax) THEN
            ZFIN=zc
            Z0FIN=z
            XFIN=X
            RFIN=R
            GOTO 97
         ENDIF

      ENDIF

c --- Extract met and apply reduction in wake wind speed
96    call ZMET(zb,ua0,ra,ta,dudz0,dpdz)
      if(mprm.EQ.1) then
c ---    PRIME module
         ufac=1.0
         dufac=0.0
         if(ipositn.LT.4) call WAKE_U(.FALSE.,xb,yb,zb,ufac,dufac)
         ua=ufac*ua0
         dudz=ufac*dudz0+dufac*ua0
      else
         ua=ua0
         dudz=dudz0
      endif

c --- Next increment
      NNP=NNP+1

c --- Stop rise at local maximum (excludes streamline descent effects)
      if(w.lt.0.0)then
         zfin=zc
         z0fin=z
         xfin=x
         rfin=r
         go to 97
      endif

c --- Adjust ds toward ds0 for next step
      if(ds.LT.ds0) ds=AMIN1(ds0,2.*ds)

      IF(S.LT.SLAST) GOTO 999
c --- END OF PLUME RISE MARCHING LOOP
c ----------------------------------------------------

      ZFIN=zc
      Z0FIN=z
      XFIN=X
      RFIN=R

97    CONTINUE

      if(mprm.EQ.1) then
c ---    PRIME module
c ---    Complete trajectory out to "15R" if required, to account for
c ---    streamline slope (vertical only)
         xfin0=xfin
         x15r=r15src-xfin0
         nnleft=mxnw-nn
         if(x15r.GT.0.0) then
c ---       Check for room in arrays
            if(nnleft.LE.0)then
               write(io6,*)'Error in Subr. NUMRISE -- NN too large ',
     &         '-- NN = ',nn,' MXNW = ',mxnw
               write(io6,*)'Cannot complete trajectory out to 15R'
               write(*,*)
               stop 'Halted in NUMRISE -- see list file.'
            endif
c ---       Set stepsize
            dsfin=nstep*ds
            dx15r=x15r/FLOAT(nnleft)
            dx15r=AMAX1(dsfin,dx15r)
c ---       Set range for additional steps
            n15r=MIN(NINT(x15r/dx15r),nnleft)
            nbeg=nn+1
            nend=nn+n15r
            do in=nbeg,nend
c ---          Define coordinates of plume relative to bldg.
               xbb=xt(in-1)-xbadj
               xbe=xbb+dx15r
               yb=y-ybadj
               zb=zt(in-1)
c ---          Obtain mean streamline slope
               dzdx=0.0
               call POSITION(xbb,yb,zb,ipos)
               if(ipos.GT.2) then
                  call ZSTREAM(hb,wb,xLb,rb,xLr,hr,xbb,yb,zb,dzdxb)
                  call ZSTREAM(hb,wb,xLb,rb,xLr,hr,xbe,yb,zb,dzdxe)
                  dzdx=0.5*(dzdxb+dzdxe)
               endif
               xt(in)=xt(in-1)+dx15r
               zt(in)=AMAX1(zmin,zt(in-1)+dzdx*dx15r)
               z0t(in)=z0t(in-1)
               rt(in)=rfin
               zcumul=zcumul+dzdx*dx15r

c ---          Check for wake entry if this has not already happened
               if(.not.LINWAKE) then
                  if(ipos.LT.4) then
c ---                Plume centerline has just entered wake
                     linwake=.TRUE.
c ---                Set "internal" variable names
                     x=xt(in)
                     z=zt(in)-zcumul
                     xbi=x-xbadj
c ---                Use unadjusted rise for BID
                     base=AMAX1(H,ZMIN)
                     rise=AMAX1(0.0,z-base)
                     bidsq=(rise/3.5)**2

c ---                Debug output
                     if(ldbhr) then
                        write(io6,*)'NUMRISE call to WAKE_DFSN'
                        write(io6,*)'x,z,z+zcum:',x,z,zt(in)
                        write(io6,*)'xb,phi      :',xbi,phi
                        write(io6,*)'rise,bidsq  :',rise,bidsq
                        write(io6,*)'sz0,sy0     :',sigz0,sigy0
                     endif

c ---                Tabulate sigmas and growth rate in wake region
                     call WAKE_DFSN(ldbhr,xbi,bidsq,sigz0,sigy0)
                  endif
c ---             Select plume radius growth rate for this location
                  call WAKE_DRDX(x,drdxa)
               endif
            enddo
c ---       Update nn and reset "fin" data
            nn=nend
            xfin=xt(nn)
            zfin=zt(nn)
            z0fin=z0t(nn)
         endif
      endif

c --- Construct trajectory arrays for calling program
      if(nn.GT.ntr) then
c ---    Sample a subset of the nn points
         xtr(ntr)=xfin
         ztr(ntr)=zfin
         rtr(ntr)=rfin
         htr(ntr)=z0fin-h
         if(nn.LE.2*ntr) then
c ---       Fill elements with nearest values
            deln=FLOAT(nn)/FLOAT(ntr)
            do in=1,ntr-1
               jn=in*deln
               xtr(in)=xt(jn)
               ztr(in)=zt(jn)
               rtr(in)=rt(jn)
               htr(in)=z0t(jn)-h
            enddo
         else
c ---       Use sliding step-size to sample nearfield more frequently
            deln=2.*FLOAT(nn-ntr)/FLOAT(ntr*(ntr-1))
            rn=0.0
            do in=1,ntr-1
               rn=rn+1.0+(in-1)*deln
               jn=rn
               xtr(in)=xt(jn)
               ztr(in)=zt(jn)
               rtr(in)=rt(jn)
               htr(in)=z0t(jn)-h
            enddo
         endif
      else
c ---    Fill elements directly
         do in=1,nn
            xtr(in)=xt(in)
            ztr(in)=zt(in)
            rtr(in)=rt(in)
            htr(in)=z0t(in)-h
         enddo
c ---    Fill excess elements with final rise properties
         do it=nn+1,ntr
            xtr(it)=xfin
            ztr(it)=zfin
            rtr(it)=rfin
            htr(it)=z0fin-h
         enddo
      endif

c --- Restore step size (may have changed)
      ds=ds0

      if(mprm.EQ.1) then
c ---    PRIME module
c ---    Determine maximum fraction of plume captured in cavity
         if(LINWAKE .AND. xbi.LT.(xLb+xLR)) then
c ---       Plume centerline enters wake boundary before clearing cavity
            call WAKE_FQC(ldbhr,xbi,xtr,ztr,ntr)
         else
            fqcav=0.0
         endif
      endif

      if(ldbhr) then
         delzfin=zfin-h
         write(io6,*)
         write(io6,*)'      Initial Plume Temperature = ',teff
         write(io6,*)'             Buoyancy flux (FB) = ',fb
         write(io6,*)'             Momentum flux (FM) = ',fm
         write(io6,*)'  Neutral dist. to final rise   = ',xmax
         write(io6,*)'Total distance tabulated (XFIN) = ',xfin
         write(io6,*)'      Final plume height (ZFIN) = ',zfin
         write(io6,*)'     Final plume rise (DELZFIN) = ',delzfin
         write(io6,*)'      Final plume radius (RFIN) = ',rfin
         if(mprm.EQ.1) then
            write(io6,*)'  Calc distance to final rise   = ',xfin0
            write(io6,*)'Distance from final rise to 15R = ',x15r
            write(io6,*)'Cumul. streamline adj. (ZCUMUL) = ',zcumul
            write(io6,*)
            write(io6,*)'    Fraction of plume in CAVITY = ',fqcav
            write(io6,*)
         endif
         write(io6,*)
c
c ---    Write the arrays passed back to the calling routine
         write(io6,28)
28       format(/4x,'I',10x,'XTR',8x,'ZTR',8x,'RTR',8x,'HTR'/)
         do i=1,ntr
            write(io6,32)i,xtr(i),ztr(i),rtr(i),htr(i)
32          format(i5,3x,4(f10.4,1x))
         enddo
         write(io6,*)
      endif

c --- Process and write RISE.DAT data records
c --- Transfer current rise data from scratch file to RISE.DAT file
      if(inrise.EQ.1) call NRISEOUT(kriseout,mprm)

      RETURN
      END
c----------------------------------------------------------------------
      subroutine numclip(mxrise,htstak,rise,ntr,xtr,ztr,rtr,htr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                NUMCLIP
c                D. Strimaitis
c
c --- PURPOSE:  Clip numerical rise tables at reduced rise
c
c --- UPDATE
c --- V6.0-V6.26    080430  (DGS): Add rise table to arrays that are
c                                  modified
c
c --- INPUTS:
c         mxrise - integer    - Size declared for rise tables
c         htstak - real       - Height of release above ground (m)
c           rise - real       - Height of rise above release (m)
c            ntr - real       - Number of entries in trajectory
c            xtr - real       - Distance from source (m)
c            ztr - real       - Height above ground (m)
c            rtr - real       - Radius of plume (m)
c            htr - real       - Rise height from release (m)
c
c
c --- OUTPUT:
c            ntr - real       - Number of entries in trajectory
c            xtr - real       - Distance from source (m)
c            ztr - real       - Height above ground (m)
c            rtr - real       - Radius of plume (m)
c            htr - real       - Rise height from release (m)
c
c
c --- NUMCLIP called by:  AREAS2, POINTS1, POINTS2
c --- NUMCLIP calls:      none
c----------------------------------------------------------------------
c
      real xtr(mxrise),ztr(mxrise),rtr(mxrise),htr(mxrise)

c --- Set final height above ground
      zfin=htstak+rise

c --- Terminate rise tables at zfin
      ntop=ntr
      if(zfin.LT.ztr(ntr)) then
         do i=2,ntop
            if(zfin.LE.ztr(i)) then
               ntr=i
               frac=(zfin-ztr(i-1))/(ztr(i)-ztr(i-1))
               ztr(i)=zfin
               xtr(i)=xtr(i-1)+frac*(xtr(i)-xtr(i-1))
               rtr(i)=rtr(i-1)+frac*(rtr(i)-rtr(i-1))
               htr(i)=htr(i-1)+frac*(htr(i)-htr(i-1))
               goto 10
            endif
         enddo
      endif

10    return
      end
c----------------------------------------------------------------------
      subroutine nummet(ixs,iys,ldbhr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070629                 NUMMET
c                X.(J.) Zhang, D. Strimaitis, J. Scire
c
c --- PURPOSE:  Prepare meteorological data for numerical plume rise
c
c --- UPDATE
c --- V5.74-V6.2    070629  (DGS): Assign PTGRAD value to default so it
c                                  is always available for debug output
c --- V5.7-V5.74    040715  (DGS): Add METFM=5 (AERMET)
c --- V5.4-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V4.0-V5.0     971107  (JSS): add logic to use METFM=2,3 formats
c                           (DGS): add logic to use METFM=4 format
c
c --- INPUTS:
c       IXS,IYS - integer       - Met cell index nearest source
c         LDBHR - logical       - Debug switch controlling debug output
c
c     Common block /AMBIENT/ variables:
c           NZA,NZAP1,ZFACEA(mxprfp1),ZGPTA(mxprfz) : for METFM=1,2,3
c           ADIA,PTGRAD0
c     Common block /NUMPARM/ variables:
c           RGAS,GRAVI
c     Common block /METHD/ variables:
c           LCALGRD, NEARS(mxnx,mxny),I2DMET
c     Common block /METHR/ variables:
c           UMET(mxnx,mxny,mxnz),VMET(mxnx,mxny,mxnz),
c           TMET(mxnx,mxny,mxnz),TEMPSS(nssta), TEMP2D(mxnx,mxny)
c           PTG(2),IPGT(mxnx,mxny), PLEXP,
c           TPRF(mxprfz),SSPRF(mxprfz),ZPRF(mxprfz),NZPRF
c     Common block /GEN/ variables:
c           METFM
c     Common block /GRID/ variables:
c           ZGPT(mxnz)
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXPRFZ, MXPRFP1, MXSS
c
c --- OUTPUT:
c
c     Common block /AMBIENT/ variables:
c           NZA,NZAP1,ZFACEA(mxprfp1),ZGPTA(mxprfz) : for METFM=4,5
c           UAMB(mxprfz),RAMB(mxprfz),DEDZ(mxprfp1),TAMB(mxprfz),
c           TAMB0,RAMB0
c
c --- NUMMET called by: AREAS2, POINTS1, POINTS2
c --- NUMMET calls:     none
c----------------------------------------------------------------------
c
c --- Include files
      include 'params.puf'
      include 'ambient.puf'
      include 'numparm.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'gen.puf'
      include 'grid.puf'

      logical ldbhr

      data zero/0.0/, half/0.5/

c --- Set default PTemp gradient (may not be used)
      kst=ipgt(ixs,iys)
      if(kst.LE.4) then
         ptgrad=ptgrad0
      elseif(kst.EQ.5) then
         ptgrad=ptg(1)
      else
         ptgrad=ptg(2)
      endif
c --- Impose minimum value
      if(ptgrad.LT.ptgrad0)ptgrad=ptgrad0

      if(metfm.eq.1)then
c
c ---    3-D meteorological fields
c ---    Velocity (m/s) and temperature (K) profiles at grid center
         do i=1,nza
            px=umet(ixs,iys,i)
            py=vmet(ixs,iys,i)
            uamb(i)=sqrt(px*px+py*py)
         enddo

c ---    Define temperature profile from 3-D temperature grid (if
c ---    available) or from the stability-dependent lapse rate
         if(LCALGRD)then
            do i=1,nza
               tamb(i)=tmet(ixs,iys,i)
            enddo
c ---       Compute the surface temperature consistent with the 3-D
c ---       field
            tamb0=tamb(1)-zgpta(1)*((tamb(2)-tamb(1))/(zgpta(2)-
     1       zgpta(1)))
         else

c ---       Use default potential temperature gradient if 3-D temp.
c ---       data is not available
            kst=ipgt(ixs,iys)
            if(kst.LE.4) then
               ptgrad=ptgrad0
            elseif(kst.EQ.5) then
               ptgrad=ptg(1)
            else
               ptgrad=ptg(2)
            endif
c ---       Impose minimum value
            if(ptgrad.LT.ptgrad0)ptgrad=ptgrad0

c ---       Construct 1-D temperature field
c frr (09/01) new calmet format (2D temp)
            if(i2dmet.EQ.1) then
               tamb0=temp2d(ixs,iys)
            elseif(i2dmet.EQ.0) then
               ista=nears(ixs,iys)
               tamb0=tempss(ista)
            else
               write(*,*)'Subr. WET:  Invalid I2DMET = ',i2dmet
               stop
            endif
            do i=1,nza
               tamb(i)=tamb0+zgpta(i)*(ptgrad-adia)
            enddo
c ---       Compute the surface temperature consistent with the 3-D
c ---       field
            tamb0=tamb(1)-zgpta(1)*((tamb(2)-tamb(1))/(zgpta(2)-
     1       zgpta(1)))
         endif
      elseif(metfm.eq.2.or.metfm.eq.3)then
c
c ---    ISC met. or PLM met. data
         kst=ipgt(ixs,iys)
         if(kst.LE.4) then
            ptgrad=ptgrad0
         elseif(kst.EQ.5) then
            ptgrad=ptg(1)
         else
            ptgrad=ptg(2)
         endif
c ---    Impose minimum value
         if(ptgrad.LT.ptgrad0)ptgrad=ptgrad0

c ---    Construct 1-D temperature field
         ista=nears(ixs,iys)
         tamb0=tempss(ista)
         do i=1,nza
            tamb(i)=tamb0+zgpta(i)*(ptgrad-adia)
         enddo

c ---    Extrapolate wind speed to plume rise layers
         zref=zgpt(1)
         wsref=sqrt(umet(ixs,iys,1)**2+vmet(ixs,iys,1)**2)
         do iz=1,nza
            call powlaw(zgpta(iz),zref,wsref,plexp,uamb(iz))
         enddo
      elseif(metfm.eq.4 .OR. metfm.EQ.5)then
c ---    Transfer CTDM PROFILE data to plume rise arrays
         nza=nzprf
         nzap1=nza+1
         do iz=1,nza
            zgpta(iz)=zprf(iz)
            uamb(iz)=ssprf(iz)
            tamb(iz)=tprf(iz)
         enddo
c ---    Compute the surface temperature consistent with the
c ---    temperature profile
         tamb0=tamb(1)-zgpta(1)*((tamb(2)-tamb(1))/(zgpta(2)-
     1    zgpta(1)))
c ---    Compute face heights.  These are NOT equivalent to CALMET
c ---    face heights because these are midway between the grid-pt
c ---    heights, whereas CALMET grid points are midway between cell
c ---    face heights.
         zfacea(1)=zero
         do iz=2,nza
            zfacea(iz)=half*(zgpta(iz)+zgpta(iz-1))
         enddo
         zfacea(nzap1)=2*zgpta(nza)-zfacea(nza)
      else
         write(io6,*)'ERROR in Subr. NUMMET - Invalid value of ',
     1    'METFM -- METFM = ',metfm
         write(*,*)
         stop 'Halted in NUMMET -- see list file.'
      endif

c --- Create potential temperature gradient at zface level
      do i=2,nza
         dedz(i)=adia+(tamb(i)-tamb(i-1))/(zgpta(i)-zgpta(i-1))
      enddo
      dedz(1)=dedz(2)
      dedz(nzap1)=dedz(nza)

c --- Create ambient density profile (kg/m^3) on grid center

c --- Ground-level air density estimated from elevation
      ramb0=1.2*exp(-gravi*elev(ixs,iys)/(rgas*tamb0))
      do i=1,nza
c ---    Compute average temperature in layer
         tbar=0.5*(tamb(i)+tamb0)
c ---    Compute ambient air density at height, ZGPTA(i)
         ramb(i)=ramb0*(tamb0/tamb(i))*exp(-gravi*zgpta(i)/
     1    (rgas*tbar))
      enddo
c
c ----------------
c --- Debug output
c ----------------
      if(ldbhr)then

         write(io6,*)
         write(io6,*)'PTGRAD  = ',ptgrad,' (deg. K/m)'
         write(io6,*)'NZA     = ',nza
         write(io6,*)'ADIA    = ',adia,' (deg. K/m)'
         write(io6,*)'PTGRAD0 = ',ptgrad0,' (deg. K/m)'
         write(io6,*)'METFM   = ',metfm
         write(io6,*)'PLEXP   = ',plexp
         write(io6,*)

         write(io6,*)'TAMB0   = ',tamb0,' (deg. K)'
         write(io6,*)'RAMB0   = ',ramb0,' (kg/m**3)'
         write(io6,*)

         write(io6,8)
8        format(/4x,'I',8x,'ZGPTA',7x,'UAMB',7x,'TAMB'/)
         do i=1,nza
            write(io6,10)i,zgpta(i),uamb(i),tamb(i)
10          format(i5,3x,f10.1,1x,f10.2,1x,f10.2)
         enddo

c ---    Echo back pot. temp. gradient & air density
         write(io6,18)
18       format(/4x,'I',7x,'ZFACEA',7x,'DEDZ',6x,'ZGPTA',7x,'RAMB'/)
         do i=1,nza
            write(io6,22)i,zfacea(i),dedz(i),zgpta(i),ramb(i)
22          format(i5,3x,f10.1,1x,f10.5,1x,f10.1,1x,f10.3)
         enddo
         write(io6,22)nzap1,zfacea(nzap1),dedz(nzap1)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine rate(ua,dudz,ra,dpdz,ta,drdxa,rhs)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 5.4      Level: 030402                   RATE
c                X. Zhang, J. Scire   EARTH TECH/Sigma Research
c
c --- PURPOSE:  Compute the right-hand side of the equations
c
c --- UPDATE
c --- V5.4-V5.7     030402  (DGS): PRIME update - add growth rate due
c                                  to ambient turbulence
c
c --- INPUTS:
c         UA - real    - Current ambient wind speed (m/s)
c       DUDZ - real    - Current wind shear (1/s)
c         RA - real    - Current ambient air density (kg/m**3)
c       DPDZ - real    - Current ambient potential temperature gradient
c                        (deg. K/m)
c         TA - real    - Current ambient air temperature (deg. K)
c      DRDXA - real    - Growth rate of plume radius due to ambient
c                        turbulence
c
c     Common block /PLU/ variables:
c           X,R,U,V,W,USC,PHI,DEN,TP
c     Common block /NUMPARM/ variables:
c           GRAVI, RP, ALPHAP(mxent), BETAP(mxent), XCAT(mxentp1),
c           NENT
c     Parameters:
c           MXENT, MXENTP1
c
c --- OUTPUT:
c        RHS(7) - real     - Right hand terms
c
c --- RATE called by:  NUMRISE
c --- RATE calls:      none
c----------------------------------------------------------------------

c --- Include files
      include 'params.puf'
      include 'numparm.puf'

      COMMON /PLU/ S,X,Y,Z,R,U,V,W,USC,PHI,DEN,TP
      DIMENSION RHS(7)

c ---   Constants:
c          GRAVI - Gravitational acceleration (m/s**2)
c          RP    - Radiation coefficient (kg/m**2/deg. K**3/s)
c          ALPHA - Entrainment coefficient (parallel direction)
c          BETA  - Entrainment coefficient (normal direction)

c --- Set default entrainment coefficients
      data alpha0/.11/, beta0/0.6/
c --- Define the entrainment coefficients
      alpha=alpha0
      beta=beta0

      if(nent.gt.0)then
c ---    Check if the plume is in the area where perturbed entrainment
c ---    coefficients apply
         if(x.lt.xcat(1))go to 99
         nentp1=nent+1
         do i=2,nentp1
            if(x.le.xcat(i))then
               alpha=alphap(i-1)
               beta=betap(i-1)
               go to 99
            endif
         enddo
c ---    Override any ambient growth rate
         drdxa=0.0
      endif
99    continue
      RHS(1)=2.0*R*ALPHA*RA*ABS(USC-UA*U/USC)+
     &               2.0*R*BETA*RA*ABS(UA*SIN(PHI))
c
c --- Condition entrainment to be .GE. growth due to ambient turb.
      rhs1a =2.0*R*RA*UA*drdxa
      rhs(1)=AMAX1(rhs(1),rhs1a)
c
      RHS(2)=-R*R*DEN*W*DUDZ
      RHS(3)=GRAVI*R*R*(RA-DEN)
      RHS(4)=-DPDZ*DEN*W*R*R-RP*R*(TP**4-TA**4)
      RHS(5)=W/USC
      RHS(6)=U/USC
c *** rhs(7)=v/usc
      RETURN
      END
c----------------------------------------------------------------------
      subroutine lump(ua,ta,f)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                   LUMP
c                X.(J.) Zhang, J. Scire  SRC
c
c --- PURPOSE:  Calculate the lumped variables
c
c --- INPUTS:
c         UA - real    - Current ambient wind speed (m/s)
c         TA - real    - Current ambient air temperature (K)
c
c --- OUTPUT:
c          F(7) - real     - lumped variables
c
c --- LUMP called by:  NUMRISE
c --- LUMP calls:      none
c----------------------------------------------------------------------
        COMMON /PLU/ S,X,Y,Z,R,U,V,W,USC,PHI,DEN,TP

        DIMENSION F(7)

        F(1)=DEN*USC*R*R
        F(2)=F(1)*(U-UA)
        F(3)=F(1)*W
        F(4)=F(1)*(TP-TA)
        F(5)=Z
        F(6)=X
c ***   F(7)=y
        RETURN
        END
c----------------------------------------------------------------------
      subroutine marching(fold,fnew,rhs,ds)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715               MARCHING
c                X.(J.) Zhang, J. Scire  SRC
c
c --- PURPOSE:  Marching S one step, either PREDICTOR or CORRECTOR
c
c --- INPUTS:
c       FOLD(7) - real     - Old values
c        RHS(7) - real     - Right hand terms
c            DS - real     - Distance (m) along plume axis
c
c
c --- OUTPUT:
c       FNEW(7) - real     - New values
c
c --- MARCHING called by:  NUMRISE
c --- MARCHING calls:      none
c----------------------------------------------------------------------
        DIMENSION FNEW(7),FOLD(7),RHS(7)

c ***   DO 10 I=1,7
        DO 10 I=1,6
           FNEW(I)=FOLD(I)+RHS(I)*DS
10      CONTINUE
        RETURN
        END
c----------------------------------------------------------------------
      subroutine unlump(ua,ta,ra,f)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                 UNLUMP
c                X.(J.) Zhang, J. Scire  SRC
c
c --- PURPOSE:  Calculate physical variables from lumped variables
c
c --- INPUTS:
c         UA - real    - Current ambient wind speed (m/s)
c         TA - real    - Current ambient air temperature (K)
c         RA - real    - Current ambient air density (kg/m^3)
c       F(7) - real    - Lumped variables
c
c --- OUTPUT:
c       common /PLU/:
c          U,V,W,USC,R,TP,PHI,Z,Y,X
c
c --- UNLUMP called by:  NUMRISE
c --- UNLUMP calls:      none
c----------------------------------------------------------------------
        COMMON /PLU/ S,X,Y,Z,R,U,V,W,USC,PHI,DEN,TP

        DIMENSION F(7)

        U=UA+F(2)/F(1)
        W=F(3)/F(1)
        USC=SQRT(U*U+W*W)
        TP=TA+F(4)/F(1)

c ---   Update plume density  (This short-cut could cause PROBLEMS!)
        DEN=RA*TA/TP

        R=SQRT(F(1)/USC/DEN)
        PHI=ATAN(W/U)
        Z=F(5)
        X=F(6)
c ***   Y=F(7)
        RETURN
        END
c----------------------------------------------------------------------
      subroutine zmet(z,ua,ra,ta,dudz,dpdz)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                   ZMET
c                X.(J.) Zhang, J. Scire  SRC
c
c --- PURPOSE:  Obtain ambient met parameters at height z
c               by interpolation of gridded values
c
c --- INPUTS:
c          Z - real    - Height (m)
c
c     Common block /AMBIENT/ variables:
c           NZA,UAMB(mxprfz),RAMB(mxprfz),TAMB(mxprfz),ZFACEA(mxprfp1),
c           ZGPTA(mxprfz),TAMB0,RAMB0,ADIA,PTGRAD0
c     Parameters:
c           MXPRFZ, MXPRFP1
c
c --- OUTPUT:
c         UA - real    - Current ambient wind speed (m/s)
c         RA - real    - Current ambient air density (kg/m**3)
c         TA - real    - Current ambient air temperature (deg. K)
c       DUDZ - real    - Current wind shear (1/s)
c       DPDZ - real    - Current ambient potential temperature gradient
c                        (deg. K/m)
c
c --- ZMET called by:  NUMRISE
c --- ZMET calls:      none
c----------------------------------------------------------------------
c     Defined at grid center: uamb,tamb,ramb
c     Defined at zface:       dedz
c----------------------------------------------------------------------
c --- Include files
      include 'params.puf'
      include 'ambient.puf'

c --- Interpolate variables defined at grid cell center
      if(z.lt.zgpta(1))then

c ---    Height is below first grid point
         zfact=(zgpta(1)-z)/zgpta(1)
         ta=tamb(1)-(tamb(1)-tamb0)*zfact
         ra=ramb(1)-(ramb(1)-ramb0)*zfact
c ---    Wind speed at z=0 is assumed to be zero
         ua=uamb(1)*(1.0-zfact)
         dudz=uamb(1)/zgpta(1)
         dpdz=adia+(tamb(1)-tamb0)/zgpta(1)
         dpdz=amax1(dpdz,ptgrad0)

      else if(z.lt.zgpta(nza))then

c ---    Find the layer containing height, Z
         do i=2,nza
            if(z.le.zgpta(i))then
               im1=i-1
               delz=zgpta(i)-zgpta(im1)
               zfact=(zgpta(i)-z)/delz
               ta=tamb(i)-(tamb(i)-tamb(im1))*zfact
               ra=ramb(i)-(ramb(i)-ramb(im1))*zfact
               ua=uamb(i)-(uamb(i)-uamb(im1))*zfact
c ---          Compute wind speed gradient & pot. temp. gradient
               dudz=(uamb(i)-uamb(im1))/delz
               dpdz=adia+(tamb(i)-tamb(im1))/delz
               dpdz=amax1(dpdz,ptgrad0)
               go to 101
            endif
         enddo

      else

c ---    Height is at or above the top grid point -- persist values
c ---    at the top grid cell
         ta=tamb(nza)
         ra=ramb(nza)
         ua=uamb(nza)
c ---    Hold wind speed and temperature constant above top layer at
c ---    values at top grid point
         dudz=0.0
         dpdz=adia
         dpdz=amax1(dpdz,ptgrad0)
      endif

101   continue

      return
      end
c----------------------------------------------------------------------
      subroutine numpr1(nz,zgpt,nzp1,zface,metfm,dsrise,trajincl)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 5.4      Level: 040715               NUMPR1
c                J. Scire, EARTH TECH/Sigma Research
c
c --- PURPOSE:  Initialize the variables used by the numerical
c               plume rise algorithm
c
c --- UPDATE
c --- V5.7-V5.74    040715  (DGS): add METFM=5 (AERMET)
c --- V5.4-V5.7     030402  (DGS): add PRIME module layers for ISC met,
c                                  change DS to DS0,
c                                  compute PHICHECK from TRAJINCL
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): DS provided in control file (compute
c                                  NSTEP from DS,SLAST,MXNW)
c --- V4.0-V5.0     971107  (JSS): add logic to use METFM=2,3,4 formats
c
c --- INPUTS:
c              NZ - integer    - Number of vertical levels
c      ZGPT(mxnz) - real       - Grid point heights (m) (NZ values)
c            NZP1 - integer    - Number of vertical cell faces (NZ+1)
c   ZFACE(mxnzp1) - real       - Cell face heights (m) (NZP1 values)
c           METFM - integer    - Meteorological format flag
c                                  1=CALMET format (CALMET.DAT)
c                                  2=ISC format (ISCMET.DAT)
c                                  3=AUSPLUME format (PLMMET.DAT)
c                                  4=CTDM format (PROFILE.DAT,
c                                                 SURFACE.DAT)
c          DSRISE - real       - Along-trajectory distance step used
c                                when marching in numerical plume rise
c                                solver
c        TRAJINCL - real       - Trajectory inclination angle (deg),
c                                ignoring streamline descent, at which
c                                check is made for PRIME wake influence
c
c       Parameters:
c          MXENT, MXENTP1, MXNZ, MXNZP1, MXPRFZ, MXPRFP1, MXNW,
c          IO6
c
c --- OUTPUT:
c
c       Common block /NUMPARM/ variables:
c          GRAVI,RGAS,ZMIN,NSTEP,SLAST,RP,ALPHAP(mxent),
c          BETAP(mxent),XCAT(mxentp1),NENT,DS0,PHICHECK
c       Common block /AMBIENT/ variables:
c          ADIA,PTGRAD0,ZGPTA(mxprfz),ZFACEA(mxprfp1)
c
c --- NUMPR1 called by:  SETUP
c --- NUMPR1 calls:      none
c----------------------------------------------------------------------

c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'numparm.puf'
      include 'ambient.puf'

      data deg2rad/0.017453293/

      real zgpt(nz),zface(nzp1)

c -----------------------
c --- /NUMPARM/ variables
c -----------------------
c
c --- Set the acceleration due to gravity (m/s**2)
      gravi=9.807

c --- Set the gas constant (m**2/s**2/deg. K)
      rgas=287.026

c --- Set the minimum plume centerline height (m)
      zmin=0.001

c --- Set the termination distance (m) of the plume rise calculation
      slast=5000.

c --- Pass computation step size provided in control file into DS
      ds0=dsrise

c --- Compute the internal save frequency of plume rise calculations
c     (i.e., every DS*NSTEP meters) assuring that no more than MXNW
c     values are saved over the distance SLAST
c     (NOTE: this the frequency with which the results are saved
c     internally -- not that passed back from the NUMRISE routine)
      nstep=1+(slast/(ds0*FLOAT(mxnw)))

c --- Set the radiation coefficient (kg/m**2/deg. K**3/s)
      rp=9.1e-11

c --- Set the perturbed entrainment coefficients
c     ALPHAP (parallel direction), BETAP (normal direction)
      nent=0
      alphap(1)=0.11
      betap(1)=0.6
      xcat(1)=-9.e9
      xcat(2)= 9.e9

c --- Compute trajectory inclination angle (radians)
      phicheck=trajincl*deg2rad

c -----------------------
c --- /AMBIENT/ variables
c -----------------------

c --- Set dry adiabatic lapse rate (deg. K/m)
      adia=.0098

c --- Set minimum potential temperature lapse rate (deg. K/m)
      ptgrad0=0.0

c --- Define plume rise layers based on selection of met. format
      if(metfm.eq.1)then

c ---    CALMET met. format
c -------------------------
c ---    Set the default number of layers same as model layers
         nza=nz
         nzap1=nza+1
         if(nza.gt.mxprfz)then
            write(io6,*)'ERROR in SUBR. NUMPR1 -- NZA is too large ',
     1      'for array dimension -- NZA = ',nza,' MXPRFZ = ',mxprfz
            write(*,*)
            stop 'Halted in NUMPR1 -- see list file.'
         endif
         if(nzap1.gt.mxprfp1)then
            write(io6,*)'ERROR in SUBR. NUMPR1 -- NZAP1 is too large ',
     1      'for array dimension -- NZAP1 = ',nzap1,' MXPRFP1 = ',
     2      mxprfp1
            write(*,*)
            stop 'Halted in NUMPR1 -- see list file.'
         endif

c ---    Define the meteorological grid
c ---    Set plume rise arrays with met. grid point heights
         do i=1,nza
            zgpta(i)=zgpt(i)
         enddo

c ---    Set the plume rise cell face heights
         do i=1,nzap1
            zfacea(i)=zface(i)
         enddo

      else if(metfm.eq.2.or.metfm.eq.3)then

c ---    ISC met. or AUSPLUME met. format
c ---------------------------------------
c ---    Set number of layers for plume rise to 45
         nza=45
         nzap1=nza+1
         if(nza.gt.mxprfz)then
            write(io6,*)'ERROR in SUBR. NUMPR1 -- NZA is too large ',
     1      'for array dimension -- NZA = ',nza,' MXPRFZ = ',mxprfz
            write(*,*)
            stop 'Halted in NUMPR1 -- see list file.'
         endif
         if(nzap1.gt.mxprfp1)then
            write(io6,*)'ERROR in SUBR. NUMPR1 -- NZAP1 is too large ',
     1      'for array dimension -- NZAP1 = ',nzap1,' MXPRFP1 = ',
     2      mxprfp1
            write(*,*)
            stop 'Halted in NUMPR1 -- see list file.'
         endif

c ---    Define the meteorological grid
c ---    Set cell face heights at every 10 m from 10-200 m
         dz=10.
         nn=1
         zfacea(nn)=0.0
         do i=1,20
            nn=nn+1
            zfacea(nn)=zfacea(nn-1)+dz
         enddo
c ---    Set cell face heights every 50 m from 250-500 m
         dz=50.
         do i=21,26
            nn=nn+1
            zfacea(nn)=zfacea(nn-1)+dz
         enddo
c ---    Set cell face heights every 100 m from 600-2000 m
         dz=100.
         do i=27,41
            nn=nn+1
            zfacea(nn)=zfacea(nn-1)+dz
         enddo
c ---    Set cell face heights every 500 m from 2500-4000 m
         dz=500.
         do i=42,45
            nn=nn+1
            zfacea(nn)=zfacea(nn-1)+dz
         enddo

         if(nn.NE.nzap1) stop 'NUMPR1: nn.NE.nzap1'

c ---    Compute grid point heights
         do i=1,nza
            zgpta(i)=0.5*(zfacea(i+1)+zfacea(i))
         enddo

      else if(metfm.GT.5)then
c ---    N.B.: Layer structure varies hourly if using metfm=4,5 
c ---    so these levels are defined in NUMMET.  Any value of metfm
c ---    greater than 5 is not supported.
         write(io6,*)'ERROR in Subr. NUMPR1 -- Invalid value of METFM ',
     1   '-- METFM = ',metfm
         write(*,*)
         stop 'Halted in NUMPR1 -- see list file.'
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine RDHDEM2(iunit0,i,lprt,lnpt2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                RDHDEM2
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Read the header records from the PTEMARB point source
c               emissions file (arbitrarily-varying emissions)
c
c --- UPDATE
c --- V6.1-V6.22: 070921 (DGS): Condition GEO referencing string
c                               variables and add QA
c                               Remove calls to ALLCAP
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added,
c                               including full coordinate and time
c                               documentation with begin/end times with
c                               seconds.
c                               Header information is passed to scratch
c                               file.
c --- V5.5-V5.7 : 030402 (DGS): CALUTILS version of XTRACTLL
c                               Add list file unit to YR4 call
c --- V5.4-V5.4 : 000602_6(DGS): Change name of LCC longitude from
c                                '-ELON-' to '-WLON-'
c --- V5.2-V5.4 : 000602 (DGS): allow multiple PTEMARB files
c                 000602 (DGS): add header record for LC map data
c                 000602 (DGS): add message to "stop"
c --- V5.0-V5.2 : 991104 (DGS): YYYY format used for year
c --- V4.0-V5.0 : 971107 (DGS): PTEMARB.DAT either binary or ASCII
c                 971107 (DGS): Check for valid version of file
c
c --- INPUTS:
c           IUNIT0 - integer    - Fortran unit number for the FIRST
c                                 PTEMARB file
c                I - integer    - Index for current PTEMARB file
c             LPRT - logical    - Flag controlling printing of header
c                                 record data (F=suppress, T=print)
c            LNPT2 - logical    - Flag indicating all sources found
c
c     Common Block /PT2/ variables:
c            MFPT2, NPT2
c     Common Block /DATASET/ variables:
c            VERPARB(mxemdat)
c     Common Block /DATEHR/ variables:
c            XBTZ
c     Common Block /QA/ variables:
c            NCOMMOUT
c   Parameters:
c            IO6, MXSPEC, MXEMDAT, MXQSTEP, IOX
c
c --- OUTPUT:
c
c     Common Block /PT2/ variables:
c           NSE2,MFPT2(mxemdat),
c           IBSRC2(mxemdat),IESRC2(mxemdat),
c           IBDATHR2(mxemdat),IBSEC2(mxemdat),IEDATHR2(mxemdat),
c           IESEC2(mxemdat),XTZ2(mxemdat),T2BTZ2(mxemdat),
c           XMWEM2(mxspec),IXREM2(mxspec),
c           lutmpt2(mxemdat),llccpt2(mxemdat),lpspt2(mxemdat),
c           lempt2(mxemdat),llazapt2(mxemdat),lttmpt2(mxemdat),
c           iutmznpt2(mxemdat),feastpt2(mxemdat),fnorthpt2(mxemdat),
c           rnlat0pt2(mxemdat),relon0pt2(mxemdat),
c           rnlat1pt2(mxemdat),rnlat2pt2(mxemdat),NSTEP2(mxemdat),
c           NDHRQB2(mxqstep,mxemdat),NSECQB2(mxqstep,mxemdat),
c           NDHRQE2(mxqstep,mxemdat),NSECQE2(mxqstep,mxemdat),
c           CSLST2(mxspec),CID2(mxarea),
c           pmappt2(mxemdat),utmhempt2(mxemdat),datumpt2(mxemdat),
c           datenpt2(mxemdat),xyunitpt2(mxemdat)
c
c --- RDHDEM2 called by: SETUP
c --- RDHDEM2 calls:     YR4, XTRACTLL, INCR, TCLOCK, GEOFMT
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'pt2.puf'
      include 'dataset.puf'
      include 'datehr.puf'
      include 'qa.puf'
c
      LOGICAL lprt, lnpt2, lmatch

c --- Local variables
      real xmwem2x(mxspec)
      character*8 axtz2
      character*12 fname2,label2(mxemdat)
      character*12 cslst2x(mxspec),vrs2
      character*16 dataset,dataver
      character*16 clat0,clon0,clat1,clat2
      character*33 blank33,break33
      character*64 datamod
      character*132 comment1,blank,break

      data blank33/'                                 '/
      data break33/'.................................'/
      data nlim/1/
      data zero/0.0/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Set break (132 characters)
      break(1:33)=break33
      break(34:66)=break33
      break(67:99)=break33
      break(100:132)=break33

c --- Begin scratch file image
      write(iox,'(a132)') blank
      write(iox,'(a132)') break
      write(iox,'(a132)') blank
      ncommout=ncommout+3

c --- Set unit number
      iunit=iunit0+i-1

c --- Initialize map projection logicals
      lutmpt2(i)=.FALSE.
      llccpt2(i)=.FALSE.
      lpspt2(i)=.FALSE.
      lempt2(i)=.FALSE.
      llazapt2(i)=.FALSE.
      lttmpt2(i)=.FALSE.

c --- Initialize other variables
      datenpt2(i)='02-21-2003  '
      xyunitpt2(i)='KM  '
      ibsec2(i)=0.0
      iesec2(i)=0.0
      feastpt2(i)=0.0
      fnorthpt2(i)=0.0
      clat0='0.0N            '
      clon0='0.0W            '
      clat1='0.0N            '
      clat2='0.0N            '
      dataset='                '
      dataver='                '
      pmappt2(i)='XXX     '
      iutmznpt2(i)=1
      utmhempt2(i)='N   '
      datumpt2(i)='XXX     '
      axtz2='UTC+0000'

c     -----------------------
      if(verparb(i).EQ.'1.5' .OR.
     &   verparb(i).EQ.'1.54' .OR.
     &   verparb(i).EQ.'1.6') then
c     -----------------------

c ---    Provide help and then stop (these formats are not supported)
         dataset='PTEMARB.DAT     '

         if(verparb(i).EQ.'1.5') then
            read(iunit,*)fname2,npt2file,nse2x,iutmznpt2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs2,label2(i)
            dataver='1.5a            '
            datamod(1:40)='Augmented 5 format with Map Projection, '
            datamod(41:64)='DATUM, Time Zone        '

         elseif(verparb(i).EQ.'1.54') then
            read(iunit,*)fname2,npt2file,nse2x,iutmznpt2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs2,label2(i)
            dataver='1.54a           '
            datamod(1:42)='Augmented 5.4 format with Map Projection, '
            datamod(43:64)='DATUM, Time Zone      '

         elseif(verparb(i).EQ.'1.6') then
            read(iunit,*)fname2,npt2file,nse2x,iuser0,iuser1,iuser2,
     &                iutmznpt2(i),ibyr,ibdy,ibhr,ibsec2(i),
     &                ieyr,iedy,iehr,iesec2(i),vrs2,label2(i)
            dataver='1.6a            '
            datamod(1:40)='Augmented 6 format with Map Projection, '
            datamod(41:64)='DATUM, Time Zone        '

         endif

         write(io6,*)
         write(io6,*)
         write(io6,*)'ERROR in PTEMARB files'
         write(io6,*)
         write(io6,*)'Old PTEMARB.DAT format cannot be used because:'
         write(io6,*)'1.  Coordinate map projection is incomplete'
         write(io6,*)'2.  The DATUM for the coordinates is missing'
         write(io6,*)'3.  The time zone is missing'
         write(io6,*)
         write(io6,*)'ADD these records to the top of the file:'
         write(io6,*)
         write(io6,'(2a16,a64)') dataset,dataver,datamod
         if(iutmznpt2(i).NE.0) then
            write(io6,'(a8)')'UTM     '
            write(io6,'(a8)')'  xxN   '
         else
            write(io6,'(a8)')'LCC     '
            if(verparb(i).NE.'1.54') then
              write(io6,'(4a16)')'yy.yyyN         ','xx.xxxW         ',
     &                           'yy.yyyN         ','yy.yyyN         '
            endif
            write(io6,*)zero,zero
         endif
         write(io6,'(a8)')'DATUM   '
         write(io6,'(a8)')'UTC-0500'
         write(io6,*)
         write(io6,*)'UPDATE these records to describe your file:'
         if(iutmznpt2(i).NE.0) then
           write(io6,*)'- Replace the xxN with your UTM zone and',
     &                 ' hemisphere (S for Southern Hemisphere)'
         else
           if(verparb(i).NE.'1.54') then
             write(io6,*)'- Replace the xx.xxxW and yy.yyyN with your',
     &                 ' LCC projection parameters.'
             write(io6,*)'  The order is Origin Latitude, Origin',
     &                 ' Longitude, and the 2 Matching Parallels'
             write(io6,*)'  (each field is 16 characters)'
           endif
           write(io6,*)'- Replace the 0.0 0.0 with your False Easting',
     &                 ' and Northing if non-zero'   
         endif
         write(io6,*)'- Replace DATUM with your datum code (enter',
     &               ' left-justified in the 8-character field)'
         write(io6,*)'- Replace UTC-0500 with your time zone code'
         write(io6,*)'  (GMT=UTC+0000, EST=UTC-0500, CET=UTC+0100)'
         write(io6,*)
         write(*,*)
         write(*,*)'ERROR in PTEMARB files -- see list file'
         write(*,*)
         stop

c     ----------------------------
      elseif(verparb(i).EQ.'1.5a' .OR.
     &       verparb(i).EQ.'1.54a' .OR.
     &       verparb(i).EQ.'1.6a') then
c     ----------------------------

c ---    Augmented headers

         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         ncommout=ncommout+1
c ---    Map projection
         read(iunit,'(a8)') pmappt2(i)
         write(iox,'(a8)') pmappt2(i)
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmappt2(i),iutmznpt2(i),
     &               utmhempt2(i),clat0,clon0,clat1,clat2,
     &               datumpt2(i),datenpt2(i),xyunitpt2(i),axtz2)

         if(pmappt2(i).EQ.'UTM     ')  lutmpt2(i) =.TRUE.
         if(pmappt2(i).EQ.'LCC     ')  llccpt2(i) =.TRUE.
         if(pmappt2(i).EQ.'PS      ')  lpspt2(i)  =.TRUE.
         if(pmappt2(i).EQ.'EM      ')  lempt2(i)  =.TRUE.
         if(pmappt2(i).EQ.'LAZA    ')  llazapt2(i)=.TRUE.
         if(pmappt2(i).EQ.'TTM     ')  lttmpt2(i) =.TRUE.
c ---    Map projection parameters
         if(LUTMPT2(i)) then
            read(iunit,'(i4,a4)') iutmznpt2(i),utmhempt2(i)
            write(iox,'(i4,a4)') iutmznpt2(i),utmhempt2(i)
            ncommout=ncommout+1
         elseif(LLCCPT2(i) .AND. verparb(i).NE.'1.54a') then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCPT2(i)) then
            read(iunit,*) feastpt2(i),fnorthpt2(i)
            write(iox,*)  feastpt2(i),fnorthpt2(i)
            ncommout=ncommout+1
         endif
c ---    Map DATUM
         read(iunit,'(a8)') datumpt2(i)
         write(iox,'(a8)')  datumpt2(i)
         ncommout=ncommout+1
c ---    Time zone
         read(iunit,'(a8)') axtz2
         write(iox,'(a8)')  axtz2
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmappt2(i),iutmznpt2(i),
     &               utmhempt2(i),clat0,clon0,clat1,clat2,
     &               datumpt2(i),datenpt2(i),xyunitpt2(i),axtz2)

c ---    Process time zone
         read(axtz2(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM2 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz2
            stop 'Halted in RDHDEM2 -- see list file'
         endif
         xtz2(i)=-FLOAT(ibtzhh)

c ---    Old Header Record(s)

         if(verparb(i).EQ.'1.5a') then
            read(iunit,*)fname2,npt2file,nse2x,iutmznpt2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs2,label2(i)
            ibyr=ibdat/1000
            ibdy=ibdat-ibyr*1000
            ieyr=iedat/1000
            iedy=iedat-ieyr*1000
            write(iox,'(a12,9i6,2a12)')fname2,npt2file,nse2x,
     &                iutmznpt2(i),ibyr,ibdy,ibhr,ieyr,iedy,iehr,
     &                vrs2,label2(i)
            ncommout=ncommout+1
         elseif(verparb(i).EQ.'1.54a') then
            read(iunit,*)fname2,npt2file,nse2x,iutmznpt2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs2,label2(i)
            read(iunit,*) clat1,clat2,clat0,clon0
            ibyr=ibdat/1000
            ibdy=ibdat-ibyr*1000
            ieyr=iedat/1000
            iedy=iedat-ieyr*1000
            write(iox,'(a12,9i6,2a12)')fname2,npt2file,nse2x,
     &                iutmznpt2(i),ibyr,ibdy,ibhr,ieyr,iedy,iehr,
     &                vrs2,label2(i)
            write(iox,'(4a16)') clat1,clat2,clat0,clon0
            ncommout=ncommout+2
         elseif(verparb(i).EQ.'1.6a') then
            read(iunit,*)fname2,npt2file,nse2x,iuser0,iuser1,iuser2,
     &                iutmznpt2(i),ibyr,ibdy,ibhr,ibsec2(i),
     &                ieyr,iedy,iehr,iesec2(i),vrs2,label2(i)
            write(iox,'(a12,14i6,2a12)')fname2,npt2file,nse2x,
     &                iuser0,iuser1,iuser2,iutmznpt2(i),ibyr,ibdy,ibhr,
     &                ibsec2(i),ieyr,iedy,iehr,iesec2(i),vrs2,label2(i)
            ncommout=ncommout+1
         endif

c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) then
            write(*,*)
            stop 'Halted in RDHDEM2'
         endif

c ---    Species list
         read(iunit,*)(cslst2x(n),n=1,nse2x)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem2x(n),n=1,nse2x)

c     ---------------------------
      elseif(verparb(i).EQ.'2.1') then
c     ---------------------------

c ---    First record and comments
         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         read(iunit,*) ncom
         write(iox,*) ncom
         do k=1,ncom
            comment1=blank
            read(iunit,'(a132)') comment1
            write(iox,'(a132)') comment1
         enddo
         ncommout=ncommout+2+ncom

c ---    Map projection
         read(iunit,'(a8)') pmappt2(i)
         write(iox,'(a8)') pmappt2(i)
         ncommout=ncommout+1
c ---    Condition map projection

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmappt2(i),iutmznpt2(i),
     &               utmhempt2(i),clat0,clon0,clat1,clat2,
     &               datumpt2(i),datenpt2(i),xyunitpt2(i),axtz2)

         if(pmappt2(i).EQ.'UTM     ')  lutmpt2(i) =.TRUE.
         if(pmappt2(i).EQ.'LCC     ')  llccpt2(i) =.TRUE.
         if(pmappt2(i).EQ.'PS      ')  lpspt2(i)  =.TRUE.
         if(pmappt2(i).EQ.'EM      ')  lempt2(i)  =.TRUE.
         if(pmappt2(i).EQ.'LAZA    ')  llazapt2(i)=.TRUE.
         if(pmappt2(i).EQ.'TTM     ')  lttmpt2(i) =.TRUE.

c ---    Map projection parameters
         if(LUTMPT2(i)) then
            read(iunit,'(i4,a4)') iutmznpt2(i),utmhempt2(i)
            write(iox,'(i4,a4)') iutmznpt2(i),utmhempt2(i)
            ncommout=ncommout+1
         elseif(LLCCPT2(i)) then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         elseif(LPSPT2(i)) then
            read(iunit,'(3a16)') clat0,clon0,clat1
            write(iox,'(3a16)')  clat0,clon0,clat1
            ncommout=ncommout+1
         elseif(LEMPT2(i).or.LLAZAPT2(i).or.LTTMPT2(i)) then
            read(iunit,'(2a16)') clat0,clon0
            write(iox,'(2a16)')  clat0,clon0
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCPT2(i).or.LLAZAPT2(i).or.LTTMPT2(i)) then
            read(iunit,*) feastpt2(i),fnorthpt2(i)
            write(iox,*)  feastpt2(i),fnorthpt2(i)
            ncommout=ncommout+1
         else
            feastpt2(i)=0.0
            fnorthpt2(i)=0.0
         endif

c ---    Map DATUM
         read(iunit,'(a8,a12)') datumpt2(i),datenpt2(i)
         write(iox,'(a8,a12)')  datumpt2(i),datenpt2(i)
         ncommout=ncommout+1

c ---    Map units
         read(iunit,'(a4)') xyunitpt2(i)
         write(iox,'(a4)')  xyunitpt2(i)
         ncommout=ncommout+1

c ---    Time zone
         read(iunit,'(a8)') axtz2
         write(iox,'(a8)')  axtz2
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmappt2(i),iutmznpt2(i),
     &               utmhempt2(i),clat0,clon0,clat1,clat2,
     &               datumpt2(i),datenpt2(i),xyunitpt2(i),axtz2)

c ---    Process Time zone
         read(axtz2(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM2 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz2
            stop 'Halted in RDHDEM2 -- see list file'
         endif
         xtz2(i)=-FLOAT(ibtzhh)

c ---    Time period
         read(iunit,*)ibyr,ibdy,ibhr,ibsec2(i),
     &                ieyr,iedy,iehr,iesec2(i)
c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDHDEM2'
         write(iox,'(9i6)')ibyr,ibdy,ibhr,ibsec2(i),
     &                     ieyr,iedy,iehr,iesec2(i)
         ncommout=ncommout+1

c ---    Number of sources and species
         read(iunit,*) npt2file,nse2x
         write(iox,*) npt2file,nse2x
         ncommout=ncommout+1

c ---    Species list
         read(iunit,*)(cslst2x(n),n=1,nse2x)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem2x(n),n=1,nse2x)

c     -----
      else
c     -----

         write(*,*)'ERROR in PTEMARB File: ',i
         write(*,*)'Bad Dataset Version: ',verparb(i)
         write(*,*)'Expected 1.5, 1.5a, 1.54, 1.54a, 1.6, 1.6a, 2.1'
         stop

c     -----
      endif
c     -----

c --- Species info to scratch file
      do n=1,nse2x
         write(iox,'(a16,f12.4)')cslst2x(n),xmwem2x(n)
      enddo
      ncommout=ncommout+nse2x

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibsec2(i))
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iesec2(i))

c --- Apply time zone adjustment to date/times
      if(xtz2(i).GE.-13 .AND. xtz2(i).LE.13) then
         t2btz2(i)=xtz2(i)-xbtz
         ishift=NINT(t2btz2(i))
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
         call INCR(io6,ieyr,iedy,iehr,ishift)
      else
         write(io6,*)
         write(io6,*)'ERROR in PTEMARB.DAT file : Bad Time Zone'
         write(io6,*)'Expected zone between -13 and 13'
         write(io6,*)'Found zone = ',xtz2(i)
         stop 'Bad Time Zone in PTEMARB.DAT file -- see list file'
      endif

c --- Hourly Data:  Move the time for the first period from the end
c ---               to the start of the first hour
      if(verparb(i).EQ.'1.5a' .OR. verparb(i).EQ.'1.54a') then
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      endif

c --- Form date-hr variables for /PT2/
      ibdathr2(i)=ibyr*100000+ibdy*100+ibhr
      iedathr2(i)=ieyr*100000+iedy*100+iehr

c --- Process lat/lon character variables to extract content
      call XTRACTLL(io6,'LAT ',clat1,rnlat1pt2(i))
      call XTRACTLL(io6,'LAT ',clat2,rnlat2pt2(i))
      call XTRACTLL(io6,'LAT ',clat0,rnlat0pt2(i))
      call XTRACTLL(io6,'LON ',clon0,relon0pt2(i))

c --- Set source index range for this file
      if(i.EQ.1) then
         ibsrc2(i)=1
         iesrc2(i)=npt2file
      else
         ibsrc2(i)=iesrc2(i-1)+1
         iesrc2(i)=iesrc2(i-1)+npt2file
      endif
c --- Set logical to indicate if the number of sources specified in
c --- the control file (NPT2) have been found
      lnpt2=.FALSE.
      if(npt2.EQ.iesrc2(i)) lnpt2=.TRUE.

c --- Process data that must be identical in all PTEMARB.DAT files
      if(i.EQ.1) then
c ---    Pass into /pt2/ names
         nse2=nse2x
c
         if(nse2.gt.mxspec)then
            write(io6,11)nse2,mxspec
11          format(/1x,'ERROR in SUBR. RDHDEM2 -- No. emitted species',
     1      ' in PTEMARB file is greater than current array',
     2      ' dimension'/1x,
     3      '     No. emitted species in file: ',i5/1x,
     4      'Current Array dimension (MXSPEC): ',i5)
            write(*,*)
            stop 'Halted in RDHDEM2 -- see list file.'
         endif
      else
c ---    Check for consistency with first file
         if(nse2.NE.nse2x) then
            write(io6,12)nse2,nse2x
12          format(/1x,'ERROR in SUBR. RDHDEM2 -- No. emitted species',
     1      ' must match in all PTEMARB files',/1x,
     2      '     No. emitted species expected/found: ',2i5)
            write(*,*)
            stop 'Halted in RDHDEM2 -- see list file.'
         endif
      endif

c --- Pass into /pt2/ names or check for consistency
      if(i.EQ.1) then
         do is=1,nse2
            cslst2(is)=cslst2x(is)
            xmwem2(is)=xmwem2x(is)
         enddo
      else
         lmatch=.TRUE.
         do is=1,nse2
            if(cslst2(is).NE.cslst2x(is)) lmatch=.FALSE.
            if(xmwem2(is).NE.xmwem2x(is)) lmatch=.FALSE.
         enddo
         if(.not.LMATCH) then
            write(io6,15)
15          format(/1x,'ERROR in SUBR. RDHDEM2 -- Species names and',
     &      ' molecular weights must match in all PTEMARB files',/)
            write(io6,*)
            write(io6,*)'PTEMARB.DAT File:    1'
            do is=1,nse2
               write(io6,*) cslst2(is),xmwem2(is)
            enddo
            write(io6,*)
            write(io6,*)'PTEMARB.DAT File:',i
            do is=1,nse2
               write(io6,*) cslst2x(is),xmwem2x(is)
            enddo
            write(*,*)
            stop 'Halted in RDHDEM2 -- see list file.'
         endif
      endif

c --- WRITE CONTENTS OF HEADER RECORDS (if requested)
      if(lprt)then
         write(io6,102) i
102      format(///1x,13('----------')//1x,'Header record data from ',
     1   'the PTEMARB point source file',i5)
         write(io6,103)dataset,ibsrc2(i),iesrc2(i),nse2x,axtz2,
     &         ibdathr2(i),ibsec2(i),iedathr2(i),iesec2(i),pmappt2(i),
     &         datumpt2(i)
103      format(/1x,'DATASET: ',a16/1x,'IBSRC2:  ',i9/
     1   1x,'IESRC2:  ',i9/1x,'NSE2:    ',i6/1x,'AXTZ2:   ',a8/
     2   1x,'IBDATHR2:',i9/1x,'IBSEC2:  ',i4/
     3   1x,'IEDATHR2:',i9/1x,'IESEC2:  ',i4/
     4   1x,'MAP2:    ',a8/1x,'DATUM:   ',a8)

         if(LUTMPT2(i)) write(io6,104) iutmznpt2(i),utmhempt2(i)
         if(LLCCPT2(i)) write(io6,105) clat0,clon0,clat1,clat2,
     &                                 feastpt2(i),fnorthpt2(i)
         if(LPSPT2(i)) write(io6,106) clat0,clon0,clat1
         if(LEMPT2(i)) write(io6,107) clat0,clon0
         if(LLAZAPT2(i).or.LTTMPT2(i)) write(io6,108) clat0,clon0,
     &                                 feastpt2(i),fnorthpt2(i)

104      format(/1x,'UTMZN:   ',i4/1x,'UTMHEM:  ',a4)
105      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16/1x,'Lat2:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)
106      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16)
107      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16)
108      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)

         write(io6,109)
109      format(4x,'SPECIES',6x,'MOL. WT.'/)
         do is=1,nse2
            write(io6,110)cslst2(is),xmwem2(is)
         enddo
110      format(1x,a12,3x,f7.3)
      endif


c --- Initialize "previous" period times for /PT2/
      nstep2(i)=1
      ndhrqb2(1,i)=-000100100
      nsecqb2(1,i)=0
      ndhrqe2(1,i)=ibdathr2(i)
      nsecqe2(1,i)=ibsec2(i)

      return
      end
c----------------------------------------------------------------------
      subroutine RDHDEM3(iunit0,i,lprt,lnar2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                RDHDEM3
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Read the header records from the BAEMARB buoyant area
c               source file (arbitrarily-varying location & emissions)
c
c --- UPDATE
c --- V6.1-V6.22: 070921 (DGS): Condition GEO referencing string
c                               variables and add QA
c                               Remove calls to ALLCAP
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added,
c                               including full coordinate and time
c                               documentation with begin/end times with
c                               seconds.
c                               Header information is passed to scratch
c                               file.
c --- V5.5-V5.7 : 030402 (DGS): CALUTILS version of XTRACTLL
c                               Add list file unit to YR4 call
c --- V5.4-V5.4 : 000602_6(DGS): Change name of LCC longitude from
c                                '-ELON-' to '-WLON-'
c --- V5.2-V5.4 : 000602 (DGS): allow multiple BAEMARB files
c                 000602 (DGS): add message to "stop"
c                 000602 (DGS): add header record for LC map data
c --- V5.0-V5.2 : 991104 (DGS): YYYY format used for year
c --- V4.0-V5.0 : 971107 (DGS): Check for valid version of file
c
c --- INPUTS:
c           IUNIT0 - integer    - Fortran unit number for the FIRST
c                                 BAEMARB file
c                I - integer    - Index for current BAEMARB file
c             LPRT - logical    - Flag controlling printing of header
c                                 record data (F=suppress, T=print)
c            LNAR2 - logical    - Flag indicating all sources found
c
c     Common Block /AR2/ variables:
c            NAR2
c     Common Block /DATASET/ variables:
c            VERAARB(mxemdat)
c     Common Block /DATEHR/ variables:
c            XBTZ
c     Common Block /QA/ variables:
c            NCOMMOUT
c     Parameters:
c            IO6, MXSPEC, MXEMDAT, MXQSTEP, IOX
c
c
c --- OUTPUT:
c
c     Common Block /AR2/ variables:
c           NSE3,
c           IBSRC3(mxemdat),IESRC3(mxemdat),IUEM3(mxemdat),
c           IBDATHR3(mxemdat),IBSEC3(mxemdat),IEDATHR3(mxemdat),
c           IESEC3(mxemdat),XTZ3(mxemdat),T2BTZ3(mxemdat),
c           XMWEM3(mxspec),IXREM3(mxspec),
c           lutmar2(mxemdat),llccar2(mxemdat),lpsar2(mxemdat),
c           lemar2(mxemdat),llazaar2(mxemdat),lttmar2(mxemdat),
c           iutmznar2(mxemdat),feastar2(mxemdat),fnorthar2(mxemdat),
c           rnlat0ar2(mxemdat),relon0ar2(mxemdat),
c           rnlat1ar2(mxemdat),rnlat2ar2(mxemdat),NSTEP3(mxemdat),
c           NDHRQB3(mxqstep,mxemdat),NSECQB3(mxqstep,mxemdat),
c           NDHRQE3(mxqstep,mxemdat),NSECQE3(mxqstep,mxemdat),
c           CSLST3(mxspec),CID3(mxarea),
c           pmapar2(mxemdat),utmhemar2(mxemdat),datumar2(mxemdat),
c           datenar2(mxemdat),xyunitar2(mxemdat)
c
c --- RDHDEM3 called by: SETUP
c --- RDHDEM3 calls:     YR4, XTRACTLL, INCR, TCLOCK, GEOFMT
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'ar2.puf'
      include 'dataset.puf'
      include 'datehr.puf'
      include 'qa.puf'
c
      LOGICAL lprt, lnar2, lmatch

c --- Local variables
      real xmwem3x(mxspec)
      character*8 axtz3
      character*12 fname3,label3(mxemdat)
      character*12 cslst3x(mxspec),vrs3
      character*16 dataset,dataver
      character*16 clat0,clon0,clat1,clat2
      character*33 blank33,break33
      character*64 datamod
      character*132 comment1,blank,break

      data blank33/'                                 '/
      data break33/'.................................'/
      data nlim/1/
      data zero/0.0/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Set break (132 characters)
      break(1:33)=break33
      break(34:66)=break33
      break(67:99)=break33
      break(100:132)=break33

c --- Begin scratch file image
      write(iox,'(a132)') blank
      write(iox,'(a132)') break
      write(iox,'(a132)') blank
      ncommout=ncommout+3

c --- Set unit number
      iunit=iunit0+i-1

c --- Initialize map projection logicals
      lutmar2(i)=.FALSE.
      llccar2(i)=.FALSE.
      lpsar2(i)=.FALSE.
      lemar2(i)=.FALSE.
      llazaar2(i)=.FALSE.
      lttmar2(i)=.FALSE.

c --- Initialize other variables
      datenar2(i)='02-21-2003  '
      xyunitar2(i)='KM  '
      ibsec3(i)=0.0
      iesec3(i)=0.0
      feastar2(i)=0.0
      fnorthar2(i)=0.0
      clat0='0.0N            '
      clon0='0.0W            '
      clat1='0.0N            '
      clat2='0.0N            '
      dataset='                '
      dataver='                '
      pmapar2(i)='XXX     '
      iutmznar2(i)=1
      utmhemar2(i)='N   '
      datumar2(i)='XXX     '
      axtz3='UTC+0000'

c     -----------------------
      if(veraarb(i).EQ.'1.5' .OR.
     &   veraarb(i).EQ.'1.54' .OR.
     &   veraarb(i).EQ.'1.6') then
c     -----------------------

c ---    Provide help and then stop (these formats are not supported)
         dataset='BAEMARB.DAT     '

         if(veraarb(i).EQ.'1.5') then
            read(iunit,*)fname3,nar2file,nse3x,iutmznar2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs3,label3(i)
            dataver='1.5a            '
            datamod(1:40)='Augmented 5 format with Map Projection, '
            datamod(41:64)='DATUM, Time Zone        '

         elseif(veraarb(i).EQ.'1.54') then
            read(iunit,*)fname3,nar2file,nse3x,iutmznar2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs3,label3(i)
            dataver='1.54a           '
            datamod(1:42)='Augmented 5.4 format with Map Projection, '
            datamod(43:64)='DATUM, Time Zone      '

         elseif(veraarb(i).EQ.'1.6') then
            read(iunit,*)fname3,nar2file,nse3x,iuem3(i),iuser1,iuser2,
     &                iutmznar2(i),ibyr,ibdy,ibhr,ibsec3(i),
     &                ieyr,iedy,iehr,iesec3(i),vrs3,label3(i)
            dataver='1.6a            '
            datamod(1:40)='Augmented 6 format with Map Projection, '
            datamod(41:64)='DATUM, Time Zone        '

         endif

         write(io6,*)
         write(io6,*)
         write(io6,*)'ERROR in BAEMARB files'
         write(io6,*)
         write(io6,*)'Old BAEMARB.DAT format cannot be used because:'
         write(io6,*)'1.  Coordinate map projection is incomplete'
         write(io6,*)'2.  The DATUM for the coordinates is missing'
         write(io6,*)'3.  The time zone is missing'
         write(io6,*)
         write(io6,*)'ADD these records to the top of the file:'
         write(io6,*)
         write(io6,'(2a16,a64)') dataset,dataver,datamod
         if(iutmznar2(i).NE.0) then
            write(io6,'(a8)')'UTM     '
            write(io6,'(a8)')'  xxN   '
         else
            write(io6,'(a8)')'LCC     '
            if(veraarb(i).NE.'1.54') then
              write(io6,'(4a16)')'yy.yyyN         ','xx.xxxW         ',
     &                           'yy.yyyN         ','yy.yyyN         '
            endif
            write(io6,*)zero,zero
         endif
         write(io6,'(a8)')'DATUM   '
         write(io6,'(a8)')'UTC-0500'
         write(io6,*)
         write(io6,*)'UPDATE these records to describe your file:'
         if(iutmznar2(i).NE.0) then
           write(io6,*)'- Replace the xxN with your UTM zone and',
     &                 ' hemisphere (S for Southern Hemisphere)'
         else
           if(veraarb(i).NE.'1.54') then
             write(io6,*)'- Replace the xx.xxxW and yy.yyyN with your',
     &                 ' LCC projection parameters.'
             write(io6,*)'  The order is Origin Latitude, Origin',
     &                 ' Longitude, and the 2 Matching Parallels'
             write(io6,*)'  (each field is 16 characters)'
           endif
           write(io6,*)'- Replace the 0.0 0.0 with your False Easting',
     &                 ' and Northing if non-zero'   
         endif
         write(io6,*)'- Replace DATUM with your datum code (enter',
     &               ' left-justified in the 8-character field)'
         write(io6,*)'- Replace UTC-0500 with your time zone code'
         write(io6,*)'  (GMT=UTC+0000, EST=UTC-0500, CET=UTC+0100)'
         write(io6,*)
         write(*,*)
         write(*,*)'ERROR in BAEMARB files -- see list file'
         write(*,*)
         stop

c     ----------------------------
      elseif(veraarb(i).EQ.'1.5a' .OR.
     &       veraarb(i).EQ.'1.54a' .OR.
     &       veraarb(i).EQ.'1.6a') then
c     ----------------------------

c ---    Augmented headers

         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         ncommout=ncommout+1
c ---    Map projection
         read(iunit,'(a8)') pmapar2(i)
         write(iox,'(a8)') pmapar2(i)
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmapar2(i),iutmznar2(i),
     &               utmhemar2(i),clat0,clon0,clat1,clat2,
     &               datumar2(i),datenar2(i),xyunitar2(i),axtz3)

         if(pmapar2(i).EQ.'UTM     ')  lutmar2(i) =.TRUE.
         if(pmapar2(i).EQ.'LCC     ')  llccar2(i) =.TRUE.
         if(pmapar2(i).EQ.'PS      ')  lpsar2(i)  =.TRUE.
         if(pmapar2(i).EQ.'EM      ')  lemar2(i)  =.TRUE.
         if(pmapar2(i).EQ.'LAZA    ')  llazaar2(i)=.TRUE.
         if(pmapar2(i).EQ.'TTM     ')  lttmar2(i) =.TRUE.
c ---    Map projection parameters
         if(LUTMAR2(i)) then
            read(iunit,'(i4,a4)') iutmznar2(i),utmhemar2(i)
            write(iox,'(i4,a4)') iutmznar2(i),utmhemar2(i)
            ncommout=ncommout+1
         elseif(LLCCAR2(i) .AND. veraarb(i).NE.'1.54a') then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCAR2(i)) then
            read(iunit,*) feastar2(i),fnorthar2(i)
            write(iox,*)  feastar2(i),fnorthar2(i)
            ncommout=ncommout+1
         endif
c ---    Map DATUM
         read(iunit,'(a8)') datumar2(i)
         write(iox,'(a8)')  datumar2(i)
         ncommout=ncommout+1
c ---    Time zone
         read(iunit,'(a8)') axtz3
         write(iox,'(a8)')  axtz3
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmapar2(i),iutmznar2(i),
     &               utmhemar2(i),clat0,clon0,clat1,clat2,
     &               datumar2(i),datenar2(i),xyunitar2(i),axtz3)

c ---    Process Time zone
         read(axtz3(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM3 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz3
            stop 'Halted in RDHDEM3 -- see list file'
         endif
         xtz3(i)=-FLOAT(ibtzhh)

c ---    Old Header Record(s)

         if(veraarb(i).EQ.'1.5a') then
            read(iunit,*)fname3,nar2file,nse3x,iutmznar2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs3,label3(i)
            ibyr=ibdat/1000
            ibdy=ibdat-ibyr*1000
            ieyr=iedat/1000
            iedy=iedat-ieyr*1000
            write(iox,'(a12,9i6,2a12)')fname3,nar2file,nse3x,
     &                iutmznar2(i),ibyr,ibdy,ibhr,ieyr,iedy,iehr,
     &                vrs3,label3(i)
            ncommout=ncommout+1
         elseif(veraarb(i).EQ.'1.54a') then
            read(iunit,*)fname3,nar2file,nse3x,iutmznar2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs3,label3(i)
            read(iunit,*) clat1,clat2,clat0,clon0
            ibyr=ibdat/1000
            ibdy=ibdat-ibyr*1000
            ieyr=iedat/1000
            iedy=iedat-ieyr*1000
            write(iox,'(a12,9i6,2a12)')fname3,nar2file,nse3x,
     &                iutmznar2(i),ibyr,ibdy,ibhr,ieyr,iedy,iehr,
     &                vrs3,label3(i)
            write(iox,'(4a16)') clat1,clat2,clat0,clon0
            ncommout=ncommout+2
         elseif(veraarb(i).EQ.'1.6a') then
            read(iunit,*)fname3,nar2file,nse3x,iuem3(i),iuser1,iuser2,
     &                iutmznar2(i),ibyr,ibdy,ibhr,ibsec3(i),
     &                ieyr,iedy,iehr,iesec3(i),vrs3,label3(i)
            write(iox,'(a12,14i6,2a12)')fname3,nar2file,nse3x,iuem3(i),
     &                iuser1,iuser2,iutmznar2(i),ibyr,ibdy,ibhr,
     &                ibsec3(i),ieyr,iedy,iehr,iesec3(i),vrs3,label3(i)
            ncommout=ncommout+1
         endif

c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) then
            write(*,*)
            stop 'Halted in RDHDEM3'
         endif

c ---    Species list
         read(iunit,*)(cslst3x(n),n=1,nse3x)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem3x(n),n=1,nse3x)

c     ---------------------------
      elseif(veraarb(i).EQ.'2.1') then
c     ---------------------------

c ---    First record and comments
         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         read(iunit,*) ncom
         write(iox,*) ncom
         do k=1,ncom
            comment1=blank
            read(iunit,'(a132)') comment1
            write(iox,'(a132)') comment1
         enddo
         ncommout=ncommout+2+ncom

c ---    Map projection
         read(iunit,'(a8)') pmapar2(i)
         write(iox,'(a8)') pmapar2(i)
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmapar2(i),iutmznar2(i),
     &               utmhemar2(i),clat0,clon0,clat1,clat2,
     &               datumar2(i),datenar2(i),xyunitar2(i),axtz3)

         if(pmapar2(i).EQ.'UTM     ')  lutmar2(i) =.TRUE.
         if(pmapar2(i).EQ.'LCC     ')  llccar2(i) =.TRUE.
         if(pmapar2(i).EQ.'PS      ')  lpsar2(i)  =.TRUE.
         if(pmapar2(i).EQ.'EM      ')  lemar2(i)  =.TRUE.
         if(pmapar2(i).EQ.'LAZA    ')  llazaar2(i)=.TRUE.
         if(pmapar2(i).EQ.'TTM     ')  lttmar2(i) =.TRUE.

c ---    Map projection parameters
         if(LUTMAR2(i)) then
            read(iunit,'(i4,a4)') iutmznar2(i),utmhemar2(i)
            write(iox,'(i4,a4)') iutmznar2(i),utmhemar2(i)
            ncommout=ncommout+1
         elseif(LLCCAR2(i)) then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         elseif(LPSAR2(i)) then
            read(iunit,'(3a16)') clat0,clon0,clat1
            write(iox,'(3a16)')  clat0,clon0,clat1
            ncommout=ncommout+1
         elseif(LEMAR2(i).or.LLAZAAR2(i).or.LTTMAR2(i)) then
            read(iunit,'(2a16)') clat0,clon0
            write(iox,'(2a16)')  clat0,clon0
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCAR2(i).or.LLAZAAR2(i).or.LTTMAR2(i)) then
            read(iunit,*) feastar2(i),fnorthar2(i)
            write(iox,*)  feastar2(i),fnorthar2(i)
            ncommout=ncommout+1
         else
            feastar2(i)=0.0
            fnorthar2(i)=0.0
         endif

c ---    Map DATUM
         read(iunit,'(a8,a12)') datumar2(i),datenar2(i)
         write(iox,'(a8,a12)')  datumar2(i),datenar2(i)
         ncommout=ncommout+1

c ---    Map units
         read(iunit,'(a4)') xyunitar2(i)
         write(iox,'(a4)')  xyunitar2(i)
         ncommout=ncommout+1

c ---    Time zone
         read(iunit,'(a8)') axtz3
         write(iox,'(a8)')  axtz3
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmapar2(i),iutmznar2(i),
     &               utmhemar2(i),clat0,clon0,clat1,clat2,
     &               datumar2(i),datenar2(i),xyunitar2(i),axtz3)

c ---    Process Time zone
         read(axtz3(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM3 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz3
            stop 'Halted in RDHDEM3 -- see list file'
         endif
         xtz3(i)=-FLOAT(ibtzhh)

c ---    Time period
         read(iunit,*)ibyr,ibdy,ibhr,ibsec3(i),
     &                ieyr,iedy,iehr,iesec3(i)
c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDHDEM3'
         write(iox,'(9i6)')ibyr,ibdy,ibhr,ibsec3(i),
     &                     ieyr,iedy,iehr,iesec3(i)
         ncommout=ncommout+1

c ---    Number of sources and species
         read(iunit,*) nar2file,nse3x
         write(iox,*) nar2file,nse3x
         ncommout=ncommout+1

c ---    Species list
         read(iunit,*)(cslst3x(n),n=1,nse3x)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem3x(n),n=1,nse3x)

c     -----
      else
c     -----

         write(*,*)'ERROR in BAEMARB File: ',i
         write(*,*)'Bad Dataset Version: ',veraarb(i)
         write(*,*)'Expected 1.5, 1.5a, 1.54, 1.54a, 1.6, 1.6a, 2.1'
         stop

c     -----
      endif
c     -----

c --- Species info to scratch file
      do n=1,nse3x
         write(iox,'(a16,f12.4)')cslst3x(n),xmwem3x(n)
      enddo
      ncommout=ncommout+nse3x

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibsec3(i))
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iesec3(i))

c --- Apply time zone adjustment to date/times
      if(xtz3(i).GE.-13 .AND. xtz3(i).LE.13) then
         t2btz3(i)=xtz3(i)-xbtz
         ishift=NINT(t2btz3(i))
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
         call INCR(io6,ieyr,iedy,iehr,ishift)
      else
         write(io6,*)
         write(io6,*)'ERROR in BAEMARB.DAT file : Bad Time Zone'
         write(io6,*)'Expected zone between -13 and 13'
         write(io6,*)'Found zone = ',xtz3(i)
         stop 'Bad Time Zone in BAEMARB.DAT file -- see list file'
      endif

c --- Hourly Data:  Move the time for the first period from the end
c ---               to the start of the first hour
      if(veraarb(i).EQ.'1.5a' .OR. veraarb(i).EQ.'1.54a') then
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      endif

c --- Form date-hr variables for /AR2/
      ibdathr3(i)=ibyr*100000+ibdy*100+ibhr
      iedathr3(i)=ieyr*100000+iedy*100+iehr

c --- Process lat/lon character variables to extract content
      call XTRACTLL(io6,'LAT ',clat1,rnlat1ar2(i))
      call XTRACTLL(io6,'LAT ',clat2,rnlat2ar2(i))
      call XTRACTLL(io6,'LAT ',clat0,rnlat0ar2(i))
      call XTRACTLL(io6,'LON ',clon0,relon0ar2(i))

c --- Set source index range for this file
      if(i.EQ.1) then
         ibsrc3(i)=1
         iesrc3(i)=nar2file
      else
         ibsrc3(i)=iesrc3(i-1)+1
         iesrc3(i)=iesrc3(i-1)+nar2file
      endif
c --- Set logical to indicate if the number of sources specified in
c --- the control file (NAR2) have been found
      lnar2=.FALSE.
      if(nar2.EQ.iesrc3(i)) lnar2=.TRUE.

c --- Process data that must be identical in all BAEMARB.DAT files
      if(i.EQ.1) then
c ---    Pass into /ar2/ names
         nse3=nse3x
c
         if(nse3.gt.mxspec)then
            write(io6,11)nse3,mxspec
11          format(/1x,'ERROR in SUBR. RDHDEM3 -- No. emitted species',
     1      ' in BAEMARB file is greater than current array',
     2      ' dimension'/1x,
     3      '     No. emitted species in file: ',i5/1x,
     4      'Current Array dimension (MXSPEC): ',i5)
            write(*,*)
            stop 'Halted in RDHDEM3 -- see list file.'
         endif
      else
c ---    Check for consistency with first file
         if(nse3.NE.nse3x) then
            write(io6,12)nse3,nse3x
12          format(/1x,'ERROR in SUBR. RDHDEM3 -- No. emitted species',
     1      ' must match in all BAEMARB files',/1x,
     2      '     No. emitted species expected/found: ',2i5)
            write(*,*)
            stop 'Halted in RDHDEM3 -- see list file.'
         endif
      endif

c --- Pass into /ar2/ names or check for consistency
      if(i.EQ.1) then
         do is=1,nse3
            cslst3(is)=cslst3x(is)
            xmwem3(is)=xmwem3x(is)
         enddo
      else
         lmatch=.TRUE.
         do is=1,nse3
            if(cslst3(is).NE.cslst3x(is)) lmatch=.FALSE.
            if(xmwem3(is).NE.xmwem3x(is)) lmatch=.FALSE.
         enddo
         if(.not.LMATCH) then
            write(io6,15)
15          format(/1x,'ERROR in SUBR. RDHDEM3 -- Species names and',
     &      ' molecular weights must match in all BAEMARB files',/)
            write(io6,*)
            write(io6,*)'BAEMARB.DAT File:    1'
            do is=1,nse3
               write(io6,*) cslst3(is),xmwem3(is)
            enddo
            write(io6,*)
            write(io6,*)'BAEMARB.DAT File:',i
            do is=1,nse3
               write(io6,*) cslst3x(is),xmwem3x(is)
            enddo
            write(*,*)
            stop 'Halted in RDHDEM3 -- see list file.'
         endif
      endif

c --- WRITE CONTENTS OF HEADER RECORDS (if requested)
      if(lprt)then
         write(io6,102) i
102      format(///1x,13('----------')//1x,'Header record data from ',
     1   'the BAEMARB area source file',i5)
         write(io6,103)dataset,ibsrc3(i),iesrc3(i),nse3x,axtz3,
     &         ibdathr3(i),ibsec3(i),iedathr3(i),iesec3(i),pmapar2(i),
     &         datumar2(i)
103      format(/1x,'DATASET: ',a16/1x,'IBSRC3:  ',i9/
     1   1x,'IESRC3:  ',i9/1x,'NSE3:    ',i6/1x,'AXTZ3:   ',a8/
     2   1x,'IBDATHR3:',i9/1x,'IBSEC3:  ',i4/
     3   1x,'IEDATHR3:',i9/1x,'IETIM3:  ',i4/
     4   1x,'MAP3:    ',a8/1x,'DATUM:   ',a8)

         if(LUTMAR2(i)) write(io6,104) iutmznar2(i),utmhemar2(i)
         if(LLCCAR2(i)) write(io6,105) clat0,clon0,clat1,clat2,
     &                                 feastar2(i),fnorthar2(i)
         if(LPSAR2(i)) write(io6,106) clat0,clon0,clat1
         if(LEMAR2(i)) write(io6,107) clat0,clon0
         if(LLAZAAR2(i).or.LTTMAR2(i)) write(io6,108) clat0,clon0,
     &                                 feastar2(i),fnorthar2(i)

104      format(/1x,'UTMZN:   ',i4/1x,'UTMHEM:  ',a4)
105      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16/1x,'Lat2:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)
106      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16)
107      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16)
108      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)

         write(io6,109)
109      format(4x,'SPECIES',6x,'MOL. WT.'/)
         do is=1,nse3
            write(io6,110)cslst3(is),xmwem3(is)
         enddo
110      format(1x,a12,3x,f7.3)
      endif


c --- Initialize "previous" period times for /AR2/
      nstep3(i)=1
      ndhrqb3(1,i)=-000100100
      nsecqb3(1,i)=0
      ndhrqe3(1,i)=ibdathr3(i)
      nsecqe3(1,i)=ibsec3(i)

      return
      end
c----------------------------------------------------------------------
      subroutine RDHDEM4(iunit0,i,lprt,lnvl2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                RDHDEM4
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Read the header records from the VOLEMARB volume source
c               variable emissions file
c
c --- UPDATE
c --- V6.1-V6.22: 070921 (DGS): Condition GEO referencing string
c                               variables and add QA
c                               Remove calls to ALLCAP
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added,
c                               including full coordinate and time
c                               documentation with begin/end times with
c                               seconds.
c                               Header information is passed to scratch
c                               file.
c                               VOLEMARB.DAT file must be ASCII.
c --- V5.5-V5.7 : 030402 (DGS): CALUTILS version of XTRACTLL
c                               Add list file unit to YR4 call
c --- V5.4-V5.4 : 000602_6(DGS): Change name of LCC longitude from
c                                '-ELON-' to '-WLON-'
c --- V5.2-V5.4 : 000602 (DGS): update from VOLEM.DAT to VOLEMARB.DAT
c                               with multiple files
c                 000602 (DGS): add header record for LC map data
c                 000602 (DGS): add message to "stop"
c --- V5.0-V5.2 : 991104 (DGS): YYYY format used for year
c --- V4.0-V5.0 : 980807 (DGS): VOLEM.DAT either binary or ASCII
c
c --- INPUTS:
c           IUNIT0 - integer    - Fortran unit number for the FIRST
c                                 VOLEMARB file
c                I - integer    - Index for current VOLEMARB file
c             LPRT - logical    - Flag controlling printing of header
c                                 record data (F=suppress, T=print)
c            LNVL2 - logical    - Flag indicating all sources found
c
c     Common Block /VOL2/ variables:
c            NVL2
c     Common Block /DATASET/ variables:
c            VERVARB(mxemdat)
c     Common Block /DATEHR/ variables:
c            XBTZ
c     Common Block /QA/ variables:
c            NCOMMOUT
c     Parameters:
c            IO6, MXSPEC, MXEMDAT, MXQSTEP, MXVOL,  IOX
c
c
c --- OUTPUT:
c
c     Common Block /VOL2/ variables:
c           NSE4,
c           IBSRC4(mxemdat),IESRC4(mxemdat),
c           IBDATHR4(mxemdat),IBSEC4(mxemdat),IEDATHR4(mxemdat),
c           IESEC4(mxemdat),XTZ4(mxemdat),T2BTZ4(mxemdat),
c           XMWEM4(mxspec),IXREM4(mxspec),
c           lutmvl2(mxemdat),llccvl2(mxemdat),lpsvl2(mxemdat),
c           lemvl2(mxemdat),llazavl2(mxemdat),lttmvl2(mxemdat),
c           iutmznvl2(mxemdat),feastvl2(mxemdat),fnorthvl2(mxemdat),
c           rnlat0vl2(mxemdat),relon0vl2(mxemdat),
c           rnlat1vl2(mxemdat),rnlat2vl2(mxemdat),NSTEP4(mxemdat),
c           NDHRQB4(mxqstep,mxemdat),NSECQB4(mxqstep,mxemdat),
c           NDHRQE4(mxqstep,mxemdat),NSECQE4(mxqstep,mxemdat),
c           CSLST4(mxspec),CID4(mxvol),
c           pmapvl2(mxemdat),utmhemvl2(mxemdat),datumvl2(mxemdat),
c           datenvl2(mxemdat),xyunitvl2(mxemdat)
c
c --- RDHDEM4 called by: SETUP
c --- RDHDEM4 calls:     YR4, XTRACTLL, INCR, TCLOCK, GEOFMT
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'vol2.puf'
      include 'dataset.puf'
      include 'datehr.puf'
      include 'qa.puf'
c
      LOGICAL lprt, lnvl2, lmatch

c --- Local variables
      real xmwem4x(mxspec)
      character*8 axtz4
      character*12 fname4,label4(mxemdat)
      character*12 cslst4x(mxspec),vrs4
      character*16 dataset,dataver
      character*16 clat0,clon0,clat1,clat2
      character*33 blank33,break33
      character*64 datamod
      character*132 comment1,blank,break

      data blank33/'                                 '/
      data break33/'.................................'/
      data nlim/1/
      data zero/0.0/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Set break (132 characters)
      break(1:33)=break33
      break(34:66)=break33
      break(67:99)=break33
      break(100:132)=break33

c --- Begin scratch file image
      write(iox,'(a132)') blank
      write(iox,'(a132)') break
      write(iox,'(a132)') blank
      ncommout=ncommout+3

c --- Set unit number
      iunit=iunit0+i-1

c --- Initialize map projection logicals
      lutmvl2(i)=.FALSE.
      llccvl2(i)=.FALSE.
      lpsvl2(i)=.FALSE.
      lemvl2(i)=.FALSE.
      llazavl2(i)=.FALSE.
      lttmvl2(i)=.FALSE.

c --- Initialize other variables
      datenvl2(i)='02-21-2003  '
      xyunitvl2(i)='KM  '
      ibsec4(i)=0.0
      iesec4(i)=0.0
      feastvl2(i)=0.0
      fnorthvl2(i)=0.0
      clat0='0.0N            '
      clon0='0.0W            '
      clat1='0.0N            '
      clat2='0.0N            '
      dataset='                '
      dataver='                '
      pmapvl2(i)='XXX     '
      iutmznvl2(i)=1
      utmhemvl2(i)='N   '
      datumvl2(i)='XXX     '
      axtz4='UTC+0000'

c     -----------------------
      if(vervarb(i).EQ.'1.54' .OR.
     &   vervarb(i).EQ.'1.6') then
c     -----------------------

c ---    Provide help and then stop (these formats are not supported)
         dataset='VOLEMARB.DAT    '

         if(vervarb(i).EQ.'1.54') then
            read(iunit,*)fname4,nvl2file,nse4x,iutmznvl2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs4,label4(i)
            dataver='1.54a           '
            datamod(1:42)='Augmented 5.4 format with Map Projection, '
            datamod(43:64)='DATUM, Time Zone      '

         elseif(vervarb(i).EQ.'1.6') then
            read(iunit,*)fname4,nvl2file,nse4x,iutmznvl2(i),
     &                ibyr,ibdy,ibhr,ibsec4(i),
     &                ieyr,iedy,iehr,iesec4(i),vrs4,label4(i)
            dataver='1.6a            '
            datamod(1:40)='Augmented 6 format with Map Projection, '
            datamod(41:64)='DATUM, Time Zone        '

         endif

         write(io6,*)
         write(io6,*)
         write(io6,*)'ERROR in VOLEMARB files'
         write(io6,*)
         write(io6,*)'Old VOLEMARB.DAT format cannot be used because:'
         write(io6,*)'1.  Coordinate map projection is incomplete'
         write(io6,*)'2.  The DATUM for the coordinates is missing'
         write(io6,*)'3.  The time zone is missing'
         write(io6,*)
         write(io6,*)'ADD these records to the top of the file:'
         write(io6,*)
         write(io6,'(2a16,a64)') dataset,dataver,datamod
         if(iutmznvl2(i).NE.0) then
            write(io6,'(a8)')'UTM     '
            write(io6,'(a8)')'  xxN   '
         else
            write(io6,'(a8)')'LCC     '
            if(vervarb(i).NE.'1.54') then
              write(io6,'(4a16)')'yy.yyyN         ','xx.xxxW         ',
     &                           'yy.yyyN         ','yy.yyyN         '
            endif
            write(io6,*)zero,zero
         endif
         write(io6,'(a8)')'DATUM   '
         write(io6,'(a8)')'UTC-0500'
         write(io6,*)
         write(io6,*)'UPDATE these records to describe your file:'
         if(iutmznvl2(i).NE.0) then
           write(io6,*)'- Replace the xxN with your UTM zone and',
     &                 ' hemisphere (S for Southern Hemisphere)'
         else
           if(vervarb(i).NE.'1.54') then
             write(io6,*)'- Replace the xx.xxxW and yy.yyyN with your',
     &                 ' LCC projection parameters.'
             write(io6,*)'  The order is Origin Latitude, Origin',
     &                 ' Longitude, and the 2 Matching Parallels'
             write(io6,*)'  (each field is 16 characters)'
           endif
           write(io6,*)'- Replace the 0.0 0.0 with your False Easting',
     &                 ' and Northing if non-zero'   
         endif
         write(io6,*)'- Replace DATUM with your datum code (enter',
     &               ' left-justified in the 8-character field)'
         write(io6,*)'- Replace UTC-0500 with your time zone code'
         write(io6,*)'  (GMT=UTC+0000, EST=UTC-0500, CET=UTC+0100)'
         write(io6,*)
         write(*,*)
         write(*,*)'ERROR in VOLEMARB files -- see list file'
         write(*,*)
         stop

c     ----------------------------
      elseif(vervarb(i).EQ.'1.54a' .OR.
     &       vervarb(i).EQ.'1.6a') then
c     ----------------------------

c ---    Augmented headers

         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         ncommout=ncommout+1
c ---    Map projection
         read(iunit,'(a8)') pmapvl2(i)
         write(iox,'(a8)') pmapvl2(i)
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmapvl2(i),iutmznvl2(i),
     &               utmhemvl2(i),clat0,clon0,clat1,clat2,
     &               datumvl2(i),datenvl2(i),xyunitvl2(i),axtz4)

         if(pmapvl2(i).EQ.'UTM     ')  lutmvl2(i) =.TRUE.
         if(pmapvl2(i).EQ.'LCC     ')  llccvl2(i) =.TRUE.
         if(pmapvl2(i).EQ.'PS      ')  lpsvl2(i)  =.TRUE.
         if(pmapvl2(i).EQ.'EM      ')  lemvl2(i)  =.TRUE.
         if(pmapvl2(i).EQ.'LAZA    ')  llazavl2(i)=.TRUE.
         if(pmapvl2(i).EQ.'TTM     ')  lttmvl2(i) =.TRUE.
c ---    Map projection parameters
         if(LUTMVL2(i)) then
            read(iunit,'(i4,a4)') iutmznvl2(i),utmhemvl2(i)
            write(iox,'(i4,a4)') iutmznvl2(i),utmhemvl2(i)
            ncommout=ncommout+1
         elseif(LLCCVL2(i) .AND. vervarb(i).NE.'1.54a') then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCVL2(i)) then
            read(iunit,*) feastvl2(i),fnorthvl2(i)
            write(iox,*)  feastvl2(i),fnorthvl2(i)
            ncommout=ncommout+1
         endif
c ---    Map DATUM
         read(iunit,'(a8)') datumvl2(i)
         write(iox,'(a8)')  datumvl2(i)
         ncommout=ncommout+1
c ---    Time zone
         read(iunit,'(a8)') axtz4
         write(iox,'(a8)')  axtz4
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmapvl2(i),iutmznvl2(i),
     &               utmhemvl2(i),clat0,clon0,clat1,clat2,
     &               datumvl2(i),datenvl2(i),xyunitvl2(i),axtz4)

c ---    Process Time zone
         read(axtz4(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM4 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz4
            stop 'Halted in RDHDEM4 -- see list file'
         endif
         xtz4(i)=-FLOAT(ibtzhh)

c ---    Old Header Record(s)

         if(vervarb(i).EQ.'1.54a') then
            read(iunit,*)fname4,nvl2file,nse4x,iutmznvl2(i),
     &                ibdat,ibhr,iedat,iehr,
     &                vrs4,label4(i)
            read(iunit,*) clat1,clat2,clat0,clon0
            ibyr=ibdat/1000
            ibdy=ibdat-ibyr*1000
            ieyr=iedat/1000
            iedy=iedat-ieyr*1000
            write(iox,'(a12,9i6,2a12)')fname4,nvl2file,nse4x,
     &                iutmznvl2(i),ibyr,ibdy,ibhr,ieyr,iedy,iehr,
     &                vrs4,label4(i)
            write(iox,'(4a16)') clat1,clat2,clat0,clon0
            ncommout=ncommout+2
         elseif(vervarb(i).EQ.'1.6a') then
            read(iunit,*)fname4,nvl2file,nse4x,iutmznvl2(i),
     &                ibyr,ibdy,ibhr,ibsec4(i),
     &                ieyr,iedy,iehr,iesec4(i),vrs4,label4(i)
            write(iox,'(a12,11i6,2a12)')fname4,nvl2file,nse4x,
     &                iutmznvl2(i),ibyr,ibdy,ibhr,ibsec4(i),
     &                ieyr,iedy,iehr,iesec4(i),vrs4,label4(i)
            ncommout=ncommout+1
         endif

c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) then
            write(*,*)
            stop 'Halted in RDHDEM4'
         endif

c ---    Species list
         read(iunit,*)(cslst4x(n),n=1,nse4x)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem4x(n),n=1,nse4x)

c     ---------------------------
      elseif(vervarb(i).EQ.'2.1') then
c     ---------------------------

c ---    First record and comments
         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         read(iunit,*) ncom
         write(iox,*) ncom
         do k=1,ncom
            comment1=blank
            read(iunit,'(a132)') comment1
            write(iox,'(a132)') comment1
         enddo
         ncommout=ncommout+2+ncom

c ---    Map projection
         read(iunit,'(a8)') pmapvl2(i)
         write(iox,'(a8)') pmapvl2(i)
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmapvl2(i),iutmznvl2(i),
     &               utmhemvl2(i),clat0,clon0,clat1,clat2,
     &               datumvl2(i),datenvl2(i),xyunitvl2(i),axtz4)

         if(pmapvl2(i).EQ.'UTM     ')  lutmvl2(i) =.TRUE.
         if(pmapvl2(i).EQ.'LCC     ')  llccvl2(i) =.TRUE.
         if(pmapvl2(i).EQ.'PS      ')  lpsvl2(i)  =.TRUE.
         if(pmapvl2(i).EQ.'EM      ')  lemvl2(i)  =.TRUE.
         if(pmapvl2(i).EQ.'LAZA    ')  llazavl2(i)=.TRUE.
         if(pmapvl2(i).EQ.'TTM     ')  lttmvl2(i) =.TRUE.

c ---    Map projection parameters
         if(LUTMVL2(i)) then
            read(iunit,'(i4,a4)') iutmznvl2(i),utmhemvl2(i)
            write(iox,'(i4,a4)') iutmznvl2(i),utmhemvl2(i)
            ncommout=ncommout+1
         elseif(LLCCVL2(i)) then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         elseif(LPSVL2(i)) then
            read(iunit,'(3a16)') clat0,clon0,clat1
            write(iox,'(3a16)')  clat0,clon0,clat1
            ncommout=ncommout+1
         elseif(LEMVL2(i).or.LLAZAVL2(i).or.LTTMVL2(i)) then
            read(iunit,'(2a16)') clat0,clon0
            write(iox,'(2a16)')  clat0,clon0
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCVL2(i).or.LLAZAVL2(i).or.LTTMVL2(i)) then
            read(iunit,*) feastvl2(i),fnorthvl2(i)
            write(iox,*)  feastvl2(i),fnorthvl2(i)
            ncommout=ncommout+1
         else
            feastvl2(i)=0.0
            fnorthvl2(i)=0.0
         endif

c ---    Map DATUM
         read(iunit,'(a8,a12)') datumvl2(i),datenvl2(i)
         write(iox,'(a8,a12)')  datumvl2(i),datenvl2(i)
         ncommout=ncommout+1

c ---    Map units
         read(iunit,'(a4)') xyunitvl2(i)
         write(iox,'(a4)')  xyunitvl2(i)
         ncommout=ncommout+1

c ---    Time zone
         read(iunit,'(a8)') axtz4
         write(iox,'(a8)')  axtz4
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmapvl2(i),iutmznvl2(i),
     &               utmhemvl2(i),clat0,clon0,clat1,clat2,
     &               datumvl2(i),datenvl2(i),xyunitvl2(i),axtz4)

c ---    Process Time zone
         read(axtz4(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM4 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz4
            stop 'Halted in RDHDEM4 -- see list file'
         endif
         xtz4(i)=-FLOAT(ibtzhh)

c ---    Time period
         read(iunit,*)ibyr,ibdy,ibhr,ibsec4(i),
     &                ieyr,iedy,iehr,iesec4(i)
c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDHDEM4'
         write(iox,'(9i6)')ibyr,ibdy,ibhr,ibsec4(i),
     &                     ieyr,iedy,iehr,iesec4(i)
         ncommout=ncommout+1

c ---    Number of sources and species
         read(iunit,*) nvl2file,nse4x
         write(iox,*) nvl2file,nse4x
         ncommout=ncommout+1

c ---    Species list
         read(iunit,*)(cslst4x(n),n=1,nse4x)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem4x(n),n=1,nse4x)

c     -----
      else
c     -----

         write(*,*)'ERROR in VOLEMARB File: ',i
         write(*,*)'Bad Dataset Version: ',vervarb(i)
         write(*,*)'Expected 1.54, 1.54a, 1.6, 1.6a, 2.1'
         stop

c     -----
      endif
c     -----

c --- Species info to scratch file
      do n=1,nse4x
         write(iox,'(a16,f12.4)')cslst4x(n),xmwem4x(n)
      enddo
      ncommout=ncommout+nse4x

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibsec4(i))
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iesec4(i))

c --- Apply time zone adjustment to date/times
      if(xtz4(i).GE.-13 .AND. xtz4(i).LE.13) then
         t2btz4(i)=xtz4(i)-xbtz
         ishift=NINT(t2btz4(i))
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
         call INCR(io6,ieyr,iedy,iehr,ishift)
      else
         write(io6,*)
         write(io6,*)'ERROR in VOLEMARB.DAT file : Bad Time Zone'
         write(io6,*)'Expected zone between -13 and 13'
         write(io6,*)'Found zone = ',xtz4(i)
         stop 'Bad Time Zone in VOLEMARB.DAT file -- see list file'
      endif

c --- Hourly Data:  Move the time for the first period from the end
c ---               to the start of the first hour
      if(vervarb(i).EQ.'1.54a') then
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      endif

c --- Form date-hr variables for /VOL2/
      ibdathr4(i)=ibyr*100000+ibdy*100+ibhr
      iedathr4(i)=ieyr*100000+iedy*100+iehr

c --- Process lat/lon character variables to extract content
      call XTRACTLL(io6,'LAT ',clat1,rnlat1vl2(i))
      call XTRACTLL(io6,'LAT ',clat2,rnlat2vl2(i))
      call XTRACTLL(io6,'LAT ',clat0,rnlat0vl2(i))
      call XTRACTLL(io6,'LON ',clon0,relon0vl2(i))

c --- Set source index range for this file
      if(i.EQ.1) then
         ibsrc4(i)=1
         iesrc4(i)=nvl2file
      else
         ibsrc4(i)=iesrc4(i-1)+1
         iesrc4(i)=iesrc4(i-1)+nvl2file
      endif
c --- Set logical to indicate if the number of sources specified in
c --- the control file (Nvl2) have been found
      lnvl2=.FALSE.
      if(nvl2.EQ.iesrc4(i)) lnvl2=.TRUE.

c --- Process data that must be identical in all VOLEMARB.DAT files
      if(i.EQ.1) then
c ---    Pass into /VOL2/ names
         nse4=nse4x
c
         if(nse4.gt.mxspec)then
            write(io6,11)nse4,mxspec
11          format(/1x,'ERROR in SUBR. RDHDEM4 -- No. emitted species',
     1      ' in VOLEMARB file is greater than current array',
     2      ' dimension'/1x,
     3      '     No. emitted species in file: ',i5/1x,
     4      'Current Array dimension (MXSPEC): ',i5)
            write(*,*)
            stop 'Halted in RDHDEM4 -- see list file.'
         endif
      else
c ---    Check for consistency with first file
         if(nse4.NE.nse4x) then
            write(io6,12)nse4,nse4x
12          format(/1x,'ERROR in SUBR. RDHDEM4 -- No. emitted species',
     1      ' must match in all VOLEMARB files',/1x,
     2      '     No. emitted species expected/found: ',2i5)
            write(*,*)
            stop 'Halted in RDHDEM4 -- see list file.'
         endif
      endif

c --- Pass into /VOL2/ names or check for consistency
      if(i.EQ.1) then
         do is=1,nse4
            cslst4(is)=cslst4x(is)
            xmwem4(is)=xmwem4x(is)
         enddo
      else
         lmatch=.TRUE.
         do is=1,nse4
            if(cslst4(is).NE.cslst4x(is)) lmatch=.FALSE.
            if(xmwem4(is).NE.xmwem4x(is)) lmatch=.FALSE.
         enddo
         if(.not.LMATCH) then
            write(io6,15)
15          format(/1x,'ERROR in SUBR. RDHDEM4 -- Species names and',
     &      ' molecular weights must match in all VOLEMARB files',/)
            write(io6,*)
            write(io6,*)'VOLEMARB.DAT File:    1'
            do is=1,nse4
               write(io6,*) cslst4(is),xmwem4(is)
            enddo
            write(io6,*)
            write(io6,*)'VOLEMARB.DAT File:',i
            do is=1,nse4
               write(io6,*) cslst4x(is),xmwem4x(is)
            enddo
            write(*,*)
            stop 'Halted in RDHDEM4 -- see list file.'
         endif
      endif

c --- WRITE CONTENTS OF HEADER RECORDS (if requested)
      if(lprt)then
         write(io6,102) i
102      format(///1x,13('----------')//1x,'Header record data from ',
     1   'the VOLEMARB volume source file',i5)
         write(io6,103)dataset,ibsrc4(i),iesrc4(i),nse4x,axtz4,
     &         ibdathr4(i),ibsec4(i),iedathr4(i),iesec4(i),pmapvl2(i),
     &         datumvl2(i)
103      format(/1x,'DATASET: ',a16/1x,'IBSRC4:  ',i9/
     1   1x,'IESRC4:  ',i9/1x,'NSE4:    ',i6/1x,'AXTZ4:   ',a8/
     2   1x,'IBDATHR4:',i9/1x,'IBSEC4:  ',i4/
     3   1x,'IEDATHR4:',i9/1x,'IESEC4:  ',i4/
     4   1x,'MAP4:    ',a8/1x,'DATUM:   ',a8)

         if(LUTMVL2(i)) write(io6,104) iutmznvl2(i),utmhemvl2(i)
         if(LLCCVL2(i)) write(io6,105) clat0,clon0,clat1,clat2,
     &                                 feastvl2(i),fnorthvl2(i)
         if(LPSVL2(i)) write(io6,106) clat0,clon0,clat1
         if(LEMVL2(i)) write(io6,107) clat0,clon0
         if(LLAZAVL2(i).or.LTTMVL2(i)) write(io6,108) clat0,clon0,
     &                                 feastvl2(i),fnorthvl2(i)

104      format(/1x,'UTMZN:   ',i4/1x,'UTMHEM:  ',a4)
105      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16/1x,'Lat2:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)
106      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16)
107      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16)
108      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)

         write(io6,109)
109      format(4x,'SPECIES',6x,'MOL. WT.'/)
         do is=1,nse4
            write(io6,110)cslst4(is),xmwem4(is)
         enddo
110      format(1x,a12,3x,f7.3)
      endif


c --- Initialize "previous" period times for /VOL2/
      nstep4(i)=1
      ndhrqb4(1,i)=-000100100
      nsecqb4(1,i)=0
      ndhrqe4(1,i)=ibdathr4(i)
      nsecqe4(1,i)=ibsec4(i)

      return
      end

c----------------------------------------------------------------------
      subroutine RDHDEM5(iunit,lprt)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                RDHDEM5
c                J. Scire
c
c --- PURPOSE:  Read the header records from the LNEMARB line source
c               emissions file (arbitrarily-varying emissions)
c
c --- UPDATE:
c --- V6.1-V6.22: 070921 (DGS): Condition GEO referencing string
c                               variables and add QA
c                               Remove calls to ALLCAP
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added,
c                               including full coordinate and time
c                               documentation with begin/end times with
c                               seconds.
c                               Header information is passed to scratch
c                               file.
c                               LNEMARB.DAT file must be ASCII.
c --- V5.5-V5.7 : 030402 (DGS): CALUTILS version of XTRACTLL
c                               Add list file unit to YR4 call
c --- V5.4-V5.4 : 000602_6(DGS): Change name of LCC longitude from
c                                '-ELON-' to '-WLON-'
c --- V5.2-V5.4 : 000602 (DGS): add header record for LC map data
c                 000602 (DGS): add message to "stop"
c --- V5.0-V5.2 : 991104 (DGS): YYYY format used for year
c
c --- INPUTS:
c            IUNIT - integer    - Fortran unit number of LNEMARB file
c             LPRT - logical    - Flag controlling printing of header
c                                 record data (F=suppress, T=print)
c     Common Block /LN2/ variables:
c            NLN2
c     Common Block /DATASET/ variables:
c            VERLARB
c     Common Block /DATEHR/ variables:
c            XBTZ
c     Common Block /QA/ variables:
c            NCOMMOUT
c   Parameters:
c            IO6, MXSPEC
c
c
c --- OUTPUT:
c
c     Common Block /LN2/ variables:
c            NSE5,IBDATHR5,IBSEC5,IEDATHR5,IESEC5,XTZ5,T2BTZ5,
c            lutmln2,llccln2,lpsln2,lemln2,llazaln2,lttmln2,
c            iutmznln2,feastln2,fnorthln2,rnlat0ln2,relon0ln2,
c            rnlat1ln2,rnlat2ln2,
c            XMWEM5(mxspec),IXREM5(mxspec),
c            CSLST5(mxspec),CID5(mxlines),
c            pmapln2,utmhemln2,datumln2,datenln2,xyunitln2
c
c --- RDHDEM5 called by: SETUP
c --- RDHDEM5 calls:     YR4, XTRACTLL, INCR, TCLOCK, GEOFMT
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'ln2.puf'
      include 'dataset.puf'
      include 'datehr.puf'
      include 'qa.puf'
c
      LOGICAL lprt

c --- Local variables
      character*8 axtz5
      character*12 fname5,label5
      character*12 vrs5
      character*16 dataset,dataver
      character*16 clat0,clon0,clat1,clat2
      character*33 blank33,break33
      character*64 datamod
      character*132 comment1,blank,break

      data blank33/'                                 '/
      data break33/'.................................'/
      data nlim/1/
      data zero/0.0/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Set break (132 characters)
      break(1:33)=break33
      break(34:66)=break33
      break(67:99)=break33
      break(100:132)=break33

c --- Begin scratch file image
      write(iox,'(a132)') blank
      write(iox,'(a132)') break
      write(iox,'(a132)') blank
      ncommout=ncommout+3

c --- Initialize map projection logicals
      lutmln2=.FALSE.
      llccln2=.FALSE.
      lpsln2=.FALSE.
      lemln2=.FALSE.
      llazaln2=.FALSE.
      lttmln2=.FALSE.

c --- Initialize other variables
      datenln2='02-21-2003  '
      xyunitln2='KM  '
      ibsec5=0.0
      iesec5=0.0
      feastln2=0.0
      fnorthln2=0.0
      clat0='0.0N            '
      clon0='0.0W            '
      clat1='0.0N            '
      clat2='0.0N            '
      dataset='                '
      dataver='                '
      pmapln2='XXX     '
      iutmznln2=1
      utmhemln2='N   '
      datumln2='XXX     '
      axtz5='UTC+0000'

c --- Only previous dataset version 5.4 is recognized

c     -----------------------
      if(verlarb.EQ.'1.54') then
c     -----------------------

c ---    Provide help and then stop (this format is not supported)
         dataset='LNEMARB.DAT    '

            read(iunit,*)fname5,nsrc5,nse5,iutmznln2,
     &                   ibdat,ibhr,iedat,iehr,vrs5,label5
            dataver='1.54a           '
            datamod(1:42)='Augmented 5.4 format with Map Projection, '
            datamod(43:64)='DATUM, Time Zone      '


         write(io6,*)
         write(io6,*)
         write(io6,*)'ERROR in LNEMARB files'
         write(io6,*)
         write(io6,*)'Old LNEMARB.DAT format cannot be used because:'
         write(io6,*)'1.  Coordinate map projection is incomplete'
         write(io6,*)'2.  The DATUM for the coordinates is missing'
         write(io6,*)'3.  The time zone is missing'
         write(io6,*)
         write(io6,*)'ADD these records to the top of the file:'
         write(io6,*)
         write(io6,'(2a16,a64)') dataset,dataver,datamod
         if(iutmznln2.NE.0) then
            write(io6,'(a8)')'UTM     '
            write(io6,'(a8)')'  xxN   '
         else
            write(io6,'(a8)')'LCC     '
            write(io6,'(4a16)')'yy.yyyN         ','xx.xxxW         ',
     &                         'yy.yyyN         ','yy.yyyN         '
            write(io6,*)zero,zero
         endif
         write(io6,'(a8)')'DATUM   '
         write(io6,'(a8)')'UTC-0500'
         write(io6,*)
         write(io6,*)'UPDATE these records to describe your file:'
         if(iutmznln2.NE.0) then
           write(io6,*)'- Replace the xxN with your UTM zone and',
     &                 ' hemisphere (S for Southern Hemisphere)'
         else
           write(io6,*)'- Replace the 0.0 0.0 with your False Easting',
     &                 ' and Northing if non-zero'   
         endif
         write(io6,*)'- Replace DATUM with your datum code (enter',
     &               ' left-justified in the 8-character field)'
         write(io6,*)'- Replace UTC-0500 with your time zone code'
         write(io6,*)'  (GMT=UTC+0000, EST=UTC-0500, CET=UTC+0100)'
         write(io6,*)
         write(*,*)
         write(*,*)'ERROR in LNEMARB files -- see list file'
         write(*,*)
         stop

c     ----------------------------
      elseif(verlarb.EQ.'1.54a') then
c     ----------------------------

c ---    Augmented headers

         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         ncommout=ncommout+1
c ---    Map projection
         read(iunit,'(a8)') pmapln2
         write(iox,'(a8)') pmapln2
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmapln2,iutmznln2,utmhemln2,
     &               clat0,clon0,clat1,clat2,datumln2,datenln2,
     &               xyunitln2,axtz5)

         if(pmapln2.EQ.'UTM     ')  lutmln2 =.TRUE.
         if(pmapln2.EQ.'LCC     ')  llccln2 =.TRUE.
         if(pmapln2.EQ.'PS      ')  lpsln2  =.TRUE.
         if(pmapln2.EQ.'EM      ')  lemln2  =.TRUE.
         if(pmapln2.EQ.'LAZA    ')  llazaln2=.TRUE.
         if(pmapln2.EQ.'TTM     ')  lttmln2 =.TRUE.
c ---    Map projection parameters
         if(LUTMLN2) then
            read(iunit,'(i4,a4)') iutmznln2,utmhemln2
            write(iox,'(i4,a4)') iutmznln2,utmhemln2
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCLN2) then
            read(iunit,*) feastln2,fnorthln2
            write(iox,*)  feastln2,fnorthln2
            ncommout=ncommout+1
         endif
c ---    Map DATUM
         read(iunit,'(a8)') datumln2
         write(iox,'(a8)')  datumln2
         ncommout=ncommout+1
c ---    Time zone
         read(iunit,'(a8)') axtz5
         write(iox,'(a8)')  axtz5
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmapln2,iutmznln2,utmhemln2,
     &               clat0,clon0,clat1,clat2,datumln2,datenln2,
     &               xyunitln2,axtz5)

c ---    Process time zone
         read(axtz5(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM5 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz5
            stop 'Halted in RDHDEM5 -- see list file'
         endif
         xtz5=-FLOAT(ibtzhh)

c ---    Old Header Record(s)

         read(iunit,*)fname5,nsrc5,nse5,iutmznln2,
     &                ibdat,ibhr,iedat,iehr,
     &                vrs5,label5
         read(iunit,*) clat1,clat2,clat0,clon0
         ibyr=ibdat/1000
         ibdy=ibdat-ibyr*1000
         ieyr=iedat/1000
         iedy=iedat-ieyr*1000
         write(iox,'(a12,9i6,2a12)')fname5,nsrc5,nse5,
     &                iutmznln2,ibyr,ibdy,ibhr,ieyr,iedy,iehr,
     &                vrs5,label5
         write(iox,'(4a16)') clat1,clat2,clat0,clon0
         ncommout=ncommout+2

c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) then
            write(*,*)
            stop 'Halted in RDHDEM5'
         endif

c ---    Species list
         read(iunit,*)(cslst5(n),n=1,nse5)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem5(n),n=1,nse5)

c     ---------------------------
      elseif(verlarb.EQ.'2.1') then
c     ---------------------------

c ---    First record and comments
         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         read(iunit,*) ncom
         write(iox,*) ncom
         do k=1,ncom
            comment1=blank
            read(iunit,'(a132)') comment1
            write(iox,'(a132)') comment1
         enddo
         ncommout=ncommout+2+ncom

c ---    Map projection
         read(iunit,'(a8)') pmapln2
         write(iox,'(a8)') pmapln2
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmapln2,iutmznln2,utmhemln2,
     &               clat0,clon0,clat1,clat2,datumln2,datenln2,
     &               xyunitln2,axtz5)

         if(pmapln2.EQ.'UTM     ')  lutmln2 =.TRUE.
         if(pmapln2.EQ.'LCC     ')  llccln2 =.TRUE.
         if(pmapln2.EQ.'PS      ')  lpsln2  =.TRUE.
         if(pmapln2.EQ.'EM      ')  lemln2  =.TRUE.
         if(pmapln2.EQ.'LAZA    ')  llazaln2=.TRUE.
         if(pmapln2.EQ.'TTM     ')  lttmln2 =.TRUE.

c ---    Map projection parameters
         if(LUTMLN2) then
            read(iunit,'(i4,a4)') iutmznln2,utmhemln2
            write(iox,'(i4,a4)') iutmznln2,utmhemln2
            ncommout=ncommout+1
         elseif(LLCCLN2) then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         elseif(LPSLN2) then
            read(iunit,'(3a16)') clat0,clon0,clat1
            write(iox,'(3a16)')  clat0,clon0,clat1
            ncommout=ncommout+1
         elseif(LEMLN2.or.LLAZALN2.or.LTTMLN2) then
            read(iunit,'(2a16)') clat0,clon0
            write(iox,'(2a16)')  clat0,clon0
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCCLN2.or.LLAZALN2.or.LTTMLN2) then
            read(iunit,*) feastln2,fnorthln2
            write(iox,*)  feastln2,fnorthln2
            ncommout=ncommout+1
         else
            feastln2=0.0
            fnorthln2=0.0
         endif
c ---    Map DATUM
         read(iunit,'(a8,a12)') datumln2,datenln2
         write(iox,'(a8,a12)')  datumln2,datenln2
         ncommout=ncommout+1
c ---    Map units
         read(iunit,'(a4)') xyunitln2
         write(iox,'(a4)')  xyunitln2
         ncommout=ncommout+1
c ---    Time zone
         read(iunit,'(a8)') axtz5
         write(iox,'(a8)')  axtz5
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmapln2,iutmznln2,utmhemln2,
     &               clat0,clon0,clat1,clat2,datumln2,datenln2,
     &               xyunitln2,axtz5)

c ---    Process time zone
         read(axtz5(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDEM5 -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz5
            stop 'Halted in RDHDEM5 -- see list file'
         endif
         xtz5=-FLOAT(ibtzhh)

c ---    Time period
         read(iunit,*)ibyr,ibdy,ibhr,ibsec5,
     &                ieyr,iedy,iehr,iesec5
c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDHDEM5'
         write(iox,'(9i6)')ibyr,ibdy,ibhr,ibsec5,
     &                     ieyr,iedy,iehr,iesec5
         ncommout=ncommout+1

c ---    Number of sources and species
         read(iunit,*) nsrc5,nse5
         write(iox,*) nsrc5,nse5
         ncommout=ncommout+1

c ---    Species list
         read(iunit,*)(cslst5(n),n=1,nse5)

c ---    Molecular weights of each emitted species
         read(iunit,*)(xmwem5(n),n=1,nse5)

c     -----
      else
c     -----

         write(*,*)'ERROR in LNEMARB File '
         write(*,*)'Bad Dataset Version: ',verlarb
         write(*,*)'Expected 1.54, 1.54a, 2.1'
         stop

c     -----
      endif
c     -----

c --- Species info to scratch file
      do n=1,nse5
         write(iox,'(a16,f12.4)')cslst5(n),xmwem5(n)
      enddo
      ncommout=ncommout+nse5

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibsec5)
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iesec5)

c --- Apply time zone adjustment to date/times
      if(xtz5.GE.-13 .AND. xtz5.LE.13) then
         t2btz5=xtz5-xbtz
         ishift=NINT(t2btz5)
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
         call INCR(io6,ieyr,iedy,iehr,ishift)
      else
         write(io6,*)
         write(io6,*)'ERROR in LNEMARB.DAT file : Bad Time Zone'
         write(io6,*)'Expected zone between -13 and 13'
         write(io6,*)'Found zone = ',xtz5
         stop 'Bad Time Zone in LNEMARB.DAT file -- see list file'
      endif

c --- Hourly Data:  Move the time for the first period from the end
c ---               to the start of the first hour
      if(verlarb.EQ.'1.54a') then
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      endif

c --- Form date-hr variables for /LN2/
      ibdathr5=ibyr*100000+ibdy*100+ibhr
      iedathr5=ieyr*100000+iedy*100+iehr

c --- Process lat/lon character variables to extract content
      call XTRACTLL(io6,'LAT ',clat1,rnlat1ln2)
      call XTRACTLL(io6,'LAT ',clat2,rnlat2ln2)
      call XTRACTLL(io6,'LAT ',clat0,rnlat0ln2)
      call XTRACTLL(io6,'LON ',clon0,relon0ln2)

c --- Check sources and species
      if(nln2.ne.nsrc5)then
         write(io6,11)nln2,nsrc5
11       format(/1x,'ERROR in SUBR. RDHDEM5 -- number of line sources',
     1   ' does not match expected value'/
     2   1x,'Expected NLN2: ',i6,/
     3   1x,'Found   NSRC5: ',i6)
         write(*,*)
         stop 'Halted in RDHDEM5 -- see list file.'
      endif
c
      if(nse5.gt.mxspec)then
         write(io6,12)nse5,mxspec
12       format(/1x,'ERROR in SUBR. RDHDEM5 -- No. emitted species ',
     1   ' in LNEMARB file is greater than current array dimension'/1x,
     2   '     No. emitted species in file: ',i5/1x,
     3   'Current Array dimension (MXSPEC): ',i5)
         write(*,*)
         stop 'Halted in RDHDEM5 -- see list file.'
      endif

c --- WRITE CONTENTS OF HEADER RECORDS (if requested)
      if(lprt)then
         write(io6,102)
102      format(///1x,13('----------')//1x,'Header record data from ',
     1   'the LNEMARB line source file',i5)
         write(io6,103)dataset,nse5,axtz5,
     &         ibdathr5,ibsec5,iedathr5,iesec5,pmapln2,
     &         datumln2
103      format(/1x,'DATASET: ',a16/1x,'NSE5:    ',i6/
     1   1x,'AXTZ5:   ',a8/
     2   1x,'IBDATHR5:',i9/1x,'IBSEC5:  ',i4/
     3   1x,'IEDATHR5:',i9/1x,'IESEC5:  ',i4/
     4   1x,'MAP5:    ',a8/1x,'DATUM:   ',a8)

         if(LUTMLN2) write(io6,104) iutmznln2,utmhemln2
         if(LLCCLN2) write(io6,105) clat0,clon0,clat1,clat2,
     &                              feastln2,fnorthln2
         if(LPSLN2) write(io6,106) clat0,clon0,clat1
         if(LEMLN2) write(io6,107) clat0,clon0
         if(LLAZALN2.or.LTTMLN2) write(io6,108) clat0,clon0,
     &                                 feastln2,fnorthln2

104      format(/1x,'UTMZN:   ',i4/1x,'UTMHEM:  ',a4)
105      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16/1x,'Lat2:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)
106      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16)
107      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16)
108      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)

         write(io6,109)
109      format(4x,'SPECIES',6x,'MOL. WT.'/)
         do is=1,nse5
            write(io6,110)cslst5(is),xmwem5(is)
         enddo
110      format(1x,a12,3x,f7.3)
      endif

c --- Initialize "previous" period times for /LN2/
      nstep5=1
      ndhrqb5(1)=-000100100
      nsecqb5(1)=0
      ndhrqe5(1)=ibdathr5
      nsecqe5(1)=ibsec5
c
      return
      end
c----------------------------------------------------------------------
      subroutine EMQA(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                   EMQA
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Perform QA checks on data from emissions files --
c               check for consistency with the control file inputs
c
c               Compute cross-referencing arrays relating species
c               ordering in the emissions files to that of the main
c               concentration array
c
c --- UPDATE
c --- V5.4-V6.1     050915  (DGS): Add check on begin/end times with
c                                  seconds, and report time zone shifts
c --- V5.3-V5.4     000602  (DGS): replace VOLEM.DAT with VOLEMARB.DAT
c ---               000602  (DGS): add message to "stop"
c --- V5.2-V5.3     991222  (DGS): add LEMIT to QCHECK call
c --- V4.0-V5.0     971107  (DGS): add LNEMARB.DAT data
c
c --- INPUTS:
c
c           LDB - logical - Control variable for printing debug
c                           information
c     Common Block /FILNAM/ variables:
c            nptdat,nardat,nvoldat,
c            ptdat(mxemdat),ardat(mxemdat),voldat(mxemdat)
c     Common Block /GEN/ variables:
c            NSE, CSPEC(mxspec), XMOL(mxspec), ISPLST(4,mxspec),
c            IBDATHR, IBSEC, IEDATHR, IESEC, METRUN
c     Common Block /GRID/ variables:
c            NX, NY, DGRID, XORIG, YORIG
c     Common Block /PT2/ variables:
c            NPT2, NSE2, CSLST2(mxspec), XMWEM2(mxspec)
c     Common Block /AR2/ variables:
c            NAR2, NSE3, CSLST3(mxspec), XMWEM3(mxspec),
c            IBDATHR3(mxemdat),IBSEC3(mxemdat),IEDATHR3(mxemdat),
c            IESEC3(mxemdat),T2BTZ3(mxemdat)
c     Common Block /VOL2/ variables:
c            NVL2, NSE4, CSLST4(mxspec), XMWEM4(mxspec)
c            IBDATHR4(mxemdat),IBSEC4(mxemdat),IEDATHR4(mxemdat),
c            IESEC4(mxemdat),T2BTZ4(mxemdat)
c     Common Block /LN2/ variables:
c            NLN2, NSE5, CSLST5(mxspec), XMWEM5(mxspec)
c            IBDATHR5,IBSEC5,IEDATHR5,IESEC5,T2BTZ5
c     Parameters:
c            MXSPEC, IO6, MXEMDAT
c
c --- OUTPUT:
c
c     Common Block /PT2/ variables:
c            IXREM2(mxspec)
c     Common Block /AR2/ variables:
c            IXREM3(mxspec)
c     Common Block /VOL2/ variables:
c            IXREM4(mxspec)
c     Common Block /LN2/ variables:
c            IXREM5(mxspec)
c
c --- EMQA called by: SETUP
c --- EMQA calls:     QCHECK, TCHECK
c----------------------------------------------------------------------
c
c --- Include parameters
      INCLUDE 'params.puf'
c
c --- Include common blocks
      INCLUDE 'ar2.puf'
      INCLUDE 'filnam.puf'
      INCLUDE 'gen.puf'
      INCLUDE 'grid.puf'
      INCLUDE 'ln2.puf'
      INCLUDE 'pt2.puf'
      INCLUDE 'vol2.puf'

      character*12 ftype(5)

      logical ldb,lemit,lzone
      data lemit/.true./
      data ftype/'not used    ','PTEMARB.DAT ','BAEMARB.DAT ',
     &           'VOLEMARB.DAT','LNEMARB.DAT '/

      data ione/1/
c
c --- Check inputs from each emissions file
      ierr=0
      itzn=0
c
c --- PTEMARB.DAT -- point sources with arbitrarily-varying emissions
      if(npt2.gt.0) then
         call QCHECK(mxspec,io6,nspec,nse,isplst,cspec,xmol,
     &               lemit,ftype(2),nse2,cslst2,xmwem2,ierr,ixrem2)
         call TCHECK(mxemdat,io6,ftype(2),nptdat,ibdathr,ibsec,
     &               iedathr,iesec,ibdathr2,ibsec2,iedathr2,iesec2,
     &               t2btz2,metrun,ierr,itzn)
      endif
c
c --- BAEMARB.DAT -- area sources with arbitrarily-varying emissions
      if(nar2.gt.0) then
         call QCHECK(mxspec,io6,nspec,nse,isplst,cspec,xmol,
     &               lemit,ftype(3),nse3,cslst3,xmwem3,ierr,ixrem3)
         call TCHECK(mxemdat,io6,ftype(3),nardat,ibdathr,ibsec,
     &               iedathr,iesec,ibdathr3,ibsec3,iedathr3,iesec3,
     &               t2btz3,metrun,ierr,itzn)
      endif
c
c --- VOLEMARB.DAT -- volume sources with arbitrarily-varying emissions
      if(nvl2.gt.0) then
         call QCHECK(mxspec,io6,nspec,nse,isplst,cspec,xmol,
     &               lemit,ftype(4),nse4,cslst4,xmwem4,ierr,ixrem4)
         call TCHECK(mxemdat,io6,ftype(4),nvoldat,ibdathr,ibsec,
     &               iedathr,iesec,ibdathr4,ibsec4,iedathr4,iesec4,
     &               t2btz4,metrun,ierr,itzn)
      endif
c
c --- LNEMARB.DAT -- line sources with arbitrarily-varying emissions
      if(nln2.gt.0) then
         call QCHECK(mxspec,io6,nspec,nse,isplst,cspec,xmol,
     &               lemit,ftype(5),nse5,cslst5,xmwem5,ierr,ixrem5)
         call TCHECK(ione,io6,ftype(5),ione,ibdathr,ibsec,
     &               iedathr,iesec,ibdathr5,ibsec5,iedathr5,iesec5,
     &               t2btz5,metrun,ierr,itzn)
      endif


c --- Write notice to screen if any time zone shifts are done
      if(itzn.EQ.1) then
         write(*,*)
         write(*,*)'NOTICE: Times are adjusted in emissions file(s)'
         write(*,*)'(See list file for details)'
         write(*,*)
      endif
c
      if(ldb)then
         if(npt2.gt.0)write(io6,*)  'IXREM2 = ',(ixrem2(n),n=1,nse)
         if(nar2.gt.0)write(io6,*)  'IXREM3 = ',(ixrem3(n),n=1,nse)
         if(nvl2.gt.0)write(io6,*)  'IXREM4 = ',(ixrem4(n),n=1,nse)
         if(nln2.gt.0)write(io6,*)  'IXREM5 = ',(ixrem5(n),n=1,nse)
      endif
c
c --- Terminate execution if any errors encountered
      if(ierr.eq.1) then
         write(*,*)
         stop 'Halted in EMQA -- see list file.'
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine QCHECK(mxspec,io6,nspec,nse,isplst,cspec,xmol,lemit,
     1 fnamen,nsen,cslstn,xmwemn,ierr,ixremn)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991222                 QCHECK
c                J. Scire, SRC
c                R. Yamartino, SRC
c
c --- PURPOSE:  Check no. species, species names against control
c               file inputs, molecular weights -- Set up cross-
c               referencing table
c
c --- UPDATE
c --- V5.2-V5.3   991222  (DGS): add LEMIT argument to check that all
c                                emitted species (and no more) are in
c                                the CSLSTN array
c --- V5.0-V5.0   990228e (DGS): recast IXREMN array as map to FULL
c                                advected species array, not to the
c                                emitted species array
c --- V5.0-V5.0   980430  (DGS): 'use' all variables (compiler warning)
c --- V4.0-V5.0   971107  (DGS): isplst()  dimensions updated from
c                                (3,mxspec) to (4,mxspec)
c                 971107  (DGS): add treatment for special case of NSE=0
c
c --- INPUTS:
c           MXSPEC - integer       - Maximum number of species
c              IO6 - integer       - Fortran unit number for error
c                                    messages
c            NSPEC - integer       - Number of species modeled
c              NSE - integer       - Number of emitted species (control
c                                    file input)
c ISPLST(4,mxspec) - integer array - Flags indicating which species are
c                                    (1,-)=modeled,
c                                    (2,-)=emitted, (3,-)=deposited
c    CSPEC(mxspec) - char*12 array - List of chemical species
c     XMOL(mxspec) - real array    - Molecular weights of each advected
c                                    species
c            LEMIT - logical       - Check that all emitted species are
c                                    present?
c                                    T: check for all NSE species
c                                    F: just check that species is one
c                                       of the NSPEC modeled species
c           FNAMEN - char*12       - Emissions file name
c             IERR - integer       - Error flag (initialized to zero in
c                                    calling routine)
c             NSEN - integer       - Number of emitted species
c                                    (emissions file input)
c   CSLSTN(mxspec) - char*12 array - List of emitted species (from
c                                    emissions file)
c   XMWEMN(mxspec) - real array    - Molecular weights of emitted
c                                    species (from emissions file)
c
c --- OUTPUT:
c             IERR - integer       - Error flag (set to one if any errors
c                                    are found)
c   IXREMN(mxspec) - integer array - Cross-referencing array of "NSEN"
c                                    values relating species ordering
c                                    in the emissions file to the
c                                    ordering in the master species list
c
c --- QCHECK called by: EMQA, RDHDBC, RDHDBC2
c --- QCHECK calls:     none
c----------------------------------------------------------------------
      real xmol(mxspec),xmwemn(mxspec)
      integer isplst(4,mxspec),ixremn(mxspec)
      logical lemit
      character*12 cspec(mxspec),cslstn(mxspec),fnamen


      if(NSE.eq.0) then
c ---    SPECIAL CASE:  First time emissions are encountered in this
c ---    application, so loop over emitted species names and set
c ---    corresponding ISPLST(2,-) in master species list
         do j=1,nsen
            do i=1,nspec
               if(cslstn(j).eq.cspec(i)) then
                  isplst(2,i)=1
                  nse=nse+1
               endif
            enddo
         enddo
      endif
c
c --- Number of emitted species should match
      if(NSEN.ne.NSE .AND. LEMIT)then
         ierr=1
         write(io6,10)fnamen
10       format(/1x,'ERROR in subr. QCHECK -- Emissions data do not ',
     1   'match control file input -- FILE: ',a12)
         write(io6,12)nsen,nse
12       format(5x,'No. emitted species from emissions file: ',i6/
     1          5x,'No. emitted species from control file:   ',i6)
      endif
c
c --- set up cross-referencing array & check that all emitted species
c     are in the emissions file
c --- NOTE: Pollutants in the emission files can be in any order --
c           IXREMN contains a number from 1 to NSPEC (not NSE) relating
c           the data file species ordering to that of MODELED species
c           in the master concentration array
      match=0
      LL=0
c --- Loop over all modeled species
      do 35 i=1,nspec
      if(isplst(2,i).eq.1 .OR. .not.LEMIT)then
c ---    This is an emitted species if LEMIT=T
         LL=LL+1
c
c ---    Loop over species in CSLSTN array to search for this species
         do 22 j=1,nsen
         if(cslstn(j).eq.cspec(i))then
            ixremn(j)=i
            jsave=j
            match=match+1
            go to 25
         endif
22       continue
c
c ---    species not found in emissions file
         if(LEMIT) then
            ierr=1
            write(io6,10)fnamen
            write(io6,23)cspec(i),(cslstn(n),n=1,nsen)
23          format(/5x,'Emitted species not found in emission file'/
     1           5x,'Species: ',a12/
     2           5x,'Emissions file species list: ',7(a12,1x)/
     3           10(34x,7(a12,1x)/))
         endif
         go to 35
c
25       continue
c -----------------------------------------   DISABLED !
cc ---    Check that molecular weight in emissions file matches model value
c         absdif=abs(xmol(i)-xmwemn(jsave))
c         if(absdif.gt.0.1)then
cc92         ierr=1
c            write(io6,10)fnamen
c            write(io6,26)cspec(i),xmol(i),xmwemn(jsave)
cC9226       format(/5x,'Molecular weight specified in emissions file ',
c26          format(/5x,'*** WARNING ***  ',
c     1      'Molecular weight specified in emissions file ',
c     1      'does not match value in model'/5x,'Species: ',a12/
c     2      5x,'Molecular weight (model = *.RXP) = ',f10.2/
c     3      5x,'Molecular weight (emission file) = ',f10.2/)
c         endif
c -----------------------------------------   DISABLED !
      endif
35    continue
c
c --- NSEN matches should have been found
      if(match.NE.nsen) then
         ierr=1
         write(io6,10)fnamen
         write(io6,*)'Match on all species names NOT found'
         write(io6,*)'Cross-References found:'
         do k=1,nsen
            if(ixremn(k).EQ.0) then
               write(io6,'(a16)') cslstn(k)
            else
               write(io6,'(a16,4x,a16)') cslstn(k),cspec(ixremn(k))
            endif
         enddo
      endif
c --- LL should add up to NSE
      if(LL.ne.NSE .AND. LEMIT)then
         ierr=1
         write(io6,10)fnamen
         write(io6,*)'LL ne NSE -- LL = ',LL,' NSE = ',nse
      endif

c --- 'Use' variables (compiler warning)
      jsave=jsave
      xmol(1)=xmol(1)
      xmwemn(1)=xmwemn(1)
c
      return
      end
c----------------------------------------------------------------------
      subroutine TCHECK(mxemdat,io6,fnamen,nfiles,ibdathr,ibsec,
     & iedathr,iesec,ibdathrn,ibsecn,iedathrn,iesecn,t2btzn,metrun,
     & ierr,itzn)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                 TCHECK
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Check time periods against control file inputs,
c               report any time zone adjustments
c
c --- INPUTS:
c          MXEMDAT - integer       - Maximum number of emissions files
c              IO6 - integer       - Fortran unit number for list file
c           FNAMEN - char*12       - Emissions file type
c           NFILES - integer       - Number of emissions files
c   IBDATHR, IBSEC - integer       - Starting date/time in CALPUFF
c                                    (YYYYJJJHH, SSSS)
c   IEDATHR, IESEC - integer       - Ending date/time in CALPUFF
c                                    (YYYYJJJHH, SSSS)
cIBDATHRN(mxemdat) - integer array - Starting date/time in each emission
c  IBSECN(mxemdat)                   file (YYYYJJJHH, SSSS)
cIEDATHRN(mxemdat) - integer array - Ending date/time in each emission
c  IESECN(mxemdat)                   file (YYYYJJJHH, SSSS)
c  T2BTZN(mxemdat) - real array    - Time zone adjustment for each
c                                    emission file (hr)
c           METRUN - integer       - Run all met periods flag
c
c --- OUTPUT:
c             IERR - integer       - Error flag (set to 1 if any errors
c                                    are found)
c             ITZN - integer       - Time Zone flag (set to 1 if any 
c                                    adjustments to the CALPUFF base
c                                    time zone are needed)
c
c --- TCHECK called by: EMQA
c --- TCHECK calls:     TPERIOD
c----------------------------------------------------------------------
      real t2btzn(mxemdat)
      integer ibdathrn(mxemdat),ibsecn(mxemdat)
      integer iedathrn(mxemdat),iesecn(mxemdat)
      logical lzone
      character*12 fnamen

c --- Check data time period in each file, and identify time zone
c --- shifts to screen
      lzone=.FALSE.
      do i=1,nfiles
         ishift=NINT(t2btzn(i))
         if(ishift.NE.0) lzone=.TRUE.
         call TPERIOD(0,ibdathr,ibsec,ibdathrn(i),ibsecn(i),
     &                iedathrn(i),iesecn(i),ilocb)
         call TPERIOD(0,iedathr,iesec,ibdathrn(i),ibsecn(i),
     &                iedathrn(i),iesecn(i),iloce)
c ---    Do not include end-time test when running all met periods
         if(metrun.EQ.1) iloce=0
         if(ilocb.NE.0 .OR. iloce.NE.0) then
            ierr=1
            write(io6,*)
            write(io6,*)'ERROR in emissions file -- ',fnamen,i
            write(io6,*)'Emission period does not cover simulation',
     &                  ' period'
            write(io6,*)'Simulation begins: ',ibdathr,ibsec
            if(metrun.EQ.0) then
               write(io6,*)'Simulation ends  : ',iedathr,iesec
            endif
            write(io6,*)'Emission begins  : ',ibdathrn(i),ibsecn(i)
            write(io6,*)'Emission ends    : ',iedathrn(i),iesecn(i)
            write(io6,*)
         endif
      enddo
c --- Report any time zone adjustments
      if(LZONE) then
         itzn=1
         write(io6,*)
         write(io6,*)'EMQA: Times are adjusted in emissions file'
         write(io6,*)'      to obtain the CALPUFF Time Zone '
         write(io6,*)'      Emissions File Type -- ',fnamen
         write(io6,*)'      Emissions File #     Time Shift(hr)'
         do i=1,nfiles
            write(io6,'(12x,i4,18x,i4)') i,NINT(t2btzn(i))
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine RDTIEM2(iunit0,npt2,nptdat,i,mfpt2,ibsrc2,iesrc2,
     &                   avrs2,mbdw,ldb,io6,iox,tiem2,zplat2,bht2,bwd2,
     &                   bln2,xbadj2,ybadj2,cid2,ncommout)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                RDTIEM2
c                J. Scire, SRC
c
c --- PURPOSE:  Read the time-invariant records of the PTEMARB point
c               source emissions file (arbitrarily-varying emissions)
c
c --- UPGRADE
c --- V5.75-V6.1: 050915 (DGS): Dataset version as character.
c                               Header information is passed to scratch
c                               file.
c                               Process 1 file per call.
c --- V5.7-V5.75: 050225 (DGS): Add building downwash data for
c                               elevated structures (platforms)
c --- V5.4-V5.7 : 030402 (DGS): add PRIME building downwash data
c                               signaled by argument MBDW=2
c --- V5.0-V5.4 : 000602 (DGS): Allow multiple PTEMARB files
c                 000602 (DGS): Add vertical momentum flux factor as
c                               TIEM2(7,i)
c --- V5.0-V5.0 : 980430 (DGS): 'Use' CID (compiler warning)
c --- V4.0-V5.0 : 971107 (DGS): PTEMARB.DAT either binary or ASCII
c                 971107 (DGS): TIEM2(6,i) now holds downwash flag
c                 971107 (DGS): Building hts & widths added for downwash
c                               older files are not supported
c
c --- INPUTS:
c           IUNIT0 - integer    - Fortran unit number for the FIRST
c                                 PTEMARB file
c             NPT2 - integer    - Number of PTEMARB point sources
c           NPTDAT - integer    - Number of PTEMARB files
c                I - integer    - Current PTEMARB file
c    MFPT2(nptdat) - integer    - Formatted file? (0:NO, 1:YES)
c   IBSRC2(nptdat) - integer    - Source ID for first source in each
c                                 PTEMARB file
c   IESRC2(nptdat) - integer    - Source ID for last source in each
c                                 PTEMARB file
c    AVRS2(nptdat) - char*16    - PTEMARB data-set version
c             MBDW - integer    - Building downwash mode
c                                 1 = HS/SS
c                                 2 = PRIME
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c              IOX - integer    - Fortran unit number for scratch file
c         NCOMMOUT - integer    - Currrent number of header comments
c
c --- OUTPUT:
c    TIEM2(8,npt2) - real array - Time-invariant PTEMARB source data
c     ZPLAT2(npt2) - real array - Platform height (m)
c    BHT2(36,npt2) - real array - Building heights every 10 deg from N
c    BWD2(36,npt2) - real array - Building widths every 10 deg from N
c    BLN2(36,npt2) - real array - Building lengths every 10 deg from N
c  XBADJ2(36,npt2) - real array - Alongwind distance from source to
c                                 upwind face of projected building,
c                                 every 10 deg from N
c  YBADJ2(36,npt2) - real array - Crosswind distance from source to
c                                 upwind face of projected building,
c                                 every 10 deg from N
c       CID2(npt2) - char*16    - PTEMARB source identifiers
c         NCOMMOUT - integer    - Updated number of header comments
c                                 in scratch file
c
c --- RDTIEM2 called by: SETUP
c --- RDTIEM2 calls:     none
c----------------------------------------------------------------------
c
      real tiem2(8,npt2),bht2(36,npt2),bwd2(36,npt2),bln2(36,npt2)
      real xbadj2(36,npt2),ybadj2(36,npt2)
      real zplat2(npt2)
      integer mfpt2(nptdat),ibsrc2(nptdat),iesrc2(nptdat)
      character*16 cid2(npt2)
      character*16 avrs2(nptdat)
      logical ldb, problem, lfmf
      data fmfeps/0.01/

c --- Initialize PROBLEM
      data problem/.FALSE./
c
c --- Process file "i"
         iunit=iunit0+i-1
c
c ---    Set structure for older and newer formats
         nwords=8
         lfmf=.TRUE.
         if(avrs2(i).EQ.'1.5a' .OR. avrs2(i).EQ.'1.6a') then
            nwords=7
            lfmf=.FALSE.
         endif
c
c ---    Loop over sources
         if(mfpt2(i).EQ.0) then
            do k=ibsrc2(i),iesrc2(i)
               ii=MIN(k,npt2)
               read(iunit)cid2(ii),(tiem2(n,ii),n=1,nwords)
               write(iox,'(a16,20f12.3)') cid2(ii),
     &                                   (tiem2(n,ii),n=1,nwords)
               ncommout=ncommout+1
               if(NINT(tiem2(6,ii)).EQ.2) then
c ---             Platform height record
                  read(iunit)zplat2(ii)
                  write(iox,'(f12.3)') zplat2(ii)
                  ncommout=ncommout+1
               endif
               if(NINT(tiem2(6,ii)).GE.1) then
c ---             Building data
                  read(iunit)(bht2(n,ii),n=1,36)
                  read(iunit)(bwd2(n,ii),n=1,36)
                  write(iox,'(6f9.3)') (bht2(n,ii),n=1,36)
                  write(iox,'(6f9.3)') (bwd2(n,ii),n=1,36)
                  ncommout=ncommout+12
                  if(mbdw.EQ.2) then
                     read(iunit)(bln2(n,ii),n=1,36)
                     read(iunit)(xbadj2(n,ii),n=1,36)
                     read(iunit)(ybadj2(n,ii),n=1,36)
                     write(iox,'(6f9.3)') (bln2(n,ii),n=1,36)
                     write(iox,'(6f9.3)') (xbadj2(n,ii),n=1,36)
                     write(iox,'(6f9.3)') (ybadj2(n,ii),n=1,36)
                     ncommout=ncommout+18
                  endif
               endif
            enddo
         else
            do k=ibsrc2(i),iesrc2(i)
               ii=MIN(k,npt2)
               read(iunit,*)cid2(ii),(tiem2(n,ii),n=1,nwords)
               write(iox,'(a16,20f12.3)') cid2(ii),
     &                                   (tiem2(n,ii),n=1,nwords)
               ncommout=ncommout+1
               if(NINT(tiem2(6,ii)).EQ.2) then
c ---             Platform height record
                  read(iunit,*)zplat2(ii)
                  write(iox,'(f12.3)') zplat2(ii)
                  ncommout=ncommout+1
               endif
               if(NINT(tiem2(6,ii)).GE.1) then
c ---             Building data
                  read(iunit,*)(bht2(n,ii),n=1,36)
                  read(iunit,*)(bwd2(n,ii),n=1,36)
                  write(iox,'(6f9.3)') (bht2(n,ii),n=1,36)
                  write(iox,'(6f9.3)') (bwd2(n,ii),n=1,36)
                  ncommout=ncommout+12
                  if(mbdw.EQ.2) then
                     read(iunit,*)(bln2(n,ii),n=1,36)
                     read(iunit,*)(xbadj2(n,ii),n=1,36)
                     read(iunit,*)(ybadj2(n,ii),n=1,36)
                     write(iox,'(6f9.3)') (bln2(n,ii),n=1,36)
                     write(iox,'(6f9.3)') (xbadj2(n,ii),n=1,36)
                     write(iox,'(6f9.3)') (ybadj2(n,ii),n=1,36)
                     ncommout=ncommout+18
                  endif
               endif
            enddo
         endif
c
c ---    Check building downwash configuration
         do k=ibsrc2(i),iesrc2(i)
            ii=MIN(k,npt2)
            if(NINT(tiem2(6,ii)).EQ.2 .AND. mbdw.EQ.2) then
               write(io6,*)
               write(io6,*)'FATAL Error in subr. RDTIEM2 -- PLATFORM',
     1         ' downwash is not modeled with PRIME at this time'
               write(io6,*)'    Source # = ',ii
               problem=.TRUE.
            elseif(NINT(tiem2(6,ii)).EQ.2 .AND. ZPLAT2(ii).LT.0.) then
               write(io6,*)
               write(io6,*)'FATAL Error in subr. RDTIEM2 -- PLATFORM',
     1         ' height cannot be negative'
               write(io6,*)'    Source #, ZPLAT2 = ',ii,zplat2(ii)
               problem=.TRUE.
            endif
         enddo
c
c ---    Process the vertical momentum factor
         if(LFMF) then
c ---       Value from file must be 0. to 1.0
            do k=ibsrc2(i),iesrc2(i)
               ii=MIN(k,npt2)
               adel0=ABS(tiem2(7,ii))
               adel1=ABS(tiem2(7,ii)-1.0)
               if(adel0.LT.fmfeps) then
                  tiem2(7,ii)=0.0
               elseif(adel1.LT.fmfeps) then
                  tiem2(7,ii)=1.0
               else
                  write(io6,*)
                  write(io6,*)'FATAL Error in subr. RDTIEM2 -- FMFAC ',
     1            'values for sources in PTEMARB must be either 0 or 1'
                  write(io6,*)'    Source #, FMFAC = ',ii,tiem2(7,ii)
                  problem=.TRUE.
               endif
            enddo
         else
c ---       Update older format structure that uses tiem2(7,ii)
            do k=ibsrc2(i),iesrc2(i)
               ii=MIN(k,npt2)
               tiem2(8,ii)=tiem2(7,ii)
c ---          Default vertical momentum factor to 1.0 (full)
               tiem2(7,ii)=1.0
            enddo
         endif

c
      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-invariant PTEMARB data'
         do 150 i=1,npt2
            write(io6,*)'I = ',i,'CID2 = ',cid2(i)
            write(io6,*)'I = ',i,'TIEM2 = ',(tiem2(n,i),n=1,8)
            if(NINT(tiem2(6,i)).EQ.2) then
               write(io6,*)'I = ',i,'ZPLAT2 = ',zplat2(i)
            endif
            if(NINT(tiem2(6,i)).GE.1) then
               write(io6,*)'--- BHT2 = ',(bht2(n,i),n=1,36)
               write(io6,*)'--- BWD2 = ',(bwd2(n,i),n=1,36)
               if(mbdw.EQ.2) then
                 write(io6,*)'--- BLN2 = ',(bln2(n,i),n=1,36)
                 write(io6,*)'--- XBADJ2 = ',(xbadj2(n,i),n=1,36)
                 write(io6,*)'--- YBADJ2 = ',(ybadj2(n,i),n=1,36)
               endif
            endif
150      continue
      endif

c --- Check number of sources
      if(iesrc2(nptdat).NE.npt2) then
         write(io6,*)
         write(io6,*)'FATAL Error in RDTIEM2:  Wrong number of sources'
         write(io6,*)'          Control file NPT2 = ',npt2
         write(io6,*)' PTEMARB.DAT Time-Invariant = ',iesrc2(nptdat)
         problem=.TRUE.
      endif

      if(PROBLEM) then
         write(*,*)
         stop 'Halted in RDTIEM2 -- see list file.'
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine RDEM2(iunit,mfpt2,nsrc2,nse2,cid2,ibsrc2,iesrc2,vers,
     &               tzhr,ldb,io6,ibegh,ibegs,iendh,iends,em2dat,ieof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDEM2
c                J. Scire, SRC
c
c --- PURPOSE:  Read the time-varying records of the PTEMARB point
c               source emissions file (arbitrarily-varying emissions)
c
c --- UPGRADE
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added, and other
c                               versions are retained.
c                               Begin/end times include seconds.
c --- V5.5-V5.7   030402 (DGS): Add list file unit to YR4 call
c --- V5.2-V5.4 : 000602 (DGS): Allow multiple PTEMARB files (CID used)
c                 000602 (DGS): Add initial sigmas
c --- V5.0-V5.2 : 991104 (DGS): YYYY format for year
c --- V5.0-V5.0 : 980430 (DGS): 'Use' CID (compiler warning)
c --- V4.0-V5.0 : 971107 (DGS): PTEMARB.DAT either binary or ASCII
c                 971107 (DGS): Remove volume flux from data records
c                               read
c
c --- INPUTS:
c            IUNIT - integer    - Fortran unit number of PTEMARB file
c            MFPT2 - integer    - Formatted file? (0:NO, 1:YES)
c            NSRC2 - integer    - Number of sources in the PTEMARB file
c             NSE2 - integer    - Number of emitted species
c      CID2(nsrc2) - char*16    - Source identifiers
c           IBSRC2 - integer    - Index for 1st source in current file
c           IESRC2 - integer    - Index for Last source in current file
c             VERS - char*16    - Data-set version for file
c             TZHR - real       - Hours to ADD to times in file to
c                                 convert to BASE TIME ZONE
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c
c --- OUTPUT:
c      IBEGH,IBEGS - integer    - Starting time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c      IENDH,IENDS - integer    - Ending time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c EM2DAT(NSE2+4,nsrc2) - real array - Time-varying PTEMARB source data
c             IEOF - integer    - End-of-file flag
c
c --- RDEM2 called by: INITPUF
c --- RDEM2 calls:     YR4, INCR, TCLOCK
c----------------------------------------------------------------------
c
      real em2dat(nse2+4,nsrc2)
      character*16 cid, cid2(nsrc2), vers
      logical ldb, lproblem

c --- Initialize EOF flag
      ieof=0

c --- Read starting, ending date and time
      if(vers.EQ.'1.5a' .OR. vers.EQ.'1.54a') then
         if(mfpt2.EQ.0) then
            read(iunit,end=999)ibdat,ibhr,iedat,iehr
         else
            read(iunit,*,end=999)ibdat,ibhr,iedat,iehr
         endif
         ibegs=0.0
         iends=0.0
         ibyr=ibdat/1000
         ibdy=ibdat-ibyr*1000
         ieyr=iedat/1000
         iedy=iedat-ieyr*1000
c ---    Shift start time to beginning of hour
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      elseif(vers.EQ.'1.6a' .OR. vers.EQ.'2.1') then
         if(mfpt2.EQ.0) then
            read(iunit,end=999)ibyr,ibdy,ibhr,ibegs,
     &                         ieyr,iedy,iehr,iends
         else
            read(iunit,*,end=999)ibyr,ibdy,ibhr,ibegs,
     &                           ieyr,iedy,iehr,iends
         endif
      else
         write(io6,*)
         write(io6,*)'RDEM2: Invalid Dataset Version for PTEMARB.DAT'
         write(io6,*)'Expected 1.5a, 1.54a, 1.6a, 2.1'
         write(io6,*)'Found: ',vers
         write(*,*)
         stop 'Halted in RDEM2 -- see list file.'
      endif

c --- Enforce YYYY format for year
      call YR4(io6,ibyr,ierrb)
      call YR4(io6,ieyr,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) then
         write(*,*)
         stop 'Halted in RDEM2'
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibegs)
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iends)

c --- Adjust times to BASE TIME ZONE
      ishift=NINT(tzhr)
      call INCR(io6,ibyr,ibdy,ibhr,ishift)
      call INCR(io6,ieyr,iedy,iehr,ishift)

c --- Form date-hour
      ibegh=ibyr*100000+ibdy*100+ibhr
      iendh=ieyr*100000+iedy*100+iehr

c --- Set structure for older and newer formats
      nwords=nse2+4
      if(vers.EQ.'1.5a' .OR. vers.EQ.'1.6a') nwords=nse2+2

c --- Loop over sources
      lproblem = .FALSE.
      if(mfpt2.EQ.0) then
         do i=ibsrc2,iesrc2
            read(iunit)cid,(em2dat(n,i),n=1,nwords)
            if(cid.NE.cid2(i)) lproblem=.TRUE.
         enddo
      else
         do i=ibsrc2,iesrc2
            read(iunit,*)cid,(em2dat(n,i),n=1,nwords)
            if(cid.NE.cid2(i)) lproblem=.TRUE.
         enddo
      endif

c --- Check for source problem
      if(lproblem) then
         write(io6,*)
         write(io6,*)'RDEM2: Problem with source names in PTEMARB.DAT'
         write(io6,*)'Names in data record do not match header record'
         write(io6,*)'Beginning time: ',ibegh,ibegs
         write(io6,*)'Ending time   : ',iendh,iends
         write(*,*)
         stop 'Halted in RDEM2 -- see list file.'
      endif

c --- Add initial sigmas to older format (sigy and sigz are inserted
c --- into positions 3,4)
      if(vers.EQ.'1.5a' .OR. vers.EQ.'1.6a') then
         do i=ibsrc2,iesrc2
c ---       Move the emission rates out 2 places in array
            do j=nwords,3,-1
               em2dat(j+2,i)=em2dat(j,i)
            enddo
c ---       Set initial sigmas to zero
            em2dat(3,i)=0.0
            em2dat(4,i)=0.0
         enddo
      endif

      if(ldb)then
c ---    Report full em2dat array
         nwords=nse2+4
         write(io6,*)
         write(io6,*)'Time-varying PTEMARB data'
         write(io6,*)'Beginning time: ',ibegh,ibegs
         write(io6,*)'Ending time   : ',iendh,iends
         write(io6,*)'Source Range  : ',ibsrc2,iesrc2
         do i=ibsrc2,iesrc2
            write(io6,*)'I = ',i,'EM2DAT = ',(em2dat(n,i),n=1,nwords)
         enddo
      endif

      return

c --- Reached end of BAEMARB.DAT file
999   ieof=1
      write(*,*)'RDEM2: Data in PTEMARB.DAT file end early'
      write(io6,*)'RDEM2: Data in PTEMARB.DAT file end early'
      return

      end
c----------------------------------------------------------------------
      subroutine RDTIEM3(iunit0,nar2,nardat,i,ibsrc3,iesrc3,iuem3,
     &                   avrs3,ldb,io6,iox,cid3,baemunit,ncommout)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                RDTIEM3
c                J. Scire
c
c --- PURPOSE:  Read the time-invariant records of the BAEMARB buoyant
c               area source data file (arbitrarily-varying emissions)
c
c --- UPGRADE
c --- V6.1-V6.1 : 070921 (DGS): Initialize DUMMY (compiler checks)
c --- V5.4-V6.1 : 050915 (DGS): Dataset version as character.
c                               Header information is passed to scratch
c                               file.
c                               Process 1 file per call.
c --- V5.0-V5.4 : 000602 (DGS): Allow multiple BAEMARB files
c                 000602 (DGS): Add units choice
c
c --- INPUTS:
c           IUNIT0 - integer    - Fortran unit number for the FIRST
c                                 BAEMARB file
c             NAR2 - integer    - Number of BAEMARB sources
c           NARDAT - integer    - Number of BAEMARB files
c                I - integer    - Current BAEMARB file
c   IBSRC3(nardat) - integer    - Source ID for first source in each
c                                 BAEMARB file
c   IESRC3(nardat) - integer    - Source ID for last source in each
c                                 BAEMARB file
c    IUEM3(nardat) - integer    - Emission units for sources in each
c                                 BAEMARB file
c    AVRS3(nardat) - char*16    - BAEMARB data-set version
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c              IOX - integer    - Fortran unit number for scratch file
c         NCOMMOUT - integer    - Currrent number of header comments
c                                 in scratch file
c
c --- OUTPUT:
c       CID3(nar2) - char*16    - BAEMARB source identifiers
c   BAEMUNIT(nar2) - char*16    - Emissions units for each source
c         NCOMMOUT - integer    - Updated number of header comments
c                                 in scratch file
c
c --- RDTIEM3 called by: SETUP
c --- RDTIEM3 calls:     none
c----------------------------------------------------------------------
c
      integer ibsrc3(nardat),iesrc3(nardat),iuem3(nardat)
      character*16 cid3(nar2),baemunit(nar2),qaunits(2)
      character*16 avrs3(nardat)
      logical ldb, lunits

c --- Set expected units
      data qaunits/'g/s','g/m2/s'/

c --- Initialize dummy variable
      dummy=0.0

c --- Set units QA logical to false
      lunits=.FALSE.

c --- Process file "i"
         iunit=iunit0+i-1
c
c ---    Loop over sources
         do k=ibsrc3(i),iesrc3(i)
            ii=MIN(k,nar2)
            if(avrs3(i).EQ.'1.5a') then
               read(iunit,*) cid3(ii)
               write(iox,'(a16)') cid3(ii)
               ncommout=ncommout+1
               baemunit(ii)=qaunits(1)
            elseif(avrs3(i).EQ.'1.54a') then
               read(iunit,*) cid3(ii),baemunit(ii),dummy,dummy
               write(iox,'(2a16)') cid3(ii),baemunit(ii)
               ncommout=ncommout+1
               if(baemunit(ii).NE.qaunits(1) .AND.
     &            baemunit(ii).NE.qaunits(2)) lunits=.TRUE.
            elseif(avrs3(i).EQ.'1.6a') then
               read(iunit,*) cid3(ii)
               write(iox,'(a16)') cid3(ii)
               ncommout=ncommout+1
               if(iuem3(i).GE.1 .AND. iuem3(i).LE.2) then
                  baemunit(ii)=qaunits(iuem3(i))
               else
                  lunits=.TRUE.
                  baemunit(ii)='                '
               endif
            elseif(avrs3(i).EQ.'2.1') then
               read(iunit,*)cid3(ii),baemunit(ii),dummy,dummy
               write(iox,'(2a16)') cid3(ii),baemunit(ii)
               ncommout=ncommout+1
               if(baemunit(ii).NE.qaunits(1) .AND.
     &            baemunit(ii).NE.qaunits(2)) lunits=.TRUE.
            else
               write(io6,*)'FATAL Error in RDTIEM3:  Unknown Version'
               write(io6,*)'avrs3(i) = ',avrs3(i)
               stop 'Halted in RDTIEM3 -- see list file.'
            endif
         enddo

c --- Check units if provided
      if(lunits) then
         write(io6,*)'FATAL Error in RDTIEM3:  Wrong units specified'
         write(io6,*)'     Allowed units = ',qaunits
         write(io6,*)'   Units Specified = '
         do k=ibsrc3(i),iesrc3(i)
            ii=MIN(k,nar2)
            write(io6,*) cid3(ii),baemunit(ii)
         enddo
         write(*,*)
         stop 'Halted in RDTIEM3 -- see list file.'
      endif

c --- Perform final QA after LAST file is processed
      if(i.NE.nardat) return

      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-invariant BAEMARB data'
         do 150 k=1,nar2
            write(io6,*)'I = ',k,'CID3 = ',cid3(k),baemunit(k)
150      continue
      endif

c --- Check number of sources
      if(iesrc3(nardat).NE.nar2) then
         write(io6,*)'FATAL Error in RDTIEM3:  Wrong number of sources'
         write(io6,*)'          Control file NAR2 = ',nar2
         write(io6,*)' BAEMARB.DAT Time-Invariant = ',iesrc3(nardat)
         write(*,*)
         stop 'Halted in RDTIEM3 -- see list file.'
      endif

c --- Use dummy (satisfy compiler warning)
      dummy=dummy
c
      return
      end
c----------------------------------------------------------------------
      subroutine RDEM3(iunit,nsrc3,nse3,cid3,ibsrc3,iesrc3,vers,tzhr,
     &                 ldb,io6,ibegh,ibegs,iendh,iends,em3dat,ieof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDEM3
c                J. Scire, D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read the time-varying records of the BAEMARB buoyant
c               area source data file (arbitrarily-varying emissions)
c
c --- UPGRADE
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added, and other
c                               versions are retained.
c                               Begin/end times include seconds.
c --- V5.5-V5.7   030402 (DGS): Add list file unit to YR4 call
c --- V5.2-V5.4 : 000602 (DGS): Allow multiple BAEMARB files (CID used)
c --- V5.0-V5.2 : 991104 (DGS): YYYY format for year
c --- V5.0-V5.0 : 980430 (DGS): 'Use' CID (compiler warning)
c --- V4.0-V5.0 : 971107 (DGS): Remove heat flux from data records,
c                               and add initial rise velocity and
c                               effective rise radius, elevation,
c                               and initial sigma-z
c
c --- INPUTS:
c            IUNIT - integer    - Fortran unit number of BAEMARB file
c            NSRC3 - integer    - Number of sources in the BAEMARB file
c             NSE3 - integer    - Number of emitted species
c      CID3(nsrc3) - char*16    - Source identifiers
c           IBSRC3 - integer    - Index for 1st source in current file
c           IESRC3 - integer    - Index for Last source in current file
c             VERS - char*16    - Dataset version for file
c             TZHR - real       - Hours to ADD to times in file to
c                                 convert to BASE TIME ZONE
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c
c --- OUTPUT:
c      IBEGH,IBEGS - integer    - Starting time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c      IENDH,IENDS - integer    - Ending time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c EM3DAT(NSE3+14,nsrc3) - real array - Time-varying BAEMARB source data
c             IEOF - integer    - End-of-file flag
c
c --- RDEM3 called by: INITPUF
c --- RDEM3 calls:     YR4, INCR, TCLOCK
c----------------------------------------------------------------------
c
      real em3dat(nse3+14,nsrc3)
      character*16 cid, cid3(nsrc3), vers
      logical ldb, lproblem

c --- Initialize EOF flag
      ieof=0

c --- Read starting, ending date and time
      if(vers.EQ.'1.5a' .OR. vers.EQ.'1.54a') then
         read(iunit,*,end=999)ibdat,ibhr,iedat,iehr
         ibegs=0.0
         iends=0.0
         ibyr=ibdat/1000
         ibdy=ibdat-ibyr*1000
         ieyr=iedat/1000
         iedy=iedat-ieyr*1000
c ---    Shift start time to beginning of hour
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      elseif(vers.EQ.'1.6a' .OR. vers.EQ.'2.1') then
         read(iunit,*,end=999)ibyr,ibdy,ibhr,ibegs,
     &                        ieyr,iedy,iehr,iends
      else
         write(io6,*)
         write(io6,*)'RDEM3: Invalid Dataset Version for BAEMARB.DAT'
         write(io6,*)'Expected 1.5a, 1.54a, 1.6a, 2.1'
         write(io6,*)'Found: ',vers
         write(*,*)
         stop 'Halted in RDEM3 -- see list file.'
      endif

c --- Enforce YYYY format for year
      call YR4(io6,ibyr,ierrb)
      call YR4(io6,ieyr,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) then
         write(*,*)
         stop 'Halted in RDEM3'
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibegs)
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iends)

c --- Adjust times to BASE TIME ZONE
      ishift=NINT(tzhr)
      call INCR(io6,ibyr,ibdy,ibhr,ishift)
      call INCR(io6,ieyr,iedy,iehr,ishift)

c --- Form date-hour
      ibegh=ibyr*100000+ibdy*100+ibhr
      iendh=ieyr*100000+iedy*100+iehr

c --- Loop over sources
      lproblem = .FALSE.
      nwords=nse3+14
      do i=ibsrc3,iesrc3
         read(iunit,*)cid,(em3dat(n,i),n=1,nwords)
         if(cid.NE.cid3(i)) lproblem=.TRUE.
      enddo

c --- Check for source problem
      if(lproblem) then
         write(io6,*)
         write(io6,*)'RDEM3: Problem with source names in BAEMARB.DAT'
         write(io6,*)'Names in data record do not match header record'
         write(io6,*)'Beginning time: ',ibegh,ibegs
         write(io6,*)'Ending time   : ',iendh,iends
         write(*,*)
         stop 'Halted in RDEM3 -- see list file.'
      endif
c
      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-varying BAEMARB data'
         write(io6,*)'Beginning time: ',ibegh,ibegs
         write(io6,*)'Ending time   : ',iendh,iends
         write(io6,*)'Source Range  : ',ibsrc3,iesrc3
         do i=ibsrc3,iesrc3
            write(io6,*)'I = ',i,'EM3DAT = ',(em3dat(n,i),n=1,nwords)
         enddo
      endif

      return

c --- Reached end of BAEMARB.DAT file
999   ieof=1
      write(*,*)'RDEM3: Data in BAEMARB.DAT file end early'
      write(io6,*)'RDEM3: Data in BAEMARB.DAT file end early'
      return

      end
c----------------------------------------------------------------------
      subroutine RDTIEM4(iunit0,nvl2,nvoldat,i,ibsrc4,iesrc4,avrs4,ldb,
     &                   io6,iox,cid4,ncommout)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                RDTIEM4
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Read the time-invariant records of a VOLEMARB volume
c               source file (arbitrarily-varying properties)
c
c --- UPGRADE
c --- V5.4-V6.1 : 050915 (DGS): Dataset version as character.
c                               Header information is passed to scratch
c                               file.
c                               Process 1 file per call.
c
c --- INPUTS:
c           IUNIT0 - integer    - Fortran unit number for the FIRST
c                                 VOLEMARB file
c             NVL2 - integer    - Number of VOLEMARB volume sources
c          NVOLDAT - integer    - Number of VOLEMARB files
c                I - integer    - Current VOLEMARB file
c  IBSRC4(nvoldat) - integer    - Source ID for first source in each
c                                 VOLEMARB file
c  IESRC4(nvoldat) - integer    - Source ID for last source in each
c                                 VOLEMARB file
c   AVRS4(nvoldat) - char*16    - VOLEMARB data-set version
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c              IOX - integer    - Fortran unit number for scratch file
c         NCOMMOUT - integer    - Currrent number of header comments
c                                 in scratch file
c
c --- OUTPUT:
c       CID4(nvl2) - char*16    - VOLEMARB source identifiers
c         NCOMMOUT - integer    - Updated number of header comments
c                                 in scratch file
c
c --- RDTIEM4 called by: SETUP
c --- RDTIEM4 calls:     none
c----------------------------------------------------------------------
c
      integer ibsrc4(nvoldat),iesrc4(nvoldat)
      character*16 cid4(nvl2),avrs4(nvl2)
      logical ldb

c --- Process file "i"
         iunit=iunit0+i-1

c ---    Loop over sources
         do k=ibsrc4(i),iesrc4(i)
            ii=MIN(k,nvl2)
            if(avrs4(i).EQ.'1.54a') then
               read(iunit,*) cid4(ii),dummy
               write(iox,'(a16,f10.0)') cid4(ii),dummy
               ncommout=ncommout+1
            elseif(avrs4(i).EQ.'1.6a') then
               read(iunit,*) cid4(ii)
               write(iox,'(a16)') cid4(ii)
               ncommout=ncommout+1
            elseif(avrs4(i).EQ.'2.1') then
               read(iunit,*)cid4(ii),dummy
               write(iox,'(a16,f10.0)') cid4(ii),dummy
               ncommout=ncommout+1
            endif
         enddo

c --- Perform final QA after LAST file is processed
      if(i.NE.nvoldat) return

      if(ldb)then
         write(io6,*)
         write(io6,*)
         write(io6,*)'Time-invariant VOLEMARB data (Source IDs)'
         write(io6,*)'-----------------------------------------'
         do k=1,nvl2
            write(io6,*)'I = ',k,'CID4 = ',cid4(k)
         enddo
      endif

c --- Check number of sources
      if(iesrc4(nvoldat).NE.nvl2) then
         write(io6,*)'FATAL Error in RDTIEM4:  Wrong number of sources'
         write(io6,*)'          Control file NVL2 = ',nvl2
         write(io6,*)'VOLEMARB.DAT Time-Invariant = ',iesrc4(nvoldat)
         write(*,*)
         stop 'Halted in RDTIEM4 -- see list file.'
      endif


      return
      end
c----------------------------------------------------------------------
      subroutine RDEM4(iunit,nsrc4,nse4,cid4,ibsrc4,iesrc4,vers,tzhr,
     &                 ldb,io6,ibegh,ibegs,iendh,iends,em4dat,ieof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDEM4
c                J. Scire, D. Strimaitis,  EarthTech
c
c --- PURPOSE:  Read the time-varying records of the VOLEMARB volume
c               source emissions file (arbitrarily-varying emissions)
c
c --- UPDATE
c --- V5.7-V6.1   050915 (DGS): Dataset version 2.1 is added, and other
c                               versions are retained.
c                               Begin/end times include seconds.
c --- V5.5-V5.7   030402 (DGS): Add list file unit to YR4 call
c
c --- INPUTS:
c            IUNIT - integer    - Fortran unit number of VOLEMARB file
c            NSRC4 - integer    - Total number of sources in VOLEMARB
c                                 files
c             NSE4 - integer    - Number of emitted species
c      CID4(nsrc4) - char*16    - Source identifiers
c           IBSRC4 - integer    - Index for 1st source in current file
c           IESRC4 - integer    - Index for Last source in current file
c             VERS - char*16    - Dataset version for file
c             TZHR - real       - Hours to ADD to times in file to
c                                 convert to BASE TIME ZONE
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c
c --- OUTPUT:
c      IBEGH,IBEGS - integer    - Starting time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c      IENDH,IENDS - integer    - Ending time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c EM4DAT(NSE4+6,nsrc4) - real array - Time-varying VOLEMARB source data
c             IEOF - integer    - End-of-file flag
c
c --- RDEM4 called by: INITPUF
c --- RDEM4 calls:     YR4, INCR, TCLOCK
c----------------------------------------------------------------------
c
      real em4dat(nse4+6,nsrc4)
      character*16 cid, cid4(nsrc4), vers
      logical ldb, lproblem

c --- Initialize EOF flag
      ieof=0

c --- Read starting, ending date and time
      if(vers.EQ.'1.54a') then
         read(iunit,*,end=999)ibdat,ibhr,iedat,iehr
         ibegs=0.0
         iends=0.0
         ibyr=ibdat/1000
         ibdy=ibdat-ibyr*1000
         ieyr=iedat/1000
         iedy=iedat-ieyr*1000
c ---    Shift start time to beginning of hour
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      elseif(vers.EQ.'1.6a' .OR. vers.EQ.'2.1') then
         read(iunit,*,end=999)ibyr,ibdy,ibhr,ibegs,
     &                        ieyr,iedy,iehr,iends
      else
         write(io6,*)
         write(io6,*)'RDEM4: Invalid Dataset Version for VOLEMARB.DAT'
         write(io6,*)'Expected 1.54a, 1.6a, 2.1'
         write(io6,*)'Found: ',vers
         write(*,*)
         stop 'Halted in RDEM4 -- see list file.'
      endif

c --- Enforce YYYY format for year
      call YR4(io6,ibyr,ierrb)
      call YR4(io6,ieyr,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) then
         write(*,*)
         stop 'Halted in RDEM4'
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibegs)
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iends)

c --- Adjust times to BASE TIME ZONE
      ishift=NINT(tzhr)
      call INCR(io6,ibyr,ibdy,ibhr,ishift)
      call INCR(io6,ieyr,iedy,iehr,ishift)

c --- Form date-hour
      ibegh=ibyr*100000+ibdy*100+ibhr
      iendh=ieyr*100000+iedy*100+iehr

c --- Loop over sources
      lproblem = .FALSE.
      nwords=nse4+6
      do i=ibsrc4,iesrc4
         read(iunit,*)cid,(em4dat(n,i),n=1,nwords)
         if(cid.NE.cid4(i)) lproblem=.TRUE.
      enddo

c --- Check for source problem
      if(lproblem) then
         write(io6,*)
         write(io6,*)'RDEM4: Problem with source names in VOLEMARB.DAT'
         write(io6,*)'Names in data record do not match header record'
         write(io6,*)'Beginning time: ',ibegh,ibegs
         write(io6,*)'Ending time   : ',iendh,iends
         write(*,*)
         stop 'Halted in RDEM4 -- see list file.'
      endif
c
      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-varying VOLEMARB data'
         write(io6,*)'Beginning time: ',ibegh,ibegs
         write(io6,*)'Ending time   : ',iendh,iends
         write(io6,*)'Source Range  : ',ibsrc4,iesrc4
         do i=ibsrc4,iesrc4
            write(io6,*)'I = ',i,'EM4DAT = ',(em4dat(n,i),n=1,nwords)
         enddo
      endif

      return

c --- Reached end of VOLEMARB.DAT file
999   ieof=1
      write(*,*)'RDEM4: Data in VOLEMARB.DAT file end early'
      write(io6,*)'RDEM4: Data in VOLEMARB.DAT file end early'
      return
      end

c----------------------------------------------------------------------
      subroutine RDTIEM5(iunit,mxrise,nsrc5,ldb,io6,iox,cid,ncommout,
     &                   mxnseg,nlrise)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                RDTIEM5
c                J. Scire, D. Strimaitis    EARTH TECH
c
c --- PURPOSE:  Read the time-invariant records of the LNEMARB buoyant
c               line source data file (arbitrarily-varying emissions)
c
c --- UPDATE
c --- V5.4-V6.1 : 050915  (DGS): Header information is passed to scratch
c                                file.
c --- V5.3-V5.4 : 000602  (DGS): add message to "stop"
c
c --- INPUTS:
c            IUNIT - integer    - Fortran unit number of LNEMARB file
c           MXRISE - integer    - Max number of distances for trans rise
c            NSRC5 - integer    - Number of sources (individual lines)
c                                 in the LNEMARB file
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c              IOX - integer    - Fortran unit number for scratch file
c         NCOMMOUT - integer    - Currrent number of header comments
c                                 in scratch file
c
c --- OUTPUT:
c              CID - char array - line source names
c         NCOMMOUT - integer    - Updated number of header comments
c                                 in scratch file
c           MXNSEG - integer    - Max number of segments for one line
c           NLRISE - integer    - Number of distances for transitional
c                                 rise
c
c --- RDTIEM5 called by: SETUP
c --- RDTIEM5 calls:     none
c----------------------------------------------------------------------
c
      character*16 cid(nsrc5)
      logical ldb
c
      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-invariant LNEMARB data'
      endif
c
c --- Set number of segments and number of transitional rise distances
      read(iunit,*)mxnseg,nlrise
      write(iox,'(2i10)') mxnseg,nlrise
      ncommout=ncommout+1
      if(LDB) write(io6,*)'MXNSEG, NLRISE = ',mxnseg,nlrise
c
c --- Check number of points used to tabulate buoyant rise
      if(nlrise.gt.mxrise)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDTIEM5 -- too many points ',
     1   'for rise table -- ','NLRISE = ',nlrise,' MXRISE = ',mxrise
         write(*,*)
         stop 'Halted in RDTIEM5 -- see list file.'
      endif
c
c --- Loop over line sources
      read(iunit,*)cid
      write(iox,'(a16)') cid
      ncommout=ncommout+nsrc5
      if(LDB) then
         do i=1,nsrc5
            write(io6,*)'I = ',i,'  CID = ',cid(i)
         enddo
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine RDEM5(iunit,ngrp5,nsrc5,nse5,cid5,vers,tzhr,
     &                 ldb,io6,ibegh,ibegs,iendh,iends,lngrp,idline,
     &                 em5dat,em5grp,ieof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDEM5
c                J. Scire, D. Strimaitis   EARTH TECH
c
c --- PURPOSE:  Read the time-varying records of the LNEMARB buoyant
c               line source data file (arbitrarily-varying emissions)
c
c --- UPDATE
c --- V5.7-V6.1   050915 (DGS): Dataset version 2.1 is added, and other
c                               versions are retained.
c                               Begin/end times include seconds.
c --- V5.5-V5.7   030402  (DGS): Add list file unit to YR4 call
c --- V5.2-V5.4 : 000602  (DGS): YYYY format for year
c --- V5.0-V5.2 : 991104  (DGS): YYYY format for year
c
c --- INPUTS:
c            IUNIT - integer    - Fortran unit number of LNEMARB file
c            NGRP5 - integer    - Max number of groups in LNEMARB file
c            NSRC5 - integer    - Max number of lines in  LNEMARB file
c             NSE5 - integer    - Number of emitted species
c      CID5(nsrc5) - integer ar - Line source names
c             VERS - char*16    - Dataset version for file
c             TZHR - real       - Hours to ADD to times in file to
c                                 convert to BASE TIME ZONE
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c              IO6 - integer    - Fortran unit number for debug output
c
c --- OUTPUT:
c      IBEGH,IBEGS - integer    - Starting time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c      IENDH,IENDS - integer    - Ending time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH & SSSS)
c                                 in BASE TIME ZONE
c            LNGRP - integer    - Number of groups of line sources
c                                 active this period
c    IDLINE(nsrc5) - integer ar - Line source ID for each line
c                                 active this period
c  EM5DAT(NSE5+6,nsrc5)
c                  - real array - Time-varying LNEMARB line data
c  EM5GRP(7,ngrp5) - real array - Time-varying LNEMARB group data
c
c --- RDEM5 called by: INITPUF
c --- RDEM5 calls:     YR4, INCR, TCLOCK
c----------------------------------------------------------------------
c
      real em5dat(nse5+6,nsrc5)
      real em5grp(7,ngrp5)
      character*16 cid,cid5(nsrc5), vers
      integer idline(nsrc5)
      logical ldb

c --- Initialize EOF flag
      ieof=0

c --- Read starting, ending date and time
      if(vers.EQ.'1.54a') then
         read(iunit,*,end=999)ibdat,ibhr,iedat,iehr
         ibegs=0.0
         iends=0.0
         ibyr=ibdat/1000
         ibdy=ibdat-ibyr*1000
         ieyr=iedat/1000
         iedy=iedat-ieyr*1000
c ---    Shift start time to beginning of hour
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      elseif(vers.EQ.'2.1') then
         read(iunit,*,end=999)ibyr,ibdy,ibhr,ibegs,
     &                        ieyr,iedy,iehr,iends
      else
         write(io6,*)
         write(io6,*)'RDEM5: Invalid Dataset Version for LNEMARB.DAT'
         write(io6,*)'Expected 1.54a, 2.1'
         write(io6,*)'Found: ',vers
         write(*,*)
         stop 'Halted in RDEM5 -- see list file.'
      endif

c --- Enforce YYYY format for year
      call YR4(io6,ibyr,ierrb)
      call YR4(io6,ieyr,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) then
         write(*,*)
         stop 'Halted in RDEM5'
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibegs)
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iends)

c --- Adjust times to BASE TIME ZONE
      ishift=NINT(tzhr)
      call INCR(io6,ibyr,ibdy,ibhr,ishift)
      call INCR(io6,ieyr,iedy,iehr,ishift)

c --- Form date-hour
      ibegh=ibyr*100000+ibdy*100+ibhr
      iendh=ieyr*100000+iedy*100+iehr

c --- Read number of groups of line sources
      read(iunit,*)lngrp
      if(lngrp.GT.ngrp5) then
         write(io6,10)lngrp,ngrp5
10       format(/1x,'ERROR in SUBR. RDEM5 -- No. line groups',
     1   ' in LNEMARB file exceeds current array dimension'/1x,
     2   '          No. line groups in file: ',i5/1x,
     3   'Current Array dimension (MXLNGRP): ',i5)
         write(*,*)
         stop 'Halted in RDEM5 -- see list file.'
      endif
c
      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-varying LNEMARB data'
         write(io6,*)'Beginning time: ',ibegh,ibegs
         write(io6,*)'Ending time   : ',iendh,iends
      endif
c
c --- Loop over groups
      nlines=0
      do ig=1,lngrp
c ---    Get group parameters
         read(iunit,*)(em5grp(n,ig),n=1,7)
         if(ldb)then
            write(io6,*)
            write(io6,*)'Group  = ',ig
            write(io6,*)'EM5GRP = ',(em5grp(n,ig),n=1,7)
            write(io6,*)
            write(io6,*)'Line,  EM5DAT = '
         endif
c
c ---    Test total number of lines so far
         nlprev=nlines
         nlines=nlines+em5grp(1,ig)
         if(nlines.GT.nsrc5) then
            write(io6,11)nlines,nsrc5
11          format(/1x,'ERROR in SUBR. RDEM5 -- Total no. lines',
     1      ' in LNEMARB file exceeds total expected'/1x,
     2      '    No. lines this period in file: ',i5/1x,
     3      '            Total expected (NLN2): ',i5)
            write(*,*)
            stop 'Halted in RDEM5 -- see list file.'
         endif
c
c ---    Loop over lines in group
         nwords=nse5+6
         do i=nlprev+1,nlines
            read(iunit,*)cid,(em5dat(n,i),n=1,nwords)
c ---       Check for valid source name and assign ID
            idline(i)=-1
            do isrc=1,nsrc5
               if(cid.EQ.cid5(isrc)) idline(i)=isrc
            enddo
            if(idline(i).LT.0) then
               write(io6,12)cid
12             format(/1x,'ERROR in SUBR. RDEM5 -- Invalid line source',
     1         ' name found in LNEMARB file'/1x,
     2         '   Line Source Name Found in file: ',a16/1x,
     3         '   List of valid names     (CID5): ')
               write(io6,*)cid5
               write(*,*)
               stop 'Halted in RDEM5 -- see list file.'
            endif
         enddo
c
         if(ldb)then
            do i=nlprev+1,nlines
               write(io6,*) i,idline(i),(em5dat(n,i),n=1,nwords)
            enddo
         endif
      enddo
c
      return

c --- Reached end of LNEMARB.DAT file
999   ieof=1
      write(*,*)'RDEM5: Data in LNEMARB.DAT file end early'
      write(io6,*)'RDEM5: Data in LNEMARB.DAT file end early'
      return
      end
c----------------------------------------------------------------------
      subroutine readcf(title,itest)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                 READCF
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Read the free-formatted control file (IO5)
c
c --- UPDATE
c --- V6.25-V6.26  080430  (DGS): Add numerical rise output data option
c                                 (INRISE)
c                                 Add choice of point source plume rise
c                                 option (MRISE)
c --- V6.24-V6.25  080227  (DGS): Add NLUTIBL (number of cells) for 
c                                 search radius in TIBL module
c --- V6.21-V6.24  080208  (DGS): Add MPARTLBA switch to toggle MPARTL
c                                 application to buoyant areas
c --- V6.2-V6.21   070801  (DGS): Add sigma-z cap (SZCAP_M) in
c                                 /COMPARM/ (group 12)
c --- V6.11-V6.2   070629  (DGS): Always write control file variables
c                                 to the list file to confirm values
c                                 used
c                  070629  (DGS): Initialize IGRDVL = 0
c --- V6.1-V6.11   060309  (DGS): Add minimum overwater svmin,swmin
c --- V5.751-V6.1  050915  (DGS): start-time is clock time at beginning
c                                 of first period, and the run length is
c                                 replaced with an end-date/time
c                                 (group 1)
c                          (DGS): add Length of Time-Step (seconds)
c                                 (group 1)
c                          (DGS): Force number of timesteps in output
c                                 to be IAVG=1, and do not place in
c                                 the control file
c --- V5.75-V5.751 050805  (DGS): Add turbulence advection option for
c                                 including advection effects with
c                                 decay to modify the local sigma-v and
c                                 sigma-w for puff growth (MDISP=2)
c --- V5.741-V5.75 050225  (DGS): Add building downwash option for
c                                 elevated structures
c                  050225  (DGS): Add MCTURB to select method for
c                                 computing turbulence sigmas-(v,w)
c                  050225  (DGS): Add MTAULY to set the Lagrangian time
c                                 scale for lateral growth for Draxler
c                                 Fy functions (MDISP=1,2)
c --- V5.724-V5.725 050128 (DGS): Add call to COORDSVER and write info
c                                 to list file
c                  050128  (DGS): Add IT2D control for creating a 2D
c                                 temperature file
c                  050128  (DGS): Add IRHO control for creating a 2D
c                                 density file
c --- V5.74-V5.741 040913  (DGS): Add puff-age cutoff control MXAGEHR
c                                 in Group 12.
c --- V5.73-V5.74  040715  (DGS): add MPRFFM flag to distinguish the
c                                 CTDM and AERMET PROFILE.DAT formats
c --- V5.72-V5.73  040611  (DGS): add MTILT flag
c                                 change variable NINT to NPSINT
c --- V5.71-V5.72  031017  (DGS): add MSOURCE flag, and place source
c                                 names into common as c*16;
c                                 update c*12 to c*16 for source names
c ---              031017  (DGS): add QA plot file flag (IQAPLOT)
c --- V5.701-V5.71 030528  (DGS): add MDEPBC, HTMINBC, RSAMPBC in
c                                 Group 12
c                  030528  (DGS): Trap zero bldg length with MBDW=2
c                  030528  (DGS): assign rlat0,rlon0 variables
c                  030528  (DGS): require non-negative emissions
c --- V5.5-V5.7    030402  (DGS): rdate changed to include YYYY
c                                 format for year (MM-DD-YYYY)
c                  030402  (DGS): New map projection and datum
c                                 specification
c                  030402  (DGS): Do not close control file
c                  030402  (DGS): add PRIME option and the new
c                                 building data arrays;
c                                 include TRAJINCL as possible input
c --- V5.4-V5.5    010730_1(DGS): allow initial sigmas less than symin
c                                 and szmin
c --- V5.4-V5.4    000602_4(DGS): remove XLAT,XLONG,XTZ variables from
c                                 Input Group 4, and add XBTZ to Input
c                                 Group 1 (store in /DATEHR/)
c --- V5.4-V5.4    000602_4(DGS): monthly BCKO3M, BCKNH3M, BCKH2O2M
c --- V5.4-V5.4    000602_3(DGS): add aqueous chemistry option
c --- V5.3-V5.4    000602  (DGS): replace VOLEM.DAT inputs with
c                                 VOLEMARB.DAT inputs
c                  000602  (DGS): allow multiple PTEMARB, BAEMARB,
c                                 and VOLEMARB files
c                  000602  (DGS): add message to "stop"
c                  000602  (DGS): add horizontal splitting controls
c                  000602  (DGS): add FOG module (MFOG=1,2)
c --- V5.3-V5.3    991222b (DGS): revise FMFAC input (bug)
c --- V5.3-V5.3    991222b (DGS): add FMFAC to adjust point source 
c                                 momentum rise
c --- V5.2-V5.3    991222  (DGS): add boundary condition (BC) option &
c                                 store IQNEXT in /COMPARM/
c --- V5.1-V5.2    991104  (DGS): enforce YYYY format for year
c                  991104  (DGS): add metric tons for emission units
c                  991104  (DGS): add DSRISE (numerical rise) to
c                                 control file
c --- V5.0-V5.1    990625b (DGS): add PGTIME; drop MMODEL options
c --- V5.0-V5.0    990228e (DGS): add 3 new TIBL parameters
c --- V5.0-V5.0    990228d (DGS): add mass balance output option
c                  990228d (DGS): add IPFDEB to input group 5
c                  990228d (DGS): use WRIVL for list file banner
c --- V5.0-V5.0    990228c (DGS): add mass flux output option
c --- V5.0-V5.0    990228b (DGS): add discrete receptor ht above ground
c --- V5.0-V5.0    990228  (DGS): Change CDIV to CDIV(2)
c --- V5.0-V5.0    980918  (DGS): add SOA module data (MCHEM=4)
c --- V5.0-V5.0    980821  (DGS): add NCOUNT for transport wind during
c                                 rise
c --- V5.0-V5.0    980731  (DGS): add temp arrays for SVMIN & SWMIN
c --- V5.0-V5.0    980722  (DGS): SVMIN & SWMIN by stability class
c --- V5.0-V5.0    980515  (DGS): add MSGTIBL option to /FLAGS/ (group 2)
c --- V5.0-V5.0    980304  (DGS): source names increased C*6 to C*12
c                                 add initial sigmay,z input for points
c                                 add RESTART option
c                                 add lat,lon,elevation for single met
c --- V4.0-V5.0    971107  (DGS): add METRUN (group 1)
c                                 add Species Group Option
c                                     (groups 3,5)
c                                 add Units Option for List File Output
c                                     (group 5)
c                                 add User-Specified Wind Speed Categories
c                                     (group 12)
c                                 add Units Option for Emissions Input
c                                     (groups 13-16)
c                                 add Source Names for all related inputs
c                                 add Variable Emissions Option
c                                     (groups 13-16)
c                                 reverse order of elements in storing
c                                     vertex coordinates for area and
c                                     line sources
c                                 redefine wscalm as 0.99999*wscalm to
c                                     assure smallest valid speed is
c                                     treated properly
c                                 add EPSSLUG & EPSAREA to /COMPARM/
c                                     data read from control file
c                                 add option for variable line source
c                                     file (LNEMARB.DAT)
c                                 add MPDF option to /FLAGS/ (group 2)
c                                 add CDIV to /COMPARM/ (group 12)
c                                 add MTINV option to /FLAGS/ (group 2)
c --- V4.0-V5.0    971107  (JCC): clear temp array for area source name
c
c --- INPUTS:
c     Common block /GEN/:
c           CSPEC(mxspec), CGRUP(mxgrup)
c     Common block /QA/:
c           VER, LEVEL
c     Parameters:
c           MXSG, MXVAR, MXSPEC, MXGRUP, MXNZ, IO5, IO6, MXNZP1, MXP3,
c           MXP6, MXP8, MX2, MX5, MXAREA, MXHILL, MXPNT1, MXRECT, MXREC,
c           MXLINES, MXVERT, MXVERTP1, MXVOL, MMODEL
c
c --- OUTPUT:
c       TITLE(3) - char*80    - Run title (3 lines of 80 characters)
c          ITEST - integer    - Flag indicating if execution is to
c                                proceed beyond SETUP phase
c                                (ITEST = 1 to STOP program after
c                                           SETUP phase,
c                                 ITEST = 2 to CONTINUE execution)
c
c     Common block /AR1/
c           XAR1GRD(mxvertp1,mxarea),YAR1GRD(mxvertp1,mxarea),
c           HTAR1(mxarea),ELAR1(mxarea),SZ0AR1(mxarea),
c           QAR1(mxspec,mxarea),NAR1,AREA1(mxarea),
c           IARU, ivar1(mxspec,mxar1), iq12ar1(mxspec,mxar1),
c           cnamar1(mxarea)
c     Common block /AR2/
c           NAR2
c     Common block /BCS/
c           MDEPBC,HTMINBC,RSAMPBC
c     Common block /CHEMDAT/:
c           MOZ, BCKO3M(12), BCKNH3M(12), RNITE1, RNITE2, RNITE3,
c           MH2O2, BCKH2O2M(12),
c           BCKPMF(12),OFRAC(12),VCNX(12)
c     Common block /COMPARM/:
c           XMXLEN, MXNEW, XSAMLEN, MXSAM, SL2PF, CDIV,
c           WSCALM,WSCAT(5),TCCAT(11),VQFAC(12,mxq12),IQNUM(5),IQNEXT,
c           SVMIN(6,2),SWMIN(6,2),SYMIN,SZMIN,SZCAP_M,XMINZI,XMAXZI,
c           PLX0(6), PTG0(2), PPC(6), TBD, TIBLDIST(3), NLUTIBL,
c           NSPLIT, IRESPLIT(24), ZISPLIT, ROLDMAX,
c           NSPLITH, SYSPLITH, CNSPLITH(mxspec),SHSPLITH,
c           EPSSLUG, EPSAREA, NCOUNT, DSRISE,TRAJINCL
c           TIBLDIST(3), MXAGEHR,TSECMAX,LAGE
c     Common block /CSIGMA/:
c           TYIDR
c     Common block /CTSGDAT/:
c           NHILL, NCTREC, MHILL, HILLDAT(11,mxhill), XRCT(mxrect),
c           YRCT(mxrect), ELRECT(mxrect), IHILL(mxrect),
c           XHILL2M,ZHILL2M,XCTDMKM,YCTDMKM,XMETCT0M,YMETCT0M
c     Common block /DATEHR/:
c           XBTZ
c     Common block /DISPDAT/:
c           SYTDEP, JSUP, CONK1, CONK2, IURB1, IURB2, AVET, PGTIME
c     Common block /DRYGAS/:
c           RCUTR, RGR, REACTR, PCONST, BMIN, BMAX, QSWMAX,
c           DCONST1, DCONST2, DCONST3
c     Common block /DRYPART/:
c           DCONST4, NPSINT
c     Common block /DRYDEP/:
c           IVEG
c     Common block /FLAGS/:
c           MGAUSS, MCTADJ, MCTSG, MSLUG, MTRANS, MTIP, MSHEAR, MSPLIT,
c           MCHEM, MWET, MDRY, MDISP, MDISP2, MTURBVW, MBCON,
c           MROUGH, MPARTL, MTINV, MHFTSZ, MPDF, MSGTIBL, MREG, MFOG,
c           MAQCHEM, MBDW, MTILT, MCTURB, MTAULY, MTAUADV,
c           MPARTLBA, MRISE
c     Common block /FILNAM/:
c           puflst, nptdat, nardat, nvoldat
c     Common block /GEN/:
c           IBYR, IBMO, IBDY, IBHR, IBSEC, NSECDT, IRLG, IAVG,
c           IBDATHR, IEDATHR, IESEC, NSPEC, NSE, NGRUP,
c           METFM, METRUN, MRESTART, NRESPD, CSPEC(mxspec),
c           CGRUP(mxgrup), ISPLST(4,mxspec), XMOL(mxspec),
c           ISPGRP(mxspec), MPRFFM
c     Common block /GRID/:
c           NX, NY, NZ, DGRID, DGRIDI, XORIG, YORIG, ZFACE(mxnzp1),
c           XTZ, IBCOMP, JBCOMP, IECOMP, JECOMP,
c           LSAMP, IBSAMP, JBSAMP, IESAMP, JESAMP, MESHDN
c     Common block /LN1/:
c           XL,HBL,WBL,WML,DXL,FPRIMEL,XLBEGGRD(mxlines),
c           YLBEGGRD(mxlines),XLENDGRD(mxlines),YLENDGRD(mxlines),
c           HSL(mxlines),BELEVL(mxlines),
c           XVERTL(4,mxlines),YVERTL(4,mxlines),
c           XLBAR,YLBAR,ORIENTL,MXNSEG,
c           QTL(mxspec,mxlines),BELEVL(mxlines),NLRISE,
c           ILNU, ivln1(mxspec,mxlines), iq12ln1(mxspec,mxlines),
c           cnamln1(mxlines)
c     Common block /LN2/:
c           NLN2
c     Common block /MAP/:
c           lutm,llcc,lps,lem,llaza,lttm,
c           iutmzn,feast,fnorth,
c           rnlat0,relon0,rlat0,rlon0,xlat1,xlat2,
c           pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2
c     Common block /METHD/:
c           ANEMHT, ISIGMAV, IMIXCTDM, ILANDUIN, Z0IN, XLAIIN,
c           ELEVIN, XLATIN, XLONIN
c           XLATSS(mxss), XLONSS(mxss)
c     Common block /NONGRD/:
c           NREC, XNG(mxrec), YNG(mxrec), ZNG(mxrec), ELEVNG(mxrec)
c     Common block /OUTPT/:
c           ICON,IDRY,IWET,ICPRT,IDPRT,IWPRT,ICFRQ,IDFRQ,IWFRQ,IPRTU,
c           IOUTOP(7,mxspec),IMESG,IOMESG,IVIS,LDEBUG,IPFDEB,NPFDEB,
c           NN1,NN2,IMFLX,IMBAL,IFOG,LCOMPRS,IQAPLOT,MSOURCE,IT2D,IRHO,
c           INRISE
c     Common block /PT1/:
c           XPT1GRD(mxpt1),YPT1GRD(mxpt1),ELSTAK(mxpt1),HTSTAK(mxpt1),
c           DIAM(mxpt1),EXITW(mxpt1),TSTAK(mxpt1), IDOWNW(mxpt1),
c           QSTAK(mxspec,mxpt1), NPT1, BWIDTH(36,mxpt1), BHT(36,mxpt1),
c           BLN1(36,mxpt1), XBADJ1(36,mxpt1), YBADJ1(36,mxpt1),
c           IPTU, ivpt1(mxspec,mxpt1), iq12pt1(mxspec,mxpt1),
c           SYIPT1(mxpt1),SZIPT1(mxpt1),FMFPT1(mxpt1),ZPLATPT1(mxpt1),
c           cnampt1(mxpt1)
c     Common block /PT2/:
c           NPT2
c     Common block /WETDAT/:
c           WA(2,mxspec)
c     Common block /VOL1/:
c           XVL1GRD(mxvol),YVL1GRD(mxvol),HTVL1(mxvol),
c           ELVL1(mxvol),SY0VL1(mxvol),SZ0VL1(mxvol),QVL1(mxspec,mxvol),
c           NVL1,
c           IVLU, ivvl1(mxspec,mxvol), iq12vl1(mxspec,mxvol),
c           cnamvl1(mxvol)
c     Common block /VOL2/:
c           NVL2
c
c --- READCF called by:  SETUP
c --- READCF calls:      READFN, READIN, QAINP, WRIVL, QAYR4, YR4C,
c                        QAFOG, NIMADATE, COORDSVER
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
      include 'params.cal'
c
      real dryg(5,mxspec),dryp(2,mxspec)
      real ctrdat(4)
      real pt1data(mxp8),recwrk(4),pt1sigs(2)
      real ardata(mxp3)
      real xvert(mxvert),yvert(mxvert)
      real vldata(mxp6)
      real xlndata(mxp6)
      real bwtemp(36),bhtemp(36),bltemp(36),bxtemp(36),bytemp(36)
      real svtemp(12),swtemp(12)
      real vqtemp(96,mxspec)
      real cstemp(mxspec)
      real qunits(7)
      character*12 qnam1(7),qnam2(7)
      character*80 title(3)
      character*50 verdoc
c --- Names for sources
      character*16 cnamsrc
      character*4 ctemp12(12),ctemp16(16)
      logical lecho,problem,lmatch,lqneg
c *** Note equivalencing of variable dictionary,length & type arrays
      character*12 cvdic(mxvar,mxsg)
      character*12 cvdic1(mxvar,10),cvdic2(mxvar,20),cvdic3(mxvar,2)
      integer ivleng(mxvar,mxsg)
      integer ivleng1(mxvar,10),ivleng2(mxvar,20),ivleng3(mxvar,2)
      integer ivtype(mxvar,mxsg)
      integer ivtype1(mxvar,10),ivtype2(mxvar,20),ivtype3(mxvar,2)
      equivalence(cvdic(1,1),cvdic1(1,1))
      equivalence(cvdic(1,11),cvdic2(1,1))
      equivalence(ivleng(1,1),ivleng1(1,1))
      equivalence(ivleng(1,11),ivleng2(1,1))
      equivalence(ivtype(1,1),ivtype1(1,1))
      equivalence(ivtype(1,11),ivtype2(1,1))
c ***
c --- Temp variables for map inputs
      character*4 clatlon(16,4)
      character*4 cpmap(8),cdatum(8)
c
c --- Include common blocks
      include 'ar1.puf'
      include 'ar2.puf'
      include 'bcs.puf'
      include 'chemdat.puf'
      include 'comparm.puf'
      include 'csigma.puf'
      include 'ctsgdat.puf'
      include 'datehr.puf'
      include 'dispdat.puf'
      include 'drygas.puf'
      include 'drypart.puf'
      include 'drydep.puf'
      include 'flags.puf'
      include 'filnam.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'map.puf'
      include 'methd.puf'
      include 'nongrd.puf'
      include 'outpt.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'qa.puf'
      include 'vol1.puf'
      include 'vol2.puf'
      include 'wetdat.puf'
c
      data dryg/mx5*-999./,dryp/mx2*-999./
      data lecho/.true./

c --- Identify input groups with letters as continuation character;
c --- and input subgroups with numbers as continuation character.

      data cvdic1/
     a  'IBYR','IBMO','IBDY','IBHR','IBMIN','IBSEC','IEYR','IEMO',
     a  'IEDY','IEHR','IEMIN','IESEC','NSECDT','IRLG','XBTZ',
     a  'NSPEC','NSE','ITEST','METFM','AVET','PGTIME','METRUN',
     a  'MRESTART','NRESPD','MPRFFM', 35*' ',
     b  'MGAUSS','MCTADJ','MCTSG','MSLUG','MTRANS','MCHEM','MWET',
     b  'MDRY','MDISP','MDISP2','MTURBVW','MROUGH','MTIP',
     b  'MSHEAR','MSPLIT','MPARTL','MTINV','MPDF','MSGTIBL',
     b  'MBCON','MSOURCE','MFOG','MAQCHEM','MBDW','MREG',
     b  'MTILT','MCTURB','MTAULY','MTAUADV','MPARTLBA',
     b  'MRISE',  29*' ',
     c  60*' ',
     d  'PMAP','DATUM','FEAST','FNORTH','IUTMZN','UTMHEM',
     d  'RLAT0','RLON0','XLAT1','XLAT2',
     d  'NX','NY','NZ','ZFACE','DGRIDKM','XORIGKM','YORIGKM',
     d  'XLAT','XLONG','XTZ','IBCOMP','JBCOMP','IECOMP','JECOMP',
     d  'LSAMP','IBSAMP','JBSAMP','IESAMP','JESAMP','MESHDN',30*' ',
     e  'ICON','IDRY','IWET','IVIS','ICPRT','IDPRT','IWPRT','ICFRQ',
     e  'IDFRQ','IWFRQ','IMESG','LDEBUG','IPFDEB','NPFDEB','NN1','NN2',
     e  'IPRTU','IMFLX','IMBAL','LCOMPRS','IQAPLOT','IT2D',
     e  'IRHO','INRISE',36*' ',
c ---  (Note: the 36*' ' above includes mxspec entries)
     f  'NHILL','NCTREC','MHILL','XHILL2M','ZHILL2M',
     f  'XCTDMKM','YCTDMKM',53*' ',
     2  'HILL',59*' ',
     3  'CTREC',59*' ',
     g  60*' ',
     h  60*' '/

        data cvdic2/
     i  'RCUTR','RGR','REACTR','PCONST','BMIN','BMAX','QSWMAX',
     i  'DCONST1','DCONST2','DCONST3','DCONST4','NINT','IVEG',47*' ',
     j  60*' ',
     k  'MOZ','BCKO3','BCKNH3','RNITE1','RNITE2','RNITE3',
     k  'MH2O2','BCKH2O2','BCKPMF','OFRAC','VCNX',49*' ',
     l  'SYTDEP','MHFTSZ','JSUP','CONK1','CONK2','IURB1','IURB2',
     l  'XMXLEN','MXNEW','SYMIN','SZMIN','XSAMLEN','MXSAM','XMINZI',
     l  'XMAXZI','SL2PF','SVMIN','SWMIN','WSCALM','WSCAT','PLX0',
     l  'PTG0','PPC','TBD','NSPLIT','IRESPLIT','ZISPLIT','ROLDMAX',
     l  'ANEMHT','ISIGMAV','IMIXCTDM','ILANDUIN','Z0IN','XLAIIN',
     l  'ELEVIN','XLATIN','XLONIN','EPSSLUG','EPSAREA','CDIV',
     l  'NCOUNT','NSS','XLATSS','XLONSS','TIBLDIST','DSRISE',
     l  'NSPLITH','SYSPLITH','SHSPLITH','CNSPLITH','TRAJINCL',
     l  'MDEPBC','HTMINBC','RSAMPBC','MXAGEHR','SZCAP_M',
     l  'NLUTIBL', 3*' ',
     m  'NPT1','NPT2','IPTU','NSPT1',56*' ',
     2  'X','SIGYZI','FMFAC','ZPLTFM','SRCNAM',55*' ',
     3  'WIDTH','HEIGHT','LENGTH','XBADJ','YBADJ','SRCNAM',54*' ',
     4  'SRCNAM','IVARY',58*' ',
c ---  (Note: the 58*' ' above includes mxspec entries)
     n  'NAR1','NAR2','IARU','NSAR1',56*' ',
     2  'X','SRCNAM',58*' ',
     3  'XVERT','YVERT','SRCNAM',57*' ',
     4  'SRCNAM','IVARY',58*' ',
c ---  (Note: the 58*' ' above includes mxspec entries)
     o  'NLINES','XL','HBL','WBL','WML','DXL','FPRIMEL','MXNSEG',
     o  'NLRISE','ILNU','NSLN1','NLN2',48*' ',
     2  'X','SRCNAM',58*' ',
     3  'SRCNAM','IVARY',58*' ',
c ---  (Note: the 58*' ' above includes mxspec entries)
     p  'NVL1','NVL2','IVLU','NSVL1',
c ---  (Note: retain VOLEM.DAT variables for reading old files)
     p  'IGRDVL','VEFFHT','VSIGYI','VSIGZI',  52*' ',
     2  'X','SRCNAM',58*' ',
     3  'SRCNAM','IVARY',58*' ',
c ---  (Note: the 58*' ' above includes mxspec entries)
     q  'NREC',59*' ',
     2  'X',59*' '/

      data cvdic3/
     c  'CSPEC', 59*' ',
     2  'CGRUP', 59*' '/

      data ivleng1/
     a             25*1, 35*0,
     b             31*1, 29*0,
     c             60*0,
     d             2*8,4*1,4*16,3*1, mxnzp1, 16*1, 30*0,
     e             24*1, 36*0,
c ---             (Note: the 36*0 must include mxspec entries)
     f             7*1, 53*0,
     2             11, 59*0,
     3             4, 59*0,
     g             60*0,
     h             60*0/
      data ivleng2/
     i             13*1, 47*0,
     j             60*0,
     k             1,2*12,4*1,4*12, 49*0,
     l             16*1,2*12,1,5,6,2,6,1,1,24,13*1,2,2*1,2*mxss,
     l             3,4*1,mxspec,7*1, 3*0,
     m             4*1, 56*0,
     2             mxp8,2,2*1,16, 55*0,
     3             36, 36, 36, 36, 36, 16, 54*0,
     4             16,1, 58*0,
c ---             (Note: the 58*0 above includes mxspec entries)
     n             4*1, 56*0,
     2             mxp3,16, 58*0,
     3             mxvert,mxvert,16, 57*0,
     4             16,1, 58*0,
c ---             (Note: the 58*0 above includes mxspec entries)
     o             12*1, 48*0,
     2             mxp6,16, 58*0,
     3             16,1, 58*0,
c ---             (Note: the 58*0 above includes mxspec entries)
     p             8*1, 52*0,
     2             mxp6,16, 58*0,
     3             16,1, 58*0,
c ---             (Note: the 58*0 above includes mxspec entries)
     q             1, 59*0,
     2             4, 59*0/
      data ivleng3/
     c             12, 59*0,
     2             12, 59*0/

c --- Variable types (ivtype) are coded as:
c          0 = null
c          1 = real
c          2 = integer
c          3 = logical
c          4 = character
      data ivtype1/
     a             14*2, 1, 4*2, 2*1, 4*2, 35*0,
     b             27*2,1,3*2, 29*0,
     c             60*0,
     d             2*4,2*1,2,5*4,3*2,4*1,3*1,4*2,3,5*2, 30*0,
     e             11*2, 3, 7*2, 3, 4*2, 36*0,
c ---             (Note:  the 36*0 must include mxspec type 2 entries)
     f             3*2, 4*1, 53*0,
     2             1, 59*0,
     3             1, 59*0,
     g             60*0,
     h             60*0/
      data ivtype2/
     i             11*1, 2*2, 47*0,
     j             60*0,
     k             2, 5*1, 2, 4*1, 49*0,
     l             1,2*2,2*1,2*2,1,2,3*1,2,11*1,2*2,3*1,3*2,8*1,
     l             2,2,4*1,2,4*1,2,2*1,2,1,2, 3*0,
     m             4*2, 56*0,
     2             4*1,4, 55*0,
     3             5*1,4, 54*0,
     4             4,2, 58*0,
c ---             (Note:  the 58*0 includes mxspec entries of type 1)
     n             4*2, 56*0,
     2             1,4, 58*0,
     3             2*1,4, 57*0,
     4             4,2, 58*0,
c ---             (Note:  the 58*0 includes mxspec entries of type 1)
     o             2, 6*1, 5*2, 48*0,
     2             1,4, 58*0,
     3             4,2, 58*0,
c ---             (Note:  the 58*0 includes mxspec entries of type 1)
     p             5*2, 3*1, 52*0,
     2             1,4, 58*0,
     3             4,2, 58*0,
c ---             (Note:  the 58*0 includes mxspec entries of type 1)
     q             2, 59*0,
     2             1, 59*0/
      data ivtype3/
     c             4, 59*0,
     2             4, 59*0/
c
c --- Set array of emission rate conversion factors to convert user
c --- units to g/s (or g/s/m**2)
      data qunits/1.0,       0.2777778, 0.1260,
     &            0.0287671, 1.0,       0.0166667,
     &            0.0317098/
c --- Name those factors
      data qnam1/'    g/s     ','  kg/hr     ','  lb/hr     ',
     &           'tons/yr     ','  OUV/s     ','OUV/min     ',
     &           'met. tons/yr'/
      data qnam2/'    g/s/m^2 ','  kg/hr/m^2 ','  lb/hr/m^2 ',
     &           'tons/yr/m^2 ','  OUV/s/m^2 ','OUV/min/m^2 ',
     &           'm.tons/y/m^2'/

c
c --- Set "problem" marker to FALSE
      data problem/.FALSE./

c --- Initialize OLD number of VOLEM volume sources to ZERO
      igrdvl=0
c
c --- read/write title (First 3 lines of the control file)
      read(io5,102)title
102   format(a80/a80/a80)
c
c --- Get NIMA date for datum transformation parameters
      call NIMADATE(daten)
c
c ----------------------------------------------
c --- Read file names from control file - IG # 0
c ----------------------------------------------
      call readfn
c
c --- Open the output LIST file
      open(io6,file=puflst,status='unknown')
c
c --- write page header
      call WRIVL(io6,mmodel,ver,level)
c
c --- write clock date/time of run
      write(io6,1402)rtime,rdate
1402  format(//2x,'Clock time: ',a8/
     1         2x,'      Date: ',a10)

c --- Obtain COORDS version information
      call COORDSVER(io6,verdoc)
      write(io6,*)
      write(io6,*)
      write(io6,*)'Internal Coordinate Transformations by ',verdoc
      write(io6,*)
c
      write(io6,1410)title
1410  format(//2x,'Run Title:'/
     1 3(5x,a80/))
c
c --------------------------------------------
c --- General run control parameters -- IG # 1
c --------------------------------------------
c
c --- Initialize local date/time variables to zero (not in /GEN/)
      ibmin=0
      ieyr=0
      iemo=0
      iehr=0
      iemin=0
c
      call readin(cvdic(1,1),ivleng(1,1),ivtype(1,1),io5,io6,lecho,
     1 IBYR,IBMO,IBDY,IBHR,IBMIN,IBSEC,IEYR,IEMO,IEDY,IEHR,IEMIN,IESEC,
     2 NSECDT,IRLG,XBTZ,NSPEC,NSE,ITEST,METFM,AVET,
     3 PGTIME,METRUN,MRESTART,NRESPD,MPRFFM,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c --- Special QA on starting year of simulation
      call QAYR4(io6,ibyr,metrun,ierr)
      if(ierr.NE.0) then
         write(*,*)
         stop 'CORRECT THE CONTROL FILE'
      endif
c
c --- Set runtime information
      if(metrun.EQ.1) then
c ---    Run period is defined in met file
         ibyr=0
         ibmo=0
         ibdy=0
         ibhr=0
         ibsec=0
         irlg=0
      else
c ---    Start Date-Time
         call YR4(io6,ibyr,ierr)
         if(ierr.NE.0) stop 'Halted in READCF'
         call JULDAY(io6,ibyr,ibmo,ibdy,ibjul)
c ---    Convert minutes to seconds (0-3599)
         ibsec=ibsec+ibmin*60
         if(ibsec.GE.3600) then
            nhrinc=ibsec/3600
            ibsec=ibsec-nhrinc*3600
            call INCR(io6,ibyr,ibjul,ibhr,nhrinc)
            call GRDAY(io6,ibyr,ibjul,ibmo,ibdy)
         endif
c ---    End Date-Time
         if(irlg.EQ.0) then
c ---       Mod6 control file: true starting date/time and
c ---       end date/time are provided in the control file
            call YR4(io6,ieyr,ierr)
            if(ierr.NE.0) then
               stop 'Halted in READCF'
            endif
            call JULDAY(io6,ieyr,iemo,iedy,iejul)
c ---       Convert minutes to seconds (0-3599)
            iesec=iesec+iemin*60
            if(iesec.GE.3600) then
               nhrinc=iesec/3600
               iesec=iesec-nhrinc*3600
               call INCR(io6,ieyr,iejul,iehr,nhrinc)
               call GRDAY(io6,ieyr,iejul,iemo,iedy)
            endif
            call DELTT(ibyr,ibjul,ibhr,ieyr,iejul,iehr,nrunhr)
            nsecrun=nrunhr*3600.-ibsec+iesec
            irlg=nsecrun/nsecdt
         else
c ---       Mod5 control file: end-time of first hour and
c ---       run length (hours) provided in the control file
            rhrinc=(FLOAT(nsecdt)/3600.)*FLOAT(irlg)
            nhrinc=rhrinc-1
            nsecinc=0
            ieyr=ibyr
            iejul=ibjul
            iehr=ibhr
            iesec=ibsec
            call INCR(io6,ieyr,iejul,iehr,nhrinc)
            call INCRS(io6,ieyr,iejul,iehr,iesec,nsecinc)
            call GRDAY(io6,ieyr,iejul,iemo,iedy)
c ---       Move start-time to beginning of first hour
            nhrinc=-1
            call INCR(io6,ibyr,ibjul,ibhr,nhrinc)
            call GRDAY(io6,ibyr,ibjul,ibmo,ibdy)
         endif
c ---    Compute date/time integers for simulation period
         ibdathr=ibyr*100000+ibjul*100+ibhr
         iedathr=ieyr*100000+iejul*100+iehr
      endif
c
c -------------------------------
c --- Technical Options -- IG # 2
c -------------------------------

c --- Initialize RTAULY to zero
      rtauly=0.0

      call readin(cvdic(1,2),ivleng(1,2),ivtype(1,2),io5,io6,lecho,
     1 MGAUSS,MCTADJ,MCTSG,MSLUG,MTRANS,MCHEM,MWET,MDRY,MDISP,MDISP2,
     2 MTURBVW,MROUGH,MTIP,MSHEAR,MSPLIT,MPARTL,MTINV,MPDF,MSGTIBL,
     3 MBCON,MSOURCE,MFOG,MAQCHEM,MBDW,MREG,MTILT,MCTURB,RTAULY,
     4 MTAUADV,MPARTLBA,MRISE,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum)

c --- Define IFOG here from MFOG selection
      if(mfog.GT.0) ifog=1

c --- Interpret RTAULY input (real)
      mtauly=NINT(rtauly)
      if(mtauly.GT.10) then
c ---    User has provided a specific value for the Lagrangian time
c ---    scale so update the value in /CSIGMA/ for Draxler Fy
         tyidr=1./(1.62*rtauly)
      endif
c
c --------------------------
c --- Species list -- IG # 3
c --------------------------
c
c --- Subgroup 3(a) - Species names
c
      do i=1,nspec

         do j=1,12
            ctemp12(j)(1:1)=' '
         enddo

         call readin(cvdic3(1,1),ivleng3(1,1),ivtype3(1,1),io5,io6,
     1   lecho,
     1   CTEMP12,
     2   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 species name into CHAR*12 variable
         cspec(i)='            '
         do j=1,12
            cspec(i)(j:j)=ctemp12(j)(1:1)
         enddo
      enddo
c
c --- transfer species names from master species list into variable
c --- dictionary for use in subsequent input groups
      do i=1,mxspec
c ---    Group 3
         cvdic(i,3)=cspec(i)
         ivleng(i,3)=4
         ivtype(i,3)=2
c
c ---    Group 7
         cvdic(i,9)=cspec(i)
         ivleng(i,9)=5
         ivtype(i,9)=1
c
c ---    Group 8
         cvdic(i,10)=cspec(i)
         ivleng(i,10)=2
         ivtype(i,10)=1
c
c ---    Group 10
         cvdic(i,12)=cspec(i)
         ivleng(i,12)=2
         ivtype(i,12)=1
c
c ---    Group 13d
c ---    NOTE: ip2 variable needs to be adjusted if any changes in
c ---    the variables list of Input Group 13d occurs (before vqtemp)
         ip2=i+2
         cvdic(ip2,18)=cspec(i)
         ivleng(ip2,18)=96
         ivtype(ip2,18)=1
c
c ---    Group 14d
c ---    NOTE: ip2 variable needs to be adjusted if any changes in
c ---    the variables list of Input Group 14d occurs (before vqtemp)
         ip2=i+2
         cvdic(ip2,22)=cspec(i)
         ivleng(ip2,22)=96
         ivtype(ip2,22)=1
c
c ---    Group 15c
c ---    NOTE: ip2 variable needs to be adjusted if any changes in
c ---    the variables list of Input Group 15c occurs (before vqtemp)
         ip2=i+2
         cvdic(ip2,25)=cspec(i)
         ivleng(ip2,25)=96
         ivtype(ip2,25)=1
c
c ---    Group 16c
c ---    NOTE: ip2 variable needs to be adjusted if any changes in
c ---    the variables list of Input Group 16c occurs (before vqtemp)
         ip2=i+2
         cvdic(ip2,28)=cspec(i)
         ivleng(ip2,28)=96
         ivtype(ip2,28)=1
      enddo
c
c --- Species list & options
c ---------------------------
c --- The following call is set for MXSPEC=35
c *** call readin(cvdic(1,3),ivleng(1,3),ivtype(1,3),io5,io6,lecho,
c ***1 ISPLST(1,1),ISPLST(1,2),ISPLST(1,3),ISPLST(1,4),ISPLST(1,5),
c ***2 ISPLST(1,6),ISPLST(1,7),ISPLST(1,8),ISPLST(1,9),ISPLST(1,10),
c ***3 ISPLST(1,11),ISPLST(1,12),ISPLST(1,13),ISPLST(1,14),ISPLST(1,15),
c ***4 ISPLST(1,16),ISPLST(1,17),ISPLST(1,18),ISPLST(1,19),ISPLST(1,20),
c ***5 ISPLST(1,21),ISPLST(1,22),ISPLST(1,23),ISPLST(1,24),ISPLST(1,25),
c ***6 ISPLST(1,26),ISPLST(1,27),ISPLST(1,28),ISPLST(1,29),ISPLST(1,30),
c ***7 ISPLST(1,31),ISPLST(1,32),ISPLST(1,33),ISPLST(1,34),ISPLST(1,35),
c ***8 idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***a idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=20
      call readin(cvdic(1,3),ivleng(1,3),ivtype(1,3),io5,io6,lecho,
     1 ISPLST(1,1),ISPLST(1,2),ISPLST(1,3),ISPLST(1,4),ISPLST(1,5),
     2 ISPLST(1,6),ISPLST(1,7),ISPLST(1,8),ISPLST(1,9),ISPLST(1,10),
     3 ISPLST(1,11),ISPLST(1,12),ISPLST(1,13),ISPLST(1,14),ISPLST(1,15),
     4 ISPLST(1,16),ISPLST(1,17),ISPLST(1,18),ISPLST(1,19),ISPLST(1,20),
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8 idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=5
c *** call readin(cvdic(1,3),ivleng(1,3),ivtype(1,3),io5,io6,lecho,
c ***1 ISPLST(1,1),ISPLST(1,2),ISPLST(1,3),ISPLST(1,4),ISPLST(1,5),
c ***2 idum,idum,idum,idum,idum,
c ***3 idum,idum,idum,idum,idum,
c ***4 idum,idum,idum,idum,idum,
c ***5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***8 idum,idum,idum,idum)
c
c --- Transfer dry deposition flags and group flags into common block
c --- arrays; also set number of group names expected in next subgroup
      ngrupin=0
      do i=1,nspec
         idryflg(i)=isplst(3,i)
         ispgrp(i)=isplst(4,i)
         if(ispgrp(i).GT.ngrupin) ngrupin=ispgrp(i)
      enddo

c
c --- Subgroup 3(b) - Group names (output species list)
c

c --- First, fill group names provided for species that are in a group
      do i=1,ngrupin
         do j=1,12
            ctemp12(j)(1:1)=' '
         enddo
c
         call readin(cvdic3(1,2),ivleng3(1,2),ivtype3(1,2),io5,io6,
     1   lecho,
     1   CTEMP12,
     2   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 species name into CHAR*12 variable
         cgrup(i)='            '
         do j=1,12
            cgrup(i)(j:j)=ctemp12(j)(1:1)
         enddo
      enddo
c
c --- Now, fill group names for species that are not in a group
      ngrup=ngrupin
      do i=1,nspec
         if(ispgrp(i).EQ.0) then
            ngrup=ngrup+1
            cgrup(ngrup)=cspec(i)
            ispgrp(i)=ngrup
         endif
      enddo
c
c --------------------------------------------------------
c --- Map Projection and Grid control parameters -- IG # 4
c --------------------------------------------------------

c --- Initialize the temporary arrays for the character lat/lon fields
      do i=1,4
         do j=1,16
            clatlon(j,i)(1:1)=' '
         enddo
      enddo
      do j=1,16
         clat0(j:j)=' '
         clon0(j:j)=' '
         clat1(j:j)=' '
         clat2(j:j)=' '
      enddo

c --- Initialize the temporary array for the Datum-Region name and 
c --- map projection
      do j=1,8
         cpmap(j)(1:1)=' '
         cdatum(j)(1:1)=' '
      enddo

c --- Retain XLAT,XLONG,XTZ in dictionary to 'read' older control files
c --- (these variables are no longer used)
      call readin(cvdic(1,4),ivleng(1,4),ivtype(1,4),io5,io6,lecho,
     1 CPMAP,CDATUM,FEAST,FNORTH,IUTMZN,UTMHEM,
     2 CLATLON(1,1),CLATLON(1,2),CLATLON(1,3),CLATLON(1,4),
     3 NX,NY,NZ,ZFACE,DGRIDKM,XORIGKM,YORIGKM,XLAT,XLONG,XTZ,IBCOMP,
     4 JBCOMP,IECOMP,JECOMP,LSAMP,IBSAMP,JBSAMP,IESAMP,JESAMP,MESHDN,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum,idum)

c --- Pad the char*4 UTM Hemisphere
      utmhem(2:4)='   '

c --- Transfer the char*4 data into the char*16 variables
      do j=1,16
         if(clatlon(j,1)(1:1).ne.' ')clat0(j:j)=clatlon(j,1)(1:1)
         if(clatlon(j,2)(1:1).ne.' ')clon0(j:j)=clatlon(j,2)(1:1)
         if(clatlon(j,3)(1:1).ne.' ')clat1(j:j)=clatlon(j,3)(1:1)
         if(clatlon(j,4)(1:1).ne.' ')clat2(j:j)=clatlon(j,4)(1:1)
      enddo

c --- Transfer the char*4 data into the char*8 variables
      if(cpmap(1)(1:1).ne.' ') then
         do j=1,8
            pmap(j:j)=cpmap(j)(1:1)
         enddo
      endif
      if(cdatum(1)(1:1).ne.' ') then
         do j=1,8
            datum(j:j)=cdatum(j)(1:1)
         enddo
      endif

c --- Translate character lat/lon to real NLat/ELon
      if(clat0(1:1).NE.' ') call XTRACTLL(io6,'LAT ',clat0,rnlat0)
      if(clon0(1:1).NE.' ') call XTRACTLL(io6,'LON ',clon0,relon0)
      if(clat1(1:1).NE.' ') call XTRACTLL(io6,'LAT ',clat1,xlat1)
      if(clat2(1:1).NE.' ') call XTRACTLL(io6,'LAT ',clat2,xlat2)

c --- Set logicals for map projection PMAP
      if(pmap.EQ.'UTM     ')  lutm =.TRUE.
      if(pmap.EQ.'LCC     ')  llcc =.TRUE.
      if(pmap.EQ.'PS      ')  lps  =.TRUE.
      if(pmap.EQ.'EM      ')  lem  =.TRUE.
      if(pmap.EQ.'LAZA    ')  llaza=.TRUE.
      if(pmap.EQ.'TTM     ')  lttm =.TRUE.

c --- Adjust projection information if needed
      if(LEM) then
c ---    Equatorial Mercator projection matches at 0.0N, 
c ---    and places the northing origin at 0.0N
         rnlat0=0.0
         xlat1=0.0
         xlat2=0.0
      endif
c --- Assign internal reference variables
      rlat0=rnlat0
      rlon0=-relon0
c
c --- convert horizontal coordinate variables from km to m
      dgrid = 1000. * dgridkm
      xorig = 1000. * xorigkm
      yorig = 1000. * yorigkm
c --- Set reciprocal of dgrid (common GRID)
      dgridi = 1. / dgrid
c
c --- Pass XTZ into XBTZ if XBTZ is not provided (needed for old 
c --- control file format)
      if(xbtz.LT.-900) xbtz=xtz
c
c ----------------------------
c --- Output options -- IG # 5
c ----------------------------
c
c --- NOTE: ip24 variable needs to be adjusted if any changes in
c --- the variables list of Input Group 5 occurs (before ioutop)
c
c --- transfer group names from master species-group list into variable
c --- dictionary (master names were provided in Group 3)
      do i=1,mxgrup
         ip24=i+24
         cvdic(ip24,5)=cgrup(i)
         ivleng(ip24,5)=7
         ivtype(ip24,5)=2
      enddo
c
c --- The following call is set for MXGRUP=35 (check MXSPEC)
c *** call readin(cvdic(1,5),ivleng(1,5),ivtype(1,5),io5,io6,lecho,
c ***1 ICON,IDRY,IWET,IVIS,ICPRT,IDPRT,IWPRT,ICFRQ,IDFRQ,IWFRQ,IMESG,
c ***2 LDEBUG,IPFDEB,NPFDEB,NN1,NN2,IPRTU,IMFLX,IMBAL,LCOMPRS,IQAPLOT,
c ***3 IT2D,IRHO,INRISE,
c ***4 IOUTOP(1,1),IOUTOP(1,2),IOUTOP(1,3),IOUTOP(1,4),IOUTOP(1,5),
c ***5 IOUTOP(1,6),IOUTOP(1,7),IOUTOP(1,8),IOUTOP(1,9),IOUTOP(1,10),
c ***6 IOUTOP(1,11),IOUTOP(1,12),IOUTOP(1,13),IOUTOP(1,14),IOUTOP(1,15),
c ***7 IOUTOP(1,16),IOUTOP(1,17),IOUTOP(1,18),IOUTOP(1,19),IOUTOP(1,20),
c ***8 IOUTOP(1,21),IOUTOP(1,22),IOUTOP(1,23),IOUTOP(1,24),IOUTOP(1,25),
c ***9 IOUTOP(1,26),IOUTOP(1,27),IOUTOP(1,28),IOUTOP(1,29),IOUTOP(1,30),
c ***a IOUTOP(1,31),IOUTOP(1,32),IOUTOP(1,33),IOUTOP(1,34),IOUTOP(1,35),
c ***1 idum)
c
c --- The following call is set for MXGRUP=20 (check MXSPEC)
      call readin(cvdic(1,5),ivleng(1,5),ivtype(1,5),io5,io6,lecho,
     1 ICON,IDRY,IWET,IVIS,ICPRT,IDPRT,IWPRT,ICFRQ,IDFRQ,IWFRQ,IMESG,
     2 LDEBUG,IPFDEB,NPFDEB,NN1,NN2,IPRTU,IMFLX,IMBAL,LCOMPRS,IQAPLOT,
     3 IT2D,IRHO,INRISE,
     4 IOUTOP(1,1),IOUTOP(1,2),IOUTOP(1,3),IOUTOP(1,4),IOUTOP(1,5),
     5 IOUTOP(1,6),IOUTOP(1,7),IOUTOP(1,8),IOUTOP(1,9),IOUTOP(1,10),
     6 IOUTOP(1,11),IOUTOP(1,12),IOUTOP(1,13),IOUTOP(1,14),IOUTOP(1,15),
     7 IOUTOP(1,16),IOUTOP(1,17),IOUTOP(1,18),IOUTOP(1,19),IOUTOP(1,20),
     8 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     9 idum,idum,idum,idum)
c
c --- The following call is set for MXGRUP=5 (check MXSPEC)
c *** call readin(cvdic(1,5),ivleng(1,5),ivtype(1,5),io5,io6,lecho,
c ***1 ICON,IDRY,IWET,IVIS,ICPRT,IDPRT,IWPRT,ICFRQ,IDFRQ,IWFRQ,IMESG,
c ***2 LDEBUG,IPFDEB,NPFDEB,NN1,NN2,IPRTU,IMFLX,IMBAL,LCOMPRS,IQAPLOT,
c ***3 IT2D,IRHO,INRISE,
c ***4 IOUTOP(1,1),IOUTOP(1,2),IOUTOP(1,3),IOUTOP(1,4),IOUTOP(1,5),
c ***5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7 idum,idum,idum,idum,idum,idum,idum)

c --- Turn the print frequency inputs from averaging periods to
c --- timesteps by multiplying by the number of timesteps in an
c --- averaging period
      icfrq=iavg*icfrq
      idfrq=iavg*idfrq
      iwfrq=iavg*iwfrq
c
c -------------------------------------------------
c --- Subgrid scale complex terrain inputs -- IG #6
c -------------------------------------------------
c
c --- Subgroup (6a)
      call readin(cvdic(1,6),ivleng(1,6),ivtype(1,6),io5,io6,lecho,
     1 NHILL,NCTREC,MHILL,XHILL2M,ZHILL2M,XCTDMKM,YCTDMKM,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum)
c
c --- Compute origin of CTDM coordinate system relative to the SW
c --- corner of cell (1,1) in the CALPUFF MET grid (meters)
      if(mhill.EQ.1) then
         xmetct0m=1000.*(xctdmkm-xorigkm)
         ymetct0m=1000.*(yctdmkm-yorigkm)
      else
         xmetct0m=0.0
         ymetct0m=0.0
      endif
c
c --- Perform certain CTSG input checks before additional data are read
      if(nctrec.gt.mxrect)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many complex ',
     1   'terrain receptors -- ','NCTREC = ',nctrec,' MXRECT = ',
     2   mxrect
         problem=.TRUE.
      endif
      if(nhill.gt.mxhill)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many hills -- ',
     1   'NHILL = ',nhill,' MXHILL = ',mxhill
         problem=.TRUE.
      endif
      if(mhill.lt.0.or.mhill.gt.2)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- Invalid value of ',
     1   'MHILL entered (MHILL must be 0, 1 or 2) -- MHILL = ',mhill
         problem=.TRUE.
      endif
      if(problem) then
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
c
c --- Subgroup (6b) -- Hill data (one subgroup per hill)
c
      if(mhill.eq.2)then
         do 14 i=1,nhill
         call readin(cvdic(1,7),ivleng(1,7),ivtype(1,7),io5,io6,lecho,
     1    HILLDAT(1,i),
     2    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
14       continue
c
c --- Convert hill coordinates from km to met. grid units
         do 15 i=1,nhill
           hilldat(1,i)=(hilldat(1,i)-xorigkm)/dgridkm
           hilldat(2,i)=(hilldat(2,i)-yorigkm)/dgridkm
15       continue
      endif
c
c --- Subgroup (6c) -- Complex terrain receptor information
c
      if(mhill.eq.2)then
         do 16 i=1,nctrec
         call readin(cvdic(1,8),ivleng(1,8),ivtype(1,8),io5,io6,lecho,
     1    CTRDAT,
     2    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---       Transfer Complex terrain receptor data into common blocks
            xrct(i)=(ctrdat(1)-xorigkm)/dgridkm
            yrct(i)=(ctrdat(2)-yorigkm)/dgridkm
            elrect(i)=ctrdat(3)
            ihill(i)=ctrdat(4)+0.001
16       continue
      endif
c
c -------------------------------------
c --- Dry deposition of gases -- IG # 7
c -------------------------------------
c
c --- The following call is set for MXSPEC=35
c *** call readin(cvdic(1,9),ivleng(1,9),ivtype(1,9),io5,io6,lecho,
c ***1 DRYG(1,1),DRYG(1,2),DRYG(1,3),DRYG(1,4),DRYG(1,5),
c ***2 DRYG(1,6),DRYG(1,7),DRYG(1,8),DRYG(1,9),DRYG(1,10),
c ***3 DRYG(1,11),DRYG(1,12),DRYG(1,13),DRYG(1,14),DRYG(1,15),
c ***4 DRYG(1,16),DRYG(1,17),DRYG(1,18),DRYG(1,19),DRYG(1,20),
c ***5 DRYG(1,21),DRYG(1,22),DRYG(1,23),DRYG(1,24),DRYG(1,25),
c ***6 DRYG(1,26),DRYG(1,27),DRYG(1,28),DRYG(1,29),DRYG(1,30),
c ***7 DRYG(1,31),DRYG(1,32),DRYG(1,33),DRYG(1,34),DRYG(1,35),
c ***8 idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***a idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=20
      call readin(cvdic(1,9),ivleng(1,9),ivtype(1,9),io5,io6,lecho,
     1 DRYG(1,1),DRYG(1,2),DRYG(1,3),DRYG(1,4),DRYG(1,5),
     2 DRYG(1,6),DRYG(1,7),DRYG(1,8),DRYG(1,9),DRYG(1,10),
     3 DRYG(1,11),DRYG(1,12),DRYG(1,13),DRYG(1,14),DRYG(1,15),
     4 DRYG(1,16),DRYG(1,17),DRYG(1,18),DRYG(1,19),DRYG(1,20),
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8 idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=5
c *** call readin(cvdic(1,9),ivleng(1,9),ivtype(1,9),io5,io6,lecho,
c ***1 DRYG(1,1),DRYG(1,2),DRYG(1,3),DRYG(1,4),DRYG(1,5),
c ***2 idum,idum,idum,idum,idum,
c ***3 idum,idum,idum,idum,idum,
c ***4 idum,idum,idum,idum,idum,
c ***5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c*** 8 idum,idum,idum,idum)
c
c --- Transfer gas dry deposition data into common block arrays
      do 20 i=1,nspec
      pdiff(i)=dryg(1,i)
      alphas(i)=dryg(2,i)
      react(i)=dryg(3,i)
      rm(i)=dryg(4,i)
      henry(i)=dryg(5,i)
20    continue
c
c -----------------------------------------
c --- Dry deposition of particles -- IG # 8
c -----------------------------------------
c
c --- The following call is set for MXSPEC=35
c *** call readin(cvdic(1,10),ivleng(1,10),ivtype(1,10),io5,io6,lecho,
c ***1 DRYP(1,1),DRYP(1,2),DRYP(1,3),DRYP(1,4),DRYP(1,5),
c ***2 DRYP(1,6),DRYP(1,7),DRYP(1,8),DRYP(1,9),DRYP(1,10),
c ***3 DRYP(1,11),DRYP(1,12),DRYP(1,13),DRYP(1,14),DRYP(1,15),
c ***4 DRYP(1,16),DRYP(1,17),DRYP(1,18),DRYP(1,19),DRYP(1,20),
c ***5 DRYP(1,21),DRYP(1,22),DRYP(1,23),DRYP(1,24),DRYP(1,25),
c ***6 DRYP(1,26),DRYP(1,27),DRYP(1,28),DRYP(1,29),DRYP(1,30),
c ***7 DRYP(1,31),DRYP(1,32),DRYP(1,33),DRYP(1,34),DRYP(1,35),
c ***8 idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***a idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=20
      call readin(cvdic(1,10),ivleng(1,10),ivtype(1,10),io5,io6,lecho,
     1 DRYP(1,1),DRYP(1,2),DRYP(1,3),DRYP(1,4),DRYP(1,5),
     2 DRYP(1,6),DRYP(1,7),DRYP(1,8),DRYP(1,9),DRYP(1,10),
     3 DRYP(1,11),DRYP(1,12),DRYP(1,13),DRYP(1,14),DRYP(1,15),
     4 DRYP(1,16),DRYP(1,17),DRYP(1,18),DRYP(1,19),DRYP(1,20),
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8 idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=5
c *** call readin(cvdic(1,10),ivleng(1,10),ivtype(1,10),io5,io6,lecho,
c ***1 DRYP(1,1),DRYP(1,2),DRYP(1,3),DRYP(1,4),DRYP(1,5),
c ***2 idum,idum,idum,idum,idum,
c ***3 idum,idum,idum,idum,idum,
c ***4 idum,idum,idum,idum,idum,
c ***5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***8 idum,idum,idum,idum)
c
c --- Transfer data into common block arrays
      np=0
      do 30 i=1,nspec
      if(idryflg(i).eq.2)then
         np=np+1
         if(np.gt.mxpdep)then
            write(io6,*)'ERROR in subr. READCF -- too many particle ',
     1      'species specified -- i = ',i,' np = ',np,' mxpdep = ',
     2      mxpdep
            write(*,*)
            stop 'Halted in READCF -- see list file.'
         endif
c
         gdiam(np)=dryp(1,i)
         gsig(np)=dryp(2,i)
      endif
30    continue
c
c -----------------------------------------------------
c --- Miscellaneous dry deposition parameters -- IG # 9
c -----------------------------------------------------
      call readin(cvdic(1,11),ivleng(1,11),ivtype(1,11),io5,io6,lecho,
     1 RCUTR,RGR,REACTR,PCONST,BMIN,BMAX,QSWMAX,DCONST1,DCONST2,
     2 DCONST3,DCONST4,NPSINT,IVEG,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c -------------------------------------
c --- Wet removal parameters -- IG # 10
c -------------------------------------
c
c --- The following call is set for MXSPEC=35
c *** call readin(cvdic(1,12),ivleng(1,12),ivtype(1,12),io5,io6,lecho,
c ***1 WA(1,1),WA(1,2),WA(1,3),WA(1,4),WA(1,5),
c ***2 WA(1,6),WA(1,7),WA(1,8),WA(1,9),WA(1,10),
c ***3 WA(1,11),WA(1,12),WA(1,13),WA(1,14),WA(1,15),
c ***4 WA(1,16),WA(1,17),WA(1,18),WA(1,19),WA(1,20),
c ***5 WA(1,21),WA(1,22),WA(1,23),WA(1,24),WA(1,25),
c ***6 WA(1,26),WA(1,27),WA(1,28),WA(1,29),WA(1,30),
c ***7 WA(1,31),WA(1,32),WA(1,33),WA(1,34),WA(1,35),
c ***8 idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***a idum,idum,idum,idum) 
c
c --- The following call is set for MXSPEC=20
      call readin(cvdic(1,12),ivleng(1,12),ivtype(1,12),io5,io6,lecho,
     1 WA(1,1),WA(1,2),WA(1,3),WA(1,4),WA(1,5),
     2 WA(1,6),WA(1,7),WA(1,8),WA(1,9),WA(1,10),
     3 WA(1,11),WA(1,12),WA(1,13),WA(1,14),WA(1,15),
     4 WA(1,16),WA(1,17),WA(1,18),WA(1,19),WA(1,20),
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8 idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=5
c *** call readin(cvdic(1,12),ivleng(1,12),ivtype(1,12),io5,io6,lecho,
c ***1 WA(1,1),WA(1,2),WA(1,3),WA(1,4),WA(1,5),
c ***2 idum,idum,idum,idum,idum,
c ***3 idum,idum,idum,idum,idum,
c ***4 idum,idum,idum,idum,idum,
c ***5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***8 idum,idum,idum,idum)
c
c -----------------------------------
c --- Chemistry parameters -- IG # 11
c -----------------------------------
      call readin(cvdic(1,13),ivleng(1,13),ivtype(1,13),io5,io6,lecho,
     1 MOZ,BCKO3M,BCKNH3M,RNITE1,RNITE2,RNITE3,
     2 MH2O2,BCKH2O2M,BCKPMF,OFRAC,VCNX,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum)
c
c ----------------------------------------------------------
c --- Dispersion & misc. computational parameters -- IG # 12
c ----------------------------------------------------------
c --- Initialize temporary SVMIN, SWMIN to 'missing'
      do k=1,12
         svtemp(k)=-999.
         swtemp(k)=-999.
      enddo
c
c --- Move CNSPLITH block data defaults into temporary array
c --- and replace with missing data marker
      do is=1,mxspec
         cstemp(is)=cnsplith(is)
         cnsplith(is)=-999.
      enddo
c
      call readin(cvdic(1,14),ivleng(1,14),ivtype(1,14),io5,io6,lecho,
     1 SYTDEP,MHFTSZ,JSUP,CONK1,CONK2,IURB1,IURB2,XMXLEN,MXNEW,SYMIN,
     2 SZMIN,XSAMLEN,MXSAM,XMINZI,XMAXZI,SL2PF,SVTEMP,SWTEMP,WSCALM,
     3 WSCAT,PLX0,PTG0,PPC,TBD,NSPLIT,IRESPLIT,ZISPLIT,ROLDMAX,
     4 ANEMHT,ISIGMAV,IMIXCTDM,ILANDUIN,Z0IN,XLAIIN,ELEVIN,XLATIN,
     5 XLONIN,EPSSLUG,EPSAREA,CDIV,NCOUNT,NSS,XLATSS,XLONSS,
     6 TIBLDIST,DSRISE,NSPLITH,SYSPLITH,SHSPLITH,CNSPLITH,TRAJINCL,
     7 MDEPBC,HTMINBC,RSAMPBC,MXAGEHR,SZCAP_M,NLUTIBL,
     8 idum,idum,idum)
c
c --- Reset calm wind speed threshold by "small" amount
      wscalm=0.99999*wscalm
c
c --- If no inputs are read, keep all 12 default values from BLOCK DATA
c --- Otherwise, replace defaults with values that are read.
c --- Sigma-v:
      if(svtemp(1).GT.-990.) then
         if(svtemp(12).LT.-990.) then
            write(io6,*)
            write(io6,*)'*********  WARNING  ***********'
            write(io6,*)'READCF -- Missing SVMIN inputs set to default'
            write(*,*)
            write(*,*)'Warning -- Default SVMIN values are used --'
            write(*,*)'See list file.'
         endif
c ---    Replace defaults with values read
         do ist=1,6
            if(svtemp(ist).GT.-990.) then
               svmin(ist,1)=svtemp(ist)
            else
               write(io6,*)'Over LAND  stability,value = ',
     &                      ist,svmin(ist,1)
            endif
            if(svtemp(ist+6).GT.-990.) then
               svmin(ist,2)=svtemp(ist+6)
            else
               write(io6,*)'Over WATER stability,value = ',
     &                      ist,svmin(ist,2)
            endif
         enddo
      endif
c --- Sigma-w:
      if(swtemp(1).GT.-990.) then
         if(swtemp(12).LT.-990.) then
            write(io6,*)
            write(io6,*)'*********  WARNING  ***********'
            write(io6,*)'READCF -- Missing SWMIN inputs set to default'
            write(*,*)
            write(*,*)'Warning -- Default SWMIN values are used --'
            write(*,*)'See list file.'
         endif
c ---    Replace defaults with values read
         do ist=1,6
            if(swtemp(ist).GT.-990.) then
               swmin(ist,1)=swtemp(ist)
            else
               write(io6,*)'Over LAND  stability,value = ',
     &                      ist,swmin(ist,1)
            endif
            if(swtemp(ist+6).GT.-990.) then
               swmin(ist,2)=swtemp(ist+6)
            else
               write(io6,*)'Over WATER stability,value = ',
     &                      ist,swmin(ist,2)
            endif
         enddo
      endif
c
c --- Reset sigma-y units from Grid Units to m (splitting)
c --- and reset shear test units from SYSPLITH/hr to m/s
      sysplith=sysplith*dgrid
      shsplith=shsplith*sysplith/3600.
c
c --- Test for missing values of CNSPLITH
      if(cnsplith(1).LT.0.0) then
c ---    Set all values to default
         do is=1,nspec
            cnsplith(is)=cstemp(is)
         enddo
      elseif(cnsplith(2).LT.0.0) then
c ---    Use valid first value for all nspec
         do is=2,nspec
            cnsplith(is)=cnsplith(1)
         enddo
      endif

c --- Process puff age cutoff
      if(mxagehr.LE.0) then
         lage=.FALSE.
      else
         lage=.TRUE.
         tsecmax=3600.*FLOAT(mxagehr)
      endif

c
c ---------------------------------------
c --- Point source information -- IG # 13
c ---------------------------------------
c
c --- Subgroup (13a) -- First read NPT1, NPT2, IPTU, NSPT1
c
      call readin(cvdic(1,15),ivleng(1,15),ivtype(1,15),io5,io6,lecho,
     1 NPT1,NPT2,IPTU,NSPT1,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum)
c
      if(iptu.LE.0 .OR. iptu.GT.7)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- invalid units for PT1 ',
     1   'sources -- ','IPTU = ',iptu,' valid = 1-7'
         iptu=1
         problem=.TRUE.
      endif
      if(npt1.gt.mxpt1)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many point ',
     1   'sources -- ','NPT1 = ',npt1,' MXPT1 = ',mxpt1
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
      if(npt2.gt.mxpt2)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many point ',
     1   'sources -- ','NPT2 = ',npt2,' MXPT2 = ',mxpt2
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
c
c --- Change NPTDAT to 1 if single PTEMARB.DAT name is provided in
c     first section of Group 0
      if(nptdat.EQ.0 .AND. npt2.GT.0) nptdat=1

c
c --- Subgroup (13b) -- Read source data for each point source
c
      do 150 i=1,npt1
c --- Clear temporary array for source name
      do j=1,16
         ctemp16(j)(1:1)=' '
      enddo
c
c --- Initialize sigmas to zero
      pt1sigs(1)=0.0
      pt1sigs(2)=0.0
c
c --- Initialize vertical momentum flux factor to unity
      fmfac=1.0
c
c --- Initialize platform height to zero
      zpltfm=0.0
c
      call readin(cvdic(1,16),ivleng(1,16),ivtype(1,16),io5,io6,lecho,
     1 PT1DATA,PT1SIGS,FMFAC,ZPLTFM,CTEMP16,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum)
c
c --- Transfer CHAR*4 source name array into CHAR*16 variable for source
      cnampt1(i)='                '
      do j=1,16
         cnampt1(i)(j:j)=ctemp16(j)(1:1)
      enddo
c --- Names must be different
      if(i.GT.1) then
         do j=1,i-1
            if(cnampt1(j).EQ.cnampt1(i)) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. READCF -- name duplicated ',
     1         'for source -- ',i,'  name = ',cnampt1(i)
               problem=.TRUE.
            endif
         enddo
      endif
c
c --- Transfer the point source data to the common block arrays
c
c --- Compute relative grid coordinates
      xpt1grd(i)=(pt1data(1)-xorigkm)/dgridkm
      ypt1grd(i)=(pt1data(2)-yorigkm)/dgridkm
c
c --- Stack parameters
      htstak(i)=pt1data(3)
      elstak(i)=pt1data(4)
      diam(i)=pt1data(5)
      exitw(i)=pt1data(6)
      tstak(i)=pt1data(7)
c     idownw(i)=pt1data(8)+0.001
      idownw(i)=NINT(pt1data(8))
      fmfpt1(i)=fmfac
      zplatpt1(i)=zpltfm
c
c --- Emission rates (apply units conversion factor to obtain g/s)
      lqneg=.FALSE.
      do j=1,nspec
         qstak(j,i)=pt1data(8+j)*qunits(iptu)
         if(qstak(j,i).LT.0.0) lqneg=.TRUE.
      enddo
c --- Report problem if any emissions are negative
      if(lqneg) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- Invalid emission rate ',
     1   ' (must NOT be negative) -- Pt. Source = ',cnampt1(i)
         problem=.TRUE.
      endif
c
c --- Initial sigmas
      syipt1(i)=AMAX1(pt1sigs(1),0.0)
      szipt1(i)=AMAX1(pt1sigs(2),0.0)
c
150   continue

c
c --- Subgroup (13c) -- Building dimension data for each source subject
c                       to building downwash effects
c
c --- Only sources with building downwash have bldg. dimensions
c --- Identify number of these sources
      ndownw=0
      do i=1,npt1
         if(idownw(i).GE.1) ndownw=ndownw+1
      enddo
c
      do 160 i=1,ndownw
c ---    Prepare temporary array for source name
         do j=1,16
            ctemp16(j)(1:1)=' '
         enddo
c ---    Zero building data in temporary arrays
         do j=1,36
            bwtemp(j)=0.0
            bhtemp(j)=0.0
            bltemp(j)=0.0
            bxtemp(j)=0.0
            bytemp(j)=0.0
         enddo

         call readin(cvdic(1,17),ivleng(1,17),ivtype(1,17),io5,io6,
     1      lecho,
     1   BWTEMP,BHTEMP,BLTEMP,BXTEMP,BYTEMP,CTEMP16,
     2   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6   idum,idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name into CHAR*16 variable for source
         cnamsrc='                '
         do j=1,16
            cnamsrc(j:j)=ctemp16(j)(1:1)
         enddo
c ---    Match source name to index (with downwash)
         lmatch=.FALSE.
         do ip=1,npt1
            if(cnamsrc.EQ.cnampt1(ip) .AND. idownw(ip).GE.1) then
               index=ip
               lmatch=.TRUE.
            endif
         enddo
c ---    Pass building data to common arrays
         if(lmatch) then
            do idir=1,36
               bwidth(idir,index)=bwtemp(idir)
               bht(idir,index)=bhtemp(idir)
               bln1(idir,index)=bltemp(idir)
               xbadj1(idir,index)=bxtemp(idir)
               ybadj1(idir,index)=bytemp(idir)
            enddo
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- source name for ',
     1      'building data not valid:',' name = ',cnamsrc
            write(io6,*)'Valid source names for downwash are: '
            do ip=1,npt1
               if(idownw(ip).GE.1) write(io6,*) cnampt1(ip)
            enddo
            problem=.TRUE.
         endif
160   continue
c --- Were data provided for all sources with downwash?
      nfind=0
      nfind2=0
      do i=1,npt1
         test=0
         test2=0
         do j=1,36
            test=test+bwidth(j,i)
            test2=test2+bln1(j,i)
         enddo
         if(test.GT.1.) nfind=nfind+1
         if(test2.GT.1.) nfind2=nfind2+1
      enddo
      if(nfind.NE.ndownw) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- building data for ',
     1   nfind,' sources processed'
         write(io6,*)'                         Expected data for ',
     1   ndownw,' sources'
         problem=.TRUE.
      endif
      if(mbdw.EQ.2 .AND. (nfind.NE.nfind2)) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- building widths for ',
     1   nfind,' sources processed and'
         write(io6,*)'                         building lengths for ',
     1   nfind2,' sources processed.'
         write(io6,*)'Expected both width and length data for MBDW=2'
         problem=.TRUE.
      endif
c
c --- Subgroup (13d) -- Variable emission scaling factors
c
      do i=1,nspt1
c ---    Clear temporary arrays
         do j=1,16
            ctemp16(j)(1:1)=' '
         enddo
         do is=1,mxspec
            do iv=1,96
               vqtemp(iv,is)=0.0
            enddo
         enddo
c
c --- The following call is set for MXSPEC=35
c ***    call readin(cvdic(1,18),ivleng(1,18),ivtype(1,18),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
c ***4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
c ***5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
c ***6   VQTEMP(1,19),VQTEMP(1,20),VQTEMP(1,21),VQTEMP(1,22),
c ***7   VQTEMP(1,23),VQTEMP(1,24),VQTEMP(1,25),VQTEMP(1,26),
c ***8   VQTEMP(1,27),VQTEMP(1,28),VQTEMP(1,29),VQTEMP(1,30),
c ***9   VQTEMP(1,31),VQTEMP(1,32),VQTEMP(1,33),VQTEMP(1,34),
c ***a   VQTEMP(1,35),                                              
c ***b   idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***c   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***d   idum,idum)
c
c --- The following call is set for MXSPEC=20
         call readin(cvdic(1,18),ivleng(1,18),ivtype(1,18),io5,io6,
     1      lecho,
     1   CTEMP16,IVARY,
     2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
     3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
     4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
     5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
     6   VQTEMP(1,19),VQTEMP(1,20),
     7   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     9   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     1   idum,idum)

c --- The following call is set for MXSPEC=5
c ***    call readin(cvdic(1,18),ivleng(1,18),ivtype(1,18),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7   idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name into CHAR*16 variable for source
         cnamsrc='                '
         do j=1,16
            cnamsrc(j:j)=ctemp16(j)(1:1)
         enddo
c ---    Scan variable emissions factors for negatives
         lqneg=.FALSE.
         do iv=1,96
            do isp=1,mxspec
               if(vqtemp(iv,isp).LT.0.0) lqneg=.TRUE.
            enddo
         enddo
c ---    Report problem if any factors are negative
         if(lqneg) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- Invalid scaling',
     1    ' factor  (must NOT be negative) -- Pt. Source = ',cnamsrc
            problem=.TRUE.
         endif
c ---    Match source name to index
         lmatch=.FALSE.
         do ip=1,npt1
            if(cnamsrc.EQ.cnampt1(ip)) then
               isrc=ip
               lmatch=.TRUE.
            endif
         enddo
         if(lmatch) then
c ---       Check IVARY
            if(ivary.LE.0 .OR. ivary.GT.5) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. READCF -- type of variable',
     1         ' emission factor invalid:',' type = ',ivary
               write(io6,*)'                         Valid type is 1-5'
               problem=.TRUE.
            else
c ---          Find species (a value of VQTEMP will be >0.0)
               do iv=1,96
                  do isp=1,mxspec
                     if(vqtemp(iv,isp).GT.0.0) goto 1001
                  enddo
               enddo
1001           continue
c ---          Place data into arrays
               ivpt1(isp,isrc)=ivary
               iq12pt1(isp,isrc)=iqnext
               iqnext=iqnext+iqnum(ivary)
               if((iqnext-1).LE.mxq12) then
                  do iq=iq12pt1(isp,isrc),iqnext-1
                     do n12=1,12
                        itemp=12*(iq-iq12pt1(isp,isrc))+n12
                        vqfac(n12,iq)=vqtemp(itemp,isp)
                     enddo
                  enddo
               else
                  write(io6,*)
                  write(io6,*)'*********  FATAL  ***********'
                  write(io6,*)'ERROR in subr. READCF -- array dim. ',
     1                        'MXQ12 too small for emissions factors'
                  write(io6,*)'MXQ12 = ',mxq12,'    Need  ',iqnext
                  write(io6,*)'Increase parameter and recompile '
                  write(*,*)
                  stop 'Halted in READCF -- see list file.'
               endif
            endif
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- source name for ',
     1      'POINT q-factor invalid :',' name = ',cnamsrc
            write(io6,*)'Valid point source names are: '
            do ip=1,npt1
               write(io6,*) cnampt1(ip)
            enddo
            problem=.TRUE.
         endif
      enddo

c --------------------------------------
c --- Area source information -- IG # 14
c --------------------------------------
c
c --- Subgroup (14a) -- First read NAR1, NAR2, IARU, NSAR1
c
      call readin(cvdic(1,19),ivleng(1,19),ivtype(1,19),io5,io6,lecho,
     1 NAR1,NAR2,IARU,NSAR1,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum)
      if(iaru.LE.0 .OR. iaru.GT.7)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- invalid units for AR1 ',
     1   'sources -- ','IARU = ',iaru,' valid = 1-7'
         iaru=1
         problem=.TRUE.
      endif
      if(nar1.gt.mxarea)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many area ',
     1   'sources -- ','NAR1 = ',nar1,' MXAREA = ',mxarea
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
      if(nar2.gt.mxarea)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many area ',
     1   'sources -- ','NAR2 = ',nar1,' MXAREA = ',mxarea
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
c
c --- Change NARDAT to 1 if single BAEMARB.DAT name is provided in
c     first section of Group 0
      if(nardat.EQ.0 .AND. nar2.GT.0) nardat=1
c
c --- Subgroup (14b) -- Read data for each area source
c
      do 170 i=1,nar1
c --- Clear temporary array for source name
      do j=1,16
         ctemp16(j)(1:1)=' '
      enddo
c
      call readin(cvdic(1,20),ivleng(1,20),ivtype(1,20),io5,io6,lecho,
     1 ARDATA,CTEMP16,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c --- Transfer CHAR*4 source name array into CHAR*16 variable for source
      cnamar1(i)='                '
      do j=1,16
         cnamar1(i)(j:j)=ctemp16(j)(1:1)
      enddo
c --- Names must be different
      if(i.GT.1) then
         do j=1,i-1
            if(cnamar1(j).EQ.cnamar1(i)) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. READCF -- name duplicated ',
     1         'for source -- ',i,'  name = ',cnamar1(i)
               problem=.TRUE.
            endif
         enddo
      endif
c
c --- Transfer the area source data to the common block arrays
c
c --- Area parameters
c --- nvert1(i) is set to 4 in Block Data (hardwired).  If this is made
c --- a user input in the future, array ARDATA should be expanded.
      htar1(i)=ardata(1)
      elar1(i)=ardata(2)
      sz0ar1(i)=ardata(3)
c
c --- Emission rates (apply units conversion factor to obtain g/s/m**2)
      lqneg=.FALSE.
      do j=1,nspec
         qar1(j,i)=ardata(3+j)*qunits(iaru)
         if(qar1(j,i).LT.0.0) lqneg=.TRUE.
      enddo
c --- Report problem if any emissions are negative
      if(lqneg) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- Invalid emission rate ',
     1   ' (must NOT be negative) -- Area Source = ',cnamar1(i)
         problem=.TRUE.
      endif
170   continue
c
c --- Subgroup (14c) -- Read & process vertex data for each area source
c
      do i=1,nar1
c
c ---    Prepare temporary array for source name
         do j=1,16
            ctemp16(j)(1:1)=' '
         enddo
c
         call readin(cvdic(1,21),ivleng(1,21),ivtype(1,21),io5,io6,
     1      lecho,
     1    XVERT,YVERT,CTEMP16,
     2    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6    idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name into CHAR*16 variable for source
         cnamsrc='                '
         do j=1,16
            cnamsrc(j:j)=ctemp16(j)(1:1)
         enddo
c ---    Match source name to index
         lmatch=.FALSE.
         do ia=1,nar1
            if(cnamsrc.EQ.cnamar1(ia)) then
               isrc=ia
               lmatch=.TRUE.
            endif
         enddo
         if(lmatch) then
c ---       Compute and store relative vertex coordinates; accumulate
c ---       sums for computing the mean location of the area source
            sumx=0.
            sumy=0.
            do iv=1,nvert1(isrc)
               xar1grd(iv,isrc)=(xvert(iv)-xorigkm)/dgridkm
               yar1grd(iv,isrc)=(yvert(iv)-yorigkm)/dgridkm
               sumx=sumx+xar1grd(iv,isrc)
               sumy=sumy+yar1grd(iv,isrc)
            enddo
c
c ---       Mean location of source
            xar1grd(nvert1(isrc)+1,isrc)=sumx/FLOAT(nvert1(isrc))
            yar1grd(nvert1(isrc)+1,isrc)=sumy/FLOAT(nvert1(isrc))
c
c ---       Area of 4-sided area source in m^2
            call quadarea(xvert,yvert,area1(isrc))
c
c ---       Convert emission rate from (g/s/m^2) to (g/s)
            do j=1,nspec
               qar1(j,isrc)=qar1(j,isrc)*area1(isrc)
            enddo
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- source name for ',
     1      'AREA vertices invalid :',' name = ',cnamsrc
            write(io6,*)'Valid area source names are: '
            do ia=1,nar1
               write(io6,*) cnamar1(ia)
            enddo
            problem=.TRUE.
         endif
      enddo
c
c --- Subgroup (14d) -- Variable emission scaling factors
c
      do i=1,nsar1
c ---    Clear temporary arrays
         do j=1,16
            ctemp16(j)(1:1)=' '
         enddo
         do is=1,mxspec
            do iv=1,96
               vqtemp(iv,is)=0.0
            enddo
         enddo
c --- The following call is set for MXSPEC=35
c ***    call readin(cvdic(1,22),ivleng(1,22),ivtype(1,22),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
c ***4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
c ***5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
c ***6   VQTEMP(1,19),VQTEMP(1,20),VQTEMP(1,21),VQTEMP(1,22),
c ***7   VQTEMP(1,23),VQTEMP(1,24),VQTEMP(1,25),VQTEMP(1,26),
c ***8   VQTEMP(1,27),VQTEMP(1,28),VQTEMP(1,29),VQTEMP(1,30),
c ***9   VQTEMP(1,31),VQTEMP(1,32),VQTEMP(1,33),VQTEMP(1,34),
c ***a   VQTEMP(1,35),                                              
c ***b   idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***8   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9   idum,idum)
c
c --- The following call is set for MXSPEC=20
         call readin(cvdic(1,22),ivleng(1,22),ivtype(1,22),io5,io6,
     1      lecho,
     1   CTEMP16,IVARY,
     2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
     3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
     4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
     5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
     6   VQTEMP(1,19),VQTEMP(1,20),
     6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     9   idum,idum)

c --- The following call is set for MXSPEC=5
c ***    call readin(cvdic(1,22),ivleng(1,22),ivtype(1,22),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7   idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name into CHAR*16 variable for source
         cnamsrc='                '
         do j=1,16
            cnamsrc(j:j)=ctemp16(j)(1:1)
         enddo
c ---    Scan variable emissions factors for negatives
         lqneg=.FALSE.
         do iv=1,96
            do isp=1,mxspec
               if(vqtemp(iv,isp).LT.0.0) lqneg=.TRUE.
            enddo
         enddo
c ---    Report problem if any factors are negative
         if(lqneg) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- Invalid scaling',
     1    ' factor  (must NOT be negative) -- Area Source = ',cnamsrc
            problem=.TRUE.
         endif
c ---    Match source name to index
         lmatch=.FALSE.
         do ia=1,nar1
            if(cnamsrc.EQ.cnamar1(ia)) then
               isrc=ia
               lmatch=.TRUE.
            endif
         enddo
         if(lmatch) then
c ---       Check IVARY
            if(ivary.LE.0 .OR. ivary.GT.5) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. READCF -- type of variable',
     1         ' emission factor invalid:',' type = ',ivary
               write(io6,*)'                         Valid type is 1-5'
               problem=.TRUE.
            else
c ---          Find species (a value of VQTEMP will be >0.0)
               do iv=1,96
                  do isp=1,mxspec
                     if(vqtemp(iv,isp).GT.0.0) goto 1002
                  enddo
               enddo
1002           continue
c ---          Place data into arrays
               ivar1(isp,isrc)=ivary
               iq12ar1(isp,isrc)=iqnext
               iqnext=iqnext+iqnum(ivary)
               if((iqnext-1).LE.mxq12) then
                  do iq=iq12ar1(isp,isrc),iqnext-1
                     do n12=1,12
                        itemp=12*(iq-iq12ar1(isp,isrc))+n12
                        vqfac(n12,iq)=vqtemp(itemp,isp)
                     enddo
                  enddo
               else
                  write(io6,*)
                  write(io6,*)'*********  FATAL  ***********'
                  write(io6,*)'ERROR in subr. READCF -- array dim. ',
     1                        'MXQ12 too small for emissions factors'
                  write(io6,*)'MXQ12 = ',mxq12,'    Need  ',iqnext
                  write(io6,*)'Increase parameter and recompile '
                  write(*,*)
                  stop 'Halted in READCF -- see list file.'
               endif
            endif
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- source name for ',
     1      'AREA q-factor invalid :',' name = ',cnamsrc
            write(io6,*)'Valid area source names are: '
            do ia=1,nar1
               write(io6,*) cnamar1(ia)
            enddo
            problem=.TRUE.
         endif
      enddo
c
c
c --------------------------------------
c --- Line source information -- IG # 15
c --------------------------------------
c
c --- Subgroup (15a) -- First read NLINES, average line source
c ---                   buoyancy and layout information
c
      call readin(cvdic(1,23),ivleng(1,23),ivtype(1,23),io5,io6,lecho,
     1 NLINES,XL,HBL,WBL,WML,DXL,FPRIMEL,MXNSEG,NLRISE,ILNU,NSLN1,
     2 NLN2,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
      if(nlines.gt.mxlines)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many line ',
     1   'sources -- ','NLINES = ',nlines,' MXLINES = ',mxlines
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
      if(nln2.gt.mxlines)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many line ',
     1   'sources -- ','NLN2   = ',nln2,' MXLINES = ',mxlines
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
      if(mxlines.GE.1000) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- model cannot ',
     1   'function properly with more than 1000 line sources-- ',
     2   ' MXLINES = ',mxlines
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
c
      if(nlines.GT.0) then
         if(ilnu.LE.0 .OR. ilnu.GT.7)then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- invalid units for ',
     1      'LINE sources -- ','ILNU = ',ilnu,' valid = 1-7'
            ilnu=1
            problem=.TRUE.
         endif
c ---    Compute secondary information from these (/LINES/)
c ---    Separation between centers of adjacent lines (average)
         wsep=wbl+dxl
c ---    Total buoyancy flux from all line sources in block
         fptot=fprimel*nlines
c ---    Corresponding point-source buoyancy flux (fptot/pi)
         fbpt=fptot*0.3183099
      else
         nsln1=0
      endif
c
c
c --- Subgroup (15b) -- Read source data for each line source
c
      do 350 i=1,nlines
c --- Clear temporary array for source name
      do j=1,16
         ctemp16(j)(1:1)=' '
      enddo
c
      call readin(cvdic(1,24),ivleng(1,24),ivtype(1,24),io5,io6,lecho,
     1 XLNDATA,CTEMP16,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c --- Transfer CHAR*4 source name array into CHAR*16 variable for source
      cnamln1(i)='                '
      do j=1,16
         cnamln1(i)(j:j)=ctemp16(j)(1:1)
      enddo
c --- Names must be different
      if(i.GT.1) then
         do j=1,i-1
            if(cnamln1(j).EQ.cnamln1(i)) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. READCF -- name duplicated ',
     1         'for source -- ',i,'  name = ',cnamln1(i)
               problem=.TRUE.
            endif
         enddo
      endif
c
c --- Transfer the line source data to the common block arrays
c
c --- Compute relative grid coordinates (in grid units)
      xlbeggrd(i)=(xlndata(1)-xorigkm)/dgridkm
      ylbeggrd(i)=(xlndata(2)-yorigkm)/dgridkm
      xlendgrd(i)=(xlndata(3)-xorigkm)/dgridkm
      ylendgrd(i)=(xlndata(4)-yorigkm)/dgridkm
c
c --- Compute the vertex coordinates, assuming that the average line
c --- width (WML) applies, for corresponding area-source representation
      wmlby2=0.5*wml
c --- Reset to next larger whole meter
      wmlby2=float(int(wmlby2)+1)
      xdiffm=(xlbeggrd(i)-xlendgrd(i))*dgrid
      ydiffm=(ylbeggrd(i)-ylendgrd(i))*dgrid
c --- Let "c" denote 1/slope of line
      if(abs(ydiffm).LE.1.0e-10) then
         dx=0.0
         dy=-wmlby2
      else
         c=xdiffm/ydiffm
         dx=wmlby2/sqrt(1+c*c)
         dy=-dx*c
      endif
c --- Convert deltas to grid units
      dxgrd=dx*dgridi
      dygrd=dy*dgridi
c --- Pass vertices to arrays in /LN1/
      xvertl(1,i)=xlbeggrd(i)-dxgrd
      yvertl(1,i)=ylbeggrd(i)-dygrd
      xvertl(2,i)=xlbeggrd(i)+dxgrd
      yvertl(2,i)=ylbeggrd(i)+dygrd
      xvertl(3,i)=xlendgrd(i)+dxgrd
      yvertl(3,i)=ylendgrd(i)+dygrd
      xvertl(4,i)=xlendgrd(i)-dxgrd
      yvertl(4,i)=ylendgrd(i)-dygrd
c --- Corresponding area of line source in m^2
      arline(i)=2.0*wmlby2*sqrt(xdiffm*xdiffm+ydiffm*ydiffm)
c
c --- Stack parameters
      hsl(i)=xlndata(5)
      belevl(i)=xlndata(6)
c
c --- Emission rates (apply units conversion factor to obtain g/s)
      lqneg=.FALSE.
      do j=1,nspec
         qtl(j,i)=xlndata(6+j)*qunits(ilnu)
         if(qtl(j,i).LT.0.0) lqneg=.TRUE.
      enddo
c --- Report problem if any emissions are negative
      if(lqneg) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- Invalid emission rate ',
     1   ' (must NOT be negative) -- Line Source = ',cnamln1(i)
         problem=.TRUE.
      endif
350   continue
c
c --- Continue setup for line sources
      if(nlines.GT.0) then
c ---    Find center of the array of line sources, and its orientation
         xbeg=0.0
         ybeg=0.0
         xend=0.0
         yend=0.0
         do i=1,nlines
            xbeg=xbeg+xlbeggrd(i)
            ybeg=ybeg+ylbeggrd(i)
            xend=xend+xlendgrd(i)
            yend=yend+ylendgrd(i)
         enddo
         xbeg=xbeg/float(nlines)
         ybeg=ybeg/float(nlines)
         xend=xend/float(nlines)
         yend=yend/float(nlines)
c
         xlbar=0.5*(xbeg+xend)
         ylbar=0.5*(ybeg+yend)
         orientl=atan2((xbeg-xend),(ybeg-yend))
c
c ---    Check number of points used to tabulate buoyant rise
         if(nlrise.gt.mxrise)then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- too many points ',
     1      'for rise table -- ','NLRISE = ',nlrise,' MXRISE = ',mxrise
            write(*,*)
            stop 'Halted in READCF -- see list file.'
         endif
      endif
c
c --- Subgroup (15c) -- Variable emission scaling factors
c
      do i=1,nsln1
c ---    Clear temporary arrays
         do j=1,16
            ctemp16(j)(1:1)=' '
         enddo
         do is=1,mxspec
            do iv=1,96
               vqtemp(iv,is)=0.0
            enddo
         enddo
c
c --- The following call is set for MXSPEC=35
c ***    call readin(cvdic(1,25),ivleng(1,25),ivtype(1,25),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
c ***4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
c ***5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
c ***6   VQTEMP(1,19),VQTEMP(1,20),VQTEMP(1,21),VQTEMP(1,22),
c ***7   VQTEMP(1,23),VQTEMP(1,24),VQTEMP(1,25),VQTEMP(1,26),
c ***8   VQTEMP(1,27),VQTEMP(1,28),VQTEMP(1,29),VQTEMP(1,30),
c ***9   VQTEMP(1,31),VQTEMP(1,32),VQTEMP(1,33),VQTEMP(1,34),
c ***a   VQTEMP(1,35),
c ***b   idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***c   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***d   idum,idum)
c
c --- The following call is set for MXSPEC=20
         call readin(cvdic(1,25),ivleng(1,25),ivtype(1,25),io5,io6,
     1      lecho,
     1   CTEMP16,IVARY,
     2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
     3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
     4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
     5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
     6   VQTEMP(1,19),VQTEMP(1,20),
     6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     9   idum,idum)
c
c --- The following call is set for MXSPEC=5
c ***    call readin(cvdic(1,25),ivleng(1,25),ivtype(1,25),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7   idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name into CHAR*16 variable for source
         cnamsrc='                '
         do j=1,16
            cnamsrc(j:j)=ctemp16(j)(1:1)
         enddo
c ---    Scan variable emissions factors for negatives
         lqneg=.FALSE.
         do iv=1,96
            do isp=1,mxspec
               if(vqtemp(iv,isp).LT.0.0) lqneg=.TRUE.
            enddo
         enddo
c ---    Report problem if any factors are negative
         if(lqneg) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- Invalid scaling',
     1    ' factor  (must NOT be negative) -- Line Source = ',cnamsrc
            problem=.TRUE.
         endif
c ---    Match source name to index
         lmatch=.FALSE.
         do il=1,nlines
            if(cnamsrc.EQ.cnamln1(il)) then
               isrc=il
               lmatch=.TRUE.
            endif
         enddo
         if(lmatch) then
c ---       Check IVARY
            if(ivary.LE.0 .OR. ivary.GT.5) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. READCF -- type of variable',
     1         ' emission factor invalid:',' type = ',ivary
               write(io6,*)'                         Valid type is 1-5'
               problem=.TRUE.
            else
c ---          Find species (a value of VQTEMP will be >0.0)
               do iv=1,96
                  do isp=1,mxspec
                     if(vqtemp(iv,isp).GT.0.0) goto 1003
                  enddo
               enddo
1003           continue
c ---          Place data into arrays
               ivln1(isp,isrc)=ivary
               iq12ln1(isp,isrc)=iqnext
               iqnext=iqnext+iqnum(ivary)
               if((iqnext-1).LE.mxq12) then
                  do iq=iq12ln1(isp,isrc),iqnext-1
                     do n12=1,12
                        itemp=12*(iq-iq12ln1(isp,isrc))+n12
                        vqfac(n12,iq)=vqtemp(itemp,isp)
                     enddo
                  enddo
               else
                  write(io6,*)
                  write(io6,*)'*********  FATAL  ***********'
                  write(io6,*)'ERROR in subr. READCF -- array dim. ',
     1                        'MXQ12 too small for emissions factors'
                  write(io6,*)'MXQ12 = ',mxq12,'    Need  ',iqnext
                  write(io6,*)'Increase parameter and recompile '
                  write(*,*)
                  stop 'Halted in READCF -- see list file.'
               endif
            endif
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- source name for ',
     1      'LINE q-factor invalid :',' name = ',cnamsrc
            write(io6,*)'Valid line source names are: '
            do il=1,nlines
               write(io6,*) cnamln1(il)
            enddo
            problem=.TRUE.
         endif
      enddo
c
c ----------------------------------------
c --- Volume source information -- IG # 16
c ----------------------------------------
c
c --- Subgroup (16a) -- Read number of volume sources (etc.)
c
      call readin(cvdic(1,26),ivleng(1,26),ivtype(1,26),io5,io6,lecho,
     1 NVL1,NVL2,IVLU,NSVL1,IGRDVL,VEFFHT,VSIGYI,VSIGZI,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum)
      if(ivlu.LE.0 .OR. ivlu.GT.7)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- invalid units for Vol ',
     1   'sources -- ','IVLU = ',ivlu,' valid = 1-7'
         ivlu=1
         problem=.TRUE.
      endif
      if(nvl1.gt.mxvol .OR. nvl2.gt.mxvol)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many vol. ',
     1   'sources -- ','NVL1 = ',nvl1,' NVL2 = ',nvl2,' MXVOL = ',mxvol
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
      if(igrdvl.gt.0)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- old version of ',
     1   'variable volume source file is requested.',
     2   ' (Flag IGRDVL has been replaced with variale NVL2)'
         problem=.TRUE.
      endif
c
c --- Change NVOLDAT to 1 if single VOLEMARB.DAT name is provided in
c     first section of Group 0
      if(nvoldat.EQ.0 .AND. nvl2.GT.0) nvoldat=1
c
c --- Subgroup (16b) -- Read data for each volume source
c
      do i=1,nvl1
c ---    Clear temporary array for source name
         do j=1,16
            ctemp16(j)(1:1)=' '
         enddo
c
         call readin(cvdic(1,27),ivleng(1,27),ivtype(1,27),io5,io6,
     1      lecho,
     1    VLDATA,CTEMP16,
     2    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6    idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name array into CHAR*16 var. for source
         cnamvl1(i)='                '
         do j=1,16
            cnamvl1(i)(j:j)=ctemp16(j)(1:1)
         enddo
c ---    Names must be different
         if(i.GT.1) then
            do j=1,i-1
               if(cnamvl1(j).EQ.cnamvl1(i)) then
                  write(io6,*)
                  write(io6,*)'*********  FATAL  ***********'
                  write(io6,*)'ERROR in subr. READCF -- duplicate name',
     1            ' for source -- ',i,'  name = ',cnamvl1(i)
                  problem=.TRUE.
               endif
            enddo
         endif
c
c ---    Transfer the vol. source data to the common block arrays
c
c ---    Compute relative grid coordinates
         xvl1grd(i)=(vldata(1)-xorigkm)/dgridkm
         yvl1grd(i)=(vldata(2)-yorigkm)/dgridkm
c
         htvl1(i)=vldata(3)
         elvl1(i)=vldata(4)
         sy0vl1(i)=vldata(5)
         sz0vl1(i)=vldata(6)
c
c ---    Emission rates (apply units conversion factor to obtain g/s)
         lqneg=.FALSE.
         do j=1,nspec
            qvl1(j,i)=vldata(6+j)*qunits(ivlu)
            if(qvl1(j,i).LT.0.0) lqneg=.TRUE.
         enddo
c ---    Report problem if any emissions are negative
         if(lqneg) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- Invalid emission',
     1      ' rate (must NOT be negative) -- Vol. Source = ',cnamvl1(i)
            problem=.TRUE.
         endif
      enddo
c
c --- Subgroup (16c) -- Variable emission scaling factors
c
      do i=1,nsvl1
c ---    Clear temporary arrays
         do j=1,16
            ctemp16(j)(1:1)=' '
         enddo
         do is=1,mxspec
            do iv=1,96
               vqtemp(iv,is)=0.0
            enddo
         enddo
c
c --- The following call is set for MXSPEC=35
c ***    call readin(cvdic(1,28),ivleng(1,28),ivtype(1,28),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
c ***4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
c ***5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
c ***6   VQTEMP(1,19),VQTEMP(1,20),VQTEMP(1,21),VQTEMP(1,22),
c ***7   VQTEMP(1,23),VQTEMP(1,24),VQTEMP(1,25),VQTEMP(1,26),
c ***8   VQTEMP(1,27),VQTEMP(1,28),VQTEMP(1,29),VQTEMP(1,30),
c ***9   VQTEMP(1,31),VQTEMP(1,32),VQTEMP(1,33),VQTEMP(1,34),
c ***a   VQTEMP(1,35),
c ***b   idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***8   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9   idum,idum)
c
c --- The following call is set for MXSPEC=20
         call readin(cvdic(1,28),ivleng(1,28),ivtype(1,28),io5,io6,
     1      lecho,
     1   CTEMP16,IVARY,
     2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
     3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
     4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
     5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
     6   VQTEMP(1,19),VQTEMP(1,20),
     6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     9   idum,idum)
c
c --- The following call is set for MXSPEC=5
c ***    call readin(cvdic(1,28),ivleng(1,28),ivtype(1,28),io5,io6,
c ***1      lecho,
c ***1   CTEMP16,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7   idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name into CHAR*16 variable for source
         cnamsrc='                '
         do j=1,16
            cnamsrc(j:j)=ctemp16(j)(1:1)
         enddo
c ---    Scan variable emissions factors for negatives
         lqneg=.FALSE.
         do iv=1,96
            do isp=1,mxspec
               if(vqtemp(iv,isp).LT.0.0) lqneg=.TRUE.
            enddo
         enddo
c ---    Report problem if any factors are negative
         if(lqneg) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- Invalid scaling',
     1    ' factor  (must NOT be negative) -- Vol. Source = ',cnamsrc
            problem=.TRUE.
         endif
c ---    Match source name to index
         lmatch=.FALSE.
         do ii=1,nvl1
            if(cnamsrc.EQ.cnamvl1(ii)) then
               isrc=ii
               lmatch=.TRUE.
            endif
         enddo
         if(lmatch) then
c ---       Check IVARY
            if(ivary.LE.0 .OR. ivary.GT.5) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. READCF -- type of variable',
     1         ' emission factor invalid:',' type = ',ivary
               write(io6,*)'                         Valid type is 1-5'
               problem=.TRUE.
            else
c ---          Find species (a value of VQTEMP will be >0.0)
               do iv=1,96
                  do isp=1,mxspec
                     if(vqtemp(iv,isp).GT.0.0) goto 1004
                  enddo
               enddo
1004           continue
c ---          Place data into arrays
               ivvl1(isp,isrc)=ivary
               iq12vl1(isp,isrc)=iqnext
               iqnext=iqnext+iqnum(ivary)
               if((iqnext-1).LE.mxq12) then
                  do iq=iq12vl1(isp,isrc),iqnext-1
                     do n12=1,12
                        itemp=12*(iq-iq12vl1(isp,isrc))+n12
                        vqfac(n12,iq)=vqtemp(itemp,isp)
                     enddo
                  enddo
               else
                  write(io6,*)
                  write(io6,*)'*********  FATAL  ***********'
                  write(io6,*)'ERROR in subr. READCF -- array dim. ',
     1                        'MXQ12 too small for emissions factors'
                  write(io6,*)'MXQ12 = ',mxq12,'    Need  ',iqnext
                  write(io6,*)'Increase parameter and recompile '
                  write(*,*)
                  stop 'Halted in READCF -- see list file.'
               endif
            endif
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. READCF -- source name for ',
     1      'VOL. q-factor invalid :',' name = ',cnamsrc
            write(io6,*)'Valid point source names are: '
            do ii=1,nvl1
               write(io6,*) cnamvl1(ii)
            enddo
            problem=.TRUE.
         endif
      enddo
c
c --------------------------------------------
c --- Discrete receptor information -- IG # 17
c --------------------------------------------
c
c --- Subgroup (17a) -- First read number of discrete receptors (NREC)
      call readin(cvdic(1,29),ivleng(1,29),ivtype(1,29),io5,io6,lecho,
     1 NREC,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
      if(nrec.gt.mxrec)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. READCF -- too many discrete ',
     1   'receptors -- NREC = ',nrec,' MXREC = ',mxrec
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif
c
c --- Subgroup (17b) -- Read data for each discrete receptor
      do 250 i=1,nrec
c --- Initialize ht above ground as zero
      recwrk(4)=0.0
      call readin(cvdic(1,30),ivleng(1,30),ivtype(1,30),io5,io6,lecho,
     1 RECWRK,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c --- Transfer the non-gridded receptor data to the common block arrays
c
c --- Compute relative grid coordinates
      xng(i)=(recwrk(1)-xorigkm)/dgridkm
      yng(i)=(recwrk(2)-yorigkm)/dgridkm
c
c --- Receptor ground elevation
      elevng(i)=recwrk(3)
c
c --- Receptor height above ground
      zng(i)=recwrk(4)
250   continue
c
c
c ------------------------------------------------------
c --- Perform QA checks on selected control file inputs
c ------------------------------------------------------
      call QAINP(problem)
      if(mfog.NE.0) call QAFOG(problem)
c
c --- ALWAYS write control file confirmation to list file
c      if(LDEBUG.OR.PROBLEM)then
         write(io6,*)
         write(io6,*)'   ****  CONFIRMATION OF CONTROL DATA  ****'
         write(io6,*)
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 1  ---------------'
         write(io6,*)
         write(io6,*)'metrun  = ',metrun
         write(io6,*)'ibyr    = ',ibyr
         write(io6,*)'ibmo    = ',ibmo
         write(io6,*)'ibdy    = ',ibdy
         write(io6,*)'ibhr    = ',ibhr
         write(io6,*)'ibsec   = ',ibsec
         write(io6,*)'ibdathr = ',ibdathr
         write(io6,*)'ieyr    = ',ieyr
         write(io6,*)'iemo    = ',iemo
         write(io6,*)'iedy    = ',iedy
         write(io6,*)'iehr    = ',iehr
         write(io6,*)'iesec   = ',iesec
         write(io6,*)'iedathr = ',iedathr
         write(io6,*)'nsecdt  = ',nsecdt
         write(io6,*)'irlg    = ',irlg
         write(io6,*)'iavg    = ',iavg
         write(io6,*)'xbtz    = ',xbtz
         write(io6,*)'nspec   = ',nspec
         write(io6,*)'nse     = ',nse
         write(io6,*)'itest   = ',itest
         write(io6,*)'metfm   = ',metfm
         write(io6,*)'mprffm  = ',mprffm
         write(io6,*)'mrestart= ',mrestart
         write(io6,*)'nrespd  = ',nrespd
         write(io6,*)'avet    = ',avet
         write(io6,*)'pgtime  = ',pgtime
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 2  ---------------'
         write(io6,*)
         write(io6,*)'mgauss = ',mgauss
         write(io6,*)'mctadj = ',mctadj
         write(io6,*)'mctsg  = ',mctsg
         write(io6,*)'mslug  = ',mslug
         write(io6,*)'mtrans = ',mtrans
         write(io6,*)'mchem  = ',mchem
         write(io6,*)'maqchem  = ',maqchem
         write(io6,*)'mwet   = ',mwet
         write(io6,*)'mdry   = ',mdry
         write(io6,*)'mtilt  = ',mtilt
         write(io6,*)'mdisp  = ',mdisp
         write(io6,*)'mdisp2 = ',mdisp2
         write(io6,*)'mturbvw = ',mturbvw
         write(io6,*)'mtauly = ',rtauly
         write(io6,*)'mtauadv= ',mtauadv
         write(io6,*)'mcturb = ',mcturb
         write(io6,*)'mrough = ',mrough
         write(io6,*)'mtip   = ',mtip
         write(io6,*)'mbdw   = ',mbdw
         write(io6,*)'mshear = ',mshear
         write(io6,*)'mrise  = ',mrise
         write(io6,*)'msplit = ',msplit
         write(io6,*)'mpartl = ',mpartl
         write(io6,*)'mpartlba= ',mpartlba
         write(io6,*)'mtinv  = ',mtinv
         write(io6,*)'mpdf   = ',mpdf
         write(io6,*)'msgtibl= ',msgtibl
         write(io6,*)'mbcon  = ',mbcon
         write(io6,*)'msource= ',msource
         write(io6,*)'mfog   = ',mfog
         write(io6,*)'mreg   = ',mreg
         if(mreg.EQ.1) then
           write(io6,*)'  Technical options must conform to USEPA'
           write(io6,*)'   Long Range Transport (LRT) guidance'
           write(io6,*)'        METFM    1 or 2'
           write(io6,*)'        AVET     60. (min)'
           write(io6,*)'        PGTIME   60. (min)'
           write(io6,*)'        MGAUSS   1'
           write(io6,*)'        MCTADJ   3'
           write(io6,*)'        MTRANS   1'
           write(io6,*)'        MTIP     1'
           write(io6,*)'        MCHEM    1 or 3 (if modeling SOx, NOx)'
           write(io6,*)'        MWET     1'
           write(io6,*)'        MDRY     1'
           write(io6,*)'        MDISP    2 or 3'
           write(io6,*)'        MPDF     0 if MDISP=3'
           write(io6,*)'                 1 if MDISP=2'
           write(io6,*)'        MROUGH   0'
           write(io6,*)'        MPARTL   1'
           write(io6,*)'        MPARTLBA 0'
           write(io6,*)'        SYTDEP   550. (m)'
           write(io6,*)'        MHFTSZ   0'
           write(io6,*)'        SVMIN    0.5 (m/s)'
         endif
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 3  ---------------'
         write(io6,*)
         do j=1,nspec
            write(io6,105)cspec(j),j,(isplst(n,j),n=1,3),
     &                    cgrup(ispgrp(j))
105         format(1x,'SPECIES: ',a12,2x,'j:',i2,2x,'isplst(-,j) = ',
     1             3i3,'  GROUP: ',a12)
         enddo
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 4  ---------------'
         write(io6,*)
         write(io6,*)'pmap    = ',pmap
         write(io6,*)'datum   = ',datum
         write(io6,*)'daten   = ',daten
         if(LLCC.or.LLAZA.or.LTTM) then
           write(io6,*)'feast   = ',feast
           write(io6,*)'fnorth  = ',fnorth
         endif
         if(LUTM) then
           write(io6,*)'utmhem  = ',utmhem
           write(io6,*)'iutmzn  = ',iutmzn
         endif
         if(LLCC.or.LPS.or.LEM.or.LLAZA.or.LTTM) then
           write(io6,*)'rlat0   = ',rlat0
           write(io6,*)'rlon0   = ',rlon0
           if(LLCC.or.LPS) write(io6,*)'xlat1   = ',xlat1
           if(LLCC) write(io6,*)'xlat2   = ',xlat2
         endif
         write(io6,*)'nx      = ',nx
         write(io6,*)'ny      = ',ny
         write(io6,*)'nz      = ',nz
         n2=nz+1
         write(io6,*)'zface  = ',(zface(n),n=1,n2)
         write(io6,*)'dgridkm = ',dgridkm
         write(io6,*)'xorigkm = ',xorigkm
         write(io6,*)'yorigkm = ',yorigkm
         write(io6,*)'iutmzn  = ',iutmzn
         write(io6,*)'ibcomp  = ',ibcomp
         write(io6,*)'jbcomp  = ',jbcomp
         write(io6,*)'iecomp  = ',iecomp
         write(io6,*)'jecomp  = ',jecomp
         write(io6,*)'lsamp   = ',lsamp
         write(io6,*)'ibsamp  = ',ibsamp
         write(io6,*)'jbsamp  = ',jbsamp
         write(io6,*)'iesamp  = ',iesamp
         write(io6,*)'jesamp  = ',jesamp
         write(io6,*)'meshdn  = ',meshdn
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 5  ---------------'
         write(io6,*)
         write(io6,*)'icon    = ',icon
         write(io6,*)'idry    = ',idry
         write(io6,*)'iwet    = ',iwet
         write(io6,*)'it2d    = ',it2d
         write(io6,*)'irho    = ',irho
         write(io6,*)'ivis    = ',ivis
         write(io6,*)'lcomprs = ',lcomprs
         write(io6,*)'icprt   = ',icprt
         write(io6,*)'idprt   = ',idprt
         write(io6,*)'iwprt   = ',iwprt
         write(io6,*)'icfrq   = ',icfrq
         write(io6,*)'idfrq   = ',idfrq
         write(io6,*)'iwfrq   = ',iwfrq
         write(io6,*)'(note:  i_frq values converted to timesteps)'
         write(io6,*)'iprtu   = ',iprtu
         write(io6,*)'imesg   = ',imesg
         write(io6,*)'imflx   = ',imflx
         write(io6,*)'imbal   = ',imbal
         write(io6,*)'inrise  = ',inrise
         write(io6,*)'iqaplot = ',iqaplot
         write(io6,*)'ldebug  = ',ldebug
         write(io6,*)'ipfdeb  = ',ipfdeb
         write(io6,*)'npfdeb  = ',npfdeb
         write(io6,*)'nn1     = ',nn1
         write(io6,*)'nn2     = ',nn2
         write(io6,*)
c
         do 132 j=1,ngrup
         write(io6,131)cgrup(j),j,(ioutop(n,j),n=1,7)
131      format(1x,'GROUP: ',a12,2x,'j: ',i3,2x,'ioutop(-,j) = ',
     1    100i2)
132      continue
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 6  ---------------'
         write(io6,*)
         write(io6,*)'        ------  Subgroup (6a)  ------'
         write(io6,*)
         write(io6,*)'nhill  = ',nhill
         write(io6,*)'nctrec = ',nctrec
         write(io6,*)'mhill  = ',mhill
         write(io6,*)'xhill2m= ',xhill2m
         write(io6,*)'zhill2m= ',zhill2m
         write(io6,*)'xctdmkm= ',xctdmkm
         write(io6,*)'yctdmkm= ',yctdmkm
         write(io6,*)
         write(io6,*)'        ------  Subgroup (6b)  ------'
         write(io6,*)
         if(mhill.eq.1)then
            write(io6,*)'       CTDM-type terrain file read'
         else if(mhill.eq.2)then
            do 142 j=1,nhill
            write(io6,141)j,(hilldat(n,j),n=1,11)
141         format(1x,'Hill No.: ',i4,3x,'HILLDAT = ',5(f10.3,2x)/28x,
     1       6(f10.3,2x))
142         continue
         endif
c
         write(io6,*)
         write(io6,*)'        ------  Subgroup (6c)  ------'
         write(io6,*)
         if(mhill.eq.1)then
            write(io6,*)'       CTDM-type receptor file read'
         else if(mhill.eq.2)then
            do 152 j=1,nctrec
            write(io6,151)j,xrct(j),yrct(j),elrect(j),ihill(j)
151         format(1x,'CTSG Receptor No.: ',i4,3x,'XRCT = ',f10.3,2x,
     1      'YRCT = ',f10.3,2x,'ELRECT = ',f10.3,2x,'IHILL = ',i4)
152         continue
         endif
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 7  ---------------'
         write(io6,*)
         do 162 j=1,nspec
         write(io6,161)cspec(j),j,(dryg(n,j),n=1,5)
161      format(1x,'SPECIES: ',a12,2x,'j: ',i3,2x,'dryg(-,j) = ',
     1    5f10.2)
162      continue
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 8  ---------------'
         write(io6,*)
         do 172 j=1,nspec
         write(io6,171)cspec(j),j,(dryp(n,j),n=1,2)
171      format(1x,'SPECIES: ',a12,2x,'j: ',i3,2x,'dryp(-,j) = ',
     1    2f10.2)
172      continue
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 9  ---------------'
         write(io6,*)
         write(io6,*)'rcutr   = ',rcutr
         write(io6,*)'rgr     = ',rgr
         write(io6,*)'reactr  = ',reactr
         write(io6,*)'pconst  = ',pconst
         write(io6,*)'bmin    = ',bmin
         write(io6,*)'bmax    = ',bmax
         write(io6,*)'qswmax  = ',qswmax
         write(io6,*)'dconst1 = ',dconst1
         write(io6,*)'dconst2 = ',dconst2
         write(io6,*)'dconst3 = ',dconst3
         write(io6,*)'dconst4 = ',dconst4
         write(io6,*)'nint    = ',npsint
         write(io6,*)'iveg    = ',iveg
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 10  ---------------'
         write(io6,*)
         do 182 j=1,nspec
         write(io6,181)cspec(j),j,(wa(n,j),n=1,2)
181      format(1x,'SPECIES: ',a12,2x,'j: ',i3,2x,'wa(-,j) = ',
     1    2(1pe10.3,2x))
182      continue
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 11  ---------------'
         write(io6,*)
         write(io6,*)'moz      = ',moz
         write(io6,*)'bcko3m   = ',(bcko3m(ih),ih=1,4)
         write(io6,*)'         = ',(bcko3m(ih),ih=5,8)
         write(io6,*)'         = ',(bcko3m(ih),ih=9,12)
         write(io6,*)'bcknh3m  = ',(bcknh3m(ih),ih=1,4)
         write(io6,*)'         = ',(bcknh3m(ih),ih=5,8)
         write(io6,*)'         = ',(bcknh3m(ih),ih=9,12)
         write(io6,*)'rnite1   = ',rnite1
         write(io6,*)'rnite2   = ',rnite2
         write(io6,*)'rnite3   = ',rnite3
         write(io6,*)'mh2o2    = ',mh2o2
         write(io6,*)'bckh2o2m = ',(bckh2o2m(ih),ih=1,4)
         write(io6,*)'         = ',(bckh2o2m(ih),ih=5,8)
         write(io6,*)'         = ',(bckh2o2m(ih),ih=9,12)
         write(io6,*)'bckpmf   = ',(bckpmf(ih),ih=1,4)
         write(io6,*)'         = ',(bckpmf(ih),ih=5,8)
         write(io6,*)'         = ',(bckpmf(ih),ih=9,12)
         write(io6,*)'ofrac    = ',(ofrac(ih),ih=1,4)
         write(io6,*)'         = ',(ofrac(ih),ih=5,8)
         write(io6,*)'         = ',(ofrac(ih),ih=9,12)
         write(io6,*)'vcnx     = ',(vcnx(ih),ih=1,4)
         write(io6,*)'         = ',(vcnx(ih),ih=5,8)
         write(io6,*)'         = ',(vcnx(ih),ih=9,12)

         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 12  ---------------'
         write(io6,*)
         write(io6,*)'sytdep   = ',sytdep
         write(io6,*)'mhftsz   = ',mhftsz
         write(io6,*)'jsup     = ',jsup
         write(io6,*)'conk1    = ',conk1
         write(io6,*)'conk2    = ',conk2
         write(io6,*)'iurb1    = ',iurb1
         write(io6,*)'iurb2    = ',iurb2
         write(io6,*)
         write(io6,*)'anemht   = ',anemht
         write(io6,*)'isigmav  = ',isigmav
         write(io6,*)'imixctdm = ',imixctdm
         write(io6,*)'ilanduin = ',ilanduin
         write(io6,*)'z0in     = ',z0in
         write(io6,*)'xlaiin   = ',xlaiin
         write(io6,*)'elevin   = ',elevin
         write(io6,*)'xlatin   = ',xlatin
         write(io6,*)'xlonin   = ',xlonin
         write(io6,*)
         write(io6,*)'xmxlen   = ',xmxlen
         write(io6,*)'mxnew    = ',mxnew
         if(mxagehr.GT.0) then
            write(io6,*)'mxagehr  = ',mxagehr
         endif
         write(io6,*)'xsamlen  = ',xsamlen
         write(io6,*)'mxsam    = ',mxsam
         write(io6,*)'ncount   = ',ncount
         write(io6,*)'sl2pf    = ',sl2pf
         write(io6,*)'wscalm   = ',wscalm
         write(io6,*)'cdiv     = ',cdiv
         write(io6,*)
         do iws=1,5
            write(io6,*)'wscat    = ',wscat(iws),'  top for class',iws
         enddo
         write(io6,*)
         write(io6,*)'Over LAND'
         do isc=1,6
            write(io6,*)'svmin    = ',svmin(isc,1),' for stability',isc
         enddo
         do isc=1,6
            write(io6,*)'swmin    = ',swmin(isc,1),' for stability',isc
         enddo
         write(io6,*)
         write(io6,*)'Over WATER'
         do isc=1,6
            write(io6,*)'svmin    = ',svmin(isc,2),' for stability',isc
         enddo
         do isc=1,6
            write(io6,*)'swmin    = ',swmin(isc,2),' for stability',isc
         enddo
         write(io6,*)
         write(io6,*)'symin    = ',symin
         write(io6,*)'szmin    = ',szmin
         write(io6,*)'szcap_m  = ',szcap_m
         write(io6,*)'xminzi   = ',xminzi
         write(io6,*)'xmaxzi   = ',xmaxzi
         write(io6,*)
         do isc=1,6
            write(io6,*)'plx0     = ',plx0(isc),'   for stability',isc
         enddo
         write(io6,*)
         do isc=1,2
            kst=isc+4
            write(io6,*)'ptg0     = ',ptg0(isc),'   for stability',kst
         enddo
         write(io6,*)
         do isc=1,6
            write(io6,*)'ppc      = ',ppc(isc),'   for stability',isc
         enddo
         write(io6,*)'tbd      = ',tbd
         write(io6,*)'tibldist = ',(tibldist(itd),itd=1,3)
         write(io6,*)'nlutibl  = ',nlutibl
         write(io6,*)'nsplit   = ',nsplit
         write(io6,*)'iresplit = ',(iresplit(ihr),ihr=1,4)
         write(io6,*)'         = ',(iresplit(ihr),ihr=5,8)
         write(io6,*)'         = ',(iresplit(ihr),ihr=9,12)
         write(io6,*)'         = ',(iresplit(ihr),ihr=13,16)
         write(io6,*)'         = ',(iresplit(ihr),ihr=17,20)
         write(io6,*)'         = ',(iresplit(ihr),ihr=21,24)
         write(io6,*)'zisplit  = ',zisplit
         write(io6,*)'roldmax  = ',roldmax
         write(io6,*)'nsplith  = ',nsplith
         write(io6,*)'sysplith = ',sysplith
         write(io6,*)'shsplith = ',shsplith
         write(io6,*)'cnsplith = ',(cnsplith(is),is=1,nspec)
         write(io6,*)'epsslug  = ',epsslug
         write(io6,*)'epsarea  = ',epsarea
         write(io6,*)'dsrise   = ',dsrise
         write(io6,*)'trajincl = ',trajincl
         write(io6,*)'mdepbc   = ',mdepbc
         write(io6,*)'htminbc  = ',htminbc
         write(io6,*)'rsampbc  = ',rsampbc
         if(nss.GT.0) write(io6,*)'nss      = ',nss
         do iss=1,nss
            write(io6,*)'xlatss,xlonss= ',xlatss(iss),xlonss(iss)
         enddo
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 13  ---------------'
         write(io6,*)
         write(io6,*)'npt1     = ',npt1
         write(io6,*)'iptu     = ',iptu,'  units = ',qnam1(iptu)
         write(io6,*)'      converted to g/s by factor: ',qunits(iptu)
         write(io6,*)'nspt1    = ',nspt1
         write(io6,*)'npt2     = ',npt2
         write(io6,*)
         if(npt1.GT.0) then
            write(io6,*)'cnampt1  = ',(cnampt1(n),n=1,npt1)
            write(io6,*)'xpt1grd  = ',(xpt1grd(n),n=1,npt1)
            write(io6,*)'ypt1grd  = ',(ypt1grd(n),n=1,npt1)
            write(io6,*)'htstak   = ',(htstak(n),n=1,npt1)
            write(io6,*)'elstak   = ',(elstak(n),n=1,npt1)
            write(io6,*)'diam     = ',(diam(n),n=1,npt1)
            write(io6,*)'exitw    = ',(exitw(n),n=1,npt1)
            write(io6,*)'tstak    = ',(tstak(n),n=1,npt1)
            write(io6,*)'idownw   = ',(idownw(n),n=1,npt1)
            write(io6,*)'syipt1   = ',(syipt1(n),n=1,npt1)
            write(io6,*)'szipt1   = ',(szipt1(n),n=1,npt1)
            write(io6,*)'fmfpt1   = ',(fmfpt1(n),n=1,npt1)
            write(io6,*)'zplatpt1 = ',(zplatpt1(n),n=1,npt1)
         endif
         do i=1,npt1
            write(io6,*)
            write(io6,*)'pt. source: ',cnampt1(i),'  number: ',i
            write(io6,*)'qstak    = ',(qstak(n,i),n=1,nspec)
            if(idownw(i).GE.1) then
               write(io6,*)'bwidth   = ',(bwidth(n,i),n=1,36)
               write(io6,*)'bht      = ',(bht(n,i),n=1,36)
               if(mbdw.EQ.2) then
                  write(io6,*)'bln1     = ',(bln1(n,i),n=1,36)
                  write(io6,*)'xbadj1   = ',(xbadj1(n,i),n=1,36)
                  write(io6,*)'ybadj1   = ',(ybadj1(n,i),n=1,36)
               endif
            endif
            do is=1,nspec
               if(ivpt1(is,i).NE.0) then
                  write(io6,*)'emission factors for species: ',cspec(is)
                  write(io6,*)'IVARY = ',ivpt1(is,i)
                  do iq=1,iqnum(ivpt1(is,i))
                     j=iq12pt1(is,i)+iq-1
                     write(io6,'(6f8.3,/,6f8.3)') (vqfac(n12,j),
     &                                             n12=1,12)
                  enddo
               endif
            enddo
         enddo
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 14  ---------------'
         write(io6,*)
         write(io6,*)'nar1     = ',nar1
         write(io6,*)'iaru     = ',iaru,'  units = ',qnam2(iaru)
         write(io6,*)'   converted to g/s/m^2 by factor: ',qunits(iaru)
         write(io6,*)'nsar1    = ',nsar1
         write(io6,*)'nar2     = ',nar2
         write(io6,*)
         if(nar1.gt.0)then
            write(io6,*)'cnamar1  = ',(cnamar1(n),n=1,nar1)
            write(io6,*)'htar1    = ',(htar1(n),n=1,nar1)
            write(io6,*)'elar1    = ',(elar1(n),n=1,nar1)
            write(io6,*)'sz0ar1   = ',(sz0ar1(n),n=1,nar1)
         endif
         do i=1,nar1
            write(io6,*)
            write(io6,*)'area source: ',cnamar1(i),'  number: ',i
            write(io6,*)'qar1     = ',(qar1(n,i),n=1,nspec)
            write(io6,*)'area1    = ',area1(i)
            do iv=1,nvert1(i)
               write(io6,*)'[x,y]ar1grd  = ',xar1grd(iv,i),yar1grd(iv,i)
            enddo
            do is=1,nspec
               if(ivar1(is,i).NE.0) then
                  write(io6,*)'emission factors for species: ',cspec(is)
                  write(io6,*)'IVARY = ',ivar1(is,i)
                  do iq=1,iqnum(ivar1(is,i))
                     j=iq12ar1(is,i)+iq-1
                     write(io6,'(6f8.3,/,6f8.3)') (vqfac(n12,j),
     &                                             n12=1,12)
                  enddo
               endif
            enddo
         enddo
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 15  ---------------'
         write(io6,*)
         write(io6,*)'nln2     = ',nln2
         write(io6,*)'nlines   = ',nlines
         write(io6,*)'ilnu     = ',ilnu,'  units = ',qnam1(ilnu)
         write(io6,*)'      converted to g/s by factor: ',qunits(ilnu)
         write(io6,*)'nsln1    = ',nsln1
         write(io6,*)'xl       = ',xl
         write(io6,*)'hbl      = ',hbl
         write(io6,*)'wbl      = ',wbl
         write(io6,*)'wml      = ',wml
         write(io6,*)'dxl      = ',dxl
         write(io6,*)'fprimel  = ',fprimel
         write(io6,*)'mxnseg     = ',mxnseg
         write(io6,*)'nlrise   = ',nlrise
         write(io6,*)
         if(nlines.gt.0)then
            write(io6,*)'cnamln1  = ',(cnamln1(n),n=1,nar1)
            write(io6,*)'xlbeggrd = ',(xlbeggrd(n),n=1,nlines)
            write(io6,*)'ylbeggrd = ',(ylbeggrd(n),n=1,nlines)
            write(io6,*)'xlendgrd = ',(xlendgrd(n),n=1,nlines)
            write(io6,*)'ylendgrd = ',(ylendgrd(n),n=1,nlines)
            write(io6,*)'hsl      = ',(hsl(n),n=1,nlines)
            write(io6,*)'belevl   = ',(belevl(n),n=1,nlines)
            write(io6,*)
            do i=1,nlines
              write(io6,*)'line source: ',cnamln1(i),'  number: ',i
              write(io6,*)'qtl      = ',(qtl(n,i),n=1,nspec)
              write(io6,*)'arline   = ',arline(i)
              do iv=1,4
                 write(io6,*)'[x,y]vertl   = ',xvertl(iv,i),yvertl(iv,i)
              enddo
              do is=1,nspec
                 if(ivln1(is,i).NE.0) then
                    write(io6,*)'emission factors for species: ',
     &                           cspec(is)
                    write(io6,*)'IVARY = ',ivln1(is,i)
                    do iq=1,iqnum(ivln1(is,i))
                       j=iq12ln1(is,i)+iq-1
                       write(io6,'(6f8.3,/,6f8.3)') (vqfac(n12,j),
     &                                               n12=1,12)
                    enddo
                 endif
              enddo
            enddo
         endif
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 16  ---------------'
         write(io6,*)
         write(io6,*)'nvl1     = ',nvl1
         write(io6,*)'ivlu     = ',ivlu,'  units = ',qnam1(ivlu)
         write(io6,*)'      converted to g/s by factor: ',qunits(ivlu)
         write(io6,*)'nsvl1    = ',nsvl1
         write(io6,*)'nvl2     = ',nvl2
         write(io6,*)
         if(nvl1.gt.0)then
            write(io6,*)'cnamvl1  = ',(cnamvl1(n),n=1,nar1)
            write(io6,*)'xvl1grd  = ',(xvl1grd(n),n=1,nvl1)
            write(io6,*)'yvl1grd  = ',(yvl1grd(n),n=1,nvl1)
            write(io6,*)'htvl1    = ',(htvl1(n),n=1,nvl1)
            write(io6,*)'elvl1    = ',(elvl1(n),n=1,nvl1)
            write(io6,*)'sy0vl1   = ',(sy0vl1(n),n=1,nvl1)
            write(io6,*)'sz0vl1   = ',(sz0vl1(n),n=1,nvl1)
         endif
         do i=1,nvl1
            write(io6,*)
            write(io6,*)'volume source: ',cnamvl1(i),'  number: ',i
            write(io6,*)'qvl1     = ',(qvl1(n,i),n=1,nspec)
            do is=1,nspec
               if(ivvl1(is,i).NE.0) then
                  write(io6,*)'emission factors for species: ',
     &                         cspec(is)
                  write(io6,*)'IVARY = ',ivvl1(is,i)
                  do iq=1,iqnum(ivvl1(is,i))
                     j=iq12vl1(is,i)+iq-1
                     write(io6,'(6f8.3,/,6f8.3)') (vqfac(n12,j),
     &                                             n12=1,12)
                  enddo
               endif
            enddo
         enddo
c
         write(io6,*)
         write(io6,*)'--------------  INPUT GROUP 17  ---------------'
         write(io6,*)
         write(io6,*)'nrec     = ',nrec
         if(nrec.gt.0)then
            write(io6,*)'xng      = ',(xng(n),n=1,nrec)
            write(io6,*)'yng      = ',(yng(n),n=1,nrec)
            write(io6,*)'zng      = ',(zng(n),n=1,nrec)
            write(io6,*)'elevng   = ',(elevng(n),n=1,nrec)
         endif
c      endif

c --- Terminate run if QA detected a fatal flaw in control file
      if(PROBLEM) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'*******************************************'
         write(io6,*)'FATAL error(s) found in control file ---'
         write(io6,*)'Scan this file for FATAL/ERROR/WARNING '
         write(io6,*)'messages.'
         write(*,*)
         write(*,*)'*********  FATAL  ***********'
         write(*,*)'FATAL error in control file ---'
         write(*,*)
         stop 'Halted in READCF -- see list file.'
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine qainp(problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                  QAINP
c                D. Strimaitis
c                Modified by J. Scire
c
c --- PURPOSE:  Check selected input data provided in control file
c
c --- UPDATE
c --- V6.26-V6.261 080520 (DGS): Fix logic to implement QA on MTILT
c --- V6.251-V6.26 080430 (DGS): Add INRISE and MRISE checks
c --- V6.25-V6.251 080421 (DGS): MPARTLBA switch is independent of
c                                MPARTL
c --- V6.24-V6.25 080227  (DGS): Add NLUTIBL range check
c --- V6.2-V6.24  080208  (DGS): Add MPARTLBA to MREG check
c --- V6.115-V6.2 070629  (DGS): Add MREG check for svmin values 
c                                (all must be 0.5m/s)
c                 070629  (DGS): Stop if source contribution output
c                                and PRIME downwash options are used
c                                together (PRIME cavity concentrations
c                                are not stored by source)
c --- V6.11-V6.115 061020  (DGS): Add check for discrete receptors off
c                                 the computational grid
c
c --- V5.752-V5.754 060202 (DGS): Correct bugs in QAINP that did not
c                                 properly identify the EPA guidance
c                                 selections when checking user inputs:
c         -- Allow either CALMET or ISCMET (METFM=1,2)
c         -- Allow either MESOPUFF II of RIVAD chemistry (MCHEM=1,3)
c         -- Allow either PG or turbulence-based dispersion (MDISP=2,3)
c         -- Require PDF option with turbulence-based dispersion
c
c --- V5.75-V6.11  060309  (DGS): Add check for SVMIN,SWMIN
c                  060309  (DGS): Warn if MTAULY > 0
c --- V5.741-V5.75 050225  (DGS): Add check for platform downwash
c                                 configuration
c                  050225  (DGS): Add check for MCTURB
c                  050225  (DGS): Add check for MTAULY
c --- V5.74-V5.741 040913  (DGS): Add check for DATUM in control file
c                                 set to UNKNOWN.
c                                 Add check for puff-age cutoff
c                                 control MXAGEHR in Group 12.
c --- V5.73-V5.74  040715  (DGS): add MPRFFM
c --- V5.72-V5.73  040611  (DGS): add MTILT
c --- V5.71-V5.72  031017  (DGS): add MSOURCE
c --- V5.7-V5.71   030528  (DGS): Add MBCON checks
c                  030528  (DGS): Notify QA ALERT on screen
c --- V5.4-V5.7    030402  (DGS): Add map and datum checks
c                  030402  (DGS): Add PRIME checks
c --- V5.4-V5.4    000602_5(DGS): initialize QAFAIL before MREG block
c --- V5.4-V5.4    000602_4(DGS): add check for valid XBTZ
c --- V5.4-V5.4    000602_4(DGS): monthly BCKO3M, BCKNH3M, BCKH2O2M
c --- V5.4-V5.4    000602_3(DGS): add aqueous chemistry checks and 
c                                 screen for negative background concs
c --- V5.3-V5.4    000602  (DGS): use QAFAIL when testing MREG vars
c                  000602  (DGS): check NSPLITH input
c --- V5.3-V5.3    991222b (DGS): Check FMFPT1 range
c --- V5.2-V5.3    991222a (DGS): Check MTURBVW range
c --- V5.1-V5.2    991104  (DGS): Compare nx,ny against mxnx,mxny
c --- V5.0-V5.1    990625b (DGS): Add PGTIME to AVET check
c --- V5.0-V5.0    990228a (DGS): METRUN=0 if multiple CALMET.DAT files
c                                 are used
c --- V5.0-V5.0    990228  (DGS): Add QA check for CDIV
c --- V5.0-V5.0    990130  (JSS): Regulatory option with latest (1/99) 
c                                 recommendations
c --- V5.0-V5.0    980515  (DGS): Must select METFM=1 if MSGTIBL=1
c --- V5.0-V5.0    980304  (DGS): Must have valid Lat/Lon with MCHEM=3
c --- V4.0-V5.0    971107  (DGS): Restrict selection of strain-based
c                                 terrain treatment until finalized
c                  971107  (DGS): Restrict selection of PDF to
c                                 turbulence-based dispersion
c                  971107  (DGS): Add check for MTINV=1 when MPARTL=0
c
c --- INPUTS:
c        PROBLEM - logical    - Flag indicating if FATAL flaw is found
c                               (initialized in calling routine)
c
c     Common block /BCS/ variables:
c        HTMINBC, RSAMPBC
c     Common block /CHEMDAT/ variables:
c        MOZ, BCKO3M(12), BCKNH3M(12), MH2O2, BCKH2O2M(12)
c     Common block /COMPARM/ variables:
c        CDIV, NSPLITH, CNSPLITH, MXAGEHR, SVMIN(6,2), SWMIN(6,2)
c        NLUTIBL
c     Common block /CTSGDAT/ variables:
c        MHILL, NHILL, MCTREC
c     Common block /DATEHR/ variables:
c        XBTZ
c     Common block /DISPDAT/ variables:
c        SYTDEP, AVET, PGTIME
c     Common block /DRYDEP/ variables:
c        IDRYFLG
c     Common block /DRYPART/ variables:
c        GSIG
c     Common block /filnam/ variables:
c        NMETDAT
c     Common block /FLAGS/ variables:
c        MREG, MGAUSS, MCTADJ, MTRANS, MTIP, MCHEM, MWET, MDRY, MDISP,
c        MDISP2, MTURBVW, MROUGH, MPARTL, MPDF, MCTSG, MHFTSZ, MTINV,
c        MSGTIBL, MSPLIT, MAQCHEM, MBDW, MBCON, MDEPBC, MTILT,
c        MCTURB, MTAULY, MPARTLBA, MRISE
c     Common block /GEN/ variables:
c        METFM, CSPEC(mxspec), METRUN, MPRFFM
c     Common block /GRID/ variables:
c        NX, NY, NZ, ZFACE(mxnzp1)
c     Common block /MAP/ variables:
c        lutm,llcc,lps,lem,llaza,lttm,
c        iutmzn,feast,fnorth,
c        rnlat0,relon0,rlat0,rlon0,xlat1,xlat2,
c        pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2
c     Common block /METHD/ variables:
c        XLATIN, XLONIN
c     Common block /NONGRD/
c        NREC, XNG(mxrec), YNG(mxrec)
c     Common block /OUTPT/ variables:
c        MSOURCE, INRISE
c     Common block /PT1/ variables:
c        NPT1, FMFPT1(mxpt1), IDOWNW(mxpt1), ZPLATPT1(mxpt1)
c     Parameters:
c           MXSPEC, MXNZP1, MXPT1, IO6
c
c --- OUTPUT:
c        PROBLEM - logical    - Flag indicating if FATAL flaw is found
c
c     (Common block output only if a non-fatal fault is found with 
c      input data)
c     Common block /COMPARM/ variables:
c        CDIV
c     Common block /GRID/ variables:
c        NZ, ZFACE(mxnzp1)
c     Common block /CTSGDAT/ variables:
c        NHILL, MCTREC
c     Common block /FLAGS/ variables:
c        MTINV
c
c --- QAINP called by:  READCF
c --- QAINP calls:      LRSAME
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common blocks
      include 'bcs.puf'
      include 'chemdat.puf'
      include 'comparm.puf'
      include 'ctsgdat.puf'
      include 'datehr.puf'
      include 'dispdat.puf'
      include 'drydep.puf'
      include 'drypart.puf'
      include 'filnam.puf'
      include 'flags.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'map.puf'
      include 'methd.puf'
      include 'nongrd.puf'
      include 'outpt.puf'
      include 'pt1.puf'
c
      logical problem,qafail,warn
      logical lrsame

c --- Set warning logical
      warn=.FALSE.

c --- Check for regulatory option consistency
      if(mreg.lt.0.or.mreg.gt.1)then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Regulatory options available are currently '
         write(io6,*)'--  limited to two choices (0=not used or      '
         write(io6,*)'--  1=USEPA/IWAQM) -- Invalid value selected.   '   
         write(io6,*)'--  MREG =  ',mreg
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --------------------------------------------------------------------
c --- Check that regulatory options for MREG=1 (USEPA/IWAQM) have been
c --- selected
c---------------------------------------------------------------------
c
      qafail=.FALSE.
      if(mreg.eq.1)then
c
c ---    Use CALMET or ISCMET meteorological data
         if(metfm.ne.1 .and. metfm.ne.2)then
            write(io6,*)
            write(io6,*)'METFM does not match regulatory default value'
            write(io6,*)'METFM = ',metfm,' Reg. default = 1 or 2'
            qafail=.true.
         endif
c
c ---    Averaging time = 60 minutes
         iavetim=nint(avet)
         ipgtim=nint(pgtime)
         if(iavetim.ne.60)then
            write(io6,*)
            write(io6,*)'AVET does not match regulatory default value'
            write(io6,*)'AVET = ',avet,' Reg. default = 60.'
            write(io6,*)'IAVETIM = ',iavetim
            qafail=.true.
         endif
         if(ipgtim.ne.60)then
            write(io6,*)
            write(io6,*)'PGTIME does not match regulatory value'
            write(io6,*)'PGTIME = ',pgtime,' Reg. default = 60.'
            write(io6,*)'IPGTIM = ',ipgtim
            qafail=.true.
         endif
c
c ---    Gaussian vertical distribution
         if(mgauss.ne.1)then
            write(io6,*)
            write(io6,*)'MGAUSS does not match regulatory default value'
            write(io6,*)'MGAUSS = ',mgauss,' Reg. default = 1'
            qafail=.true.
         endif
c
c ---    Terrain treatment
         if(mctadj.ne.3)then
            write(io6,*)
            write(io6,*)'MCTADJ does not match regulatory default value'
            write(io6,*)'MCTADJ = ',mctadj,' Reg. default = 3'
            qafail=.true.
         endif
c
c ---    Transitional plume rise
         if(mtrans.ne.1)then
            write(io6,*)
            write(io6,*)'MTRANS does not match regulatory default value'
            write(io6,*)'MTRANS = ',mtrans,' Reg. default = 1'
            qafail=.true.
         endif
c
c ---    Stack tip downwash
         if(mtip.ne.1)then
            write(io6,*)
            write(io6,*)'MTIP does not match regulatory default value'
            write(io6,*)'MTIP = ',mtip,' Reg. default = 1'
            qafail=.true.
         endif
c
c ---    Briggs plume rise
         if(mrise.ne.1)then
            write(io6,*)
            write(io6,*)'MRISE does not match regulatory default value'
            write(io6,*)'MRISE = ',mrise,' Reg. default = 1 (Briggs)'
            qafail=.true.
         endif
c
c ---    SOx and NOx chemistry -- if SO2 is being modeled, then MCHEM must 
c ---    be set to use MESOPUFF II chemistry
c ---    NOTE: species ordering (SO2, SO4, NOx, HNO3, NO3 is enforced 
c ---          elsewhere)
         if(CSPEC(1).eq.'SO2')then
            if(mchem.ne.1 .and. mchem.ne.3)then
               write(io6,*)
               write(io6,*)'MCHEM does not match regulatory default',
     1         ' value'
               write(io6,*)'MCHEM = ',mchem,' Reg. default = 1 or 3'
               qafail=.true.
            endif 
         endif
c
c ---    Wet deposition
         if(mwet.ne.1)then
            write(io6,*)
            write(io6,*)'MWET does not match regulatory default value'
            write(io6,*)'MWET = ',mwet,' Reg. default = 1'
            qafail=.true.
         endif
c
c ---    Dry deposition
         if(mdry.ne.1)then
            write(io6,*)
            write(io6,*)'MDRY does not match regulatory default value'
            write(io6,*)'MDRY = ',mdry,' Reg. default = 1'
            qafail=.true.
         endif
c
c ---    Dispersion Coefficients
         if(mdisp.ne.2 .and. mdisp.ne.3)then
            write(io6,*)
            write(io6,*)'MDISP does not match regulatory default value'
            write(io6,*)'MDISP = ',mdisp,' Reg. default = 2 or 3'
            qafail=.true.
         endif
c
c ---    PDF option
         if(mdisp.eq.2 .and. mpdf.ne.1)then
            write(io6,*)
            write(io6,*)'MPDF does not match regulatory default value'
            write(io6,*)'MPDF = ',mpdf,' Reg. default = 1 when MDISP=2'
            qafail=.true.
         endif
c
c ---    Roughness adjustment
         if(mrough.ne.0)then
            write(io6,*)
            write(io6,*)'MROUGH does not match regulatory default value'
            write(io6,*)'MROUGH = ',mrough,' Reg. default = 0'
            qafail=.true.
         endif
c
c ---    Partial plume penetration
         if(mpartl.ne.1)then
            write(io6,*)
            write(io6,*)'MPARTL does not match regulatory default value'
            write(io6,*)'MPARTL = ',mpartl,' Reg. default = 1'
            qafail=.true.
         endif
c ---    No partial plume penetration on buoyant area sources
         if(mpartlba.ne.0)then
            write(io6,*)
            write(io6,*)'MPARTLBA does not match regulatory default'
            write(io6,*)'MPARTLBA = ',mpartlba,' Reg. default = 0'
            qafail=.true.
         endif
c
c ---    Heffter growth for sigma y
         idist=nint(sytdep)
         if(idist.ne.550)then
            write(io6,*)
            write(io6,*)'SYTDEP does not match regulatory default value'
            write(io6,*)'SYTDEP = ',sytdep,' Reg. default = 550.'
            write(io6,*)'IDIST  = ',idist
            qafail=.true.
         endif
c
c ---    Heffter growth for sigma z
         if(mhftsz.ne.0)then
            write(io6,*)
            write(io6,*)'MHFTSZ does not match regulatory default value'
            write(io6,*)'MHFTSZ = ',mhftsz,' Reg. default = 0'
            qafail=.true.
         endif
c
c ---    Minimum sigma-v values over water and land must be 0.5
         isv=0
         do k2=1,2
           do k=1,6
             if(.not.LRSAME(0.0001,svmin(k,k2),0.5)) isv=isv+1
           enddo
         enddo
         if(isv.GT.0) then
            write(io6,*)
            write(io6,*)'SVMIN does not match regulatory default value'
            write(io6,*)'Reg. default = 0.5 m/s'
            write(io6,*)'Over Land = ',(svmin(k,1),k=1,6)
            write(io6,*)'Overwater = ',(svmin(k,2),k=1,6)
            qafail=.true.
         endif
c
      endif
c
c --- Summary message for problems with regulatory options selected
      if(qafail) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Technical options conflict with the      --'
         write(io6,*)'--  regulatory option selected               --'
         write(io6,*)'--  MREG =  ',mreg
         write(io6,*)'                                               '
         write(io6,*)'--  Reset switches listed above to regulatory  '
         write(io6,*)'--  values and re-run model                    '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --------------------------------------------------------------------
c --- End of MREG=1 regulatory option checks
c---------------------------------------------------------------------
c
c --- Test for valid PMAP (restricted set until wind rotation
c --- and map factor codes are implemented)
      if(lutm.OR.llcc.OR.lttm) then
c        OK
      else
         write(io6,*)
         write(io6,*) 'QAINP:  Error in Input Group 4'
         write(io6,*) 'Unacceptable PMAP             = ',pmap
         write(io6,*) 'PMAP must be UTM,LCC,TTM'
         problem=.TRUE.
      endif
cc --- Test for valid PMAP
c      if(lutm.OR.llcc.OR.lps.OR.lem.OR.llaza.OR.lttm) then
cc        OK
c      else
c         write(io6,*)
c         write(io6,*) 'QAINP:  Error in Input Group 4'
c         write(io6,*) 'Unknown PMAP                  = ',pmap
c         write(io6,*) 'PMAP must be UTM,LCC,PS,EM,LAZA,TTM'
c         problem=.TRUE.
c      endif
c
c --- Test for valid IUTMZN
      if((iutmzn.LT.1 .OR. iutmzn.GT.60) .AND. LUTM) then
         write(io6,*)
         write(io6,*) 'QAINP:  Error in Input Group 4'
         write(io6,*) 'IUTMZN out of range           = ',iutmzn
         write(io6,*) 'IUTMZN should be 1 to 60'
         problem=.TRUE.
      endif
c
c --- Test for valid UTMHEM
      if((utmhem.NE.'N   '.AND.utmhem.NE.'S   ') .AND. LUTM) then
         write(io6,*)
         write(io6,*) 'QAINP:  Error in Input Group 4'
         write(io6,*) 'UTMHEM out of range           = ',utmhem
         write(io6,*) 'UTMHEM should be N or S'
         problem=.TRUE.
      endif
c
c --- Test for invalid DATUM
      if(datum.EQ.'UNKNOWN ' .OR. datum.EQ.'unknown ') then
         write(io6,*)
         write(io6,*) 'QAINP:  Error in Input Group 4'
         write(io6,*) 'DATUM must not be UNKNOWN'
         problem=.TRUE.
      endif
c
c --- Test for lat/lon of origin for LCC/PS/EM/LAZA/TTM map projection
      if(LLCC .or. LPS .or. LEM .or. LLAZA .or. LTTM) then
         if(rnlat0 .LT. -900.0 .OR. relon0 .LT. -900.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'Missing lat/lon of origin for ',pmap
            problem=.TRUE.
         elseif(rnlat0 .LT. -90.0 .OR. rnlat0 .GT. 90.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'RLAT0 (as N) out of range     = ',rnlat0
            write(io6,*) '|RLAT0| should be 0 to 90 degrees'
            problem=.TRUE.
         elseif(relon0 .LT. -180.0 .OR. relon0 .GT. 180.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'RLON0 (as E) out of range     = ',relon0
            write(io6,*) '|RLON0| should be 0 to 180 degrees'
            problem=.TRUE.
         endif
      endif
c
c --- Test for matching latitudes for LCC map projection
      if(LLCC) then
         if(xlat1 .LT. -900.0 .OR. xlat2 .LT. -900.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'Missing matching lats for ',pmap
            problem=.TRUE.
         elseif(xlat1 .LT. -90.0 .OR. xlat1 .GT. 90.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'XLAT1 (as N) out of range     = ',xlat1
            write(io6,*) '|XLAT1| should be 0 to 90 degrees'
            problem=.TRUE.
         elseif(xlat2 .LT. -90.0 .OR. xlat2 .GT. 90.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'XLAT2 (as N) out of range     = ',xlat2
            write(io6,*) '|XLAT2| should be 0 to 90 degrees'
            problem=.TRUE.
         endif
      endif
c
c --- Test for matching latitudes for PS/EM map projection
      if(LPS .or. LEM) then
         if(xlat1 .LT. -900.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'Missing matching lats for ',pmap
            problem=.TRUE.
         elseif(xlat1 .LT. -90.0 .OR. xlat1 .GT. 90.0) then
            write(io6,*)
            write(io6,*) 'QAINP:  Error in Input Group 4'
            write(io6,*) 'XLAT1 (as N) out of range     = ',xlat1
            write(io6,*) '|XLAT1| should be 0 to 90 degrees'
            problem=.TRUE.
         endif
      endif
c
c --- Check dimensions of met grid (note: mxnz already encountered as
c --- ZFACE heights are read in
      if(nx.GT.mxnx .OR. ny.GT.mxny) then
         write(io6,*)'ERROR in subr. QAINP -- Met Grid size exceeds ',
     1         'size set by parameters in PARAMS.PUF (mxnx,mxny),',
     2         'so revise PARAMS.PUF and recompile model.'
         write(io6,*)'    NX,NY = ',nx,ny
         write(io6,*)'MXNX,MXNY = ',mxnx,mxny
         problem=.TRUE.
      endif

c --- Check that discrete receptors are within the computational grid
      nrecbad=0
      ireclo=ibcomp-1
      jreclo=jbcomp-1
      irechi=iecomp
      jrechi=jecomp
      do k=1,nrec
         if(xng(k).LT.ireclo .OR. xng(k).GT.irechi .OR.
     &      yng(k).LT.jreclo .OR. yng(k).GT.jrechi) nrecbad=nrecbad+1
      enddo
      if(nrecbad.GT.0) then
         write(io6,*)'ERROR in subr. QAINP -- discrete receptors ',
     1         'lie outside of the computational grid'
         write(io6,*)'Easting grid cell range  = ',IBCOMP,IECOMP
         write(io6,*)'Northing grid cell range = ',JBCOMP,JECOMP
         write(io6,*)'Number outside range     = ',nrecbad
         problem=.TRUE.
      endif

c
c --- Check momentum adjustment factors for point sources (allow only
c --- 0.0 or 1.0 for now)
      fmfeps=0.01
      do i=1,npt1
         adel0=ABS(fmfpt1(i))
         adel1=ABS(fmfpt1(i)-1.0)
         if(adel0.LT.fmfeps) then
            fmfpt1(i)=0.0
         elseif(adel1.LT.fmfeps) then
            fmfpt1(i)=1.0
         else
            write(io6,*)'ERROR in subr. QAINP -- FMFAC values for all',
     1            ' point sources (Subgroup 13b) must be either 0 or 1'
            write(io6,*)'    Source #, FMFAC = ',i,fmfpt1(i)
            problem=.TRUE.
         endif
      enddo
c
c --- METFM is 1 - 5
      if(metfm.LT.1 .OR. metfm.GT.5) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Invalid selection for METFM option       --'
         write(io6,*)'--  Expected METFM = 1 to 5                  --'
         write(io6,*)'--  Found METFM = ',metfm
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Check for use of "1-layer" meteorological data (METMF=2,3) and
c --- impose a default 1-layer grid system if more than one layer
c --- is specified
      if(metfm.EQ.2 .OR. metfm.EQ.3) then
         if(nz.GT.1) then
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'------------------------------------------'
            write(io6,*)'           QA ALERT  !! '
            write(io6,*)'------------------------------------------'
            write(io6,*)'--  Only 1 layer is used for METFM=2,3  --'
            write(io6,*)'--  Single-layer grid system over-rides --'
            write(io6,*)'--  your choice of NZ =  ',nz
            zface(2)=zface(nz+1)
            nz=1
            write(io6,*)'    NZ    = ',nz
            n2=nz+1
            write(io6,*)'    ZFACE   = ',(zface(n),n=1,n2)
            write(io6,*)'------------------------------------------'
            write(io6,*)
            warn=.TRUE.
         endif
      endif
c
c --- CTSG data may have been provided regardless of the control MCTSG
c --- Make sure that NO CTSG calculations are done if MCTSG=0
      if(mctsg.EQ.0) then
         if(nhill.GT.0 .OR. nctrec.GT.0) then
            nhill=0
            nctrec=0
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'------------------------------------------'
            write(io6,*)'           QA ALERT  !! '
            write(io6,*)'------------------------------------------'
            write(io6,*)'--  CTSG hill information or receptor   --'
            write(io6,*)'--  information was found but MCTSG=0   --'
            write(io6,*)'--  Number of hills and CTSG receptors  --'
            write(io6,*)'--  are reset to zero                   --'
            write(io6,*)'------------------------------------------'
            write(io6,*)
            warn=.TRUE.
         endif
      else
c
c ---    CTSG is used, so make sure hills and receptors are provided!
         if((nhill.EQ.0 .OR. nctrec.EQ.0) .AND. mhill.EQ.2) then
            write(io6,*)'ERROR in subr. QAINP -- NHILL and NCTREC ',
     1      'must be > 0 when CTSG is used  -- NHILL = ',nhill,
     2      ' NCTREC = ',nctrec, ' MHILL = ',mhill
            problem=.TRUE.
         endif
         if(mhill.NE.1 .AND. mhill.NE.2)then
            write(io6,*)'ERROR in subr. QAINP -- MHILL must be ',
     1      'specified as 1 or 2 when CTSG option is used (MCTSG=1)'
            write(io6,*)'MCTSG = ',mctsg,' MHILL = ',mhill
         problem=.TRUE.
         endif
      endif
c
c --- Make sure that METFM=1 to fill gridded terrain array when
c --- the CALPUFF terrain adjustment is selected
      if(mctadj.EQ.2 .AND. metfm.NE.1)then
         write(io6,*)'ERROR in subr. QAINP -- METFM must be ',
     1   'specified as 1 when CALPUFF terrain adjustment option ',
     2   'is used (MCTADJ=2)'
         write(io6,*)'MCTADJ = ',mctadj,' METFM = ',metfm
         problem=.TRUE.
      endif
c
c --- Make sure that METFM=1 to resolve land use when
c --- the sub-grid TIBL module is selected
      if(msgtibl.EQ.1 .AND. metfm.NE.1)then
         write(io6,*)'ERROR in subr. QAINP -- METFM must be ',
     1   'specified as 1 (CALMET) when Sub-Grid TIBL option ',
     2   'is used (MSGTIBL=1)'
         write(io6,*)'MSGTIBL = ',msgtibl,' METFM = ',metfm
         problem=.TRUE.
      endif
c
c --- Check to see that turbulence data are available for MDISP=1,5
c --- and that a valid alternate dispersion option is selected
      if(mdisp.eq.1 .OR. mdisp.EQ.5) then
         if(mdisp2.LT.2 .OR. mdisp2.GT.4) then
            write(io6,*)'ERROR in subr. QAINP -- Back-up method for ',
     1      'computing sigmas when turbulence data are missing must ',
     2      'not require turbulence data! ( use MDISP2=2,3,4 )'
            write(io6,*)' MDISP, MDISP2 = ',mdisp,mdisp2
            problem=.TRUE.
         endif
         if(mturbvw.LT.1 .OR. mturbvw.GT.4) then
            write(io6,*)'ERROR in subr. QAINP -- Invalid choice for ',
     1      'source of turbulence data! ( use MTURBVW=1,2,3,4 )'
            write(io6,*)' MTURBVW = ',mturbvw
            problem=.TRUE.
         endif
         if(metfm.NE.4 .AND. metfm.NE.5) then
            if(mturbvw.EQ.4 .AND. metfm.NE.3) then
               write(io6,*)'ERROR in subr. QAINP -- PROFILE.DAT must ',
     1         'be selected (MTURBVW=1,2,3) for turbulence data needed',
     2         'for MDISP=1,5 when met option METFM=1,2 is used.'
               write(io6,*)'METFM = ',metfm,' MDISP = ',mdisp,
     1         ' MTURBVW = ',mturbvw
               problem=.TRUE.
            endif
         endif
      endif

c --- MCTURB is 1 or 2
      if(mcturb.LT.1 .OR. mcturb.GT.2) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Invalid selection for MCTURB option      --'
         write(io6,*)'--  Expected MCTURB = 1 or 2                 --'
         write(io6,*)'--  Found MCTURB = ',mcturb
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- MTAULY is 0,1 or 10
      if(mtauly.NE.0 .AND. mtauly.NE.1 .AND. mtauly.LE.10) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Invalid selection for MTAULY option      --'
         write(io6,*)'--  Expected MTAULY = 0,1 or >10             --'
         write(io6,*)'--  Found MTAULY = ',mtauly
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      elseif(mtauly.NE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Diagnostic selection for MTAULY option   --'
         write(io6,*)'--  MTAULY = 0 for regulatory applications   --'
         write(io6,*)'--  Found MTAULY = ',mtauly
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         warn=.TRUE.
      endif
c
c --- MPRFFM is 1 or 2
      if(mprffm.LT.1 .OR. mprffm.GT.2) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Invalid selection for MPRFFM option      --'
         write(io6,*)'--  Expected MPRFFM = 1, or 2                --'
         write(io6,*)'--  Found MPRFFM = ',mprffm
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Check/reset type of turbulence data in PROFILE.DAT file
      if(metfm.EQ.5 .OR. mprffm.EQ.2)then
         if(isigmav.NE.0) then

         isigmav=0
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  AERMET PROFILE.DAT file always has  --'
         write(io6,*)'--  sigma-theta rather than sigma-v, so --'
         write(io6,*)'--  ISIGMAV is reset to 0 here.         --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         warn=.TRUE.

         endif
      endif
c
c --- Restrict selection of PDF Option to MDISP=1,2
      if(mpdf.EQ.1 .AND. mdisp.GT.2) then
         write(io6,*)'ERROR in subr. QAINP -- PDF option is only',
     1   'available for turbulence-based dispersion (MDISP=1,2) '
         write(io6,*)'MPDF = ',mpdf,' MDISP = ',mdisp
         problem=.TRUE.
      endif

c --- Check partial penetration selections
      qafail=.FALSE.
      if(mpartl.LT.0 .OR. mpartl.GT.1)  qafail=.TRUE.
      if(mpartlba.LT.0 .OR. mpartlba.GT.1)  qafail=.TRUE.
      if(QAFAIL) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Partial penetration option must be 0 or 1--'
         write(io6,*)'--  Found MPARTL = ',mpartl
         write(io6,*)'--  and MPARTLBA = ',mpartlba
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c
c --- Inversion strength above CBL is needed only when partial
c --- penetration option is selected
      if(mtinv.EQ.1 .AND. (mpartl.EQ.0 .AND. mpartlba.EQ.0)) then
         mtinv=0
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  Temperature inversion data are not  --'
         write(io6,*)'--  used if partial penetration option  --'
         write(io6,*)'--  is not selected (MPARTL=MPARTLBA=0) --'
         write(io6,*)'--  so MTINV is reset from 1 to 0 here. --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         warn=.TRUE.
      endif
c
c --- Check for valid lat/lon for met stations when MCHEM=3 (RIVAD)
c --- This test only determines if control file contains lat/lon
c --- information consistent with the choice of met data, it does
c --- not verify that data provided are correct
      qafail=.FALSE.
      if(mchem.EQ.3) then
         if(metfm.NE.1) then
c ---       Require lat/lon in Group 12 for single-pt met station
            if(xlatin.LT.-900.) qafail=.TRUE.
            if(xlonin.LT.-900.) qafail=.TRUE.
         endif
      endif
      if(QAFAIL) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Option MCHEM = 3 requires lat/lon for    --'
         write(io6,*)'--  met station(s) which must be entered in  --'
         write(io6,*)'--  Group 12.  Provide XLATIN,XLONIN for     --'
         write(io6,*)'--  single-pt met station if METFM = 2,3,4   --'
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Aqueous phase chemistry option is not active here
      if(maqchem.NE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Option MAQCHEM is not available in this  --'
         write(io6,*)'--  version.  Reset to MAQCHEM=0, or remove  --'
         write(io6,*)'--  MAQCHEM from the control file.           --'
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Check for valid MCHEM selection when aqueous phase chemistry
c --- is selected
      qafail=.FALSE.
      if(maqchem.EQ.1) then
         if(mchem.NE.1 .AND. mchem.NE.3) qafail=.TRUE.
      elseif(maqchem.NE.0) then
         qafail=.TRUE.
      endif
      if(QAFAIL) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Valid Values for MAQCHEM are 0 and 1     --'
         write(io6,*)'--  Option MAQCHEM = 1 is only used when     --'
         write(io6,*)'--  chemical transformation of sulfates and  --'
         write(io6,*)'--  nitrates is modeled (MCHEM = 1,3)        --'
         write(io6,*)'--  MAQCHEM  =  ',maqchem
         write(io6,*)'--    MCHEM  =  ',mchem
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Check for valid background H2O2, NH3, and Ozone (Never negative)
      qafail=.FALSE.
      do imo=1,12
         if(maqchem.EQ.1 .AND. bckh2o2m(imo).LT.0.0) qafail=.TRUE.
         if(mchem.NE.0 .AND. bcko3m(imo).LT.0.0) qafail=.TRUE.
         if(mchem.NE.0 .AND. bcknh3m(imo).LT.0.0) qafail=.TRUE.
      enddo
      if(QAFAIL) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Background Ozone, Ammonia,               --'
         write(io6,*)'--  and H2O2 concentrations                  --'
         write(io6,*)'--  should never be negative (ppb)           --'
         write(io6,*)'--  BCKO3   =  ',bcko3m
         write(io6,*)'--  BCKNH3  =  ',bcknh3m
         write(io6,*)'--  BCKH2O2 =  ',bckh2o2m
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- Check number of puffs produced for horizontal splitting
      if(msplit.EQ.1 .AND. nsplith.LT.5) then
c ---    Number outside valid range
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Number of puffs after splitting 1 puff   --'
         write(io6,*)'--  horizontally must be at least 5          --'
         write(io6,*)'--  NSPLITH  =  ',nsplith
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- Check CNSPLITH values (none should be negative)
      qafail=.FALSE.
      if(msplit.EQ.1) then
         do is=1,nspec
            if(cnsplith(is).LT.0.0) qafail=.TRUE.
         enddo
      endif
      if(QAFAIL) then
c ---    Negative concentration for horizontal puff-split criteria
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Negative value in CNSPLITH array found!  --'
         write(io6,*)'--  Enter either NSPEC values, or just enter --'
         write(io6,*)'--  a single value that will be used for ALL --'
         do is=1,nspec
            write(io6,*)'--  CNSPLITH  =  ',cnsplith(is)
         enddo
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Vertical divergence thresholds CDIV control when and how fast
c --- the convergence adjustment is applied;  make sure that
c --- CDIV(1).LE.CDIV(2) and not negative
      if(cdiv(1).LT.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  Negative CDIV value(s) are RESET    --'
         write(io6,*)'--  Values found in Control File:       --'
         write(io6,*)'--  cdiv = ',cdiv
         write(io6,*)'--  New Values:                         --'
         cdiv(1)=0.00
         if(cdiv(2).LT.cdiv(1)) cdiv(2)=cdiv(1)
         write(io6,*)'--  cdiv = ',cdiv
         write(io6,*)'------------------------------------------'
         write(io6,*)
         warn=.TRUE.
      elseif(cdiv(2).LT.cdiv(1)) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  CDIV(2) is less than CDIV(1)        --'
         write(io6,*)'--  Values found in Control File:       --'
         write(io6,*)'--  cdiv = ',cdiv
         write(io6,*)'--  New Values:                         --'
         cdiv(2)=cdiv(1)
         write(io6,*)'--  cdiv = ',cdiv
         write(io6,*)'------------------------------------------'
         warn=.TRUE.
      endif
c
c --- Run period must be explicit if using multiple CALMET.DAT files
      if(metfm.EQ.1 .AND. metrun.EQ.1 .AND. nmetdat.GT.1) then
         write(io6,*)'ERROR in subr. QAINP -- Option to run all met.',
     1   'periods cannot be used with multiple CALMET.DAT files'
         write(io6,*)'METRUN = ',metrun,' NMETDAT = ',nmetdat
         problem=.TRUE.
      endif

c --- Check averaging times used to adjust PG sigma-y
      if(avet.GT.60. .OR. avet.LE.0.) then
c ---    Averaging time outside valid range
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Averaging time for sigma-y is not in     --'
         write(io6,*)'--  valid range: 0 < AVET <= 60 minutes      --'
         write(io6,*)'--  AVET =  ',avet
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
      if(pgtime.GT.60. .OR. pgtime.LE.0.) then
c ---    Averaging time outside valid range
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Averaging time for PG sigma-y is not in  --'
         write(io6,*)'--  valid range: 0 < PGTIME <= 60 minutes    --'
         write(io6,*)'--  PGTIME =  ',pgtime
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- Check base time zone
      if(xbtz.GT.12.01 .OR. xbtz.LT.-12.01) then
c ---    Time zone outside valid range
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Base time zone is not in valid range:    --'
         write(io6,*)'--  -12. <= XBTZ <= 12.                      --'
         write(io6,*)'--  XBTZ  =  ',xbtz
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- PRIME downwash option is not implemented for slugs
      if(mbdw.EQ.2 .AND. mslug.EQ.1) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Option MBDW=2 (PRIME downwash) is not    --'
         write(io6,*)'--  implemented for slugs (MSLUG=1).  Reset  --'
         write(io6,*)'--  MBDW=1 (HS/SS downwash) or MSLUG=0.      --'
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Check platform downwash configuration
c       1) Platform DW not used with PRIME at this time       (Error)
c       2) ZPLTFM > 0. not provided with platform DW          (Warn)
c       3) ZPLTFM > 0. provided but platform DW not selected  (Error)
      iplat1=0
      iplat2=0
      iplat3=0
      do i=1,npt1
         if(idownw(i).EQ.2 .AND. mbdw.EQ.2) iplat1=iplat1+1
         if(idownw(i).EQ.2 .AND. zplatpt1(i).LE.0.) iplat2=iplat2+1
         if(idownw(i).EQ.1 .AND. zplatpt1(i).GT.0.) iplat3=iplat3+1
      enddo
      if(iplat1.GT.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Option MBDW=2 (PRIME downwash) is not    --'
         write(io6,*)'--  implemented for Platform structures      --'
         write(io6,*)'--  (Group 13b Bldg Dwash = 2.).             --'
         write(io6,*)'--  Number of sources affected =   ',iplat1
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
      if(iplat2.GT.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Platform height ZPLTFM > 0 NOT provided  --'
         write(io6,*)'--  for source influenced by Platform bldgs  --'
         write(io6,*)'--  (Group 13b Bldg Dwash = 2.).             --'
         write(io6,*)'--  Number of sources affected =   ',iplat2
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         warn=.TRUE.
      endif
      if(iplat3.GT.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Platform height ZPLTFM is provided for a --'
         write(io6,*)'--  source NOT influenced by Platform bldgs  --'
         write(io6,*)'--  (Group 13b Bldg Dwash = 1.).             --'
         write(io6,*)'--  Number of sources affected =   ',iplat3
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- MBCON checks (boundary condition configuration)
      if(mbcon.LT.0 .OR. mbcon.GT.2) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Invalid selection for MBCON option       --'
         write(io6,*)'--  Expected MBCON = 0, 1, or 2              --'
         write(io6,*)'--  Found MBCON = ',mbcon
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
      dgridkm=.001*dgrid
      if(mbcon.GT.0 .AND. rsampbc.LT.dgridkm) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Search radius for sampling BC puffs may  --'
         write(io6,*)'--  be too small, compared to grid cell      --'
         write(io6,*)'--  RSAMPBC = ',rsampbc
         write(io6,*)'--  DGRIDKM = ',dgridkm
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         warn=.TRUE.
      endif
c --- Check for species BCON at end of list
      if(mbcon.GT.0 .AND. cspec(nspec).NE.'BCON'
     &              .AND. cspec(nspec).NE.'bcon') then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Last species in list must be BCON when   --'
         write(io6,*)'--  the Boundary Condition Puff otion is     --'
         write(io6,*)'--  used (MBCON > 0)                         --'
         write(io6,*)'--  Last Species Found = ',cspec(nspec)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- Check source contribution option
      if(msource.LT.0 .OR. msource.GT.1) then
c ---    Invalid MSOURCE
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Source Contribution Option is invalid :  --'
         write(io6,*)'--  0 <= MSOURCE <= 1                        --'
         write(io6,*)'--  MSOURCE  =  ',MSOURCE
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
      if(msource.GT.0 .AND. MBDW.EQ.2) then
c ---    MSOURCE is not allowed with PRIME downwash
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Source Contribution Option is not     :  --'
         write(io6,*)'--  allowed with PRIME downwash              --'
         write(io6,*)'--  MSOURCE, MBDW  =  ',MSOURCE,MBDW
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- MTILT checks (gravitational settling option)
c       Restrictions:
c       - MDRY  = 1   
c       - NSPEC = 1  (must be particle species as well)
c       - sg    = 0  GEOMETRIC STANDARD DEVIATION in Group 8 is
c                    set to zero for a single particle diameter
c       - MCTADJ= 0,1,3  (Interaction with option 2 not supported)
      if(mtilt.LT.0 .OR. mtilt.GT.1) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Invalid selection for MTILT option       --'
         write(io6,*)'--  Expected MTILT = 0, or 1                 --'
         write(io6,*)'--  Found MTILT = ',mtilt
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      elseif(mtilt.EQ.1) then
         if(mdry.EQ.0) then
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'------------------------------------------'
            write(io6,*)'          FATAL FLAW  !! '
            write(io6,*)'------------------------------------------'
            write(io6,*)'--  Gravitational settling option(MTILT)--'
            write(io6,*)'--  is allowed only if dry deposition is--'
            write(io6,*)'--  selected (MDRY=1).                  --'
            write(io6,*)'--  Found MTILT = ',mtilt
            write(io6,*)'--  Found MDRY  = ',mdry
            write(io6,*)'------------------------------------------'
            write(io6,*)
            problem=.TRUE.
         endif
         if(mctadj.EQ.2) then
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'------------------------------------------'
            write(io6,*)'          FATAL FLAW  !! '
            write(io6,*)'------------------------------------------'
            write(io6,*)'--  Gravitational settling option(MTILT)--'
            write(io6,*)'--  is not allowed with CALPUFF terrain --'
            write(io6,*)'--  option (MCTADJ=2).                  --'
            write(io6,*)'--  Found MTILT  = ',mtilt
            write(io6,*)'--  Found MCTADJ = ',mctadj
            write(io6,*)'------------------------------------------'
            write(io6,*)
            problem=.TRUE.
         endif
         if(nspec.NE.1) then
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'------------------------------------------'
            write(io6,*)'          FATAL FLAW  !! '
            write(io6,*)'------------------------------------------'
            write(io6,*)'--  Gravitational settling option(MTILT)--'
            write(io6,*)'--  is only available for a single      --'
            write(io6,*)'--  species (NSPEC=1).                  --'
            write(io6,*)'--  Found MTILT = ',mtilt
            write(io6,*)'--  Found NSPEC = ',nspec
            write(io6,*)'------------------------------------------'
            write(io6,*)
            problem=.TRUE.
         elseif(gsig(1).GT.0.0 .OR. idryflg(1).NE.2) then
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'------------------------------------------'
            write(io6,*)'          FATAL FLAW  !! '
            write(io6,*)'------------------------------------------'
            write(io6,*)'--  Gravitational settling option(MTILT)--'
            write(io6,*)'--  requires dry deposited particle (2) --'
            write(io6,*)'--  species of one size (geo sdev=0.)   --'
            write(io6,*)'--  Found MTILT    = ',mtilt
            write(io6,*)'--  Found DRY DEP  = ',idryflg(1)
            write(io6,*)'--  Found GEO SDEV = ',gsig(1)
            write(io6,*)'------------------------------------------'
            write(io6,*)
            problem=.TRUE.
         endif
      endif

c --- MXAGEHR is typically not used, so warn if MXAGE>0.
c --- If regulatory switch is set, change warning to fatal error.
      if(mxagehr.GT.0 .AND. mreg.NE.1) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  Puff age cutoff (MXAGEHR) is active --'
         write(io6,*)'--  which may lead to underestimating   --'
         write(io6,*)'--  concentrations.                     --'
         write(io6,*)'--  Found MXAGEHR    = ',mxagehr
         write(io6,*)'------------------------------------------'
         write(io6,*)
         warn=.TRUE.
      elseif(mxagehr.GT.0 .AND. mreg.EQ.1) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  Puff age cutoff (MXAGEHR) is active --'
         write(io6,*)'--  which may lead to underestimating   --'
         write(io6,*)'--  concentrations.                     --'
         write(io6,*)'--  Found MXAGEHR    = ',mxagehr
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- Check SVMIN,SWMIN values (all 24 should be valid)
      missv=0
      missw=0
      do k=1,6
         if(svmin(k,1).LE.0.0) missv=missv+1
         if(svmin(k,2).LE.0.0) missv=missv+1
         if(swmin(k,1).LE.0.0) missw=missw+1
         if(swmin(k,2).LE.0.0) missw=missw+1
      enddo
      if(missv.GT.0 .OR. missw.GT.0) then
c ---    Minimum sigv or sigw arrays are incomplete
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Minimum sigma-v values invalid :  ',missv
         write(io6,*)'--  Minimum sigma-w values invalid :  ',missw
         write(io6,*)'--         SVMIN over LAND                   --'
         write(io6,*)'--     Default  Stability   Found            --'
         write(io6,9) '0.50 ','A',svmin(1,1)
         write(io6,9) '0.50 ','B',svmin(2,1)
         write(io6,9) '0.50 ','C',svmin(3,1)
         write(io6,9) '0.50 ','D',svmin(4,1)
         write(io6,9) '0.50 ','E',svmin(5,1)
         write(io6,9) '0.50 ','F',svmin(6,1)
         write(io6,*)'--         SVMIN over WATER                  --'
         write(io6,*)'--     Default  Stability   Found            --'
         write(io6,9) '0.37 ','A',svmin(1,2)
         write(io6,9) '0.37 ','B',svmin(2,2)
         write(io6,9) '0.37 ','C',svmin(3,2)
         write(io6,9) '0.37 ','D',svmin(4,2)
         write(io6,9) '0.37 ','E',svmin(5,2)
         write(io6,9) '0.37 ','F',svmin(6,2)
         write(io6,*)'--         SWMIN over LAND                   --'
         write(io6,*)'--     Default  Stability   Found            --'
         write(io6,9) '0.20 ','A',swmin(1,1)
         write(io6,9) '0.12 ','B',swmin(2,1)
         write(io6,9) '0.08 ','C',swmin(3,1)
         write(io6,9) '0.06 ','D',swmin(4,1)
         write(io6,9) '0.03 ','E',swmin(5,1)
         write(io6,9) '0.016','F',swmin(6,1)
         write(io6,*)'--         SWMIN over LAND                   --'
         write(io6,*)'--     Default  Stability   Found            --'
         write(io6,9) '0.20 ','A',swmin(1,2)
         write(io6,9) '0.12 ','B',swmin(2,2)
         write(io6,9) '0.08 ','C',swmin(3,2)
         write(io6,9) '0.06 ','D',swmin(4,2)
         write(io6,9) '0.03 ','E',swmin(5,2)
         write(io6,9) '0.016','F',swmin(6,2)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
9     format(8x,a5,7x,a1,7x,f9.3)

c --- Check NLUTIBL search radius
      if(nlutibl.LE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Search radius for nearest land and water --'
         write(io6,*)'--  cells for TIBL must be at least 1 cell   --'
         write(io6,*)'--  NLUTIBL  =  ',NLUTIBL
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- Check Plume Rise options
      if(mrise.LT.1 .OR. mrise.GT.2) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Plume rise option (MRISE) must be 1 or 2 --'
         write(io6,*)'--  1: Briggs    2: Numerical                --'
         write(io6,*)'--  MRISE  =  ',mrise
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
      if(inrise.LT.0 .OR. inrise.GT.1) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'          FATAL FLAW  !! '
         write(io6,*)'-----------------------------------------------'
         write(io6,*)'--  Numerical rise output option (INRISE)    --'
         write(io6,*)'--  0: None    1: Create RISE.DAT file       --'
         write(io6,*)'--  INRISE  =  ',inrise
         write(io6,*)'-----------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif

c --- Place warning message on screen if needed
      if(WARN) then
         write(*,*)
         write(*,*)'*********  WARNING  ***********'
         write(*,*)'Potential problem in Control file ---'
         write(*,*)'Search for QA ALERT in List file  ---'
         write(*,*)
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine quadarea(x,y,area)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980430               QUADAREA
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute the area of a quadrilateral polygon.  The
c               shape must be regular in the sense that no line that
c               is drawn through it may cross more than 2 sides.
c
c --- UPDATE
c --- V5.0-V5.0     980430  (DGS): drop constraint that vertex locations
c                                  are resolved to nearest meter
c
c --- INPUTS:
c              X - real       - X-verticies of polygon (UTM-km)
c              Y - real       - Y-verticies of polygon (UTM-km)
c
c --- OUTPUT:
c           AREA - real       - Area of polygon (m^2)
c
c
c --- QUADAREA called by:  READCF
c --- QUADAREA calls:      TRIAREA
c----------------------------------------------------------------------
c
      real x(4),y(4)
      real xm(4),ym(4)
c
c --- Convert to meters, relative to vertex 1
      xm(1)=0.0
      ym(1)=0.0
      do iv=2,4
         xm(iv)=1000.*( x(iv)-x(1) )
         ym(iv)=1000.*( y(iv)-y(1) )
      enddo
c --- Compute the 6 distances between pairs of vertices
      d12=SQRT((xm(1)-xm(2))**2 + (ym(1)-ym(2))**2)
      d13=SQRT((xm(1)-xm(3))**2 + (ym(1)-ym(3))**2)
      d14=SQRT((xm(1)-xm(4))**2 + (ym(1)-ym(4))**2)
      d23=SQRT((xm(2)-xm(3))**2 + (ym(2)-ym(3))**2)
      d24=SQRT((xm(2)-xm(4))**2 + (ym(2)-ym(4))**2)
      d34=SQRT((xm(3)-xm(4))**2 + (ym(3)-ym(4))**2)
c
c --- Sum area of 4 triangles formed by taking 3 vertices at a time
      area=triarea(d12,d13,d23)+triarea(d23,d24,d34)+
     &     triarea(d13,d14,d34)+triarea(d12,d14,d24)
c
c --- Area of quadrilateral is half of this sum
      area=0.5*area
c
      return
      end
c----------------------------------------------------------------------
      function triarea(a,b,c)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940831                TRIAREA
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute the area of a triangle.
c
c --- INPUTS:
c          A,B,C - real       - Lengths of 3 sides (m)
c
c --- OUTPUT:
c        TRIAREA - real       - Area of triangle (m^2)
c
c
c --- TRIAREA called by:  QUADAREA
c --- TRIAREA calls:      none
c----------------------------------------------------------------------
c
      s=0.5*(a+b+c)
      triarea=SQRT(s*(s-a)*(s-b)*(s-c))
c
      return
      end
c----------------------------------------------------------------------
      subroutine readfn
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                 READFN
c                J. Scire
c
c --- PURPOSE:  Read the file containing the file names of the
c               input and output files of the run
c
c --- UPDATE
c --- V6.11-V6.26  080430  (DGS): add RISE.DAT for numerical rise output
c --- V5.725-V6.11 060309  (DGS): change c*70 filenames to c*132
c --- V5.7-V5.725  050128  (DGS): add TK2D.DAT for 2D temperature output 
c                  050128  (DGS): add RHO2D.DAT for 2D density output 
c --- V5.4-V5.7    030402  (DGS): MXVAR relocated to PARAMS.CAL
c --- V5.4-V5.4    000602_3(DGS): add H2O2.DAT for aqueous chemistry
c --- V5.3-V5.4    000602  (DGS): add multiple variable emission files
c                                 PTEMARB.DAT, BAEMARB.DAT, and
c                                 VOLEMARB.DAT
c                  000602  (DGS): add message to "stop"
c                  000602  (DGS): write error message to * (not io6)
c                  000602  (DGS): add file for FOG output (FOG.DAT)
c --- V5.2-V5.3    991222  (DGS): add boundary condition file (BCON.DAT)
c --- V5.0-V5.0    990228d (DGS): add mass balance file
c --- V5.0-V5.0    990228c (DGS): add mass flux files
c --- V5.0-V5.0    990228a (DGS): add multiple CALMET.DAT files
c --- V5.0-V5.0    980515  (DGS): add file for defining coast line(s)
c                                 (COASTLN.DAT)
c --- V5.0-V5.0    980304  (DGS): add restart filename
c --- V4.0-V5.0    971107  (DGS): expand dictionary array to MXVAR,
c                                 and report errors to screen (IOMESG)
c                  971107  (DGS): add file for variable line sources
c                                 (LNEMARB.DAT)
c
c --- INPUTS:
c        Parameters: IO5, IOMESG, MXVAR
c
c --- OUTPUT:
c
c ---    Common block /FILNAM/ variables:
c           pufinp,metdat,iscdat,plmdat,puflst,condat,dfdat,wfdat,
c           visdat,t2ddat,rhodat,ptdat,ardat,lndat,ozdat,vddat,chemdat,
c           hildat,rctdat,prfdat,sfcdat,rstartb,rstarte,
c           cstdat,debug,lcfiles,
c           nmetdat,imetdat,metdatl,
c           nptdat,ptdat,nardat,ardat,nvoldat,voldat,
c           bdydat,flxdat,baldat,bcndat,
c           fogdat,h2o2dat,risdat
c
c --- READFN called by:  READCF
c --- READFN calls:      READIN, FILCASE
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
      include 'params.cal'
c
      character*4 ctemp(132,32)
      character*12 cvdic(mxvar,5)
      integer ivleng(mxvar,5),ivtype(mxvar,5)
      logical lecho
c
c --- Include common blocks
      include 'filnam.puf'
c
      data lecho/.false./
      data names/32/
      data cvdic/
     a 'METDAT','ISCDAT','PLMDAT','PUFLST',
     a 'CONDAT','DFDAT','WFDAT','VISDAT','PTDAT','VOLDAT','ARDAT',
     a 'LNDAT','OZDAT','VDDAT','CHEMDAT','HILDAT','RCTDAT','PRFDAT',
     a 'SFCDAT','RSTARTB','RSTARTE','CSTDAT','BDYDAT','FLXDAT',
     a 'BALDAT','BCNDAT','DEBUG','FOGDAT','H2O2DAT','T2DDAT',
     a 'RHODAT','RISDAT',
     a 'LCFILES','NMETDAT','NPTDAT','NARDAT','NVOLDAT', 23*' ',
     b 'METDAT',59*' ',
     c 'PTDAT',59*' ',
     d 'ARDAT',59*' ',
     e 'VOLDAT',59*' '/
c
      data ivleng/
     a  32*132,5*1, 23*0,
     b  132, 59*0,
     c  132, 59*0,
     d  132, 59*0,
     e  132, 59*0/
c
      data ivtype/
     a  32*4,3,4*2, 23*0,
     b  4, 59*0,
     c  4, 59*0,
     d  4, 59*0,
     e  4, 59*0/
c
c --- Read the file names from the data file
c
c ---    Initialize the temporary arrays
         do i=1,names
            do j=1,132
               ctemp(j,i)(1:1)=' '
            enddo
         enddo
c
c ---    Read the file names for the model run
         call readin(cvdic(1,1),ivleng(1,1),ivtype(1,1),io5,iomesg,
     &   lecho,
     1   ctemp(1,1),ctemp(1,2),ctemp(1,3),ctemp(1,4),ctemp(1,5),
     2   ctemp(1,6),ctemp(1,7),ctemp(1,8),ctemp(1,9),ctemp(1,10),
     3   ctemp(1,11),ctemp(1,12),ctemp(1,13),ctemp(1,14),ctemp(1,15),
     4   ctemp(1,16),ctemp(1,17),ctemp(1,18),ctemp(1,19),ctemp(1,20),
     5   ctemp(1,21),ctemp(1,22),ctemp(1,23),ctemp(1,24),ctemp(1,25),
     6   ctemp(1,26),ctemp(1,27),ctemp(1,28),ctemp(1,29),ctemp(1,30),
     7   ctemp(1,31),ctemp(1,32),
     8   lcfiles,nmetdat,nptdat,nardat,nvoldat,
     9   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     &   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---    Prepare any filenames included in the I/O file by erasing
c ---    the default filename set above
         if(ctemp(1,1)(1:1).ne.' ')metdat=' '
         if(ctemp(1,2)(1:1).ne.' ')iscdat=' '
         if(ctemp(1,3)(1:1).ne.' ')plmdat=' '
         if(ctemp(1,4)(1:1).ne.' ')puflst=' '
         if(ctemp(1,5)(1:1).ne.' ')condat=' '
         if(ctemp(1,6)(1:1).ne.' ')dfdat =' '
         if(ctemp(1,7)(1:1).ne.' ')wfdat =' '
         if(ctemp(1,8)(1:1).ne.' ')visdat=' '
         if(ctemp(1,9)(1:1).ne.' ')ptdat(1)=' '
         if(ctemp(1,10)(1:1).ne.' ')voldat(1)=' '
         if(ctemp(1,11)(1:1).ne.' ')ardat(1)=' '
         if(ctemp(1,12)(1:1).ne.' ')lndat=' '
         if(ctemp(1,13)(1:1).ne.' ')ozdat=' '
         if(ctemp(1,14)(1:1).ne.' ')vddat =' '
         if(ctemp(1,15)(1:1).ne.' ')chemdat=' '
         if(ctemp(1,16)(1:1).ne.' ')hildat =' '
         if(ctemp(1,17)(1:1).ne.' ')rctdat =' '
         if(ctemp(1,18)(1:1).ne.' ')prfdat =' '
         if(ctemp(1,19)(1:1).ne.' ')sfcdat =' '
         if(ctemp(1,20)(1:1).ne.' ')rstartb=' '
         if(ctemp(1,21)(1:1).ne.' ')rstarte=' '
         if(ctemp(1,22)(1:1).ne.' ')cstdat =' '
         if(ctemp(1,23)(1:1).ne.' ')bdydat =' '
         if(ctemp(1,24)(1:1).ne.' ')flxdat =' '
         if(ctemp(1,25)(1:1).ne.' ')baldat =' '
         if(ctemp(1,26)(1:1).ne.' ')bcndat =' '
         if(ctemp(1,27)(1:1).ne.' ')debug  =' '
         if(ctemp(1,28)(1:1).ne.' ')fogdat =' '
         if(ctemp(1,29)(1:1).ne.' ')h2o2dat=' '
         if(ctemp(1,30)(1:1).ne.' ')t2ddat=' '
         if(ctemp(1,31)(1:1).ne.' ')rhodat=' '
         if(ctemp(1,32)(1:1).ne.' ')risdat=' '
c
c ---    Transfer the char*4 data into the char*132 variables
         do j=1,132
            if(ctemp(j,1)(1:1).ne.' ')metdat(j:j)=ctemp(j,1)(1:1)
            if(ctemp(j,2)(1:1).ne.' ')iscdat(j:j)=ctemp(j,2)(1:1)
            if(ctemp(j,3)(1:1).ne.' ')plmdat(j:j)=ctemp(j,3)(1:1)
            if(ctemp(j,4)(1:1).ne.' ')puflst(j:j)=ctemp(j,4)(1:1)
            if(ctemp(j,5)(1:1).ne.' ')condat(j:j)=ctemp(j,5)(1:1)
            if(ctemp(j,6)(1:1).ne.' ')dfdat (j:j)=ctemp(j,6)(1:1)
            if(ctemp(j,7)(1:1).ne.' ')wfdat (j:j)=ctemp(j,7)(1:1)
            if(ctemp(j,8)(1:1).ne.' ')visdat(j:j)=ctemp(j,8)(1:1)
            if(ctemp(j,9)(1:1).ne.' ')ptdat(1)(j:j)=ctemp(j,9)(1:1)
            if(ctemp(j,10)(1:1).ne.' ')voldat(1)(j:j)=ctemp(j,10)(1:1)
            if(ctemp(j,11)(1:1).ne.' ')ardat(1)(j:j)=ctemp(j,11)(1:1)
            if(ctemp(j,12)(1:1).ne.' ')lndat (j:j)=ctemp(j,12)(1:1)
            if(ctemp(j,13)(1:1).ne.' ')ozdat (j:j)=ctemp(j,13)(1:1)
            if(ctemp(j,14)(1:1).ne.' ')vddat (j:j)=ctemp(j,14)(1:1)
            if(ctemp(j,15)(1:1).ne.' ')chemdat(j:j)=ctemp(j,15)(1:1)
            if(ctemp(j,16)(1:1).ne.' ')hildat (j:j)=ctemp(j,16)(1:1)
            if(ctemp(j,17)(1:1).ne.' ')rctdat (j:j)=ctemp(j,17)(1:1)
            if(ctemp(j,18)(1:1).ne.' ')prfdat (j:j)=ctemp(j,18)(1:1)
            if(ctemp(j,19)(1:1).ne.' ')sfcdat (j:j)=ctemp(j,19)(1:1)
            if(ctemp(j,20)(1:1).ne.' ')rstartb(j:j)=ctemp(j,20)(1:1)
            if(ctemp(j,21)(1:1).ne.' ')rstarte(j:j)=ctemp(j,21)(1:1)
            if(ctemp(j,22)(1:1).ne.' ')cstdat (j:j)=ctemp(j,22)(1:1)
            if(ctemp(j,23)(1:1).ne.' ')bdydat (j:j)=ctemp(j,23)(1:1)
            if(ctemp(j,24)(1:1).ne.' ')flxdat (j:j)=ctemp(j,24)(1:1)
            if(ctemp(j,25)(1:1).ne.' ')baldat (j:j)=ctemp(j,25)(1:1)
            if(ctemp(j,26)(1:1).ne.' ')bcndat (j:j)=ctemp(j,26)(1:1)
            if(ctemp(j,27)(1:1).ne.' ')debug  (j:j)=ctemp(j,27)(1:1)
            if(ctemp(j,28)(1:1).ne.' ')fogdat (j:j)=ctemp(j,28)(1:1)
            if(ctemp(j,29)(1:1).ne.' ')h2o2dat(j:j)=ctemp(j,29)(1:1)
            if(ctemp(j,30)(1:1).ne.' ')t2ddat (j:j)=ctemp(j,30)(1:1)
            if(ctemp(j,31)(1:1).ne.' ')rhodat (j:j)=ctemp(j,31)(1:1)
            if(ctemp(j,32)(1:1).ne.' ')risdat (j:j)=ctemp(j,32)(1:1)
         enddo
c
c ---    Convert the file names to the proper case
         call filcase(lcfiles,metdat)
         call filcase(lcfiles,iscdat)
         call filcase(lcfiles,plmdat)
         call filcase(lcfiles,puflst)
         call filcase(lcfiles,condat)
         call filcase(lcfiles,dfdat)
         call filcase(lcfiles,wfdat)
         call filcase(lcfiles,visdat)
         call filcase(lcfiles,ptdat(1))
         call filcase(lcfiles,voldat(1))
         call filcase(lcfiles,ardat(1))
         call filcase(lcfiles,lndat)
         call filcase(lcfiles,ozdat)
         call filcase(lcfiles,vddat)
         call filcase(lcfiles,chemdat)
         call filcase(lcfiles,hildat)
         call filcase(lcfiles,rctdat)
         call filcase(lcfiles,prfdat)
         call filcase(lcfiles,sfcdat)
         call filcase(lcfiles,rstartb)
         call filcase(lcfiles,rstarte)
         call filcase(lcfiles,cstdat)
         call filcase(lcfiles,bdydat)
         call filcase(lcfiles,flxdat)
         call filcase(lcfiles,baldat)
         call filcase(lcfiles,bcndat)
         call filcase(lcfiles,debug)
         call filcase(lcfiles,fogdat)
         call filcase(lcfiles,h2o2dat)
         call filcase(lcfiles,t2ddat)
         call filcase(lcfiles,rhodat)
         call filcase(lcfiles,risdat)
c      
c --- Process group of CALMET.DAT files (conditional)
      imetdat=1
      if(nmetdat.LE.1) then
c ---    Place single file name into first element of array of names
         metdatl(1)=metdat
      elseif(nmetdat.GT.mxmetdat)then
         write(*,*)
         write(*,*)'*********  FATAL  ***********'
         write(*,*)'ERROR in subr. READFN -- too many CALMET.DAT ',
     1   'files -- NMETDAT = ',nmetdat,' MXMETDAT = ',mxmetdat
         write(*,*)
         stop 'Halted in READFN -- see list file.'
      else
         do k=1,nmetdat
c ---       Initialize the temporary array
            do j=1,132
               ctemp(j,1)(1:1)=' '
            enddo
c ---       Read the CALMET.DAT file name
            call readin(cvdic(1,2),ivleng(1,2),ivtype(1,2),io5,iomesg,
     &      lecho,
     1      ctemp(1,1),
     2      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c ---       Prepare any filenames included in the I/O file by erasing
c ---       the default filename set above
            if(ctemp(1,1)(1:1).ne.' ')metdat=' '
c ---       Transfer the char*4 data into the char*132 variable
            do j=1,132
               if(ctemp(j,1)(1:1).ne.' ')metdat(j:j)=ctemp(j,1)(1:1)
            enddo
c ---       Convert the file name to the proper case
            call filcase(lcfiles,metdat)
c ---       Place file name into array
            metdatl(k)=metdat
         enddo

      endif
c      
c --- Process group of PTEMARB.DAT files (conditional)
      if(nptdat.GT.mxemdat)then
         write(*,*)
         write(*,*)'*********  FATAL  ***********'
         write(*,*)'ERROR in subr. READFN -- too many PTEMARB.DAT ',
     1   'files -- NPTDAT = ',nptdat,' MXEMDAT = ',mxemdat
         write(*,*)
         stop 'Halted in READFN -- see list file.'
      else
         do k=1,nptdat
c ---       Initialize the temporary array
            do j=1,132
               ctemp(j,1)(1:1)=' '
            enddo
c ---       Read the PTEMARB.DAT file name
            call readin(cvdic(1,3),ivleng(1,3),ivtype(1,3),io5,iomesg,
     &      lecho,
     1      ctemp(1,1),
     2      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c ---       Prepare any filenames included in the I/O file by erasing
c ---       the default filename set above
            if(ctemp(1,1)(1:1).ne.' ')ptdat(k)=' '
c ---       Transfer the char*4 data into the char*132 variable
            do j=1,132
               if(ctemp(j,1)(1:1).ne.' ')ptdat(k)(j:j)=ctemp(j,1)(1:1)
            enddo
c ---       Convert the file name to the proper case
            call filcase(lcfiles,ptdat(k))
         enddo

      endif
c      
c --- Process group of BAEMARB.DAT files (conditional)
      if(nardat.GT.mxemdat)then
         write(*,*)
         write(*,*)'*********  FATAL  ***********'
         write(*,*)'ERROR in subr. READFN -- too many BAEMARB.DAT ',
     1   'files -- NARDAT = ',nardat,' MXEMDAT = ',mxemdat
         write(*,*)
         stop 'Halted in READFN -- see list file.'
      else
         do k=1,nardat
c ---       Initialize the temporary array
            do j=1,132
               ctemp(j,1)(1:1)=' '
            enddo
c ---       Read the BAEMARB.DAT file name
            call readin(cvdic(1,4),ivleng(1,4),ivtype(1,4),io5,iomesg,
     &      lecho,
     1      ctemp(1,1),
     2      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c ---       Prepare any filenames included in the I/O file by erasing
c ---       the default filename set above
            if(ctemp(1,1)(1:1).ne.' ')ardat(k)=' '
c ---       Transfer the char*4 data into the char*132 variable
            do j=1,132
               if(ctemp(j,1)(1:1).ne.' ')ardat(k)(j:j)=ctemp(j,1)(1:1)
            enddo
c ---       Convert the file name to the proper case
            call filcase(lcfiles,ardat(k))
         enddo

      endif
c      
c --- Process group of VOLEMARB.DAT files (conditional)
      if(nvoldat.GT.mxemdat)then
         write(*,*)
         write(*,*)'*********  FATAL  ***********'
         write(*,*)'ERROR in subr. READFN -- too many VOLEMARB.DAT ',
     1   'files -- NVOLDAT = ',nvoldat,' MXEMDAT = ',mxemdat
         write(*,*)
         stop 'Halted in READFN -- see list file.'
      else
         do k=1,nvoldat
c ---       Initialize the temporary array
            do j=1,132
               ctemp(j,1)(1:1)=' '
            enddo
c ---       Read the VOLEMARB.DAT file name
            call readin(cvdic(1,5),ivleng(1,5),ivtype(1,5),io5,iomesg,
     &      lecho,
     1      ctemp(1,1),
     2      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6      idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c ---       Prepare any filenames included in the I/O file by erasing
c ---       the default filename set above
            if(ctemp(1,1)(1:1).ne.' ')voldat(k)=' '
c ---       Transfer the char*4 data into the char*132 variable
            do j=1,132
               if(ctemp(j,1)(1:1).ne.' ')voldat(k)(j:j)=ctemp(j,1)(1:1)
            enddo
c ---       Convert the file name to the proper case
            call filcase(lcfiles,voldat(k))
         enddo

      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine wrfiles(npt2,nar2,nln2,nvl2,idryflg,mhill)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                WRFILES
c                J. Scire
c
c --- PURPOSE:  Write a table of the input and output file names
c               for the current run
c
c --- UPDATE
c --- V6.11-V6.26   080430  (DGS): add RISE.DAT for numerical rise output
c --- V5.725-V6.11  060309  (DGS): change filenames from c*70 to c*132
c --- V5.4-V5.725   050128  (DGS): add TK2D.DAT for 2D temperature  
c                   050128  (DGS): add RHO2D.DAT for 2D density
c --- V5.4-V5.74    040715  (DGS): add METFM=5 (AERMET)
c --- V5.4-V5.4     000602_3(DGS): add H2O2.DAT for aqueous chemistry
c --- V5.3-V5.4     000602  (DGS): multiple PTEMARB, BAEMARB, and
c                                  VOLEMARB files
c                   000602  (DGS): include FOG.DAT file
c --- V5.3-V5.3     991222a (DGS): use of PROFILE.DAT for turbulence
c                                  when PLMMET.DAT option is used
c --- V5.2-V5.3     991222  (DGS): add BCON.DAT file
c --- V5.0-V5.1     990625b (DGS): drop mmodel='AUSPUFF' distinction
c --- V5.0-V5.0     990228d (DGS): add mass balance file
c --- V5.0-V5.0     990228c (DGS): add mass flux files
c --- V5.0-V5.0     990228a (DGS): add multiple CALMET.DAT files
c --- V5.0-V5.0     980918  (DGS): include MCHEM=4
c --- V5.0-V5.0     980515  (DGS): add COASTLN.DAT file
c --- V5.0-V5.0     980304  (DGS): add RESTART file
c --- V4.0-V5.0     971107  (DGS): add LNEMARB.DAT file
c
c --- INPUTS:
c               NPT2 - integer - Number of point sources with variable
c                                emissions
c                                (PTEMARB.DAT - arbitrary emissions)
c               NAR2 - integer - Number of buoyant area sources with
c                                variable location and emissions
c                                (BAEMARB.DAT - arbitrary emissions)
c               NLN2 - integer - Number of buoyant line sources with
c                                variable location and emissions
c                                (LNEMARB.DAT - arbitrary emissions)
c               NVL2 - integer - Number of volume sources with
c                                variable location and emissions
c                                (VOLEMARB.DAT - arbitrary emissions)
c     IDRYFLG(mxspec) - integer - Array of dry deposition flags for
c                       array     each pollutant
c                                   0 = No deposition
c                                   1 = Resistance model - gas
c                                   2 = Resistance model - particle
c                                   3 = User-specified dep. velocities
c               MHILL - integer - Flag controlling use of CTDM-format
c                                 hill information files (for CTSG)
c                                   0 = No file (CTSG option not used)
c                                   1 = HILL.DAT & HILLRCT.DAT files
c                                   2 = No files (hill data from OPTHILL
c                                       are supplied in Subgroup 6b,
c                                       and CTSG receptors are
c                                       supplied in Subgroup 6c)
c
c     Common block /FILNAM/ variables:
c         PUFINP, METDATL, ISCDAT, PLMDAT, PTDAT, ARDAT, VOLDAT, LNDAT,
c         VDDAT, OZDAT, CHEMDAT, HILDAT, RCTDAT, DEBUG, PUFLST,
c         CONDAT, DFDAT, WFDAT, VISDAT, T2DDAT, RHODAT, PRFDAT, SFCDAT,
c         RSTARTB, RSTARTE, CSTDAT, BDYDAT, FLXDAT, BALDAT, BCNDAT,
c         H2O2DAT, RISDAT, NMETDAT, NPTDAT, NARDAT, NVOLDAT
c     Common block /CHEMDAT/ variables:
c           MOZ, MH2O2
c     Common block /FLAGS/ variables:
c           MCHEM, MDRY, MDISP, MCTSG, MTURBVW, MSGTIBL, MBCON, MAQCHEM
c     Common block /GEN/ variables:
c           METFM, NSPEC, MRESTART
c     Common block /OUTPT/ variables:
c           ICON, IVIS, IT2D, IRHO, IDRY, IWET, IMFLX, IMBAL, IFOG,
c           INRISE, LDEBUG
c
c     Parameters: IO6, IO7, IO8, IO9, IO10, IO11, IO12, IO13, IO14, IO15,
c                 IO19, IO20, IO22, IO23, IO24, IO25, IO28, IO29, IO30,
c                 IO31, IO32, IO35, IO36, IO37, IO38, MXSPEC,
c                 IOPT2, IOAR2, IOVOL
c
c --- OUTPUT:  none
c
c --- WRFILES called by:  SETUP
c --- WRFILES calls:      none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common blocks
      include 'filnam.puf'
      include 'chemdat.puf'
      include 'flags.puf'
      include 'gen.puf'
      include 'outpt.puf'
c
      integer idryflg(mxspec)
c
c --------------------------------------------------
c --- Write the list of INPUT files used in this run
c --------------------------------------------------
      write(io6,10)
10    format(//1x,13('----------')/10x,'INPUT FILES'//
     1 1x,'Default Name',5x,'Unit No.',5x,'File Name and Path'/
     2 1x,'------------',5x,'--------',5x,'------------------')
c
c --- CALPUFF.INP
      write(io6,12)'CALPUFF.INP',io5,pufinp
12    format(1x,a12,7x,i3,8x,a132)
c
c --- Restart file for continuation run
      if(mrestart.EQ.1 .OR. mrestart.EQ.3) 
     &               write(io6,12)'RESTARTB.DAT',io3,rstartb
c
c --- Meteorological data file(s)
      if(metfm.EQ.1) then
c ---    CALMET meteorological data file   (CALMET.DAT)
         write(io6,12)'CALMET.DAT',io7,metdatl(1)
         do i=2,nmetdat
            write(io6,12)'  (----)  ',io7,metdatl(i)
         enddo
      elseif(metfm.EQ.2) then
c ---    ISC meteorological data file      (ISCMET.DAT)
         write(io6,12)'ISCMET.DAT',io7,iscdat
      elseif(metfm.EQ.3) then
c ---    PLUME meteorological data file    (PLMMET.DAT)
         write(io6,12)'PLMMET.DAT',io7,plmdat
      elseif(metfm.EQ.4 .OR. metfm.EQ.5) then
c ---    Tower data file              (PROFILE.DAT)
         write(io6,12)'PROFILE.DAT',io31,prfdat
c ---    Surface parameter file       (SURFACE.DAT)
         write(io6,12)'SURFACE.DAT',io32,sfcdat
      endif
c
c --- BOUNDARY CONCENTRATION file (BCON.DAT)
c --- (all information about both constant and variable boundary data)
      if(mbcon.gt.0)write(io6,12)'BCON.DAT',io15,bcndat
c
c --- POINT SOURCE emissions file #2 (PTEMARB.DAT)
c --- (stationary point sources with arbitrary variation in emissions)
      if(npt2.gt.0) then
         do i=1,nptdat
            io=iopt2+i-1
            write(io6,12)'PTEMARB.DAT',io,ptdat(i)
         enddo
      endif
c
c --- BUOYANT AREA SOURCE file  (BAEMARB.DAT)
c --- (area sources with arbitrary variation in location & emissions)
      if(nar2.gt.0) then
         do i=1,nardat
            io=ioar2+i-1
            write(io6,12)'BAEMARB.DAT',io,ardat(i)
         enddo
      endif
c
c --- BUOYANT LINE SOURCE file  (LNEMARB.DAT)
c --- (line sources with arbitrary variation in location & emissions)
      if(nln2.gt.0)write(io6,12)'LNEMARB.DAT',io19,lndat
c
c --- VOLUME SOURCE emissions file (VOLEMARB.DAT)
c --- (volume sources with arbitrary variation in location & emissions)
      if(NVL2.gt.0) then
         do iv=1,nvoldat
            io=iovol+iv-1
            write(io6,12)'VOLEMARB.DAT',io,voldat(iv)
         enddo
      endif
c
c --- DEPOSITION VELOCITY file (VD.DAT) (if user-specified
c     deposition velocities are used for any species AND computation
c     of dry deposition is requested
      if(mdry.eq.1)then
         do 20 i=1,nspec
         if(idryflg(i).eq.3)then
            write(io6,12)'VD.DAT',io20,vddat
            go to 22
         endif
20       continue
22       continue
      endif
c
c --- OZONE data file (OZONE.DAT) (if MESOPUFF II chemical
c     scheme is used AND hourly ozone input requested)
      if((mchem.EQ.1 .OR. mchem.EQ.3 .OR. mchem.EQ.4) .AND. moz.EQ.1)
     &   write(io6,12)'OZONE.DAT',io22,ozdat
c
c --- H2O2 data file (H2O2.DAT) (if aqueous phase chemical
c     scheme is used AND hourly H2O2 input requested)
      if(maqchem.EQ.1 .AND. mh2o2.EQ.1)
     &   write(io6,12)'H2O2.DAT',io23,h2o2dat
c
c --- CHEMICAL TRANSFORMATION file (CHEM.DAT) (if user-specified
c     chemical transformation rates are used)
      if(mchem.eq.2)write(io6,12)'CHEM.DAT',io24,chemdat
c
c --- TURBULENCE data file
      if(mdisp.eq.1 .OR. mdisp.EQ.5) then
         if(metfm.LT.4 .AND. mturbvw.LT.4) then
            write(io6,12)'PROFILE.DAT',io31,prfdat
         endif
      endif
c
c --- CTSG hill information files (HILL.DAT, HILLRCT.DAT)
c     (if CTDM processors are used to create them)
      if(mctsg.eq.1.and.mhill.eq.1) then
         write(io6,12)'HILL.DAT',io28,hildat
         write(io6,12)'HILLRCT.DAT',io29,rctdat
      endif
c
c --- Sub-Grid TIBL COAST LINE file (COASTLN.DAT) (if 
c     MSGTIBL option is selected)
      if(msgtibl.eq.1)write(io6,12)'COASTLN.DAT',io25,cstdat
c
c --- Mass flux BOUNDARY file (FLUXBDY.DAT)
      if(imflx.eq.1)write(io6,12)'FLUXBDY.DAT',io35,bdydat
c
c ---------------------------------------------------
c --- Write the list of OUTPUT files used in this run
c ---------------------------------------------------
      write(io6,30)
30    format(//1x,13('----------')/10x,'OUTPUT FILES'//
     1 1x,'Default Name',5x,'Unit No.',5x,'File Name and Path'/
     2 1x,'------------',5x,'--------',5x,'------------------')
c
c --- CALPUFF.LST
      write(io6,12)'CALPUFF.LST',io6,puflst
c
c --- Output concentration file (CONC.DAT)
      if(ICON.eq.1)write(io6,12)'CONC.DAT',io8,condat
c
c --- Output dry flux file (DFLX.DAT)
      if(IDRY.eq.1)write(io6,12)'DFLX.DAT',io9,dfdat
c
c --- Output wet flux file (WFLX.DAT)
      if(IWET.eq.1)write(io6,12)'WFLX.DAT',io10,wfdat
c
c --- Visibility-related file (VISB.DAT)
      if(IVIS.eq.1)write(io6,12)'VISB.DAT',io11,visdat
c
c --- 2D Temperature file (TK2D.DAT)
      if(IT2D.eq.1)write(io6,12)'TK2D.DAT',io13,t2ddat
c
c --- 2D Density file (RHO2D.DAT)
      if(IRHO.eq.1)write(io6,12)'RHO2D.DAT',io14,rhodat
c
c --- Mass flux file (MASSFLX.DAT)
      if(imflx.eq.1)write(io6,12)'MASSFLX.DAT',io36,flxdat
c
c --- Mass balance file (MASSBAL.DAT)
      if(imbal.eq.1)write(io6,12)'MASSBAL.DAT',io37,baldat
c
c --- Fog plume data file
      if(IFOG.eq.1)write(io6,12)'FOG.DAT',io12,fogdat
c
c --- Numerical rise data file
      if(INRISE.eq.1)write(io6,12)'RIS.DAT',io38,risdat
c
c --- Restart file
      if(mrestart.GE.2) write(io6,12)'RESTARTE.DAT',io4,rstarte
c
c --- Puff/Slug TRACKING file (DEBUG.DAT) (if in DEBUG mode)
      if(LDEBUG)write(io6,12)'DEBUG.DAT',io30,debug
c
      return
      end
c----------------------------------------------------------------------
      subroutine stktip(hs,diam,fluxm,vexit,wsstk,hdw)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991222b                STKTIP
c ---            J. Scire, SRC
c
c --- PURPOSE:  Calculate the plume height adjustment to account for
c               stack-tip downwash effects
c
c --- UPDATE
c --- V5.3-V5.3     991222b (DGS): add momentum flux to argument list
c                                  and test for zero (exit velocity may
c                                  not be vertical)
c
c --- INPUTS:
c              HS - real         - Stack height (m)
c            DIAM - real         - Stack diameter (m)
c           FLUXM - real         - Vertical momentum flux (m**4/s**2)
c           VEXIT - real         - Stack gas exit velocity (m/s)
c           WSSTK - real         - Stack height wind speed (m/s)
c
c --- OUTPUT:
c             HDW - real         - Plume height DECREASE (m)
c
c --- STKTIP called by:  POINTS1, POINTS2, PUFRECS, SLGRECS. PLGRECS
c --- STKTIP calls:      none
c----------------------------------------------------------------------
c
c --- Compute adjustment in effective stack height due to stack-tip
c     downwash effects.  Note that the adjustment cannot be greater
c     than the physical stack height!  The adjustment is POSITIVE, and
c     is SUBTRACTED from, not added to, the stack height.

      if(fluxm.EQ.0.0) then
         hdw=AMIN1(hs,(3.*diam))
      elseif(vexit.LT.(1.5*wsstk)) then
         vbyws=vexit/wsstk
         hdw=AMIN1(hs,(2.*diam*(1.5-vbyws)))
      else
         hdw=0.0
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine prb(fb,wsstk,x,xfinb,zfinb,zb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                    PRB
c ---            J. Scire, SRC
c
c --- PURPOSE:  Calculate transitional buoyant plume rise
c               (excluding building downwash effects).
c               This routine is used for both neutral/unstable and
c               stable conditions.
c
c --- INPUTS:
c              FB - real         - Buoyancy flux (m**4/s**3)
c           WSSTK - real         - Stack height wind speed (m/s)
c               X - real         - Downwind distance (m) from the
c                                  stack to the receptor
c           XFINB - real         - Distance (m) to final buoyant
c                                  plume rise for neutral/unstable
c                                  conditions
c           ZFINB - real         - Final buoyant plume rise (m)
c                                  (during stable conditions, taken as
c                                  the min. of vertical and bent-over
c                                  plume equations)
c
c --- OUTPUT:
c              ZB - real         - Transitional plume rise (m) due
c                                  to plume buoyancy
c
c --- PRB called by:  GRISE
c --- PRB calls:      none
c----------------------------------------------------------------------
c
c --- Check for case of no buoyant rise
      if(x.le.0.0.or.fb.le.0.0)then
         zb=0.0
      else
c ---    Compute transitional buoyant plume rise
         if(x.lt.xfinb .AND. wsstk.gt.0.0)then
            zb=(1.6*(fb*x*x)**0.333333)/wsstk
c
c ---       Final plume height in stable conditions is based on minimum
c ---       of bent-over and vertical plume equations -- ensure plume
c ---       height does not exceed final height
            zb=amin1(zb,zfinb)
         else
            zb=zfinb
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine prm(diam,vexit,fm,wsstk,istab,sqrts,x,xfinm,zfinm,zm)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                    PRM
c ---            J. Scire, SRC
c
c --- PURPOSE:  Calculate transitional momentum plume rise
c               (excluding building downwash effects).
c               This routine is used for both neutral/unstable and
c               stable conditions.
c
c --- INPUTS:
c            DIAM - real         - Stack diameter (m)
c           VEXIT - real         - Stack gas exit velocity (m/s)
c              FM - real         - Momentum flux (m**4/s**2)
c           WSSTK - real         - Stack height wind speed (m/s)
c           ISTAB - integer      - Stability class (1=A,...6=F)
c           SQRTS - real         - Square root of stability parameter,s
c                                  (sqrt(s)=(g*(dtheta/dz)/tair)**0.5)
c               X - real         - Downwind distance (m) from the
c                                  stack to the receptor
c           XFINM - real         - Distance (m) to final momentum
c                                  plume rise
c           ZFINM - real         - Final momentum plume rise (m)
c                                  (during stable conditions, taken as
c                                  the min. of vertical and bent-over
c                                  plume equations)
c
c --- OUTPUT:
c              ZM - real         - Transitional plume rise (m) due
c                                  to momentum
c
c --- PRM called by:  GRISE, POINTS1
c --- PRM calls:      none
c----------------------------------------------------------------------
c
c --- Check for case of no momentum rise
      if(vexit.le.0.0.or.fm.le.0.0.or.x.le.0.0)then
         zm=0.0
      else
c ---    Compute transitional momentum plume rise
         if(x.lt.xfinm .AND. wsstk.gt.0.0)then
c
c ---       Compute the momentum entrainment coefficient
            betaj=0.333333+(wsstk/vexit)
c ---       Compute neutral/unstable final rise
            zmfnu=3.*diam*vexit/wsstk
c
            if(istab.le.4)then
c
c ---          Neutral/unstable conditions
               zm=(3.*fm*x/(betaj*betaj*wsstk*wsstk))**0.333333
c ---          Test zm against neutral/unstable final rise (as in ISC2)
               zm=amin1(zm,zmfnu)
            else
c
c ---          Stable conditions
               zm=(3.*fm*sin(sqrts*x/wsstk)/(betaj*betaj*wsstk*
     1          sqrts))**0.333333
c
c ---          Should make sure that zm is no greater than zfinm,
c ---          which is the minimum of final momentum rise for either
c ---          stable or non-stable conditions
c
c              zm=amin1(zm,zfinm)
c
c ---          BUT, to be consistent with ISC2, only test zm against
c ---          neutral/unstable final rise (3.*diam*vexit/wsstk)
               zm=amin1(zm,zmfnu)
            endif
         else
c
c ---       Beyond distance to final rise
            zm=zfinm
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine prfin(vexit,diam,fm,fb,wsstk,istab,sqrts,
     1 xfinm,xfinb,xfin,zfinm,zfinb,zfin)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991222b                 PRFIN
c ---            J. Scire, SRC
c
c --- PURPOSE:  Calculate distance to final rise and height of final
c               plume rise
c
c --- UPDATE
c --- V5.3-V5.3     991222b (DGS): Account for zero momentum flux that
c                                  is caused by FMFAC=0
c
c --- INPUTS:
c           VEXIT - real         - Stack gas exit velocity (m/s)
c            DIAM - real         - Stack diameter (m)
c              FM - real         - Momentum flux (m**4/s**2)
c              FB - real         - Buoyancy flux (m**4/s**3)
c           WSSTK - real         - Stack height wind speed (m/s)
c           ISTAB - integer      - Stability class (1=A,...6=F)
c           SQRTS - real         - Square root of stability parameter,s
c                                  (sqrt(s)=(g*(dtheta/dz)/tair)**0.5)
c
c --- OUTPUTS:
c           XFINM - real         - Distance (m) to final momentum
c                                  plume rise
c           XFINB - real         - Distance (m) to final buoyant
c                                  plume rise
c            XFIN - real         - Larger of XFINM and XFINB
c           ZFINM - real         - Final momentum plume rise (m)
c           ZFINB - real         - Final buoyant plume rise (m)
c            ZFIN - real         - Larger of ZFINM and ZFINB
c
c --- PRFIN called by:  POINTS1, POINTS2
c --- PRFIN calls:      none
c----------------------------------------------------------------------
c
c --- Set minimum allowed wind speed at stack-top (wsstk0).  If wind
c --- speed is less than wsstk0, set distance to final rise equal to
c --- zero, and use the "calm rise" formula for stable conditions, or
c --- the neutral/unstable rise formulas with wsstk=wsstk0.
      data wsstk0/1.0/
c
c ------------------------------------------
c --- Compute distance, height of final rise
c ------------------------------------------
c
      if(wsstk.GE.wsstk0) then
c ---    "non-CALM" conditions ------------------------
c
c ---    Buoyant plume rise
         if(istab.le.4)then
c
c ---       Neutral/unstable conditions
            if(fb.ge.55.)then
               xfinb=119.*fb**0.4
               zfinb=38.71*fb**0.6/wsstk
            else if(fb.gt.0.0)then
               xfinb=49.*fb**0.625
               zfinb=21.425*fb**0.75/wsstk
            else
c
c ---          XFINB with FB le 0.0 follows ISC2 convention
               vexit2=amax1(vexit,1.0e-10)
               xfinb=4.*diam*(vexit2+3.*wsstk)**2/(vexit2*wsstk)
               fb2=amax1(fb,1.0e-10)
               zfinb=21.425*fb2**0.75/wsstk
            endif
         else
c
c ---       Stable conditions
            xfinb=2.0715*wsstk/sqrts
            s=sqrts*sqrts
            fb2=amax1(fb,1.0e-10)
c
c ---       Bent-over plume equation
            zfinb=2.6*(fb2/(wsstk*s))**0.333333
c
c ---       Vertical plume equation
            zfinv=4.*fb2**0.25/s**0.375
c
c ---       Final stable rise is lower of bent-over and vertical plume
c ---       values
            zfinb=amin1(zfinb,zfinv)
         endif
c
c ---    Momentum plume rise
         if(istab.le.4)then
c
c ---       Neutral/unstable conditions
            vexit2=amax1(vexit,1.0e-10)
            xfinm=4.*diam*(vexit2+3.*wsstk)**2/(vexit2*wsstk)
            zfinm=3.*diam*vexit/wsstk
         else
c
c ---       Stable conditions
c ---       (Constant 1.57080 = pi/2.)
            xfinm=1.57080*wsstk/sqrts
            fm2=amax1(fm,1.0e-10)
            zfinm=1.5*(fm2/(wsstk*sqrts))**0.333333
c
c ---       Maximum stable momentum rise is restricted to be less than
c ---       final neutral/unstable momentum rise
            zfinm=amin1(zfinm,3.*diam*vexit/wsstk)
         endif
c ---    Set xfinm,zfinm to zero explicitly when FM is zero
         if(fm.EQ.0.0) then
            xfinm=0.0
            zfinm=0.0
         endif
c
      else
c ---    "CALM" conditions ----------------------------
c
c ---    Buoyant plume rise
         if(istab.le.4)then
c
c ---       Neutral/unstable conditions
            xfinb=0.0
            if(fb.ge.55.)then
               zfinb=38.71*fb**0.6/wsstk0
            else
               fb2=amax1(fb,1.0e-10)
               zfinb=21.425*fb2**0.75/wsstk0
            endif
         else
c
c ---       Stable conditions
            xfinb=0.0
            s=sqrts*sqrts
            fb2=amax1(fb,1.0e-10)
c
c ---       Vertical plume equation
            zfinb=4.*fb2**0.25/s**0.375
         endif
c
c ---    Momentum plume rise
         if(istab.le.4)then
c
c ---       Neutral/unstable conditions
            vexit2=amax1(vexit,1.0e-10)
            xfinm=0.0
            zfinm=3.*diam*vexit/wsstk0
         else
c
c ---       Stable conditions
            xfinm=0.0
            fm2=amax1(fm,1.0e-10)
            zfinm=1.5*(fm2/(wsstk0*sqrts))**0.333333
c
c ---       Maximum stable momentum rise is restricted to be less than
c ---       final neutral/unstable momentum rise
            zfinm=amin1(zfinm,3.*diam*vexit/wsstk0)
         endif
c ---    Set xfinm,zfinm to zero explicitly when FM is zero
         if(fm.EQ.0.0) then
            xfinm=0.0
            zfinm=0.0
         endif
      endif
c
c --- Set overall maximum distance to final plume rise and maximum
c --- plume rise
      xfin=amax1(xfinb,xfinm)
      zfin=amax1(zfinb,zfinm)
c
      return
      end
c----------------------------------------------------------------------
      subroutine grise(x,htgrise,risefac)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080725                  GRISE
c ---            D. Strimaitis
c
c --- PURPOSE:  Calculate height of gradual plume rise at position "x"
c
c --- UPDATE
c --- V6.261-V6.262 080725  (DGS): Refine test for invalid negative
c                                  rise factor that halted a valid run
c                                  instead of returning a zero factor
c                   080725  (DGS): Change rise method from 2 (SS
c                                  downwash) to 3 (tabulated rise) for
c                                  point sources not subject to downwash
c                                  that are modeled with numerical plume
c                                  rise.
c --- V6.26-V6.261  080520  (DGS): Replace individual rise tables with
c                                  /SRCTAB/ arrays from Direct Access
c                                  file
c                   080520  (DGS): Add call to PRSS to treat SS downwash
c --- V6.23-V6.26   080430  (DGS): Add numerical rise for point sources
c                                  (not subject to downwash)
c                                  Use source type alone for 1st-level
c                                  logic branch, and consolidate 2nd-
c                                  level branch with a METHOD flag
c --- V6.22-V6.23   080204  (DGS): Apply stack-tip downwash adjustment
c                                  here instead of after call
c --- V6.1-V6.22    070921  (DGS): Check for imet outside valid range
c                                  of 1 to MXMETSAV+1
c --- V5.725-V6.1   050915  (DGS): add emission step argument to
c                                  numerical rise arrays (PT2,AR2)
c --- V5.7-V5.725   050128  (DGS): fix gradual rise factor for the PRIME
c                                  module.  The full rise (without 
c                                  streamline depression in a building
c                                  wake) was divided by the final rise
c                                  (with rather than without streamline
c                                  depression).
c                   050128  (DGS): add check for valid risefac
c --- V5.0-V5.7     030402  (DGS): introduce rise tables for point
c                                  sources with PRIME downwash
c                   030402  (DGS): use IMET in /CURRENT/ to select
c                                  appropriate tabulated values
c --- V5.0-V5.0     980821  (DGS): replace use of IAGE for AREA-source
c                                  tables since IAGE=1 for all puffs
c --- V4.0-V5.0     971107  (DGS): add variable line source treatment
c
c --- INPUTS:
c               X - real     - Downwind dist. from  "pt." source (m)
c
c     Common block /CURRENT/ variables:
c           IPNUM, ISNUM, ISTYPE, ZFRISE, XSHIFT, IMET,
c           IQSTEP
c     Common block /PUFF/ variables:
c           DIAM0(mxpuff), EXITW0(mxpuff), HT0(mxpuff), PLEXP0(mxpuff),
c           WS0(mxpuff), ISTAB0(mxpuff), SQRTS0(mxpuff),
c           FM(mxpuff), XMFIN(mxpuff), ZMFIN(mxpuff),
c           FB(mxpuff), XBFIN(mxpuff), ZBFIN(mxpuff),
c           ZLY0(mxpuff), R0(mxpuff), STIPDW(mxpuff)
c     Common block /FLAGS/ variables:
c           MSHEAR, MRISE
c     Common block /SRCTAB/ variables:
c           NTR,XTR(mxrise),ZTR(mxrise),HTR(mxrise)
c
c --- OUTPUTS:
c         HTGRISE - real         - Plume height (m) (stack+plume rise)
c         RISEFAC - real         - Corresponding plume rise as a
c                                  fraction of final rise
c
c --- GRISE called by:  PUFRECS, SLGRECS, RECSPEC0, RISEWIND
c --- GRISE calls:      PRM, PRB, PRBL, PRSHEAR, PRSS, PRTAB, INTERTAB
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'current.puf'
      include 'puff.puf'
      include 'flags.puf'
      include 'srctab.puf'

c --- Flag determines if height needs to be computed from rise
      logical lheight

c --- Initialize full rise factor as the default
      risefac=1.0

c --- Retain IMET for compatibility with previous treatment
c --- Validate imet index
      if(imet.LT.1 .OR. imet.GT.mxmetsav+1) then
         write(io6,*)
         write(io6,*) 'FATAL ERROR in GRISE: bad met period index'
         write(io6,*) 'Expected IMET = 1 to MXMETSAV+1'
         write(io6,*) 'Found    IMET = ',imet
         write(io6,*) '     MXMETSAV = ',mxmetsav
         write(io6,*)
         write(*,*)
         stop 'Halted in GRISE -- See list file'
      endif

c --- Set rise calculation METHOD for Point sources
c ---          0 =  No Rise
c ---          1 =  Briggs Rise
c ---          2 =  Briggs rise modified for SS downwash
c ---          3 =  Tabulated Rise
      if(istype.EQ.1 .OR. istype.EQ.2) then
         if(idw0(ipnum).EQ.4) then
c ---       PRIME downwash active - Cavity plume (no rise)
            method=0
         elseif(idw0(ipnum).EQ.3) then
c ---       PRIME downwash active - Primary plume (tabulated rise)
            method=3
         elseif(idw0(ipnum).EQ.2) then
c ---       SS downwash active (modified Briggs rise)
            method=2
         elseif(idw0(ipnum).EQ.1) then
c ---       HS downwash active (Briggs rise)
            method=1
         elseif(idw0(ipnum).EQ.0) then
            if(mrise.EQ.1) then
c ---          No downwash active, Briggs rise option
               method=1
            elseif(mrise.EQ.2) then
c ---          No downwash active, Numerical rise option
               method=3
            else
               write(io6,*)
               write(io6,*) 'FATAL ERROR in GRISE: invalid MRISE'
               write(io6,*) 'Expected MRISE = 1 or 2'
               write(io6,*) 'Found MRISE = ',mrise
               write(io6,*)
               write(*,*)
               stop 'Halted in GRISE -- See list file'
            endif
         else
            write(io6,*)
            write(io6,*) 'FATAL ERROR in GRISE: invalid IDW0'
            write(io6,*) 'Expected IDW0 = 0,1,2,3, or 4'
            write(io6,*) 'Found IDW0 = ',idw0(ipnum)
            write(io6,*)
            write(*,*)
            stop 'Halted in GRISE -- See list file'
         endif
      endif

c --- Process gradual rise by source type

      if(istype.EQ.1 .OR. istype.EQ.2) then
c ---    POINT source
c ---    ------------
c ---    Control-file (1) or Variable Emissions File (2)
         if(method.EQ.0) then
c ---       No rise
            htgrise=zfinal(ipnum)
            lheight=.FALSE.
         elseif(method.EQ.1) then
c ---       Briggs Rise
c ---       Get gradual momentum rise
            call prm(diam0(ipnum),exitw0(ipnum),fm(ipnum),ws0(ipnum),
     &               istab0(ipnum),sqrts0(ipnum),x,xmfin(ipnum),
     &               zmfin(ipnum),risem)
c ---       Get gradual buoyant rise
            call prb(fb(ipnum),ws0(ipnum),x,xbfin(ipnum),zbfin(ipnum),
     &               riseb)
c ---       Compute effects of vertical wind shear
            if(mshear.eq.1)then
               call prshear(fb(ipnum),ws0(ipnum),plexp0(ipnum),
     1             ht0(ipnum),x,xbfin(ipnum),zbfin(ipnum),risesh)
c ---          Take the minimum of the Briggs rise and shear rise
               riseb=amin1(riseb,risesh)
            endif
c ---       Pick the larger of the buoyant rise & momentum rise
            rise=AMAX1(risem,riseb)
            lheight=.TRUE.
         elseif(method.EQ.2) then
c ---       Schulman-Scire building downwash
            call prss(x,zly0(ipnum),r0(ipnum),ws0(ipnum),
     &                istab0(ipnum),sqrts0(ipnum),diam0(ipnum),
     &                exitw0(ipnum),fm(ipnum),fb(ipnum),
     &                xmfin(ipnum),xbfin(ipnum),rise)
            lheight=.TRUE.
         elseif(method.EQ.3) then
c ---       Tabulated Rise
c ---       Can be used if puff was released during current
c ---       met. period: IMET must be 1 for this puff
            if(imet.EQ.1) then
c ---          Check array size
               if(ntr.LE.0) then
                  write(io6,*)
                  write(io6,*) 'FATAL ERROR in GRISE: invalid array'
                  write(io6,*) 'Expected NTR greater than 0'
                  write(io6,*) 'Found NTR = ',ntr
                  write(io6,*)
                  write(*,*)
                  stop 'Halted in GRISE -- See list file'
               endif
               call INTERTAB(x,ntr,xtr,i1,i2,factor)
               htgrise=ztr(i1)+factor*(ztr(i2)-ztr(i1))
               rise=htr(i1)+factor*(htr(i2)-htr(i1))
c ---          Look at full final rise without streamline depression
c !!!          if(zfrise.GT.0.0) risefac=rise/zfrise
               riselast=htr(ntr)
               if(riselast.GT.0.0) risefac=rise/riselast
               lheight=.FALSE.
            else
               htgrise=zfinal(ipnum)
               lheight=.FALSE.
            endif
         endif

      elseif(istype.EQ.4) then
c ---    BUOYANT AREA source (interpolate in rise table)
c ---    -------------------
c ---    Tabulated rise can be used if puff was released during current
c ---    met. period: IMET must be 1 for this puff
         if(imet.EQ.1) then
c ---       Check array size
            if(ntr.LE.0) then
               write(io6,*)
               write(io6,*) 'FATAL ERROR in GRISE: invalid array'
               write(io6,*) 'Expected NTR greater than 0'
               write(io6,*) 'Found NTR = ',ntr
               write(io6,*)
               write(*,*)
               stop 'Halted in GRISE -- See list file'
            endif
c ---       Get rise
            call prtab(x,ht0(ipnum),ntr,xtr,ztr,rise)
         else
            rise=zfrise
         endif
         lheight=.TRUE.

      elseif(istype.EQ.5 .OR. istype.EQ.6) then
c ---    LINE source
c ---    -----------
c ---    Tabulated rise can be used if puff was released during current
c ---    or previous met. period: IMET must be 1 or 2 for this puff
         if(imet.GT.2) then
            rise=zfrise
         else
c ---       Check array size
            if(ntr.LE.0) then
               write(io6,*)
               write(io6,*) 'FATAL ERROR in GRISE: invalid array'
               write(io6,*) 'Expected NTR greater than 0'
               write(io6,*) 'Found NTR = ',ntr
               write(io6,*)
               write(*,*)
               stop 'Halted in GRISE -- See list file'
            endif
c ---       Get rise
            call prbl(x,xshift,ntr,xtr,ztr,rise)
         endif
         lheight=.TRUE.

      else
         rise=0.0
         lheight=.TRUE.
      endif

      if(LHEIGHT) then
c ---    Set plume height (release ht. + rise - stipdw) and
c ---    fractional rise factor
c ---    (Note: the stack-tip DW adjustment is non-zero only for
c ---     applicable source types when the MTIP option is selected)
         htgrise=ht0(ipnum)+rise-stipdw(ipnum)
         htgrise=AMAX1(0.0,htgrise)
         if(zfrise.GT.0.) then
            risefac=rise/zfrise
         else
            risefac=1.0
         endif
         if(method.EQ.2) then
c ---       Additional conditioning for SS downwash result (method=2):
c ---       Cubic solution for small distances or very small fluxes may
c ---       result in a very small negative rise due to single precision
c ---       so condition rise factor to positive values here
c ---       (note:  rise factor for BID is not used for these sources)
            risefac=AMAX1(risefac,0.0)
         endif
      endif

c --- Check for valid risefac
      if(risefac.LT.-0.0001) then
c ---    Potential problem.  Negative rise factor is more
c ---    negative than expected from precision.
c ---    Report problem and stop
         write(io6,*)
         write(io6,*)'Fatal Error in GRISE'
         write(io6,*)'Computed risefac is less than 0.0'
         write(io6,*)'   x,htgrise      = ',x,htgrise
         write(io6,*)'   rise,zfrise    = ',rise,zfrise
         write(io6,*)'   risefac        = ',risefac
         stop 'Halted in GRISE -- see list file'
      else
c ---    Reset small negative rise factor to zero
         risefac=AMAX1(risefac,0.0)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine prss(xarg,zly,r0,ws,istab,sqrts,diam,vexit,
     &                fluxm,fluxb,xfinm,xfinb,ssrise)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                   PRSS
c ---            Adapted from ISC2:DHPSS
c
c --- PURPOSE:  Calculates distance-dependent plume rise for
c               Schulman-Scire downwash algorithm, as coded in
c               ISC2.
c
c --- INPUTS:
c          XARG - real     - Downwind distance (m)
c           ZLY - real     - Effective line length based on sigma-y
c                            at 3*HL
c            R0 - real     - Effective source radius based on sigma-z
c                            at 3*HL
c            WS - real     - Stack height wind speed (m/s)
c         ISTAB - integer  - Stability class
c         SQRTS - real     - Square root of stability parameter
c                            (sqrt(s)=(g*(dtheta/dz)/tair)**0.5)
c          DIAM - real     - Stack diameter (m)
c         VEXIT - real     - Stack gas exit velocity (m/s)
c         FLUXM - real     - Momentum flux (m**4/s**2)
c         FLUXB - real     - Buoyancy flux (m**4/s**3)
c         XFINM - real     - Distance (m) to final momentum
c                            plume rise
c         XFINB - real     - Distance (m) to final buoyant
c                            plume rise
c
c --- OUTPUT:
c        SSRISE - real     - Schulman-Scire plume rise (m)
c
c --- PRSS called by:  POINTS1, POINTS2, GRISE
c --- PRSS calls:      SSCM, SSCB, ROOT3
c----------------------------------------------------------------------

      real rt(3)
      data pi/3.1415927/, beta/0.6/

c --- Determine coefficients A, B of cubic equation
      a = (3./beta)*(zly/pi + r0)
      b = (3.*r0/beta**2)*(2.*zly/pi + r0)

c --- Compute coefficient C for MOMENTUM rise (CM)
      call sscm(xarg,ws,vexit,xfinm,istab,fluxm,sqrts,diam,cm)
c --- Compute coefficient C for BUOYANT rise (CB)
      call sscb(xarg,xfinb,istab,fluxb,ws,sqrts,cb)

c --- Solve cubic equation with buoyant rise (CB) and momentum rise (CM)
c --- and select the larger of the two as the gradual plume rise.  Take
c --- the largest of the real roots in each case.
      call root3(1.0,a,b,cb,nroots,rt)
      zb=rt(1)
      if(nroots.GT.1) then
         do iroot=2,nroots
            zb=AMAX1(zb,rt(iroot))
         enddo
      endif
      call root3(1.0,a,b,cm,nroots,rt)
      zm=rt(1)
      if(nroots.GT.1) then
         do iroot=2,nroots
            zm=AMAX1(zm,rt(iroot))
         enddo
      endif

      ssrise=AMAX1(zb,zm)

      return
      end
c----------------------------------------------------------------------
      subroutine sscb(xarg,xfinb,istab,fluxb,ws,sqrts,cb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                   SSCB
c ---            Adapted from ISC2:BLPCB
c
c --- PURPOSE:  Calculates C coefficient for BUOYANT rise used in
c               Schulman-Scire downwash algorithm, as coded in ISC2
c
c --- INPUTS:
c            XARG - real         - Distance from stack (m)
c           XFINB - real         - Distance (m) to final buoyant
c                                  plume rise
c           ISTAB - integer      - Stability class
c           FLUXB - real         - Buoyancy flux (m**4/s**3)
c              WS - real         - Stack height wind speed (m/s)
c           SQRTS - real         - Square root of stability parameter
c                                  (sqrt(s)=(g*(dtheta/dz)/tair)**0.5)
c
c --- OUTPUT:
c              CB - real         - C coefficient in cubic eqn for
c                                  buoyant rise
c
c --- SSCB called by:  PRSS
c --- SSCB calls:      none
c----------------------------------------------------------------------
c
      data betasq/0.36/

c --- Limit distance to that for final buoyant rise
      x=AMIN1(xarg,xfinb)

      if(istab.LE.4) then
         cb=-3.*fluxb*x*x/(2.*betasq*ws*ws*ws)
      else
         cbs=6.*fluxb/(betasq*ws*sqrts*sqrts)
c ---    Compare stable term to neutral term
         cbn=3.*fluxb*x*x/(2.*betasq*ws*ws*ws)
c ---    Select minimum of stable and neutral term
         cb=-1.*AMIN1(cbs,cbn)
      endif

      return
      end

c----------------------------------------------------------------------
      subroutine sscm(xarg,ws,vexit,xfinm,istab,fluxm,sqrts,diam,cm)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                   SSCM
c ---            Adapted from ISC2:BLPCM
c
c --- PURPOSE:  Calculates C coefficient for MOMENTUM rise used in
c               Schulman-Scire downwash algorithm, as coded in ISC2
c
c --- INPUTS:
c            XARG - real         - Distance from stack (m)
c              WS - real         - Stack height wind speed (m/s)
c           VEXIT - real         - Stack gas exit velocity (m/s)
c           XFINM - real         - Distance (m) to final momentum
c                                  plume rise
c           ISTAB - integer      - Stability class
c           FLUXM - real         - Momentum flux (m**4/s**2)
c           SQRTS - real         - Square root of stability parameter
c                                  (sqrt(s)=(g*(dtheta/dz)/tair)**0.5)
c            DIAM - real         - Stack diameter (m)
c
c --- OUTPUT:
c              CM - real         - C coefficient in cubic eqn for
c                                  momentum rise
c
c --- SSCM called by:  PRSS
c --- SSCM calls:      none
c----------------------------------------------------------------------
c
c --- Calculate entrainment coefficient
      betaj = 0.333333 + ws/vexit

c --- Limit distance to that for final momentum rise
      x=AMIN1(xarg,xfinm)

c --- Calculate C
      if(istab.LE.4) then
         cm=-3.*fluxm*x/(betaj*ws)**2
      else
         cms=3.*fluxm*SIN(sqrts*x/ws)/(betaj*betaj*ws*sqrts)
c ---    Calculate neutral term for comparison
         xfmn=4.*diam*(vexit+3.*ws)**2/(vexit*ws)
         x=AMIN1(xarg,xfmn)
         cmn=3.*fluxm*x/(betaj*ws)**2
c ---    Select minimum of stable and neutral term
         cm=-1.*AMIN1(cms,cmn)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine prbl(xarg,xshift,ntab,xtab,ztab,blrise)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950715                   PRBL
c ---            D. Strimaitis, SRC
c
c --- PURPOSE:  Calculates distance-dependent plume rise for
c               Buoyant Line sources from precalculated tabulation
c
c --- INPUTS:
c          XARG - real     - Downwind dist. from  "pt." source (m)
c        XSHIFT - real     - Dist. to "pt." source from upwind edge
c                            of the block of line sources (m)
c          NTAB - integer  - Number of points in XTAB and ZTAB arrays
c          XTAB - real arr.- Tabulated distances from upwind edge of
c                            the block of line sources to positions
c                            located between the "full buoyancy" point
c                            and the point of final rise (m)
c          ZTAB - real arr.- Rise tabulated at each distance in XTAB,
c                            for a point located at the most upwind
c                            point in the block of line sources (m)
c
c --- OUTPUT:
c        BLRISE - real     - Plume rise (m)
c
c --- PRBL called by:  GRISE
c --- PRBL calls:      PRTAB
c----------------------------------------------------------------------
      real xtab(ntab),ztab(ntab)
      data zero/0.0/

      if(xtab(1).GE.xtab(ntab)) then
c
c ---    Case 1:  Final rise reached before "full buoyancy" distance
         size=1.0-xshift/xtab(1)
         xfrise=xtab(ntab)*size
         zfrise=ztab(ntab)*size
         if(xarg.GE.xfrise) then
            z=zfrise
         else
            z=xarg*zfrise/xfrise
         endif
c
      else
c
c ---    Case 2:  Final rise reached beyond "full buoyancy" distance
c
c ---    Add the distance shift to xarg to "jump" to plume rise curve
c ---    for the point of the block of line sources furthest upwind
         xeff=amax1(0.0,xarg+xshift)
c
c ---    Calculate the rise
         if(xeff.EQ.0.0) then
c ---       No rise
            z=0.0
         elseif(xeff.GE.xtab(ntab)) then
c ---       Final rise
            z=ztab(ntab)
         elseif(xeff.LE.xtab(1)) then
c ---       Interpolate between zero and first entry in table
            z=xeff*ztab(1)/xtab(1)
         else
c ---       Interpolate within table
            call prtab(xeff,zero,ntab,xtab,ztab,z)
         endif
c
c ---    "Drop" back to plume rise curve for pt. source element
         if(xtab(1).GT.0.0) then
            z=z-xshift*ztab(1)/xtab(1)
         endif
c
      endif
c
c --- Make sure rise is not negative
      blrise=amax1(z,zero)

      return
      end
c----------------------------------------------------------------------
      subroutine prshear(fb,wsstk,p,hs,x,xfinb,zfinsh,zbsh)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                PRSHEAR
c ---            J. Scire, SRC
c
c --- PURPOSE:- Calculate transitional buoyant plume rise using plume
c               rise equations with WIND SHEAR effects
c               (Scire and Schulman, 1980).
c             - Used for both neutral/unstable and stable conditions.
c             - Result must be compared to Briggs plume rise w/o
c               shear & minimum of the two values used.
c
c --- INPUTS:
c              FB - real         - Buoyancy flux (m**4/s**3)
c           WSSTK - real         - Stack height wind speed (m/s)
c               P - real         - Wind shear exponent to power
c                                  law equation.
c              HS - real         - Stack top height (m)
c               X - real         - Downwind distance (m) from the
c                                  stack to the receptor
c           XFINB - real         - Distance (m) to final buoyant
c                                  plume rise for neutral/unstable
c                                  conditions
c          ZFINSH - real         - Final buoyant plume rise (m) with
c                                  wind shear
c
c --- OUTPUT:
c            ZBSH - real         - Transitional plume rise (m) due
c                                  to plume buoyancy with WIND SHEAR
c                                  effects
c
c --- PRSHEAR called by:  GRISE
c --- PRSHEAR calls:      none
c----------------------------------------------------------------------
c
c --- Check for case of no buoyant rise
      if(x.le.0.0.or.fb.le.0.0)then
         zbsh=0.0
      else
c ---    Compute transitional buoyant plume rise
         if(x.lt.xfinb .AND. wsstk.gt.0.0)then
c
c ---       Protect against zero or small stack ht.
            if(hs.gt.1.0)then
               expt=hs**(3.*p)
            else
               expt=1.0
            endif
c
            ep=3.+3.*p
c ---       Constant 0.72 = 2.*beta*beta with beta=0.6
            zbsh=((ep*ep)/(0.72*(3.+p))*(fb*expt/(wsstk**3)))**(1./ep)*
     1       x**(2./ep)
c
c ---       Final plume height in stable conditions is based on minimum
c ---       of bent-over and vertical plume equations -- ensure plume
c ---       height does not exceed final height
            zbsh=amin1(zbsh,zfinsh)
         else
c
c ---       Plume has reached final rise (x > xfinb) or winds are calm
            zbsh=zfinsh
         endif
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine prfinsh(fb,wsstk,p,hs,xfinb,istab,sqrts,zfinsh)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941215                PRFINSH
c ---            J. Scire, SRC
c
c --- PURPOSE:- Calculate FINAL buoyant plume rise using plume rise eqns
c               with WIND SHEAR effects (Scire and Schulman, 1980).
c             - Equations for neutral/unstable and stable conditions.
c             - Result must be compared to Briggs plume rise w/o
c               shear & minimum of the two values used.
c
c --- INPUTS:
c              FB - real         - Buoyancy flux (m**4/s**3)
c           WSSTK - real         - Stack height wind speed (m/s)
c               P - real         - Wind shear exponent to power
c                                  law equation.
c              HS - real         - Stack top height (m)
c           XFINB - real         - Distance (m) to final buoyant
c                                  plume rise for neutral/unstable
c                                  conditions
c           ISTAB - integer      - Stability class (1=A,...6=F)
c           SQRTS - real         - Square root of stability parameter,s
c                                  (sqrt(s)=(g*(dtheta/dz)/tair)**0.5)
c
c --- OUTPUT:
c          ZFINSH - real         - Final plume rise (m) due to
c                                  plume buoyancy with WIND SHEAR
c                                  effects
c
c --- PRFINSH called by:  POINTS1, POINTS2
c --- PRFINSH calls:      none
c----------------------------------------------------------------------
c
c --- Check for case of no buoyant rise
      if(fb.le.0.0)then
         zfinsh=0.0
      else if(istab.le.4)then
c ---    NEUTRAL/UNSTABLE final buoyant plume rise
c
c ---    Protect against zero or small stack ht. and wind speeds
         wssaf=amax1(wsstk,0.1)
         if(hs.gt.1.0)then
            expt=hs**(3.*p)
         else
            expt=1.0
         endif
c
        ep=3.+3.*p
c ---   Constant 0.72 = 2.*beta*beta with beta=0.6
        zfinsh=((ep*ep)/(0.72*(3.+p))*(fb*expt/(wssaf**3)))**(1./ep)*
     1    xfinb**(2./ep)
      else
c
c ---   STABLE final rise with WIND SHEAR
c
c ---    Protect against zero or small stack ht. and wind speeds
         wssaf=amax1(wsstk,0.1)
         if(hs.gt.1.0)then
            expt=hs**p
         else
            expt=1.0
         endif
         ep=3.+p
c ---    Constant 5.555556 = 2./(beta*beta) with beta=0.6
         zfinsh=(5.555556*ep*expt*fb/(wssaf*sqrts*sqrts))**(1./ep)
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine prfpp(zfin,fb,wsstk,hs,hmix,ta,ptginv,ti,fmix,hmax)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                  PRFPP
c ---            D. Strimaitis, SRC
c
c --- PURPOSE:  Revise height of final rise due to Partial Penetration
c               of an elevated inversion (after Manins: Atm.Env. 18,
c               p. 2339-2344; with modifications from MESOPUFF II)
c               (used for buoyant rise in convective mixed layer)
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): add temperature jump at inversion to
c                                  calling arguments
c
c --- INPUTS:
c            ZFIN - real         - Final rise (m) without inversion
c              FB - real         - Buoyancy flux (m**4/s**3)
c           WSSTK - real         - Stack height wind speed (m/s)
c              HS - real         - Stack Height (m)
c            HMIX - real         - Current mixing depth (m)
c              TA - real         - Ambient temperature (mixed layer) (K)
c          PTGINV - real         - Potential temperature gradient above
c                                  inversion (K/m)
c              TI - real         - Potential temperature gradient jump
c                                  across inversion (K)
c
c --- OUTPUTS:
c            ZFIN - real         - Final rise in mixed layer (m)
c            FMIX - real         - Fraction of mass in mixed layer
c            HMAX - real         - Final rise for mass above
c                                  inversion (m)
c
c --- PRFPP called by:  POINTS1, POINTS2
c --- PRFPP calls:      none
c----------------------------------------------------------------------
c
      data g/9.80665/
c --- Set minimum allowed wind speed at stack-top (wsstk0)
      data wsstk0/1.0/
c
c --- If wind speed is less than wsstk0, reset to wsstk0.
      u=wsstk
      if(u.LT.wsstk0) u=wsstk0
c
c --- Set height of inversion above stack-top (m)
      zi=hmix-hs
      rise0=0.67*zi
c
      if(zi.LE.0.0) then
c ---    Top of stack is above mixed layer, so no mass lies below
         fmix=0.0
c ---    Use stable rise equation
c ---    S aloft is (g/T)*d(THETA)/dz
         saloft=g*ptginv/ta
         if(saloft.GT.0.0) then
            rise1=2.6*(fb/(u*saloft) )**0.3333333
         else
            rise1=zfin
         endif
         rise2=rise1
c
      elseif(zfin.LE.rise0) then
c ---    No modifications if final rise is LE rise0
         rise1=zfin
         rise2=zi
         fmix=1.0
c
      else
c ---    Inversion may alter rise
c ---    Compute penetration parameter and its inverse (reciprocal)
         peninv=u*(g*ti/ta)*zi*zi/fb
         pen=1./peninv
c
c ---    Set fraction of plume remaining in mixed layer
         if(pen.LT.0.08) then
c ---       All mass remains in mixed layer
            fmix=1.0
         elseif(pen.GT.0.3) then
c ---       No mass remains in mixed layer
            fmix=0.0
         else
            fmix=0.08*peninv-pen+0.08
         endif
c
c ---    Set effective plume heights
         if(fmix.GT.0.0) then
            rise1=zi*(1.-0.33*fmix)
            rise2=zi*(2.-fmix)
         else
c ---       All mass penetrates inversion: use MESOPUFF rise
c ---       S aloft is (g/T)*d(THETA)/dz
            saloft=g*ptginv/ta
            if(saloft.GT.0.0) then
               rise1=( 1.8*zi*zi*zi+ 18.75*fb/(u*saloft) )**0.3333333
            else
               rise1=zfin
            endif
            rise2=rise1
         endif
      endif
c
c --- Alter the final plume rise passed as argument
      zfin=AMIN1(zfin,rise1)
c
c --- Turn rise2 into an effective "past maximum mixing height"
      hmax=hmix+2.*(rise2-zi)
c
      return
      end
c----------------------------------------------------------------------
      subroutine prtab(xarg,zstart,nt,x,z,rise)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950610                  PRTAB
c ---            D. Strimaitis, SRC
c
c --- PURPOSE:  Calculates distance-dependent plume rise by
c               interpolating in plume height table.  Note that height
c               in table is assumed to include the release height.  If
c               table contains just the rise, then argument ZSTART
c               should be entered as 0.0 in the call!
c
c --- INPUTS:
c          XARG - real     - Downwind dist. from source (m)
c        ZSTART - real     - Plume height at start of rise (m)
c            NT - integer  - Number of points in table
c         X(nt) - real     - Tabulated along-wind distance (m)
c         Z(nt) - real     - Tabulated plume height (m)
c
c --- OUTPUT:
c          RISE - real     - Interpolated plume rise (m)
c
c --- PRTAB called by:  GRISE
c --- PRTAB calls:      none
c----------------------------------------------------------------------
      real x(nt),z(nt)

c --- Find index for point in table just beyond given xarg
      ind=0
      do i=1,nt
         if(x(i).LT.xarg) ind=i
      enddo
      indp1=ind+1

c --- Compute interpolated rise at xarg
      if(indp1.EQ.1) then
         xfac=xarg/x(indp1)
         rise=(z(indp1)-zstart)*xfac
      else
         xfac=(xarg-x(ind))/(x(indp1)-x(ind))
         rise=z(ind)-zstart + (z(indp1)-z(ind))*xfac
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine setpuf(ii,tsamp,distm,istab,el,sigv,sigw,bvf,ws,dpbl,
     &                  xnew,ynew,iru,ldbhr,uavg,lcalm)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                 SETPUF
c                D. Strimaitis
c
c --- PURPOSE:  Set distances/times for puff, and update stored puff
c               data.
c
c --- UPDATE
c --- V6.2-V6.22    070921  (DGS): Check for imet outside valid range
c                                  of 1 to MXMETSAV+1
c --- V6.1-V6.2     070629  (DGS): move CALM re-assignment of IDW0()
c                                  from PUFRECS so downwash effects are
c                                  turned off as soon as a puff reaches
c                                  a calm area.
c                   070629  (DGS): add LCALM as output argument for
c                                  subsequent use
c                   070629  (DGS): use PRIME wake table to get sigmas
c                                  for puffs at travel distances that
c                                  fall within the limits of the table
c                                  (previously used virtual distance 
c                                  calc that could generate sigmas 
c                                  different from those in table if
c                                  wind speed changed)
c --- V5.75-V6.1    050915  (DGS): Add IQSTEP arg in call to WAKE_TAB
c --- V5.73-V5.75   050225  (DGS): Add DPBL arg to pass on to SETCSIG
c                                  for TAULY
c --- V5.7-V5.73    040611  (DGS): Gravitational settling adjustment
c                                  to puff height at end of step;
c                                  Add tb1,te1,vsetl to /CURRENT/
c --- V5.3-V5.7     030402  (DGS): Make puff sigmas consistent with
c                                  values at end of tables in
c                                  wake region (PRIME downwash)
c --- V5.2-V5.3     991222  (DGS): IPUFID already decoded in COMP
c --- V5.0-V5.0     980918  (DGS): add area-source sigy in quadrature
c --- V5.0-V5.0     980731  (DGS): when CALM, set min sigmas in /PUFF/
c                                  to mid-pt values for current step
c --- V4.0-V5.0     971107  (DGS): bug - ratio2 used for s_e1 instead
c                                  of ratio3
c                   971107  (DGS): ICODE obtained from /CURRENT/
c --- V4.0-V5.0     971107  (DGS): adjust puff ht for MCTADJ=2
c                   971107  (DGS): replace ZFINAL array with ZPB array
c                   971107  (DGS): add WALLTRAP call to constrain sigy
c                                  in valleys
c                   971107  (DGS): include tip DW in ZFRISE
c
c --- INPUTS:
c          II - integer   - Puff number
c       TSAMP - real      - Sampling time step (sec)
c       DISTM - real      - Advection distance (m) for time-step
c       ISTAB - integer   - PGT stability class at puff
c          EL - real      - Current Monin-Obukhov length (m)
c        SIGV - real      - Current sigma-v velocity (m/s)
c        SIGW - real      - Current sigma-w velocity (m/s)
c         BVF - real      - Current Brunt-Vaisala freq (1/s)
c          WS - real      - Current wind speed (m/s)
c        DPBL - real      - Current depth of PBL (m)
c        XNEW - real      - New puff x-position (Met Grid Units)
c        YNEW - real      - New puff y-position (Met Grid Units)
c         IRU - integer   - Rural cell indicator (rural=0 ; urban=1)
c       LDBHR - logical   - Debug write logical
c
c       Common block /COMPARM/ variables:
c             SYMIN, SZMIN, WSCALM
c       Common block /CURRENT/ variables:
c             IDOPTY, IDOPTZ, ICODE,
c             IPNUM, ISNUM, ISTYPE, IMET, IQSTEP
c       Common block /DRYPART/ variables:
c             VGRAV(mxint,mxpdep)
c       Common block /FLAGS/ variables:
c             MHFTSZ, MCTADJ, MTILT
c       Common block /GRID/ variables:
c             DGRID
c       Common block /PUFF/ variables:
c             SIGYB(mxpuff), SIGZB(mxpuff), ZPB(mxpuff),
c             TMTOTB(mxpuff), XTOTB(mxpuff), BIDFNL(mxpuff),
c             IPUFCD(mxpuff), STIPDW(mxpuff)
c             SY0(mxpuff), IDW0(mxpuff)
c       Common block /CSIGMA/ variables:
c             SYH
c       Parameters:
c             IO6
c
c --- OUTPUT:
c        UAVG - real      - Mean transport speed (m/s)
c       LCALM - logical   - CALM logical
c       Common block /CSIGMA/ variables:
c             THFTY, THFTZ, SZH
c       Common block /CURRENT/ variables:
c             xb1,yb1,zb1,syb1,szb1,
c             xe1,ye1,ze1,sye1,sze1,
c             vtyb1,vtzb1,vtye1,vtze1,
c             vdyb1,vdzb1,vdye1,vdze1,
c             xttb1,xtte1,xshift,
c             tb1,te1,vsetl,
c             sym1,szm1,zm1,fracz1,lup1
c             ipnum,iage,speedi,srat,temis,
c             bidsq,xfrise,zfrise,sy0sq
c       Common block /PUFF/ variables:
c             XPB(mxpuff), YPB(mxpuff), SIGYB(mxpuff), SIGZB(mxpuff),
c             TMTOTB(mxpuff), XTOTB(mxpuff), ZPB(mxpuff)
c
c --- SETPUF called by:  COMP
c --- SETPUF calls:      SETCSIG, SIGTY, SIGTZ, HEFTRAN, CTADJ2,
c                        WALLTRAP, WAKE_TAB
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'csigma.puf'
      include 'comparm.puf'
      include 'current.puf'
      include 'drypart.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'puff.puf'

      logical ldbhr,lcalm
      data zero/0.0/, half/0.5/, one/1.0/
      data dm2km/0.001/

c --- Validate imet index
      if(imet.LT.1) then
         write(io6,*)
         write(io6,*) 'FATAL ERROR in SETPUF: bad met period index'
         write(io6,*) 'Expected IMET = 1 to MXMETSAV+1'
         write(io6,*) 'Found    IMET = ',imet
         write(io6,*) '     MXMETSAV = ',mxmetsav
         write(io6,*)
         write(*,*)
         stop 'Halted in SETPUF -- See list file'
      endif

c --- Initialize variables associated with terrain option MCTADJ=2
      strain=one
      fracz1=zero
      lup1=.FALSE.

c --- Total travel distance (m) at beginning and end of step
      xttb1=xtotb(ii)
      xtte1=xttb1+distm

c --- Total travel time (s) at beginning and end of step
      tb1=tmtotb(ii)
      te1=tb1+tsamp

c --- Distance travelled this step by puff to midpoint (km)
      dmidkm=0.5*distm*dm2km

c --- Time travelled by puff to midpoint (sec)
      tmid=0.5*tsamp

c --- Set mean transport speed for step for use in sigma calc.
      uavg=ws
      ukps=ws*dm2km

c --- Set dispersion option ("calms" use time-based sigmas)
      lcalm=.FALSE.
      if(ws.LT.wscalm) then
         lcalm=.TRUE.
         idopty=1
         idoptz=1
c ---    Turn off any downwash and plume rise calculations if CALM
         idw0(ii)=0
         xfinal(ii)=zero
      endif
c
c --- Set selected data in /CSIGMA/ for sigma calls
      call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &             sigv,sigw,symin,szmin,zpb(ii),dpbl)
c
c --- Assign puff number
      ipnum=ii

c --- Set sigma-y squared for initial size of area source
      if(istype.EQ.3 .OR. istype.EQ.4) then
         sy0sq=sy0(ii)*sy0(ii)
      else
         sy0sq=zero
      endif

c ----------------------------------------------------------------
c --- Calculate the virtual times and sigmas at Heffter transition
c ----------------------------------------------------------------
c --- Process sigma-z only if Gaussian in vertical and Heffter is used
      if(mhftsz.EQ.0 .OR. mod(icode,2).NE.1)then
         szh=syh
         call sigty(syh,zero,zero,dum,thfty,dhfty)
      else
         call heftran(1,zpb(ii),sigyb(ii),sigzb(ii),
     &                zero,zero,zero,zero)
      endif

c ----------------------------------------------------------------------
c --- Calculate the virtual times and sigmas at start/end/midpoint
c ----------------------------------------------------------------------

c --- Initialize control variable for PRIME treatment
c --- ( 0: PRIME arrays NOT used   1: PRIME arrays used)
      iprime=0

      if(idw0(ipnum).EQ.3 .OR. idw0(ipnum).EQ.4 .AND. imet.EQ.1) then
c ---    Special case of PRIME building downwash ---
c        Sigmas are tabulated from the source to the point where the
c        turbulence reaches ambient.  WAKE_TAB is used to interpolate
c        sigmas within the tabulated range, using the appropriate
c        source arrays.  Make the virtuals here consistent with the
c        sigmas at the end of the tabulated range, for the current
c        met data, when the puff starts in the wake.

c ---    Try to process sigmas at start of step
         call WAKE_TAB(istype,isnum,iqstep,idw0(ipnum),xttb1,
     &                 syb1,szb1,hgr,rise,xlast,iprime)
         if(iprime.EQ.1) then
c ---       OK, puff starts in wake region; get virtuals at XLAST
            call WAKE_TAB(istype,isnum,iqstep,idw0(ipnum),xlast,
     &                    sylast,szlast,hgr,rise,xlast2,idone)
            call SIGTY(sylast,zero,zero,sydum,vtylast,vdylast)
            call SIGTZ(szlast,zero,zero,zpb(ii),szdum,vtzlast,vdzlast)
            vdy0km=(vdylast-xlast*dm2km)
            vdz0km=(vdzlast-xlast*dm2km)
c ---       Process puff at start (within tabulated region)
            call SIGTY(syb1,zero,zero,sydum,vtyb1,vdyb1)
            call SIGTZ(szb1,zero,zero,zpb(ii),szdum,vtzb1,vdzb1)
            syb1=AMAX1(syb1,symin)
            szb1=AMAX1(szb1,szmin)
c ---       Process midpoint
            xttm1=0.5*(xttb1+xtte1)
            call WAKE_TAB(istype,isnum,iqstep,idw0(ipnum),xttm1,
     &                 sym1,szm1,hgr,rise,xlast,idone)
            if(idone.EQ.1) then
c ---          Point within tabulated region
               call SIGTY(sym1,zero,zero,sydum,vtym1,vdym1)
               call SIGTZ(szm1,zero,zero,zpb(ii),szdum,vtzm1,vdzm1)
            else
c ---          Point beyond tabulated region
               dxkm=AMAX1(0.0,xttm1*dm2km+vdy0km)
               dts=dxkm/ukps
               call SIGTY(zero,dxkm,dts,sym1,vtym1,vdym1)
               dxkm=AMAX1(0.0,xttm1*dm2km+vdz0km)
               dts=dxkm/ukps
               call SIGTZ(zero,dxkm,dts,zpb(ii),szm1,vtzm1,vdzm1)
            endif
            sym1=AMAX1(sym1,symin)
            szm1=AMAX1(szm1,szmin)
c ---       Process endpoint
            call WAKE_TAB(istype,isnum,iqstep,idw0(ipnum),xtte1,
     &                 sye1,sze1,hgr,rise,xlast,idone)
            if(idone.EQ.1) then
c ---          Point within tabulated region
               call SIGTY(sye1,zero,zero,sydum,vtye1,vdye1)
               call SIGTZ(sze1,zero,zero,zpb(ii),szdum,vtze1,vdze1)
            else
c ---          Point beyond tabulated region
               dxkm=AMAX1(0.0,xtte1*dm2km+vdy0km)
               dts=dxkm/ukps
               call SIGTY(zero,dxkm,dts,sye1,vtye1,vdye1)
               dxkm=AMAX1(0.0,xtte1*dm2km+vdz0km)
               dts=dxkm/ukps
               call SIGTZ(zero,dxkm,dts,zpb(ii),sze1,vtze1,vdze1)
            endif
            sye1=AMAX1(sye1,symin)
            sze1=AMAX1(sze1,szmin)
         endif
      endif

      if(iprime.EQ.0) then
c ---    Obtain sigmas and virtuals from puff properties at start

c ---    SIGMA-Y:
c ---    Beginning of step (syb1,vtyb1,vdyb1)
         call sigty(sigyb(ii),zero,zero,syb1,vtyb1,vdyb1)
c ---    Midpoint of step (sym1,vtym1,vdym1)
         tm=vtyb1+tmid
         dm=vdyb1+dmidkm
         call sigty(zero,dm,tm,sym1,vtym1,vdym1)
c ---    End of step (sye1,vtye1,vdye1)
         te=tm+tmid
         de=dm+dmidkm
         call sigty(zero,de,te,sye1,vtye1,vdye1)
c
c ---    If Gaussian in vertical, do same for SIGMA-Z:
         szb1=sigzb(ii)
         szm1=sigzb(ii)
         sze1=sigzb(ii)
         if(mod(icode,2).EQ.1)then
c ---       Beginning of step (szb1,vtzb1,vdzb1)
            call sigtz(sigzb(ii),zero,zero,zpb(ii),szb1,vtzb1,vdzb1)
c ---       Midpoint of step (szm1,vtzm1,vdzm1)
            tm=vtzb1+tmid
            dm=vdzb1+dmidkm
            call sigtz(zero,dm,tm,zpb(ii),szm1,vtzm1,vdzm1)
c ---       End of step (sze1,vtze1,vdze1)
            te=tm+tmid
            de=dm+dmidkm
            call sigtz(zero,de,te,zpb(ii),sze1,vtze1,vdze1)
         endif
      endif


c --- Final Adjustments
c ---------------------

c -------------
c --- SIGMA-Y
c -------------
c --- Apply sidewall constraint to sigma-y for stable layer in
c --- valleys if MCTADJ=2 option is selected
      if(mctadj.EQ.2) then
c ---    Midpoint of step
         xmid=half*(xpb(ii)+xnew)
         ymid=half*(ypb(ii)+ynew)
         call walltrap(ldbhr,syb1,sym1,zpb(ii),xpb(ii),ypb(ii),
     &                 xmid,ymid,bvf,ws,itrap)
         if(itrap.EQ.1) then
            syadj=sym1
            call sigty(syadj,zero,zero,sym1,vtym1,vdym1)
            te=vtym1+tmid
            de=vdym1+dmidkm
            call sigty(zero,de,te,sye1,vtye1,vdye1)
         endif
c ---    End of step
         call walltrap(ldbhr,sym1,sye1,zpb(ii),xmid,ymid,
     &                 xnew,ynew,bvf,ws,itrap)
         if(itrap.EQ.1) then
            syadj=sye1
            call sigty(syadj,zero,zero,sye1,vtye1,vdye1)
         endif
      endif
c
c --- Allow for precision problems;  sigmas must grow with time
      if(syb1.GT.sym1) sym1=syb1
      if(sym1.GT.sye1) sye1=sym1
c
c --- Update stored sigma for start of next step (without BID & SY0)
      sigyb(ii)=sye1
c
c --- Add quadrature contribution to sigmas in /CURRENT/
      sysq=bidfnl(ii)+sy0sq
      if(sysq.GT.zero) then
         ratio1=sysq/(syb1*syb1)
         ratio2=sysq/(sym1*sym1)
         ratio3=sysq/(sye1*sye1)
         if(ratio1.LE.0.2) then
c ---       Approximate square root
            syb1=syb1*(one+half*ratio1)
            sym1=sym1*(one+half*ratio2)
            sye1=sye1*(one+half*ratio3)
         else
            syb1=syb1*sqrt(one+ratio1)
            sym1=sym1*sqrt(one+ratio2)
            sye1=sye1*sqrt(one+ratio3)
         endif
      endif
c
c --- Update minimum sigma (with BID) for subsequent sampling,
c     to equal current mid-point value (active only during calms)
      if(LCALM) then
         sy0(ii)=sym1
      endif

c -------------
c --- SIGMA-Z
c -------------
c --- If Gaussian in vertical, do same for SIGMA Z
      zb1=zpb(ii)
      zm1=zpb(ii)
      ze1=zpb(ii)
      if(mod(icode,2).EQ.1)then
c ---    Apply strain adjustment to sigmas and adjust puff height
c ---    for stable layers if MCTADJ=2 option is selected
         if(mctadj.EQ.2) then
c
c ---       Midpoint of step
            r=sigzb(ii)/szm1
            xmid=half*(xpb(ii)+xnew)
            ymid=half*(ypb(ii)+ynew)
            call ctadj2(r,zpb(ii),xpb(ii),ypb(ii),xmid,ymid,
     &                  sigzb(ii),bvf,ws,ldbhr,strain,zm1,fracz1,lup1)
            szadj=szm1*strain
            call sigtz(szadj,zero,zero,zpb(ii),szm1,vtzm1,vdzm1)
c ---       End of step
            r=sigzb(ii)/sze1
            call ctadj2(r,zpb(ii),xpb(ii),ypb(ii),xnew,ynew,
     &                  sigzb(ii),bvf,ws,ldbhr,strain,ze1,fracz1,lup1)
            szadj=sze1*strain
            call sigtz(szadj,zero,zero,zpb(ii),sze1,vtze1,vdze1)
         endif
c
c --- Allow for precision problems;  sigmas must grow with time
         if(szb1.GT.szm1) szm1=szb1
         if(szm1.GT.sze1) sze1=szm1
c
c ---    Update stored sigma for start of next step (without BID)
         sigzb(ii)=sze1
c
c ---    Add contribution of buoyancy-enhancement to sigmas in /CURRENT/
         if(bidfnl(ii).GT.zero) then
            ratio1=bidfnl(ii)/(szb1*szb1)
            ratio2=bidfnl(ii)/(szm1*szm1)
            ratio3=bidfnl(ii)/(sze1*sze1)
            if(ratio1.LT.0.2) then
c ---          Approximate square root
               szb1=szb1*(one+half*ratio1)
               szm1=szm1*(one+half*ratio2)
               sze1=sze1*(one+half*ratio3)
            else
               szb1=szb1*sqrt(one+ratio1)
               szm1=szm1*sqrt(one+ratio2)
               sze1=sze1*sqrt(one+ratio3)
            endif
         endif
c
c ---    Update minimum sigma (with BID) for subsequent sampling,
c        to equal current mid-point value (active only during calms)
         if(LCALM) then
            sz0(ii)=szm1
         endif

      endif

c ----------------------------------------
c --- Store remaining /CURRENT/ variables
c ----------------------------------------
c
c --- Puff coordinates in /CURRENT/ are relative to the origin of the
c --- meteorological grid (0.0, 0.0) = LL corner of cell (1,1) --
c --- units: meters
      xb1=xpb(ii)*dgrid
      yb1=ypb(ii)*dgrid
      xe1=xnew*dgrid
      ye1=ynew*dgrid
c
c --- Set sigma**2 at final rise due to buoyancy enhancement
      bidsq=bidfnl(ii)
c
c --- Set distance to final rise, and final rise height (delta)
      xfrise=xfinal(ii)
      zfrise=zfinal(ii)-(ht0(ii)-stipdw(ii))
c
c --- Set distance from upwind edge of line sources, or distance to
c --- end of cavity for point sources with PRIME downwash
      xshift=xshift0(ii)
c
c --- Wind speed variables at time of release of emissions
      speedi=ws0(ii)
      srat=srat0(ii)
c
c --- Duration (sec) of the original emissions release
      temis=temit0(ii)
c
c --- Treat all puffs as OLD
      iage=1

c --- Gravitational settling (Initial implementation!)
      vsetl=vgrav(1,1)
      if(mtilt.EQ.1) then
         ze1=ze1-vsetl*tsamp
         ze1=AMAX1(ze1,0.0)
      endif

c ------------------------------
c --- Update /PUFF/ variables
c ------------------------------
c
c --- Update total distance (m) and time (s) to end of current step
      xtotb(ii)=xtotb(ii)+distm
      tmtotb(ii)=tmtotb(ii)+tsamp
c
c --- Update position of puff at end of step
      xpb(ii)=xnew
      ypb(ii)=ynew
      zpb(ii)=ze1

      if(ldbhr)then
         write(io6,*) 'SETPUF --'
         write(io6,252)dmidkm,tmid,xtotb(ii),
     &                 tmtotb(ii)
252      format(10x,' DMID(km)=',f10.3,' TMID=',f10.1,
     1    ' XTOTB(m)=',f10.1,' TMTOTB=',f10.1)
         write(io6,256)icode,istab,sigyb(ii),sigzb(ii),strain
256      format(10x,'ICODE=',i2,' ISTAB=',i1,' SIGYB=',f10.1,
     1    ' SIGZB=',f10.1,' STRAIN=',f10.3)
         write(io6,*) 'Time to start of Heffter curves:'
         write(io6,*) '   THFTY,THFTZ =',thfty,thftz
         write(io6,*) 'Virtuals stored in /CURRENT/'
         write(io6,*) '   VTZB1,VTZE1 = ',vtzb1,vtze1
         write(io6,*) '   VDZB1,VDZE1 = ',vdzb1,vdze1
         write(io6,*) '   VTYB1,VTYE1 = ',vtyb1,vtye1
         write(io6,*) '   VDYB1,VDYE1 = ',vdyb1,vdye1
         write(io6,*) 'SIG-Y0 Squared = ',sy0sq
         if(idw0(ipnum).EQ.3 .OR. idw0(ipnum).EQ.4) then
            write(io6,*) '   IDW0,IPRIME = ',idw0(ipnum),iprime
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine setslg(ii,iold,tsamp,iru,istab,el,sigv,sigw,bvf,ws,
     &                  dpbl,dxmold,dymold,dxmnew,dymnew,ldbhr,uavg,
     &                  lcalm)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070629                 SETSLG
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Set the coordinates, sigmas, and plume height variables
c               for the "current" slug in common block /CURRENT/
c               for use by the slug sampling routine
c
c --- UPDATE
c --- V5.75-V6.2    070629  (DGS): move CALM re-assignment of IDW0()
c                                  from SLGRECS so downwash effects are
c                                  turned off as soon as a puff reaches
c                                  a calm area.
c                   070629  (DGS): add LCALM as output argument for
c                                  subsequent use
c --- V5.73-V5.75   050225  (DGS): Add DPBL arg to pass on to SETCSIG
c                                  for TAULY
c --- V5.3-V5.73    040611  (DGS): Gravitational settling adjustment
c                                  to slug height at end of step;
c                                  Add tb1/2,te1/2,vsetl to /CURRENT/
c --- V5.2-V5.3     991222  (DGS): IPUFID already decoded in COMP
c --- V5.0-V5.0     980918  (DGS): add area-source sigy in quadrature
c --- V4.0-V5.0     971107  (DGS): add treatment for variable line
c                                  sources
c                   971107  (DGS): compute speed0 to be consistent with
c                                  actual length of fresh slug
c --- V4.0-V5.0     971107  (DGS): adjust puff ht for MCTADJ=2
c                   971107  (DGS): replace ZFINAL array with ZPB,ZPE
c                   971107  (DGS): add WALLTRAP call to constrain sigy
c                                  in valleys
c                   971107  (DGS): include tip DW in ZFRISE
c
c --- INPUTS:
c          II - integer   - Slug number
c        IOLD - integer   - Flag indicating if slug "II" is a new slug
c                           currently being released (0=new slug,
c                           1=old slug)
c       TSAMP - real      - Sampling time step (sec)
c         IRU - integer   - Rural cell indicator (rural=0 ; urban=1)
c       ISTAB - integer   - Current PGT stability class at slug
c          EL - real      - Current Monin-Obukhov length (m)
c        SIGV - real      - Current sigma-v velocity (m/s)
c        SIGW - real      - Current sigma-w velocity (m/s)
c         BVF - real      - Current Brunt-Vaisala freq (1/s)
c          WS - real      - Current wind speed (m/s)
c        DPBL - real      - Current depth of PBL (m)
c      DXMOLD - real      - Change in X coordinate (m) of the oldest
c                           end of the slug
c      DYMOLD - real      - Change in Y coordinate (m) of the oldest
c                           end of the slug
c      DXMNEW - real      - Change in X coordinate (m) of the youngest
c                           end of the slug
c      DYMNEW - real      - Change in Y coordinate (m) of the youngest
c                           end of the slug
c       LDBHR - logical   - Debug write logical
c
c       Common block /COMPARM/ variables:
c             SYMIN, SZMIN, WSCALM
c       Common block /CURRENT/ variables:
c             IDOPTY, IDOPTZ, IPNUM, ISTYPE, ISNUM
c       Common block /DRYPART/ variables:
c             VGRAV(mxint,mxpdep)
c       Common block /FLAGS/ variables:
c             MSLUG, MHFTSZ, MTILT
c       Common block /GRID/ variables:
c             DGRID, DGRIDI
c       Common block /PUFF/ variables:
c             XPB(mxpuff), YPB(mxpuff), SIGYB(mxpuff), SIGZB(mxpuff)
c             ZPB(mxpuff), TMTOTB(mxpuff), XTOTB(mxpuff), HT0(mxpuff)
c             BIDFNL(mxpuff), WS0(mxpuff), SRAT0(mxpuff), TEMIT0(mxpuff)
c             XSHIFT0(mxpuff), SY0(mxpuff), SZ0(mxpuff),
c             STIPDW(mxpuff)
c       Common block /SLUG/ variables:
c             XPE(mxpuff), YPE(mxpuff), SIGYE(mxpuff), SIGZE(mxpuff),
c             ZPE(mxpuff), TMTOTE(mxpuff), XTOTE(mxpuff)
c       Common block /CSIGMA/ variables:
c             SYH
c       Parameters:
c             MXPUFF, MXSPEC, MXNZP1, IO6
c
c --- OUTPUT:
c        UAVG - real      - Mean transport speed (m/s)
c       LCALM - logical   - CALM logical
c
c       Common block /CURRENT/ variables:
c             All variables
c       Common block /CSIGMA/ variables:
c             THFTY, THFTZ, SZH
c       Common block /SLUG/ variables:
c             SPEED0(mxpuff)
c
c --- SETSLG called by:  COMP
c --- SETSLG calls:      SETCSIG, SIGTY, SIGTZ, HEFTRAN, CTADJ2
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'comparm.puf'
      include 'current.puf'
      include 'drypart.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'puff.puf'
      include 'slug.puf'
      include 'csigma.puf'
c
      logical ldbhr, lcalm
      data zero/0.0/, half/0.5/, one/1.0/, dm2km/0.001/
c
c --- Slug coordinates in /CURRENT/ are relative to the origin of the
c --- meteorological grid (0.0, 0.0) = LL corner of cell (1,1) --
c --- units: meters
c
      if(ldbhr) then
c ---    Write out SETSLG information
         write(io6,*)
         write(io6,*) 'SETSLG:  puff #= ',ii
         write(io6,*) 'SETSLG:  sigye,sigze= ',sigye(ii),sigze(ii)
         write(io6,*) 'SETSLG:  sigyb,sigzb= ',sigyb(ii),sigzb(ii)
         write(io6,*)
      endif

c --- Assign puff number
      ipnum=ii

c --- Set sigma-y squared for initial size of area source
      if(istype.EQ.3 .OR. istype.EQ.4) then
         sy0sq=sy0(ii)*sy0(ii)
      else
         sy0sq=zero
      endif
c --- Add BID to this
      sysq=bidfnl(ii)+sy0sq

c --- Note on nomenclature for variables ---
c     _____b : specifications for the NEWER end of slug (stored arrays)
c     _____e : specifications for the OLDER end of slug (stored arrays)
c     _____b0: specifications for the CENTER of slug at START of step
c     _____e0: specifications for the CENTER of slug at END of step
c     _____b1: specifications for the OLDER end of slug at START of step
c     _____e1: specifications for the OLDER end of slug at END of step
c     _____b2: specifications for the NEWER end of slug at START of step
c     _____e2: specifications for the NEWER end of slug at END of step

c --- Initialize variables associated with terrain option MCTADJ=2
      strain=one
      fracz1=zero
      fracz2=zero

c --- Determine slug travel distance and travel time (s) at BEGINNING
c --- and END of step
      xttb1=xtote(ii)
      distm1=sqrt(dxmold**2+dymold**2)
      xtte1=xtote(ii)+distm1
      tb1=tmtote(ii)
      te1=tb1+tsamp
      tmtote1=te1
      if(iold.eq.1)then
         xttb2=xtotb(ii)
         distm2=sqrt(dxmnew**2+dymnew**2)
         xtte2=xtotb(ii)+distm2
         tb2=tmtotb(ii)
         te2=tb2+tsamp
         tmtote2=te2
      else
         xttb2=zero
         xtte2=zero
         tb2=zero
         te2=zero
         tmtote2=zero
      endif

c --- Set the average transport speed (use old end at end of step)
      uavg=ws

c --- Set dispersion option ("calms" use time-based sigmas)
      if(ws.LT.wscalm) then
         idopty=1
         idoptz=1
c ---    Turn off any downwash and plume rise calculations if CALM
         idw0(ii)=0
         xfinal(ii)=zero
         lcalm=.TRUE.
      else
         lcalm=.FALSE.
      endif
c
c --- Set selected data in /CSIGMA/ for sigma calls
      call setcsig(idopty,idoptz,iru,uavg,istab,el,bvf,
     &             sigv,sigw,symin,szmin,zpe(ii),dpbl)


c --- Set gravitational settling velocity
      vsetl=vgrav(1,1)

c
c ---------------------------------------------------------
c --- Set parameters for the OLDEST end of the slug (1)
c ---------------------------------------------------------
c
c --- Values at the START of the sampling step (end of previous step)
c --------------------------------------------
      if(iold.eq.1)then
c
c ---    OLD SLUG -- Oldest end starts away from source
         xb1=xpe(ii)*dgrid
         yb1=ype(ii)*dgrid
         zb1=zpe(ii)
c ---    Identify "ambient" sigmas without BID
         syab1=sigye(ii)
         szab1=sigze(ii)
c ---    Add quadrature contribution to sigmas in /CURRENT/
         syb1=syab1
         if(sysq.GT.zero) syb1=sqrt(syab1**2+sysq)
         szb1=szab1
         if(bidfnl(ii).GT.zero) szb1=sqrt(szab1**2+bidfnl(ii))
c
      else
c
c ---    NEW SLUG -- Oldest end starts at source
         xb1=xpb(ii)*dgrid
         yb1=ypb(ii)*dgrid
         zb1=zpb(ii)
c ---    Identify "ambient" sigmas without BID
         syab1=sigyb(ii)
         szab1=sigzb(ii)
c ---    Do not add quadrature contribution to sigmas (BID is zero
c ---    at source and  NEW SLUG from AREA SOURCE uses line source
c ---    instead of effective sigma-y)
         syb1=syab1
         szb1=szab1
      endif
c
c --- Calculate the virtual times and sigmas at Heffter transition
      if(mhftsz.EQ.0)then
         szh=syh
         call sigty(syh,zero,zero,dum,thfty,dhfty)
      else
         call heftran(1,zb1,syab1,szab1,zero,zero,zero,zero)
      endif
c
c --- Set virtual time/distance for starting sigmas without BID
      call sigty(syab1,zero,zero,dumy,vtyb1,vdyb1)
      call sigtz(szab1,zero,zero,zb1,dumz,vtzb1,vdzb1)

c
c --- Values at the END of the sampling step
c ------------------------------------------
      xe1=xb1+dxmold
      ye1=yb1+dymold
      ze1=zb1
      distkm=distm1*dm2km
      tye=vtyb1+tsamp
      dye=vdyb1+distkm
      tze=vtzb1+tsamp
      dze=vdzb1+distkm

c --- Gravitational settling (Initial implementation!)
      if(mtilt.EQ.1) then
         ze1=ze1-vsetl*tsamp
         ze1=AMAX1(ze1,0.0)
      endif
c
c --- Compute new values of sigma y, sigma z (without BID),
c --- and the corresponding virtual time/distance
      call sigty(zero,dye,tye,syae1,vtye1,vdye1)
      call sigtz(zero,dze,tze,ze1,szae1,vtze1,vdze1)
c
c --- Apply the terrain adjustments to sigma-z and sigma-y at end
c --- of step if option is selected
      if(mctadj.EQ.2) then
c ---    Old end of slug
         r=szab1/szae1
         call ctadj2(r,zb1,xb1*dgridi,yb1*dgridi,xe1*dgridi,ye1*dgridi,
     &               szab1,bvf,ws,ldbhr,
     &               strain,ze1,fracz1,lup1)
         szadj=szae1*strain
         call sigtz(szadj,zero,zero,ze1,szae1,vtze1,vdze1)
c
         call walltrap(ldbhr,syab1,syae1,zb1,xb1*dgridi,yb1*dgridi,
     &                 xe1*dgridi,ye1*dgridi,bvf,ws,itrap)
         if(itrap.EQ.1) then
            syadj=syae1
            call sigty(syadj,zero,zero,syae1,vtye1,vdye1)
         endif
      endif
c
c --- Add quadrature contribution to new sigmas
      sye1=syae1
      sze1=szae1
      if(sysq.GT.zero .AND. iold.EQ.1) then
         ratio=sysq/(syae1*syae1)
         if(ratio.LE.0.2) then
c ---       Approximate square root
            sye1=syae1*(one+half*ratio)
         else
            sye1=syae1*sqrt(one+ratio)
         endif
      endif
      if(bidfnl(ii).GT.zero) then
         ratio=bidfnl(ii)/(szae1*szae1)
         if(ratio.LE.0.2) then
c ---       Approximate square root
            sze1=szae1*(one+half*ratio)
         else
            sze1=szae1*sqrt(one+ratio)
         endif
      endif
c --- Set elongation speed for fresh slug, based on older end
      if(iold .EQ. 0) speed0(ii)=distm1/(srat0(ii)*temit0(ii))
c
c ---------------------------------------------------------
c --- Set parameters for the YOUNGEST end of the slug (2)
c ---------------------------------------------------------
c
      if(iold.eq.0) then
c
c ---    NEW SLUG -- Youngest end attached to source at START & END
c ---                Set parameters equal to Old end at START (b1)
c
c ---    START of sampling step
c -----------------------------
         xb2=xb1
         yb2=yb1
         zb2=zb1
         syab2=syab1
         szab2=szab1
         syb2=syb1
         szb2=szb1
         vtyb2=vtyb1
         vdyb2=vdyb1
         vtzb2=vtzb1
         vdzb2=vdzb1
c ---    END of sampling step
c ---------------------------
         xe2=xb1
         ye2=yb1
         ze2=zb1
         syae2=syab1
         szae2=szab1
         sye2=syb1
         sze2=szb1
         vtye2=vtyb1
         vdye2=vdyb1
         vtze2=vtzb1
         vdze2=vdzb1
c
      else
c
c ---    OLD SLUG -- Youngest end may be attached to source at START
c ---             -- but is allowed to move away from source at END
c
c ---    START of the sampling step (end of previous step)
c ---------------------------------
         xb2=xpb(ii)*dgrid
         yb2=ypb(ii)*dgrid
         zb2=zpb(ii)
c ---    Identify "ambient" sigmas without BID
         syab2=sigyb(ii)
         szab2=sigzb(ii)
c ---    Add quadrature contribution to new sigmas
         syb2=syab2
         szb2=szab2
         if(sysq.GT.zero) then
            ratio=sysq/(syab2*syab2)
            if(ratio.LE.0.2) then
c ---          Approximate square root
               syb2=syab2*(one+half*ratio)
            else
               syb2=syab2*sqrt(one+ratio)
            endif
         endif
         if(bidfnl(ii).GT.zero) then
            ratio=bidfnl(ii)/(szab2*szab2)
            if(ratio.LE.0.2) then
c ---          Approximate square root
               szb2=szab2*(one+half*ratio)
            else
               szb2=szab2*sqrt(one+ratio)
            endif
         endif
c
c ---    Calculate the virtual times and sigmas at Heffter transition
         if(mhftsz.EQ.0)then
            szh=syh
            call sigty(syh,zero,zero,dum,thfty,dhfty)
         else
            call heftran(1,zb2,syab2,szab2,zero,zero,zero,zero)
         endif
c
c ---    Set virtual time/distance for starting sigmas without BID
         call sigty(syab2,zero,zero,dumy,vtyb2,vdyb2)
         call sigtz(szab2,zero,zero,zb2,dumz,vtzb2,vdzb2)
c
c
c ---    END of the sampling step
c -------------------------------
         xe2=xb2+dxmnew
         ye2=yb2+dymnew
         ze2=zb2
         distkm=distm2*dm2km
         tye=vtyb2+tsamp
         dye=vdyb2+distkm
         tze=vtzb2+tsamp
         dze=vdzb2+distkm

c ---    Gravitational settling (Initial implementation!)
         if(mtilt.EQ.1) then
            ze2=ze2-vsetl*tsamp
            ze2=AMAX1(ze2,0.0)
         endif
c
c ---    Compute new values of sigma y, sigma z (without BID),
c ---    and the corresponding virtual time/distance
         call sigty(zero,dye,tye,syae2,vtye2,vdye2)
         call sigtz(zero,dze,tze,ze2,szae2,vtze2,vdze2)
c
c ---    Apply the terrain adjustment to sigma-z and sigma-y at end
c ---    of step if option is selected
         if(mctadj.EQ.2) then
c ---       Young end of slug
            r=szab2/szae2
            call ctadj2(r,zb2,xb2*dgridi,yb2*dgridi,xe2*dgridi,
     &                  ye2*dgridi,szab2,bvf,ws,ldbhr,
     &                  strain,ze2,fracz2,lup2)
            szadj=szae2*strain
            call sigtz(szadj,zero,zero,ze2,szae2,vtze2,vdze2)
c
            call walltrap(ldbhr,syab2,syae2,ze2,xb2*dgridi,yb2*dgridi,
     &                    xe2*dgridi,ye2*dgridi,bvf,ws,itrap)
            if(itrap.EQ.1) then
               syadj=syae2
               call sigty(syadj,zero,zero,syae2,vtye2,vdye2)
            endif
         endif
c
c ---    Add contribution of buoyancy-enhancement
         sye2=syae2
         sze2=szae2
         if(sysq.GT.zero) then
            ratio=sysq/(syae2*syae2)
            if(ratio.LE.0.2) then
c ---          Approximate square root
               sye2=syae2*(one+half*ratio)
            else
               sye2=syae2*sqrt(one+ratio)
            endif
         endif
         if(bidfnl(ii).GT.zero) then
            ratio=bidfnl(ii)/(szae2*szae2)
            if(ratio.LE.0.2) then
c ---          Approximate square root
               sze2=szae2*(one+half*ratio)
            else
               sze2=szae2*sqrt(one+ratio)
            endif
         endif
      endif
c
c ------------------------------------------------------------
c --- Transfer other puff and slug array data to current slug
c ------------------------------------------------------------
c
c --- Set sigma**2 at final rise due to buoyancy enhancement
      bidsq=bidfnl(ii)
c
c --- Set distance to final rise, and final rise height (delta)
      xfrise=xfinal(ii)
      zfrise=zfinal(ii)-(ht0(ii)-stipdw(ii))
c
c --- Set distance from upwind edge of line sources
      xshift=xshift0(ii)
c
c --- Wind speed variables at time of release of emissions
      speedi=speed0(ii)
      srat=srat0(ii)
c
c --- Duration (sec) of the original emissions release
      temis=temit0(ii)
c
c --- Set the new/old slug flag (0=new slug, 1=old slug)
      iage=iold
c
c --- Reset stored slug data for the next step
      xpe(ii)=xe1*dgridi
      ype(ii)=ye1*dgridi
      zpe(ii)=ze1
      sigye(ii)=syae1
      sigze(ii)=szae1
      xtote(ii)=xtte1
      tmtote(ii)=tmtote1
      xpb(ii)=xe2*dgridi
      ypb(ii)=ye2*dgridi
      zpb(ii)=ze2
      sigyb(ii)=syae2
      sigzb(ii)=szae2
      xtotb(ii)=xtte2
      tmtotb(ii)=tmtote2
c
c
c ---------------------------------------------------------------
c --- Special treatment of NEW SLUG from LINE SOURCE (istype=5,6)
c ---------------------------------------------------------------
c
c --- Alter /CURRENT/ sigma-y, sigma-z to include only downwash effects
c --- for the line source.  During the first step, the line source is
c --- modeled as a series of crosswind line sources, so the line-length
c --- is explicitly modeled.  Later steps will be using the effective
c --- sigmas, as these are now stored in the /PUFF/ and /SLUG/ commons
c --- (sigyb(ii),sigye(ii)).
c --- NOTE: BID adjustment is zero for line sources!
      if(iold.EQ.0 .AND. (istype.EQ.5 .OR. istype.EQ.6)) then
c ---    Older end of slug
c ---    Define virtuals for the "downwash sigmas" at the source
         call sigty(sy0(ii),zero,zero,syb1,vtyb1,vdyb1)
         call sigtz(sz0(ii),zero,zero,zb1,szb1,vtzb1,vdzb1)
c ---    Sigmas and virtuals at end of step
         distkm=distm1*dm2km
         tye=vtyb1+tsamp
         dye=vdyb1+distkm
         tze=vtzb1+tsamp
         dze=vdzb1+distkm
         call sigty(zero,dye,tye,sye1,vtye1,vdye1)
         call sigtz(zero,dze,tze,ze1,sze1,vtze1,vdze1)
c ---    Younger end of slug
         syb2=sy0(ii)
         szb2=sz0(ii)
         vtyb2=vtyb1
         vdyb2=vdyb1
         vtzb2=vtzb1
         vdzb2=vdzb1
         sye2=sy0(ii)
         sze2=sz0(ii)
         vtye2=vtyb2
         vdye2=vdyb2
         vtze2=vtzb2
         vdze2=vdzb2
      endif

c*****
         if(ldbhr)then
            write(io6,*) 'SETSLG --'
            write(io6,260) xb2,yb2,zb2,syb2,szb2,
     1                     xe2,ye2,ze2,sye2,sze2
260      format(10x,'Youngest end of slug at START of sampling step:'/
     1   12x,'XB2:',f8.0,2x,'YB2:',f8.0,2x,'ZB2:',f6.1,2x,
     2       'SYB2:',f10.1,2x,'SZB2:',f10.1/
     3   10x,'Youngest end of slug at END of sampling step:'/
     4   12x,'XE2:',f8.0,2x,'YE2:',f8.0,2x,'ZE2:',f6.1,2x,
     5       'SYE2:',f10.1,2x,'SZE2:',f10.1)
            write(io6,262) xb1,yb1,zb1,syb1,szb1,
     1                     xe1,ye1,ze1,sye1,sze1
262      format(10x,'Oldest end of slug at START of sampling step:'/
     1   12x,'XB1:',f8.0,2x,'YB1:',f8.0,2x,'ZB1:',f6.1,2x,
     2       'SYB1:',f10.1,2x,'SZB1:',f10.1/
     3   10x,'Oldest end of slug at END of sampling step:'/
     4   12x,'XE1:',f8.0,2x,'YE1:',f8.0,2x,'ZE1:',f6.1,2x,
     5       'SYE1:',f10.1,2x,'SZE1:',f10.1)
            write(io6,264) xttb1,xtte1
264      format(10x,'Distance travelled by OLD end of slug       :'/
     1   12x,'XTTB1:',f8.0,2x,'XTTE1:',f8.0)
            write(io6,265) xttb2,xtte2
265      format(10x,'Distance travelled by YOUNG end of slug     :'/
     1   12x,'XTTB2:',f8.0,2x,'XTTE2:',f8.0)
         write(io6,*) 'Time/Distance to start of Heffter curves:'
         write(io6,*) '   THFTY,THFTZ =',thfty,thftz
         write(io6,*) 'Virtuals stored in /CURRENT/'
         write(io6,*) '   VTZB1,VTZE1 = ',vtzb1,vtze1
         write(io6,*) '   VDZB1,VDZE1 = ',vdzb1,vdze1
         write(io6,*) '   VTYB1,VTYE1 = ',vtyb1,vtye1
         write(io6,*) '   VDYB1,VDYE1 = ',vdyb1,vdye1
         write(io6,*) '   VTZB2,VTZE2 = ',vtzb2,vtze2
         write(io6,*) '   VDZB2,VDZE2 = ',vdzb2,vdze2
         write(io6,*) '   VTYB2,VTYE2 = ',vtyb2,vtye2
         write(io6,*) '   VDYB2,VDYE2 = ',vdyb2,vdye2
         write(io6,*) 'SIG-Y0 squared = ',sy0sq
         endif
c*****
c
      return
      end
c----------------------------------------------------------------------
      subroutine slugi(ibsamp,iesamp,jbsamp,jesamp,meshdn,dgrid,delsam)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 921231                  SLUGI
c                J. Scire, SRC
c
c --- PURPOSE:  Initialize the variables defining the sampling grid
c               in common block /RECGRD/.  This common is used by the
c               slug sampling function.
c
c --- INPUTS:
c          IBSAMP - integer    - Element number of the met. grid
c                                defining the beginning of the
c                                sampling grid in the X direction
c          JBSAMP - integer    - Element number of the met. grid
c                                defining the beginning of the
c                                sampling grid in the Y direction
c          IESAMP - integer    - Element number of the met. grid
c                                defining the end of the sampling
c                                grid in the X direction
c          JESAMP - integer    - Element number of the met. grid
c                                defining the end of the sampling
c                                grid in the Y direction
c          MESHDN - integer    - Nesting factor of the sampling grid.
c                                The sampling grid spacing (in meters)
c                                is DGRID/MESHDN
c           DGRID - real       - METOROLOGICAL grid spacing (m)
c          DELSAM - real       - SAMPLING grid spacing (m)
c
c --- OUTPUT:
c       Common block /RECGRD/ variables:
c             All variables
c
c --- SLUGI called by:  SETUP
c --- SLUGI calls:      none
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      common/RECGRD/nx,dx,xleft,xrght,ny,dy,ybot,ytop
c
      nx=meshdn*(iesamp-ibsamp)+1
      dx=delsam
      xleft=(FLOAT(ibsamp)-0.5)*dgrid
      xrght=xleft+(nx-1)*delsam
c
      ny=meshdn*(jesamp-jbsamp)+1
      dy=delsam
      ybot=(FLOAT(jbsamp)-0.5)*dgrid
      ytop=ybot+(ny-1)*delsam
c
      return
      end
c----------------------------------------------------------------------
      subroutine setup(itest)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                  SETUP
c                J. Scire
c
c --- SETUP PHASE of model run -- perform all initialization and
c     one-time setup operations
c
c --- UPDATE
c --- V6.01-V6.26   080430  (DGS): add MRISE filter to NUMPR1 call
c --- V5.75-V6.01   050915  (DGS): add call to MET4PROF and full
c                                  begin/end time structures
c                           (DGS): convert PT2 coordinates to model
c                                  Map projection and DATUM
c --- V5.74-V5.75   050225  (DGS): add platform downwash to RDTIEM2
c --- V5.72-V5.74   040715  (DGS): add METFM=5 (AERMET)
c --- V5.71-V5.72   031017  (DGS): modify call to WROUT1 for source
c                                  contribution option (MSOURCE)
c                   031017  (DGS): process source location data from
c                                  variable emissions files (RDEMSRC)
c                   031017  (DGS): add IQAPLOT control option
c --- V5.7-V5.71    030528  (DGS): MBCON=2 option for using CONC.DAT
c                                  as BCON.DAT file
c --- V5.4-V5.7     030402  (DGS): move METLATLON subroutine here
c                   030402  (DGS): add structures to pass control file
c                                  image and other inputs to header of
c                                  output files
c                   030402  (DGS): add PRIME (building downwash) inputs
c --- V5.4-V5.4     000602_5(DGS): add QA plot file subroutine
c --- V5.4-V5.4     000602_3(DGS): add aqueous phase chemistry
c --- V5.3-V5.4     000602  (DGS): NVOLDAT replaces IGRDVL for 
c                                  multiple VOLEMARB.DAT files
c                   000602  (DGS): allow multiple PTEMARB.DAT and
c                                  BAEMARB.DAT files
c                   000602  (DGS): allow units choice in BAEMARB.DAT
c                   000602  (DGS): set up FOG Model output info
c --- V5.2-V5.3     991222  (DGS): add boundary condition setup
c --- V5.0-V5.2     991104  (DGS): add DSRISE to NUMPR1 call to pass
c                                  control file variable into /numparm/
c --- V5.0-V5.0     990228d (DGS): add mass balance setup
c                   990228d (DGS): add banner to mass flux and mass
c                                  balance list files
c --- V5.0-V5.0     990228c (DGS): add mass flux setup
c --- V5.0-V5.0     980807  (DGS): add MFVL2 for VOLEM.DAT format
c --- V5.0-V5.0     980515  (DGS): add setup for sub-grid TIBL module
c --- V5.0-V5.0     980304  (DGS): add QA of RESTART file
c --- V4.0-V5.0     971107  (DGS): write errors to screen if found
c                                  before list file is opened.
c                   971107  (DGS): accept start-time from met file
c                                  for METRUN=1
c                   971107  (DGS): allow for binary of ASCII variable
c                                  emissions files
c                   971107  (JSS): add METFM to NUMPR1 call to allow
c                                  use of all met formats
c                   971107  (DGS): add call to TRELIEF and VWIDTH to set
c                                  up terrain relief and valley widths
c                                  used for MCTADJ=2
c                   971107  (DGS): add calls to process LNEMARB.DAT
c
c --- OUTPUT:
c              ITEST - integer - Flag indicating if execution is to
c                                proceed beyond SETUP phase
c                                (ITEST = 1 to STOP program after
c                                           SETUP phase,
c                                 ITEST = 2 to CONTINUE execution)
c
c     Common block /OUTPT/
c        IMESG, IOMESG, LDEBUG
c     Common block /PT2/
c        MFPT2(mxemdat), TIEM2(7,mxpt2), BHT2(36,mxpt2), BWD2(36,mxpt2)
c        BLN2(36,mxpt2), XBADJ2(36,mxpt2), YBADJ2(36,mxpt2),
c        ZPLATPT2(mxpt2)
c     Common block /VOL2/
c        MFVL2(mxemdat)
c
c --- Parameters used:
c        MXMAIN, MXARR, MXSPEC, MXNZ, MXNZP1, MXPT2,
c        MXEMDAT, IO6, IOX, IOPT2, IOAR2, IOVOL
c        mxp6, mxp14, mxarea, mxvol, mxlines, mxlngrp
c
c --- SETUP called by: MAIN
c --- SETUP calls:     DATETM,  COMLINE, READFN,  READCF,  TIMESET,
c                      WRFILES, SETCOM,  OPENOT,  RDHDEM2, RDHDEM3,
c                      RDHDEM4, RDHDEM5, RDTIEM2, RDTIEM3, RDTIEM5,
c                      RDEMSRC,
c                      CHEMI,   EMQA,
c                      MET1,    MET2,    MET3,    MET4,   MET4PROF,
c                      RDHDTVW, SIGSET,
c                      SLUGI,   DRYI,    CTINIT,  WROUT1,  ELEVI,
c                      NUMPR1,  TRELIEF, RESTARTQ,TIBLSET,
c                      MFLXSET, MFLXHDR, MBALHDR, WRIVL,
c                      RDHDBC,  RDHDBC2, SETFOG,  QAPLOT1, METLATLON,
c                      TFERCF,  MET1DOC
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'ar2.puf'
      include 'comparm.puf'
      include 'ctsgdat.puf'
      include 'dataset.puf'
      include 'drydep.puf'
      include 'filnam.puf'
      include 'flags.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'ln2.puf'
      include 'map.puf'
      include 'methd.puf'
      include 'outpt.puf'
      include 'pt2.puf'
      include 'qa.puf'
      include 'vol2.puf'
      include 'wrkspc.puf'
c
      character*80 title(3)

      logical LPRT,ldb,lnpt2,lnar2,lnvl2

c --- Time-variable emission arrays (declare full dimensions here)
      real em4dat(mxp6,mxvol)
      real em3dat(mxp14,mxarea)
      real em5dat(mxp6,mxlines),em5grp(7,mxlngrp)

c --- For coordinate transformations
      character*8 cmapi,cmapo
      character*12 caction
      character*4 c4hem
      real*8 vecti(9),vecto(9)

c --- Get date and time from system
      call datetm(rdate,rtime,rcpu)
c
c --- Get the name of the control file from the command line
      call comline(pufinp)
c
c --- Open the control file
      open(io5,file=pufinp,status='old')
c
c --- Report progress
      write(iomesg,*)'SETUP PHASE'
c
c --- Check that the version and level number in the parameter
c --- file matches those in the code itself
      if(ver.ne.mver.or.level.ne.mlevel)then
         write(iomesg,10)mmodel,ver,level,mver,mlevel
10       format(/1x,'ERROR in SUBR. SETUP -- The ',a12,' version ',
     1   'and level numbers do not match those in the parameter file'/
     2   5x,'    Model Code - Version: ',a12,' Level: ',a12/
     3   5x,'Parameter File - Version: ',a12,' Level: ',a12)
         stop
      endif
c
c --- Read control file inputs
      call readcf(title,itest)
c
c --- Pass image of CALPUFF control file to scratch file
      call TFERCF
c
c --- Assign debug logical for local use
      ldb=ldebug
c
c --- Write the files used in this run to the list file
      call wrfiles(npt2,nar2,nln2,nvl2,idryflg,mhill)
c
c --- Set misc. common block parameters (grid parameters, etc.)
      call setcom
c
c --- Pass CALMET.DAT control file images to scratch file
      if(metfm.EQ.1) call met1doc
c
c --- Open all other I/O files
      call openot(nln2,idryflg,mhill,mfpt2,mfvl2)
c
c --- Read header records from meteorological data file
      lprt=.true.
c      lprt=.false.
      if(metfm.EQ.1) then
         call met1(nx,ny,lprt,tmp1,nw1)
      elseif(metfm.EQ.2) then
         call met2(lprt)
      elseif(metfm.EQ.3) then
         call met3(lprt)
      elseif(metfm.EQ.4 .OR. metfm.EQ.5) then
         call met4(metfm,lprt)
      endif
c --- Transfer beginning/end time of met data to run-control variables
c --- if entire met file is to be processed (METRUN=1)
      if(metrun.EQ.1) then
         ibyr=ibymet
         ibmo=ibmmet
         ibdy=ibdmet
         ibhr=ibhmet
         ibsec=ibsmet
         ibdathr=ibymet*100000+ibjdmet*100+ibhmet
         iesec=iesmet
         iedathr=ieymet*100000+iejdmet*100+iehmet
c ---    Compute run length to end of met file
c ---    No. hours
         call DELTT(ibymet,ibjdmet,ibhmet,ieymet,iejdmet,iehmet,idelhr)
c ---    Adjust for seconds
         idelsec=-ibsmet+iesmet
c ---    Timesteps
         irlg=(idelhr*3600)/nsecdt+(idelsec/nsecdt)
         write(io6,*)
         write(io6,*)
         write(io6,*)'---------------------------------------------'
         write(io6,*)
         write(io6,*)'           REVISED CONTROL DATA  '
         write(io6,*)'         Running All Met Periods '
         write(io6,*)
         write(io6,*)'-------------  INPUT GROUP 1  ---------------'
         write(io6,*)
         write(io6,*)'metrun  = ',metrun
         write(io6,*)'ibyr    = ',ibyr
         write(io6,*)'ibmo    = ',ibmo
         write(io6,*)'ibdy    = ',ibdy
         write(io6,*)'ibhr    = ',ibhr
         write(io6,*)'ibsec   = ',ibsec
         write(io6,*)'nsecdt  = ',nsecdt
         write(io6,*)'irlg    = ',irlg
         write(io6,*)'ibdathr = ',ibdathr
         write(io6,*)'iedathr = ',iedathr
         write(io6,*)'iesec   = ',iesec
         write(io6,*)
         write(io6,*)'(End-times in other data files are NOT checked)'
         write(io6,*)
         write(io6,*)'---------------------------------------------'
      endif
c
c --- Set starting time variables
      call TIMESET
c
c --- Set PROFILE.DAT format if used for turbulence or inversion
c     strength data ONLY
      if(metfm.NE.4 .AND. metfm.NE.5) then
         if(mtinv.EQ.1) then
            call MET4PROF(lprt)
         elseif((mdisp.EQ.1 .OR. mdisp.EQ.5) .AND. mturbvw.LT.4) then
            call MET4PROF(lprt)
         endif
      endif
c
c --- Read header records from the emissions files:
c        PTEMARB.DAT - iopt2- Arbitrarily-varying pt. source emissions
c        BAEMARB.DAT - ioar2- Variable buoyant area source emissions
c        VOLEMARB.DAT- iovol- Variable volume source emissions
c        LNEMARB.DAT - io19 - Variable buoyant line source emissions
c --- and Pass images to scratch file

      lprt=.true.
      lnpt2=.true.
      lnar2=.true.
      lnvl2=.true.
c
      do iem=1,nptdat
         call RDHDEM2(iopt2,iem,lprt,lnpt2)
         call RDTIEM2(iopt2,npt2,nptdat,iem,mfpt2,ibsrc2,iesrc2,
     &                verparb(iem),mbdw,lprt,io6,iox,tiem2,zplatpt2,
     &                bht2,bwd2,bln2,xbadj2,ybadj2,cid2,ncommout)
      enddo
c -------------------------------------------- PTEMARB Source Locations
c --- Convert the source coordinates to the CALPUFF map projection
c --- and datum, and then convert from km to MET GRID
c --- Scale factor for Tangential TM projection
      tmsone=1.00000
c --- Output of coord transform is to CALPUFF (x,y) - /MAP/
      iutmo=iutmzn
      if(utmhem.EQ.'S   ' .AND. iutmo.LT.900) iutmo=-iutmo
      cmapo=pmap
      if(cmapo.EQ.'TTM     ') cmapo='TM      '
c --- Input is from PTEMARB.DAT header - /PT2/
c --- Loop over PTEMARB files
      do iem=1,nptdat
         iutmi=iutmznpt2(iem)
         if(utmhempt2(iem).EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
         cmapi=pmappt2(iem)
         if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---    Set conversion vectors
         call GLOBE1(cmapi,iutmi,tmsone,rnlat1pt2(iem),rnlat2pt2(iem),
     &               rnlat0pt2(iem),relon0pt2(iem),
     &               feastpt2(iem),fnorthpt2(iem),
     &               cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &               feast,fnorth,
     &               caction,vecti,vecto)
         do is=ibsrc2(iem),iesrc2(iem)
            xpt2=tiem2(1,is)
            ypt2=tiem2(2,is)
            call GLOBE(io6,caction,datumpt2(iem),vecti,datum,
     &                 vecto,xpt2,ypt2,tiem2(1,is),tiem2(2,is),
     &                 izone,c4hem)
            tiem2(1,is)=(1000.*tiem2(1,is)-xorig)*dgridi
            tiem2(2,is)=(1000.*tiem2(2,is)-yorig)*dgridi
         enddo
      enddo
c -------------------------------------------- PTEMARB Source Locations

      do iem=1,nardat
         call RDHDEM3(ioar2,iem,lprt,lnar2)
         call RDTIEM3(ioar2,nar2,nardat,iem,ibsrc3,iesrc3,iuem3,
     &                veraarb(iem),lprt,io6,iox,cid3,baemunit,ncommout)
      enddo
      do iem=1,nvoldat
         call RDHDEM4(iovol,iem,lprt,lnvl2)
         call RDTIEM4(iovol,nvl2,nvoldat,iem,ibsrc4,iesrc4,
     &                vervarb(iem),lprt,io6,iox,cid4,ncommout)
      enddo
      if(nln2.gt.0)then
         call RDHDEM5(io19,lprt)
         call RDTIEM5(io19,mxrise,nln2,lprt,io6,iox,cid5,ncommout,
     &                mxnseg2,nlrise2)
      endif
c
c --- Make sure enough sources are read from the emissions files
      if(.NOT.lnpt2) then
         write(io6,11) npt2
11       format(/1x,'ERROR in SUBR. SETUP -- number of sources in',
     &   ' PTEMARB.DAT files does not match expected value',i6)
         write(*,*)
         stop 'Halted in SETUP -- see list file.'
      endif
      if(.NOT.lnar2) then
         write(io6,12) nar2
12       format(/1x,'ERROR in SUBR. SETUP -- number of sources in',
     &   ' BAEMARB.DAT files does not match expected value',i6)
         write(*,*)
         stop 'Halted in SETUP -- see list file.'
      endif
      if(.NOT.lnvl2) then
         write(io6,13) nvl2
13       format(/1x,'ERROR in SUBR. SETUP -- number of sources in',
     &   ' VOLEMARB.DAT files does not match expected value',i6)
         write(*,*)
         stop 'Halted in SETUP -- see list file.'
      endif
c
c --- Read header records from the boundary condition file:
c --- BCON.DAT - io15 - boundary concentrations,
c --- and perform setup operations
      if(mbcon.eq.1) call RDHDBC
      if(mbcon.eq.2) call RDHDBC2(io15)
c
c --- Perform setup operations for chemical transformation module
      if(mchem.ge.1)call chemi(mchem,maqchem,ldb)
c
c --- Perform QA checks on emissions header record data
      lprt=.TRUE.
      call emqa(lprt)
c
c --- Pull source location data from the first set of time-variable
c --- records for area, volume, and line sources and reposition
c --- file pointers (source locations are needed for output files)
      call RDEMSRC(nardat,nvoldat,em3dat,em4dat,em5dat,em5grp)
c
c --- Interpolate elevations from meteorological grid to gridded recs.
      if(lsamp) then
         call elevi
      endif
c
c --- Perform setup operations for the dispersion coefficient routines
      call sigset
c
c --- Setup the sampling grid for the SLUG function
      if(lsamp) then
         call slugi(ibsamp,iesamp,jbsamp,jesamp,meshdn,dgrid,delsam)
      else
c ---    Gridded receptors are not used in run, so define slug domain
c ---    as the computational domain
         call slugi(ibcomp,iecomp,jbcomp,jecomp,1,dgrid,dgrid)
      endif
c
c --- Perform setup computations for the FOG Model output option
      if(mfog.GT.0) call SETFOG(title(1))
c
c --- Perform setup operations for dry deposition
      zgrid1=0.5*(zface(1)+zface(2))
      if(mdry.eq.1)call dryi(zgrid1,ldb)
c
c --- Perform setup computations for CTADJ2 complex terrain
c --- module (simplified CALPUFF treatment)
      if(mctadj.eq.2)then
         call trelief(ldb)
         call vwidth(ldb)
      endif
c
c --- Perform setup computations for sub-grid scale complex terrain
c --- module (CTSG)
      if(mctsg.gt.0)then
         call ctinit(dgrid,mhill,nhill,hilldat,nctrec,xrct,yrct)
      endif
c
c --- Perform setup computations for the numerical plume rise algorithm
c --- (either for buoyant areas, or points with numerical rise or PRIME)
      if(nar2.gt.0 .OR. mbdw.EQ.2 .OR. mrise.EQ.2)then
         call numpr1(nz,zgpt,nzp1,zface,metfm,dsrise,trajincl)
      endif

c --- Check (QA) information in RESTART file for continuation run
      if(mrestart.EQ.1 .OR. mrestart.EQ.3) call RESTARTQ
c
c --- Perform setup operations for the sub-grid TIBL module
      if(msgtibl.EQ.1) call TIBLSET(ldb)
c
c --- Perform setup operations for the mass flux output option
      if(imflx.EQ.1) then
         call WRIVL(io36,mmodel,ver,level)
         call MFLXSET(ldb)
         call MFLXHDR(title)
      endif
c
c --- Perform setup operations for the mass balance output option
      if(imbal.EQ.1) then
         call WRIVL(io37,mmodel,ver,level)
         call MBALHDR(title,mbcon)
      endif

c --- Compute latitude/longitude of all MET gridpoints
      call METLATLON
c
c --- Write header records to output disk files
      call wrout1(title)
c
c --- Write QA information to plot files
      if(iqaplot.EQ.1) call QAPLOT1
c
      return
      end
c----------------------------------------------------------------------
      subroutine openot(nln2,idryflg,mhill,mfpt2,mfvl2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                 OPENOT
c                J. Scire, D. Strimaitis
c
c --- PURPOSE:  Open all input/output files other than input control
c ---           file (IO5) and output list file (IO6)
c
c --- UPDATE
c --- V6.26-V6.261  080520  (DGS): add scratch file for direct access
c                                  to store source tables (rise)
c --- V6.1-V6.26    080430  (DGS): add RISE.DAT for NUMRISE output
c --- V5.74-V6.1    050915  (DGS): add FILVERS for dataset versions
c                   050915  (DGS): expand date-time in TRACK header
c --- V5.71-V5.725  050128  (DGS): add TK2D.DAT for 2D temperature
c                   050128  (DGS): add RHO2D.DAT for 2D density
c --- V5.71-V5.74   040715  (DGS): add METFM=5 (AERMET)
c --- V5.7-V5.71    030528  (DGS): MBCON=2 opens a binary CONC.DAT file
c --- V5.4-V5.7     030402  (DGS): replace OPENAB with explicit ASCII
c                                  file assumption
c --- V5.4-V5.4     000602_3(DGS): add H2O2.DAT for aqueous chemistry
c --- V5.3-V5.4     000602  (DGS): NVOLDAT replaces IGRDVL, and
c                                  open multiple VOLEMARB.DAT files
c                   000602  (DGS): open multiple PTEMARB.DAT and
c                                  BAEMARB.DAT files
c                   000602  (DGS): include FOG.DAT file
c --- V5.2-V5.3     991222  (DGS): add BCON.DAT
c --- V5.0-V5.2     991104  (DGS): YYYY for year in TRACK header
c --- V5.0-V5.0     990228d (DGS): add MASSBAL.DAT
c --- V5.0-V5.0     990228c (DGS): add FLUXBDY.DAT and MASSFLX.DAT
c --- V5.0-V5.0     990228a (DGS): allow array of CALMET.DAT filenames
c --- V5.0-V5.0     980918  (DGS): include MCHEM=4
c --- V5.0-V5.0     980807  (DGS): allow either unformatted of formatted
c                                  Variable emissions file for VOLUMES
c --- V5.0-V5.0     980731  (DGS): augment output to DEBUG.DAT
c --- V5.0-V5.0     980515  (DGS): add COASTLN.DAT file
c --- V5.0-V5.0     980304  (DGS): add RESTART file
c --- V4.0-V5.0     971107  (DGS): add LNEMARB.DAT file
c --- V4.0-V4.1     971107  (DGS): allow either unformatted of formatted
c                                  Variable emissions file for POINTS
c                   971107  (DGS): open PROFILE.DAT when MTINV=1 for
c                                  getting inversion strength
c
c --- INPUTS:
c               NLN2 - integer - Number of buoyant line sources with
c                                variable location and emissions
c                                (LNEMARB.DAT - arbitrary emissions)
c     IDRYFLG(mxspec) - integer - Array of dry deposition flags for
c                       array     each pollutant
c                                   0 = No deposition
c                                   1 = Resistance model - gas
c                                   2 = Resistance model - particle
c                                   3 = User-specified dep. velocities
c               MHILL - integer - Flag controlling use of CTDM-format
c                                 hill & receptor information (for CTSG)
c                                   0 = No file (CTSG option not used)
c                                   1 = HILL.DAT and HILLRCT.DAT files
c                                   2 = No file (hill data from OPTHILL
c                                       are supplied in Subgroup 6b, and
c                                       CTSG receptors are supplied in
c                                       Subgroup 6c)
c
c     Common block /CHEMDAT/ variables:
c           MOZ
c     Common block /FLAGS/ variables:
c           MCHEM, MDRY, MDISP, MCTSG, MTURBVW, MTINV, MSGTIBL, MBCON,
c           MAQCHEM
c     Common block /GEN/ variables:
c           METFM, MRESTART
c     Common block /OUTPT/ variables:
c           ICON, IVIS, IT2D, IRHO, IDRY, IWET, IMFLX, IMBAL, IFOG,
c           INRISE
c           LDEBUG
c     Common block /FILNAM/ variables:
c           METDATL, ISCDAT, PLMDAT, CONDAT, DFDAT, WFDAT, VISDAT,
c           T2DDAT, RHODAT, PTDAT(mxemdat), ARDAT(mxemdat),
c           VOLDAT(mxemdat), LNDAT, VDDAT, OZDAT, CHEMDAT, HILDAT,
c           RCTDAT, PRFDAT, SFCDAT, RSTARTB, CSTDAT, BDTDAT, FLXDAT,
c           BALDAT, DEBUG, NPTDAT, NARDAT, NVOLDAT, FOGDAT, H2O2DAT,
c           RISDAT
c     Parameters: IO3, IO6, IO7, IO8, IO9, IO10, IO11, IO12, IO13, IO14,
c                 IO15, IO19 IO20, IO22, IO23, IO24, IO25, IO28, IO29,
c                 IO30, IO31, IO32, IO35, IO36, IO37, IO38, MXSPEC,
c                 IOPT2, IOAR2, IOVOL, MXEMDAT, MXMETDAT,
c                 IOTAB
c
c --- OUTPUT:
c  MFPT2(mxemdat) - integer    - Formatted PTEMARB.DAT file?
c                                 (0:NO, 1:YES)
c  MFVL2(mxemdat) - integer    - Formatted VOLEMARB.DAT file?
c                                 (0:NO, 1:YES)
c
c     Common block /DATASET/ variables:
c           vermet,verisc,verplm,verprf,versfc
c           verparb(mxemdat),veraarb(mxemdat),verlarb,vervarb(mxemdat)
c           veroz,verh2o2,vercoast,verflxb,verbcon,verrest
c
c --- OPENOT called by:  SETUP
c --- OPENOT calls:      FILVERS,(OPENAB)
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common blocks
      include 'chemdat.puf'
      include 'dataset.puf'
      include 'filnam.puf'
      include 'flags.puf'
      include 'gen.puf'
      include 'outpt.puf'
c
      integer idryflg(mxspec),mfpt2(mxemdat),mfvl2(mxemdat)
c
      character*7 cstat
c
      logical lprofile
c
      data cstat/'unknown'/, lprofile/.FALSE./

c --- Open Restart file (may or may not exist)
      if(mrestart.EQ.1 .OR. mrestart.EQ.3) then
         call FILVERS(io3,'BIN',rstartb,'RESTART         ',verrest)
         open(io3,file=rstartb,form='unformatted',status='old')
      endif
c
c --- Open Primary met file
      if(metfm.EQ.1) then
c ---    open CALMET meteorological data file (CALMET.DAT)
         call FILVERS(io7,'BIN',metdatl(1),'CALMET          ',vercmet)
         open(io7,file=metdatl(1),status='old',form='unformatted')
      elseif(metfm.EQ.2) then
c ---    open ISC meteorological data file (ISCMET.DAT)
         call FILVERS(io7,'ASC',iscdat,'ISCMET          ',verisc)
         open(io7,file=iscdat,status='old')
      elseif(metfm.EQ.3) then
c ---    open PLM meteorological data file (PLMMET.DAT)
         call FILVERS(io7,'ASC',plmdat,'PLMMET          ',verplm)
         open(io7,file=plmdat,status='old')
      elseif(metfm.EQ.4 .OR. metfm.EQ.5) then
c ---    open PROFILE meteorological data file (PROFILE.DAT)
         call FILVERS(io31,'ASC',prfdat,'PROFILE         ',verprf)
         open(io31,file=prfdat,status='old')
         lprofile=.TRUE.
c ---    open SURFACE meteorological data file (SURFACE.DAT)
         call FILVERS(io32,'ASC',sfcdat,'SURFACE         ',versfc)
         open(io32,file=sfcdat,status='old')
      endif
c
c --- Open PROFILE.DAT if inversion strength data are needed
      if(.not.lprofile .AND. mtinv.EQ.1) then
         call FILVERS(io31,'ASC',prfdat,'PROFILE         ',verprf)
         open(io31,file=prfdat,status='old')
      endif
c
c --- open output concentration file (CONC.DAT)
      if(ICON.eq.1)open(io8,file=condat,status=cstat,
     1  form='unformatted')
c
c --- open output dry flux file (DFLX.DAT)
      if(IDRY.eq.1)open(io9,file=dfdat,status=cstat,
     1  form='unformatted')
c
c --- open output wet flux file (WFLX.DAT)
      if(IWET.eq.1)open(io10,file=wfdat,status=cstat,
     1  form='unformatted')
c
c --- open visibility-related file (VISB.DAT)
      if(IVIS.eq.1)open(io11,file=visdat,status=cstat,
     1  form='unformatted')
c
c --- open 2D temperature file (TK2D.DAT)
      if(IT2D.eq.1)open(io13,file=t2ddat,status=cstat,
     1  form='unformatted')
c
c --- open 2D density file (RHO2D.DAT)
      if(IRHO.eq.1)open(io14,file=rhodat,status=cstat,
     1  form='unformatted')
c
c --- open BOUNDARY CONCENTRATION file (BCON.DAT)
      if(mbcon.eq.1) then
         call FILVERS(io15,'ASC',bcndat,'BCON            ',verbcon)
         open(io15,file=bcndat,status='old')
      elseif(mbcon.eq.2) then
         call FILVERS(io15,'BIN',bcndat,'BCON            ',verbcon)
         open(io15,file=bcndat,status='old',form='unformatted')
      endif
c
c --- open output fog-model file (FOG.DAT)
      if(IFOG.eq.1)open(io12,file=fogdat,status=cstat,
     1  form='unformatted')
c
c --- open POINT SOURCE emissions file(s) (PTEMARB.DAT)
c --- (stationary point sources with arbitrary variation in emissions)
      do i=1,nptdat
         io=iopt2+i-1
c ---    Assume ASCII file (formatted)
c        call OPENAB(io,ptdat(i),mfpt2(i))
         call FILVERS(io,'ASC',ptdat(i),'PTEMARB         ',verparb(i))
         mfpt2(i)=1
         open(io,file=ptdat(i),status='old')
      enddo
c
c --- open BUOYANT AREA SOURCE file(s)  (BAEMARB.DAT)
c --- (area sources with arbitrary variation in location & emissions)
      do i=1,nardat
         io=ioar2+i-1
         call FILVERS(io,'ASC',ardat(i),'BAEMARB         ',veraarb(i))
         open(io,file=ardat(i),status='old')
      enddo
c
c --- open buoyant LINE SOURCE file  (LNEMARB.DAT)
c --- (line sources with arbitrary variation in location & emissions)
      if(nln2.gt.0) then
         call FILVERS(io19,'ASC',lndat,'LNEMARB         ',verlarb)
         open(io19,file=lndat,status='old')
      endif
c
c --- open VOLUME SOURCE file(s) (VOLEMARB.DAT)
c --- (volume sources with arbitrary variation in location & emissions)
      do i=1,nvoldat
         io=iovol+i-1
c ---    Assume ASCII file (formatted)
c        call OPENAB(io,voldat(i),mfvl2(i))
         call FILVERS(io,'ASC',voldat(i),'VOLEMARB        ',vervarb(i))
         mfvl2(i)=1
         open(io,file=voldat(i),status='old')
      enddo
c
c --- open DEPOSITION VELOCITY file (VD.DAT) (if user-specified
c     deposition velocities are used for any species AND computation
c     of dry deposition is requested
      if(mdry.eq.1)then
         do 10 i=1,mxspec
         if(idryflg(i).eq.3)then
            open(io20,file=vddat,status='old')
            go to 12
         endif
10       continue
12       continue
      endif
c
c --- open OZONE data file (OZONE.DAT) (if chemical transformation
c     is computed AND hourly ozone input is requested)
      if((mchem.EQ.1 .OR. mchem.EQ.3 .OR. mchem.EQ.4)
     &              .AND. moz.EQ.1) then
         call FILVERS(io22,'ASC',ozdat,'OZONE           ',veroz)
         open(io22,file=ozdat,status='old')
      endif
c
c --- open H2O2 data file (H2O2.DAT) (if aqueous phase chemical
c     transformation is computed AND hourly H2O2 input is requested)
      if(maqchem.EQ.1 .AND .mh2o2.EQ.1) then
         call FILVERS(io23,'ASC',h2o2dat,'H2O2            ',verh2o2)
         open(io23,file=h2o2dat,status='old')
      endif
c
c --- open CHEMICAL TRANSFORMATION file (CHEM.DAT) (if user-specified
c     chemical transformation rates are used)
      if(mchem.eq.2)open(io24,file=chemdat,status='old')
c
c --- open TURBULENCE data file (PROFILE.DAT) if needed
      if(.not.lprofile .AND. mtinv.NE.1) then
c ---    Need turbulence only for MDISP=1,5
         if(mdisp.EQ.1 .OR. mdisp.EQ.5) then
c ---       Open file only when explicitly requested
            if(mturbvw.LT.4) then
              call FILVERS(io31,'ASC',prfdat,'PROFILE         ',verprf)
              open(io31,file=prfdat,status='old')
            endif
         endif
      endif
c
c --- open CTSG hill information files (HILL.DAT, HILLRCT.DAT)
c     (if CTDM processors are used to create them)
      if(mctsg.eq.1.and.mhill.eq.1) then
         open(io28,file=hildat,status='old')
         open(io29,file=rctdat,status='old')
      endif
c
c --- open Coast Line(s) file (COASTLN.DAT)
c     (if sub-grid TIBL module is used)
      if(msgtibl.eq.1) then
         call FILVERS(io25,'ASC',cstdat,'COASTLN         ',vercoast)
         open(io25,file=cstdat,status='old')
      endif
c
c --- open Mass Flux files (FLUXBDY.DAT, MASSFLX.DAT)
c     (if mass flux output option is selected)
      if(imflx.eq.1) then
         call FILVERS(io35,'ASC',bdydat,'FLUXBDY         ',verflxb)
         open(io35,file=bdydat,status='old')
         open(io36,file=flxdat,status=cstat)
      endif
c
c --- open Mass Balance file (MASSBAL.DAT)
c     (if mass balance output option is selected)
      if(imbal.eq.1) then
         open(io37,file=baldat,status=cstat)
      endif
c
c --- open NUMRISE file (RISE.DAT) and temporary work file
c     (if output option is selected)
      if(INRISE.eq.1) then
         open(io38,file=risdat,status=cstat)
      endif
c
c --- open Puff/Slug TRACKING file (DEBUG.LST) (if in DEBUG mode)
      if(LDEBUG) then
         open(io30,file=debug,status=cstat)
c ---    Write column headers for Puffs/Slugs
         write(io30,301)
         write(io30,302)
      endif

c --- Open Direct Access scratch file for source tabulations (rise)
c --- Record length in bytes holds 6 integers and 11 real arrays
c --- dimensioned MXRISE
      nbytes=4*(6+11*mxrise)
      OPEN(iotab,access='direct',form='unformatted',recl=nbytes,
     &     status='scratch')


301   format('                              ---- PUFF/ Old SLUG end --',
     &       '-------')
302   format('YYYYJJJHH  SEC   ipnum cd   zfnl   x(metG)   y(metG)',
     &       '    sigyB    sigzB          QM          QU   zimax',
     &       '  rflctn    dpbl jdstab   Length')
c
      return
      end
c----------------------------------------------------------------------
      subroutine openab(iunit,fname,mformat)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980807                 OPENAB
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Open existing input file after determining if file
c               is ASCII or Binary format
c
c --- UPDATE
c --- V6.11  980807-060309  (DGS): filenames c*70 to c*132
c
c --- INPUTS:
c              IUNIT - integer   - File unit number
c              FNAME - character - File name
c
c --- OUTPUT:
c            MFORMAT - integer   - Formatted file?
c                                  (0:NO, 1:YES)
c
c --- OPENAB called by:  OPENOT
c --- OPENAB calls:      INQUIRE(system-dependent?)
c----------------------------------------------------------------------
c
      character*132 fname
      character aform*7
      logical linquire

c ---------------------------------------------------------------
c --- Set logical to T if system supports this form of INQUIRE
      data linquire/.FALSE./
c ---------------------------------------------------------------

      if(LINQUIRE)then
         INQUIRE(file=fname,formatted=aform)
         if(aform(1:3).EQ.'YES') then
            mformat=1
            open(iunit,file=fname,status='old')
         else
            mformat=0
            open(iunit,file=fname,status='old',form='unformatted')
         endif
         return
      endif

c ---------------------------------------------------------------
c --- Otherwise, use ERR to recover from inappropriate format
c ---------------------------------------------------------------

c --- Assume file is unformatted (binary)
c ---------------------------------------
      mformat=0
      open(iunit,file=fname,status='old',form='unformatted',
     &     err=200)
c --- Test read
      read(iunit,err=200) aform
c --- Close and ReOpen file to place pointer at start
      close(iunit)
      open(iunit,file=fname,status='old',form='unformatted')
      return

200   continue
      close(iunit)

c --- Assume file is formatted (ASCII)
c ------------------------------------
      mformat=1
      open(iunit,file=fname,status='old',err=300)
c --- Test read
      read(iunit,*,err=300) aform
c --- Close and ReOpen file to place pointer at start
      close(iunit)
      open(iunit,file=fname,status='old')
      return

300   continue
      close(iunit)
c --- FATAL ERROR - file could not be opened and read
c --- Simply open file again, and let system report the error
      open(iunit,file=fname,status='old')
      return      

      end
c----------------------------------------------------------------------
      subroutine setcom
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                 SETCOM
c                J. Scire, SRC
c
c --- PURPOSE:  Set miscellaneous common block variables in the
c               /GRID/ common block
c
c --- UPDATE
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c --- V5.2-V5.3     991222  (DGS): compute SAM2GRID here
c
c --- INPUTS:
c     Common block /GEN/ variables:
c          NSPEC, ISPLST(4,mxspec)
c     Common block /GRID/ variables:
c          NX, NY, NZ, ZFACE(mxnzp1), DGRID, IBCOMP, JBCOMP,
c          IECOMP, JECOMP, LSAMP, IBSAMP, JBSAMP, IESAMP, JESAMP,
c          MESHDN
c     Parameters:  MXNX, MXNY, MXNXG, MXNYG, MXNZ, IO6, MXNZP1
c
c --- OUTPUT:
c     Common block /GEN/ variables:
c          NSE, NSDD
c     Common block /GRID/ variables:
c          NXCMP, NYCMP, NXSAM, NYSAM, DELSAM, SAM2GRID,
c          NXM1, NXM2, NYM1, NYM2, NZP1, ZGPT(mxnz)
c
c --- SETCOM called by: SETUP
c --- SETCOM calls:     none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'gen.puf'
      include 'grid.puf'
      logical lerror
c
c --- Initialize error detector
      lerror=.false.
c
c ---------------------------------
c --- Computational grid dimensions
c ---------------------------------
      nxcmp=iecomp-ibcomp+1
      nycmp=jecomp-jbcomp+1
c
      if(ibcomp.le.0.or.iecomp.gt.mxnx.or.
     1   jbcomp.le.0.or.jecomp.gt.mxny)then
          write(io6,2)ibcomp,iecomp,jbcomp,jecomp,mxnx,mxny
2          format(/1x,'ERROR in subr. SETCOM -- Invalid range for the ',
     1     'COMPUTATIONAL grid'/1x,'IBCOMP = ',i6,2x,'IECOMP = ',i6/1x,
     2     'JBCOMP = ',i6,2x,'JECOMP = ',i6/1x,'MXNX   = ',i6,2x,
     3     'MXNY   = ',i6)
           lerror=.true.
      endif
      if(nxcmp.gt.mxnx.or.nycmp.gt.mxny)then
         write(io6,4)nxcmp,nycmp,mxnx,mxny
4        format(/1x,'ERROR in subr. SETCOM -- Computational grid is ',
     1     'too large for current array dimensions'/1x,'NXCMP  = ',i6,
     2     2x,'NYCMP  = ',i6/1x,'MXNX   = ',i6,2x,'MXNY   = ',i6)
           lerror=.true.
      endif
c
c --- Computational grid must be a subset of meteorological grid
c --- and at least 2 x 2 in size
      if(ibcomp.gt.nx.or.iecomp.gt.nx)then
         write(io6,34)ibcomp,iecomp,nx
34       format(/1x,'ERROR in subr. SETCOM -- Computational grid is ',
     1     'outside meteorological grid'/1x,'IBCOMP = ',i6,
     2     2x,'IECOMP = ',i6/1x,'NX   = ',i6)
           lerror=.true.
      endif
      if(jbcomp.gt.ny.or.jecomp.gt.ny)then
         write(io6,36)jbcomp,jecomp,ny
36       format(/1x,'ERROR in subr. SETCOM -- Computational grid is ',
     1     'outside meteorological grid'/1x,'JBCOMP = ',i6,
     2     2x,'JECOMP = ',i6/1x,'NY   = ',i6)
           lerror=.true.
      endif
c
c --- Index of end of computational grid must exceed beginning
      if(iecomp.le.ibcomp.or.jecomp.le.jbcomp)then
         write(io6,38)ibcomp,iecomp,jbcomp,jecomp
38       format(/1x,'ERROR in subr. SETCOM -- Computational grid is ',
     1     'ill-defined'/1x,'IBCOMP = ',i6,2x,'IECOMP = ',i6/
     2     1x,'JBCOMP = ',i6,2x,'JECOMP = ',i6)
           lerror=.true.
      endif
c
c -------------------------------------------
c --- Sampling grid dimensions & grid spacing
c -------------------------------------------
c
      if(lsamp)then
         if(ibsamp.le.0.or.iesamp.gt.mxnx.or.
     1   jbsamp.le.0.or.jesamp.gt.mxny)then
           write(io6,42)ibsamp,iesamp,jbsamp,jesamp,mxnx,mxny
42         format(/1x,'ERROR in subr. SETCOM -- Invalid range for the ',
     1     'SAMPLING grid'/1x,'IBSAMP = ',i6,2x,'IESAMP = ',i6/1x,
     2     'JBSAMP = ',i6,2x,'JESAMP = ',i6/1x,'MXNX   = ',i6,2x,
     3     'MXNY   = ',i6)
           lerror=.true.
      endif
c
c --- Sampling grid must be a subset of computational grid
c --- and at least 2 x 2 in size
         if(ibsamp.gt.iecomp.or.iesamp.gt.iecomp)then
            write(io6,44)ibsamp,iesamp,iecomp
44          format(/1x,'ERROR in subr. SETCOM -- Sampling grid is ',
     1      'outside computational grid'/1x,'IBSAMP = ',i6,
     2      2x,'IESAMP = ',i6/1x,'IECOMP = ',i6)
            lerror=.true.
         endif
         if(jbsamp.gt.jecomp.or.jesamp.gt.jecomp)then
            write(io6,46)jbsamp,jesamp,jecomp
46          format(/1x,'ERROR in subr. SETCOM -- Sampling grid is ',
     1      'outside computational grid'/1x,'JBSAMP = ',i6,
     2      2x,'JESAMP = ',i6/1x,'JECOMP = ',i6)
            lerror=.true.
         endif
c
c --- Sampling grid must part of computational grid
         if(ibsamp.lt.ibcomp.or.iesamp.lt.ibcomp.or.
     1   jbsamp.lt.jbcomp.or.jesamp.lt.jbcomp)then
            write(io6,48)ibsamp,iesamp,ibcomp,
     1                jbsamp,jesamp,jbcomp
48          format(/1x,'ERROR in subr. SETCOM -- Computational grid ',
     1      'is ill-defined'/1x,'IBSAMP = ',i6,2x,'IESAMP = ',i6/
     2      1x,'IECOMP = ',i6/1x,'JBSAMP = ',i6,2x,'JESAMP = ',i6/
     3      1x,'JECOMP = ',i6//1x,'IBSAMP, IESAMP must be >= IBCOMP ',
     4      'and JBSAMP, JESAMP must be >= IBCOMP')
            lerror=.true.
         endif
c
c --- Index of end of sampling grid must exceed beginning
         if(iesamp.le.ibsamp.or.jesamp.le.jbsamp)then
            write(io6,49)ibsamp,iesamp,jbsamp,jesamp
49          format(/1x,'ERROR in subr. SETCOM -- Computational grid ',
     1      'is ill-defined'/1x,'IBSAMP = ',i6,2x,'IESAMP = ',i6/
     2      1x,'JBSAMP = ',i6,2x,'JESAMP = ',i6//1x,'IESAMP must be ',
     3      '> IBSAMP and JESAMP must be > JBSAMP')
            lerror=.true.
         endif
      endif
c
      if(lsamp)then
         nxsam=meshdn*(iesamp-ibsamp)+1
         nysam=meshdn*(jesamp-jbsamp)+1
         sam2grid=1./float(meshdn)
         delsam=dgrid*sam2grid
      else
         nxsam=0
         nysam=0
         sam2grid=0.0
         delsam=0.0
      endif
c
      if(nxsam.gt.mxnxg.or.nysam.gt.mxnyg)then
         write(io6,6)nxsam,nysam,mxnxg,mxnyg
6        format(/1x,'ERROR in subr. SETCOM -- Sampling grid requested ',
     1   'is too large for current array dimensions'/1x,'NXSAM = ',i6,
     2   2x,'NYSAM = ',i6/1x,'MXNXG = ',i6,2x,'MXNYG = ',i6)
         lerror=.true.
      endif
c
c --- Derived met. grid parameters
      nxm1=nx-1
      nxm2=nx-2
      nym1=ny-1
      nym2=ny-2
      nzp1=nz+1
c
c --- Grid point heights
      do 10 i=1,nz
      zgpt(i)=0.5*(zface(i)+zface(i+1))
10    continue
c
c --- Count the number of deposited species
      LL=0
      nse=0
      nsdd=0
      do 15 i=1,nspec
c
c --- Count number of species modeled
      if(isplst(1,i).eq.1)then
         LL=LL+1
      endif
c
c --- Count number of species emitted
      if(isplst(2,i).eq.1)then
         nse=nse+1
      endif
c
c --- Count number of species dry deposited
      if(isplst(3,i).ge.1)then
         nsdd=nsdd+1
      endif
15    continue
c
      if(LL.ne.nspec)then
         write(io6,25)LL,nspec,(isplst(1,n),n=1,mxspec)
25       format(/1x,'ERROR in subr. SETCOM -- Number of species in ',
     1   'species list does not match NSPEC -- LL = ',i5,3x,
     2   'NSPEC = ',i5/1x,'ISPLST(1,-) = ',100i2)
         lerror=.true.
      endif
c
      if(lerror)then
         write(io6,*)'Execution terminating in subr. SETCOM'
         write(*,*)
         stop 'Halted in SETCOM -- see list file.'
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine elevi
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950630                  ELEVI
c                J. Scire, D. Strimaitis,  SRC
c
c --- PURPOSE:  Interpolate CALMET gridded terrain to array of
c               gridded receptors
c
c --- INPUTS:
c
c     Common block /GRID/ variables:
c           NXSAM, NYSAM, DGRID, IBSAMP, JBSAMP, DELSAM
c     Parameters:
c           MXNXG, MXNYG
c
c --- OUTPUT:
c
c     Common block /GRID/ variables:
c           ELEVG(mxnxg,mxmyg)
c
c --- ELEVI called by:  SETUP
c --- ELEVI calls:      GETELEV
c----------------------------------------------------------------------

      include 'params.puf'
      include 'grid.puf'

c --- Loop over grid receptors
      do i=1,nxsam
         do j=1,nysam
c ---       Locate the receptor (met. grid units)
            xrec = (float(ibsamp)-0.5)+float(i-1)*delsam/dgrid
            yrec = (float(jbsamp)-0.5)+float(j-1)*delsam/dgrid
c
c ---       Get elevation from the CALMET elevation array
            call getelev(xrec,yrec,zrterr)
            elevg(i,j)=zrterr
         enddo
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine sigty(sigy0,dxkm,dt,sigy,virty,virdy)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                  SIGTY
c                R. Yamartino, SRC
c                Modifications for V2.0 made by J. Scire
c                Modifications for V3.0 made by D. Strimaitis
c
c --- PURPOSE:  For a given dispersion option, IDOPT, and a given initial
c               lateral plume standard deviation, SIGY0, compute the plume
c               standard deviation for a given downwind distance or time
c               increment, consistent with the dispersion regime, and
c               return this value, SIGY (meters), for use as the puff's
c               or slug's lateral sigma.
c
c --- UPDATE
c --- V5.7-V5.721   040503  (DGS): add WARN to collect information on
c                                  the largest (most) negative
c                                  virtual time/distance;
c                                  reset very small negative virtual
c                                  time/distance to zero
c --- V5.4-V5.7     030402  (DGS): use local small variable to test for
c                                  non-zero sigy0
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c
c             SIGY0 - real    - Initial dispersion coefficient (m).
c              DXKM - real    - Incremental travel distance (km).
c                DT - real    - Incremental travel time (s).
c
c    Common block /CSIGMA/ variables:
c         TYIR, AYT, THFTY, SYH, AYPGT, BYPGT, AYPGTI, BYPGTI,
c         AYURB, XIYURB, AVEFAC, AVEFACI
c         IDOPTYS, IRUS, UAVGS, TSIGVS, KSTABS
c
c --- OUTPUTS:
c
c             SIGY  - real    - Lateral dispersion coefficient (m).
c             VIRTY - real    - Virtual travel time (total)  (s)
c             VIRDY - real    - Virtual travel distance (total) (km)
c
c ---   SIGTY called by:  AREAS1, AREAS2, LINES1, POINTS1, POINTS2,
c                         SETPUF, SETSLG, DWSIGS, SIGMA, HEFTRANS,
c                         PUFRECS, SLGRECS, PLGRECS, RECSPEC0, WARN
c ---   SIGTY calls:      XVY
c----------------------------------------------------------------------
c
c --- SUPPLEMENTAL NOTES:
c
c *** For IDOPTYS = 1,2
c     Dispersion determined by local turbulence (tsigvs,tsigws) and the
c     Irwin(1983) recommended forms of (fy,fz) of Draxler(1976):
c     fy = 1.0 / (1.0 + 0.9 * sqrt(tyidr * t) )
c                TYIDR  - real const - Reciprocal time scale (1/s) for
c                                      Draxler form of fy.
c
c *** For IDOPTYS = 3
c
c     Pasquill-Gifford-Turner(PGT) coeffs. for RURAL conditions
c     computed using the following ISC6-8 approximation formula:
c           th = 0.017453293*(c(istab)-d(istab)*alog(xkm))
c           sigy1 = 465.11628*xkm*tan(th)
c     local array C(6)  - real array - PGT Y coeffs. for each PGT class.
c     local array D(6)  - real array - PGT Y expons. for each PGT class.
c
c     Briggs urban coeffs. for each PGT class for URBAN conditions.
c     Computed exactly as in ISC6-8.
c             AYURB(6)  - real array - Urban Y coeffs. by PGT class.
c            XIYURB(6)  - real array - Reciprocal length scale (1/m)
c                                      for SIGY for each PGT class.
c
c     Heffter time dependent growth coeffs. are used for long ranges.
c                  AYT  - real const - Time dependent Y growth rate for
c                                      x > xtmdep for all PGT classes.
c                  SYH  - real const - Horizontal sigma(m) beyond which
c                                      time dependent growth assumed.
c                THFTY  - real       - Virtual travel time (s) associated
c                                      with SYH for current met; transition
c                                      to Heffter growth law.
c
c *** For IDOPTYS = 4.  Same as IDOPTYS=3, but for
c     Pasquill-Gifford-Turner(PGT) coeffs. for RURAL conditions, use
c     values of coeffs. and exponents from MESOPUFF II approximations.
c             AYPGT(6)  - real array - PGT Y coeffs. for each PGT class.
c             BYPGT(6)  - real array - PGT Y expons. for each PGT class.
c            AYPGTI(6)  - real array - Reciprocals of AYPGT(6).
c            BYPGTI(6)  - real array - Reciprocals of BYPGT(6).
c
c *** For IDOPTYS = 5
c     Dispersion determined by local turbulence (tsigvs) and the
c     CTDM form of (fy) for neutral/stable (IDOPTYS(1) otherwise):
c     fy = 1.0 / SQRT( 1.0 + u*t/20000.)
c
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'csigma.puf'
c
      real c(6),d(6)
c
c --- Declare variables to test negative virtuals
c --- (threshold for warning, threshold for HALT)
      real zerosec(2), zerokm(2)
c
c --- Include the ISC parameters for PGT (i.e.,rural) for SIGY.
      data c/24.1667,18.333,12.5,8.333,6.25,4.1667/
      data d/2.5334,1.8096,1.0857,0.72382,0.54287,0.36191/
c
      data crit/1.0e-4/,zero/0.0/
c
c --- Set values to test for negative virtuals that are treated as zero
c --- (threshold for warning, threshold for HALT)
      data zerosec/-.01,-1.0/, zerokm/-0.00001,-.001/

c --- Set a 'small' sigma (m) to test for sigy0=0.0
      data zerosig/0.001/
c
c --- Make sure travel time is positive.
      if(dt.lt.zero) then
        if(dt.ge.zerosec(1)) then
          dt=zero
        elseif(dt.ge.zerosec(2)) then
          call WARN('SIGTY-t     ',dt)
          dt=zero
        else
          write(io6,*)'ERROR in SUBR. SIGTY -- Incremental travel ',
     1    'time < 0 -- DT = ',dt
          write(*,*)
          stop 'Halted in SIGTY -- see list file.'
        endif
      endif
c
c --- Make sure downwind distance is positive.
      if(dxkm.lt.zero) then
        if(dxkm.ge.zerokm(1)) then
          dxkm=zero
        elseif(dxkm.ge.zerokm(2)) then
          call WARN('SIGTY-x     ',dxkm)
          dxkm=zero
        else
          write(io6,*)'ERROR in SUBR. SIGTY -- Incremental travel ',
     1    'distance < 0 -- DXKM = ',dxkm,' IDOPTY = ',idoptys,
     2    ' IRU = ',irus
          write(*,*)
          stop 'Halted in SIGTY -- see list file.'
        endif
      endif
c
c --- Make sure stability class is valid.
      istab=kstabs
      if(istab.lt.1 .or. istab.gt.6) then
         write(io6,*)'ERROR in SUBR. SIGTY -- Invalid value of ',
     1   'stability class -- ISTAB = ',istab,' IDOPTY = ',idoptys,
     2   ' IRU = ',irus
         write(*,*)
         stop 'Halted in SIGTY -- see list file.'
      endif
c
c --- For all values of IDOPTYS, use Heffter (1965) time-dependent
c --- equations at large virtual time (large SIGMA Y).  Include a
c --- time shift (t') to match curves at transition point.
      if(dt.GT.thfty .AND. sigy0.LT.zerosig) then
         tprime = syh/ayt - thfty
         sigy = ayt * (dt + tprime)
c ---    Assign virtuals
         virty = dt
         virdy = uavgs * virty * 0.001
         return
      elseif(sigy0.GT.syh) then
         tprime = syh/ayt - thfty
         t0 = sigy0/ayt - tprime
         t = t0 + dt
         sigy = ayt * (t + tprime)
c ---    Assign virtuals
         virty = t
         virdy = uavgs * virty * 0.001
         return
      endif
c
c --- Special treatment for IDOPTYS=5:  IDOPTYS=1 for Stabilities 1-3
      idopt5=5
      if(idoptys.eq.5 .and. istab.lt.4) idopt5=1
c
      if(idoptys.le.2 .or. idopt5.eq.1) then
c
c -------------------
c --- For IDOPTYS = 1,2
c -------------------
c        Compute dispersion coefficients using given TSIGVS.
c ---    Dispersion determined by local turbulence tsigvs and the
c        Irwin(1983) recommended form of fy of Draxler(1976):
c        fy = 1.0 / (1.0 + 0.9 * sqrt(tyidr * t) )  ,
c        where  TYIDR = Reciprocal time scale (1/s) for Draxler form of fy.
c
c ---    For all distances, compute the following.
c ---    Compute initial travel time, t0, based on SIGY0
         t0 = zero
         if(sigy0.gt.zerosig) then
            gama = sigy0 / tsigvs
c           beta = 0.5 * gama * ( 2.0   +   (0.9)**2 * gama * tyidr )
            beta = gama * (1.0 + 0.405*gama*tyidr)
            t0 = beta + sqrt(beta*beta - gama*gama)
         endif
c
c ---    Compute effective travel time, t
         t = t0 + dt

c ---    Assign virtuals
         virty = t
         virdy = uavgs * t * 0.001
c
c ---    Set sigma-y
         if(dt.GT.zero) then
c ---       Compute fy function using Draxler (1976)
            fy = 1.0 / ( 1.0  +  0.9 * sqrt(t * tyidr) )
            sigy = tsigvs * t * fy
         else
            sigy = sigy0
         endif
c
      elseif(idoptys.le.4) then
c
c ------------------
c --- IDOPTYS = 3 or 4
c ------------------
c
c --------------------------
c --- For IDOPTYS = 3 -- RURAL
c --------------------------
c --- Compute rural PGT sigma y (in m) using the ISC formulation, with
c --- an averaging time adjustment factor (AVEFAC).
         if(idoptys.eq.3 .and. irus.eq.0) then
c
            xpskm = zero
c ---       If initial sigma, sigy0, solve for pseudo distance, xpskm
            if(sigy0.gt.zerosig) then
c
c ---          Set initial guesses for travel distance x and convert to km.
c              x2=sigy0 / 0.01 assumes lateral turbulence intensity of 0.01
c              xkm2 = 0.001 * sigy0 * 100.
               xkm1 = 0.001 * sigy0
c
c ---          Improve xkm2 guess with the realistic MESOPUFF II estimate.
               xkm2 = 0.001*(sigy0*avefaci*aypgti(istab))**bypgti(istab)
c
c
c ---          compute the sigmas for the first guesses.
               th = 0.017453293*(c(istab)-d(istab)*alog(xkm1))
               sigy1 = avefac*465.11628*xkm1*tan(th)
c
               th = 0.017453293*(c(istab)-d(istab)*alog(xkm2))
               sigy2 = avefac*465.11628*xkm2*tan(th)
c
               niter = 0
c ---          iterate until the sigma is found to be within fractional
c              tolerance of crit.
c ---          new guess
   10          denx = xkm2 - xkm1
               if(denx .eq. 0.) then
                  xkm3 = xkm2
               else
                  fint = (sigy0-sigy1) / (sigy2-sigy1)
                  xkm3 = xkm1 + fint*denx
c ---          restrict rate of change of position estimate
                  step = xkm3 - xkm2
                  xstep = 0.85 * abs(denx)
                  if(abs(step) .gt. xstep) xkm3 = xkm2+sign(xstep,step)
               endif
c
               niter=niter+1
               if(niter.gt.50) then
                  write(*,*)
                  stop 'SIGTY: XPSKM failed to converge'
               endif
c ---          compute quantities now for the new guess.
               th = 0.017453293*(c(istab)-d(istab)*alog(xkm3))
               sigy3=avefac*465.11628*xkm3*tan(th)
c
c ---          compute the error in the solution.
               errsig = (sigy3-sigy0) / sigy0
c
c ---          quit if error criteria satisfied.
               if(abs(errsig) .lt. crit) go to 50
c
c ---          Always replace 1 with 2 and load new info(i.e.,3) into 2.
               xkm1 = xkm2
               sigy1 = sigy2
               xkm2 = xkm3
               sigy2 = sigy3
               go to 10
c
   50          xpskm = xkm3
c
            endif
c
c ---       Combine the actual and pseudo distances and compute sigy.
            xkm3 = xpskm + dxkm
            if(dxkm.GT.zero) then
               if(xkm3.gt.0.) then
                  th=0.017453293*(c(istab)-d(istab)*alog(xkm3))
                  sigy=avefac*465.11628*xkm3*tan(th)
               else
                  th=0.
                  sigy=0.
               endif
            else
               th=0.
               sigy=sigy0
            endif

c ---       Assign virtuals
            virdy = xkm3
            virty = xkm3 * 1000. / uavgs
c
         endif
c
c --------------------------
c --- For IDOPTYS = 4 -- RURAL
c --------------------------
c --- Compute rural PGT sigma y (in m) using MESOPUFF II formulation.
         if(idoptys.eq.4 .and. irus.eq.0) then
c
            xpsm = zero
c ---       If initial sigma, sigy0, solve for pseudo distance, xpsm
            if(sigy0.gt.zerosig) then
               xpsm = ( sigy0 *avefaci * aypgti(istab) )**bypgti(istab)
            endif
c
c ---       Combine the actual and pseudo distances and compute sigy.
            xm = xpsm + 1000.0 * dxkm
            if(dxkm.GT.zero) then
               sigy = avefac * aypgt(istab) * xm**bypgt(istab)
            else
               sigy = sigy0
            endif
c
c ---       Assign virtuals
            virdy = xm * 0.001
            virty = xm / uavgs
c
         endif
c
c -------------------------------
c --- For IDOPTYS = 3 or 4 -- URBAN
c -------------------------------
c --- Compute urban Briggs sigma y (in m) as in ISC.
         if(idoptys.ge.3 .and. irus.eq.1) then
c
            xpskm = zero
c ---       If initial sigma, sigy0, solve for pseudo distance, xpskm
            if(sigy0.gt.zerosig) xpskm = xvy(sigy0*avefaci,istab)
c
c ---       Combine the actual and pseudo distances and compute sigy.
            xm = 1000.0 * (xpskm + dxkm)
            if(dxkm.GT.zero) then
               sigy = avefac*ayurb(istab)*xm/sqrt( 1.0 +
     &                                             xiyurb(istab)*xm )
            else
               sigy = sigy0
            endif
c
c ---       Assign virtuals
            virdy = xm * 0.001
            virty = xm / uavgs
c
         endif
c
      elseif(idoptys.le.5) then
c
c ------------------------------------
c --- For IDOPTYS = 5 --- Stable/Neutral
c ------------------------------------
c        Dispersion determined by local turbulence (tsigvs) and the
c        CTDM form of (fy) for neutral/stable (IDOPTYS(1) otherwise):
c        fy = 1.0 / SQRT( 1.0 + u*t/20000.)
c
c ---    Compute reciprocal timescale using mean transport speed over
c ---    life of puff
         tyict = uavgs/20000.
c ---    Compute initial travel time, t0, based on SIGY0
         t0 = zero
         if(sigy0.gt.zerosig) then
            gamasq = (sigy0/tsigvs)**2
            beta = gamasq*tyict*0.5
            t0 = beta+SQRT(beta*beta+gamasq)
         endif
c ---    Compute effective travel time, t
         t = t0 + dt
c ---    Compute sigma
         if(dt.GT.zero) then
c ---       Compute fy function using CTDM form
            fy = 1.0 / SQRT( 1.0  +  t * tyict )
            sigy = tsigvs * t * fy
         else
            sigy = sigy0
         endif

c ---    Assign virtuals
         virty = t
         virdy = uavgs * t * 0.001
c
      endif
c
      return
      end
c ---------------------------------------------------------------------
      function xvy (sy0,kst)                                            isc36640
c ---------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900216                    XVY
c                R. Yamartino, SRC
c
c --- PURPOSE:  XVY calculates the virtual distance necessary to        isc36660
c               account for the initial crosswind dispersion.           isc36670
c               Based on Briggs urban dispersion coeffcients.           isc36680
c               Adapted directly from ISC6-8.
c
c
c --- INPUTS:
c
c               SY0 - real    - Initial dispersion coefficient (m).
c               KST - integer - PGT stability index (1-6)
c
c     COMMON /CSIGMA/ variables:
c     Briggs urban coeffs. for each PGT class for URBAN conditions.
c             AYURB(6)  - real array - Urban Y coeffs. by PGT class.
c            XIYURB(6)  - real array - Reciprocal length scale (1/m)
c                                      for SIGY for each PGT class.
c
c --- OUTPUTS:
c
c              XVY  - real    - Pseudo-distance (km).
c
c
c ---   XVY called by:  SIGTY
c ---   XVY calls:       none
c ---------------------------------------------------------------------
c                                                                       isc36650
      include 'csigma.puf'
c
      a2 = ayurb(kst)**2
      bsy0 = 0.5 * xiyurb(kst) * sy0
c
c *** Direct solution for urban dispersion                              isc36720
      xvy = sy0 * (bsy0 + sqrt(bsy0**2 + a2)) / a2                      isc36730
c
c --- Convert to kilometers                                             isc36750
      xvy = xvy * 0.001                                                 isc36760
      return                                                            isc36770
      end                                                               isc36780
c----------------------------------------------------------------------
      subroutine sigtz(sigz0,dxkm,dt,zht,sigz,virtz,virdz)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040503                  SIGTZ
c                R. Yamartino, SRC
c                Modifications for V3.0 made by D. Strimaitis
c
c --- PURPOSE:  For a given dispersion option, IDOPT, and a given initial
c               vertical plume standard deviation, SIGZ0, compute the plume
c               standard deviation for a given downwind distance or time
c               increment, consistent with the dispersion regime, and
c               return this value, SIGZ (meters), for use as the puff's
c               or slug's vertical sigma.
c
c --- UPDATE
c --- V5.7-V5.721   040503  (DGS): reset very small negative virtual
c                                  time/distance to zero
c --- V5.4-V5.7     030402  (DGS): use local small variable to test for
c                                  non-zero sigz0
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c
c --- INPUTS:
c
c             SIGZ0 - real    - Initial dispersion coefficient (m).
c              DXKM - real    - Incremental travel distance (km).
c                DT - real    - Incremental travel time (s).
c
c         For IDOPT = 5   also need:
c               ZHT - real    - Height of center of puff/slug
c
c    Common block /CSIGMA/ variables:
c     TZIDR,TZISDR,AZT,THFTZ,SZH,AZPGT,BZPGT,AZPGTI,BZPGTI,
c     AZURB,XIZURB,
c     IDOPTZS, IRUS, UAVGS, KSTABS, ELS, BVFS, MHFTSZS, TSIGWS
c
c --- OUTPUTS:
c
c             SIGZ  - real    - Vertical dispersion coefficient (m).
c             VIRTZ - real    - Virtual travel time (total)  (s)
c             VIRDZ - real    - Virtual travel distance (total)  (km)
c
c
c ---   SIGTZ called by:  AREAS1, AREAS2, LINES1, POINTS1, POINTS2,
c                         VOLS, SETPUF, SETSLG, DWSIGS,
c                         PUFRECS, SLGRECS, RECSPEC0
c ---   SIGTZ calls:      XVZ
c----------------------------------------------------------------------
c
c --- SUPPLEMENTAL NOTES:
c
c *** For IDOPTZS = 1,2
c     Dispersion determined by local turbulence (tsigvs,tsigws) and the
c     Irwin(1983) recommended forms of (fy,fz) of Draxler(1976):
c     fz = 1.0 / (1.0 + 0.9 * sqrt(tzidr * t) )         for L < 0
c     fz = 1.0 / (1.0 + 0.945 * (tzisdr * t)**0.806 )   for L > 0
c                TZIDR  - real const - Reciprocal time scale (1/s) for
c                                      Draxler form of fz for L < 0
c               TZISDR  - real const - Reciprocal time scale (1/s) for
c                                      Draxler stable form of fz (L > 0)
c
c *** For IDOPTZS = 3
c
c     Pasquill-Gifford-Turner(PGT) coeffs. for RURAL conditions
c     computed using the ISC6-8 multi-segment approximation formulae.
c
c
c *** For IDOPTZS = 3 and 4
c     Briggs urban coeffs. for each PGT class for URBAN conditions.
c     Computed exactly as in ISC6-8.
c             AZURB(6)  - real array - PGT Z coeffs. for each PGT class.
c            XIZURB(6)  - real array - Reciprocal length scale (1/m)
c                                      for SIGZ for each PGT class.
c
c     Heffter(1965) time dependent growth coeffs. for long range.
c               AZT(6)  - real array - Time dependent Z growth rates for
c                                      x > xtmdep for each PGT class.
c                                      each grid point
c                  SZH  - real const - Vertical sigma (m) beyond which
c                                      time dependent growth assumed.
c
c *** For IDOPTZS = 4.  Same as IDOPTZS=3, but for
c     Pasquill-Gifford-Turner(PGT) coeffs. for RURAL conditions, use
c     values of coeffs. and exponents from MESOPUFF II approximations.
c             AZPGT(6)  - real array - PGT Z coeffs. for each PGT class.
c             BZPGT(6)  - real array - PGT Z expons. for each PGT class.
c            AZPGTI(6)  - real array - Reciprocals of AZPGT(6).
c            BZPGTI(6)  - real array - Reciprocals of BZPGT(6).
c
c *** For IDOPTZS = 5
c     Dispersion determined by local turbulence (tsigws) and the
c     CTDM form of (fz) for neutral/stable (IDOPTZS(1) otherwise):
c     fz = 1.0 / SQRT( 1.0 + TSIGWS*t*[1./(.72*ZHT)+BVFS/(.54*TSIGWS)])
c
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'csigma.puf'
c
c
      data crit/1.0e-4/,zero/0.0/
c
c --- Set values to test for negative virtuals that are treated as zero
      data zerosec/-.01/, zerokm/-0.00001/

c --- Set a 'small' sigma (m) to test for sigz0=0.0
      data zerosig/0.001/
c
c     SIGMAX=5000. conforms with EPA use of the Urban curves.
c     See IDOPTZS > 3 and IRUS = 1 section of this routine.
      data sigmax/5000./
c
c --- Make sure travel time is positive.
      if(dt.lt.zero) then
        if(dt.ge.zerosec) then
          dt=zero
        else
          write(io6,*)'SR. SIGTZ: FATAL ERROR: dt = ',dt
          write(*,*)
          stop 'Halted in SIGTZ -- see list file.'
        endif
      endif
c
c --- Make sure downwind distance is positive.
      if(dxkm.lt.zero) then
        if(dxkm.ge.zerokm) then
          dxkm=zero
        else
          write(io6,*)'SR. SIGTZ: FATAL ERROR: dxkm = ',dxkm
          write(*,*)
          stop 'Halted in SIGTZ -- see list file.'
        endif
      endif
c
c --- Make sure stability class is valid.
      istab=kstabs
      if(istab.lt.1 .or. istab.gt.6) then
         write(io6,*)'SR. SIGTZ: FATAL ERROR: istab = ',istab
         write(*,*)
         stop 'Halted in SIGTZ -- see list file.'
      endif
c
c --- Special treatment for IDOPTZS=5:  IDOPTZS=1 for Stabilities 1-3
      idopt5=5
      if(idoptzs.eq.5 .and. istab.lt.4) idopt5=1
c
c --- For all values of IDOPTZS, use Heffter (1965) time-dependent
c --- equations at large virtual time (large SIGMA Z).  Include a
c --- time shift (t') to match curves at transition point.
      if(mhftszs.EQ.1) then
         if(dt.GT.thftz .AND. sigz0.LT.zerosig) then
            tprime = (szh/azt(istab))**2 - thftz
c ---       Compute sigma
            sigz = azt(istab) * SQRT(dt + tprime)
c ---       Assign virtuals
            virtz = dt
            virdz = uavgs * dt * 0.001
            return
         elseif(sigz0.GT.szh) then
            tprime = (szh/azt(istab))**2 - thftz
            t0 = (sigz0/azt(istab))**2 - tprime
            t = t0 + dt
c ---       Compute sigma
            sigz = azt(istab) * SQRT(t + tprime)
c ---       Assign virtuals
            virtz = t
            virdz = uavgs * t * 0.001
            return
         endif
      endif

      if(idoptzs.le.2 .or. idopt5.eq.1) then
c
c --------------------
c --- For IDOPTZS = 1,2
c --------------------
c        Dispersion determined by local turbulence (tsigvs,tsigws) and
c        Irwin(1983) recommended forms of (fy,fz) of Draxler(1976):
c        fz = 1.0 / (1.0 + 0.9 * sqrt(tzidr * t) )         for L < 0
c        fz = 1.0 / (1.0 + 0.945 * (tzisdr * t)**0.806 )   for L > 0
c                TZIDR  - real const - Reciprocal time scale (1/s) for
c                                      Draxler form of fz for L < 0
c               TZISDR  - real const - Reciprocal time scale (1/s) for
c                                      Draxler stable form of fz (L > 0)
c
c ---    For all distances, compute the following.
c ---    Compute initial travel time, t0, based on SIGZ0
         t0 = zero
         if(sigz0.gt.zerosig) then
            gama = sigz0 / tsigws
            if(els.le.zero) then
c              fz = 1.0 / (1.0 + 0.9 * sqrt(tzidr * t) )
c              beta = 0.5 * gama * ( 2.0   +   (0.9)**2 * gama * tzidr )
               beta = gama * (1.0 + 0.405*gama*tzidr)
               t0 = beta + sqrt(beta*beta - gama*gama)
            else
c              els > 0 and
c              fz = 1.0 / (1.0 + 0.945 * (tzisdr * t)**0.806 ) for L > 0
c
c ---          Use the log of gama for faster convergence.
               gamal = alog(gama)
c
c ---          Compute first guess using small t approx.
               t1 =  gama
               gm1 = t1 / (1.0 + 0.945 * (tzisdr * t1)**0.806 )
               gm1 = alog(gm1)
               t1l = alog(t1)
c
c ---          Compute second guess using large t approx. if
c ---          gamma is large enough to produce t2 > 2*t1
c ---          note: (.945/2**.194)**(-1/.806) = 1.2675
               tcrit = 1.2675/tzisdr
               if(t1.LE.tcrit) then
                  t2=2.0*t1
               else
                  t2 = (gama * 0.945 * tzisdr**0.806)**5.154639
               endif
c              t2 = amax1(t2,(100.0*t1))
               gm2 = t2 / (1.0 + 0.945 * (tzisdr * t2)**0.806 )
               gm2 = alog(gm2)
               t2l = alog(t2)
c
               niter = 0
c ---          Iterate until the sigma is found to be within fractional
c ---          tolerance of crit.
    5          niter=niter+1
c
c ---          Report failure if niter exceeds 50
               if(niter.gt.50) then
                  write(io6,*) 'SUBR. SIGTZ: T0 does not converge'
                  write(io6,*) 'sigz0, tsigws, els: ',sigz0,tsigws,els
                  write(io6,*) 'tzidr, tzisdr  : ',tzidr, tzisdr
                  write(io6,*) 't1,t2          : ',t1,t2
                  write(*,*)
                  stop 'Halted in SIGTZ -- see list file.'
               endif
c
c ---          New guess
               denx = t2l - t1l
               if(denx .eq. 0.) then
                  t3l = t2l
               else
                  fint = (gamal-gm1) / (gm2-gm1)
                  t3l = t1l + fint*denx
c ---             Restrict rate of change of position estimate
                  step = t3l - t2l
                  xstep = 0.85 * abs(denx)
                  if(abs(step) .gt. xstep) t3l = t2l + sign(xstep,step)
               endif
c
c ---          Compute quantities now for the new guess.
               t3 = exp(t3l)
               gm3 = t3 / (1.0 + 0.945 * (tzisdr * t3)**0.806 )
c
c ---          Compute the error and quit if error criteria satisfied.
               errsig = (gm3 - gama) / gama
               if(abs(errsig) .lt. crit) go to 10
c
c ---          Always replace 1 with 2 and load new info(i.e.,3) into 2.
               t1  = t2
               t1l = t2l
               gm1 = gm2
               t2  = t3
               t2l = t3l
               gm2 = alog(gm3)
               go to 5
c
   10          t0 = t3
            endif
         endif
c
c ---    Compute effective travel time, t
         t = t0 + dt
c
c ---    Compute sigma
         if(dt.GT.zero) then
c ---       Compute fz function using Draxler (1976)
            if(els.le.zero) fz = 1.0 / (1.0 + 0.9 * sqrt(tzidr * t) )
            if(els.gt.zero) fz = 1.0 / (1.0 + 0.945 * (tzisdr*t)**0.806)
            sigz = tsigws * t * fz
         else
            sigz = sigz0
         endif
c
c ---    Assign virtuals
         virtz = t
         virdz = t * uavgs * 0.001
c
      elseif(idoptzs.le.4) then
c
c -----------------------
c --- For IDOPTZS = 3 or 4
c -----------------------
c
c ---------------------------
c --- For IDOPTZS = 3 --- RURAL
c ---------------------------
c ---    Compute rural PGT sigma z (in m) using the ISC formulation.
         if(idoptzs.eq.3 .and. irus.eq.0) then
c
c ---       Define the number of sigma Z curve segments, NSEG.
            nseg = nzbrur(istab)
c
            xpskm = zero
c ---       If initial sigma, sigz0, solve for pseudo distance, xpskm
            if(sigz0.gt.zerosig) then
c
c ---          Find the correct region, denoted by the segment JSEG.
               jseg = 1
   15          if(sigz0.le.szbrur(jseg,istab)) go to 20
               jseg = jseg + 1
               if(jseg.lt.nseg) go to 15
c
   20          xpskm = ( sigz0*azruri(jseg,istab) )**bzruri(jseg,istab)
            endif
c
c ---       Combine the actual and pseudo distances and compute sigz.
            xkm = xpskm + dxkm
c
c ---       Compute sigma
            if(dxkm.GT.zero) then
c ---          Find the correct region, denoted by the segment JSEG.
               jseg = 1
   25          if(xkm.le.xzbrur(jseg,istab)) go to 30
               jseg = jseg + 1
               if(jseg.lt.nseg) go to 25
c
   30          sigz = azrur(jseg,istab) * xkm**bzrur(jseg,istab)
            else
               sigz = sigz0
            endif
c
c ---       Assign virtuals
            virdz = xkm
            virtz = xkm *1000. / uavgs
c
         endif
c
c ---------------------------
c --- For IDOPTZS = 4 --- RURAL
c ---------------------------
c ---    Compute rural PGT sigma z (in m) using MESOPUFF II formulation.
         if(idoptzs.eq.4 .and. irus.eq.0) then
c
            xpsm = zero
c ---       If initial sigma, sigz0, solve for pseudo distance, xpsm
            if(sigz0.gt.zerosig) then
               xpsm = ( sigz0 * azpgti(istab) )**bzpgti(istab)
            endif
c
c ---       Combine the actual and pseudo distances and compute sigz.
            xm = xpsm + 1000.0 * dxkm
            if(dxkm.GT.zero) then
               sigz = azpgt(istab) * xm**bzpgt(istab)
            else
               sigz = sigz0
            endif
c
c ---       Assign virtuals
            virdz = xm * 0.001
            virtz = xm / uavgs
c
         endif
c
c --------------------------------
c --- For IDOPTZS = 3 or 4 --- URBAN
c --------------------------------
c ---    Compute urban Briggs sigma z (in m) as in ISC.
         if(idoptzs.ge.3 .and. irus.eq.1) then
c
c ---       If initial sigma exceeds sigmax set sigz=sigz0 and return.
            if(sigz0.ge.sigmax) then
               sigz = sigz0
               return
            endif
c
            xpskm = zero
c ---       If initial sigma, sigz0, solve for pseudo distance, xpskm
            if(sigz0.gt.zerosig) xpskm = xvz(sigz0,istab)
c
c ---       Combine the actual and pseudo distances and compute sigz.
            xm = 1000.0 * (xpskm + dxkm)
            if(dxkm.GT.zero) then
               sigz = azurb(istab) * xm
               if(istab.le.2) sigz = sigz * sqrt(1.0+xizurb(istab)*xm)
               if(istab.ge.4) sigz = sigz / sqrt(1.0+xizurb(istab)*xm)
               if(sigz .gt. sigmax) sigz = sigmax
            else
               sigz = sigz0
            endif
c
c ---       Assign virtuals
            virdz = xm * 0.001
            virtz = xm / uavgs
c
         endif
c
      elseif(idoptzs.le.5) then
c
c ------------------------------------
c --- For IDOPTZS = 5 --- Stable/Neutral
c ------------------------------------
c        Dispersion determined by local turbulence (tsigws) and the
c        CTDM form of (fz) for neutral/stable (IDOPTZS(1) otherwise):
c        fz = 1.0/SQRT(1.0 +t*TSIGWS*[1./(.72*ZHT)+BVFS/(.54*TSIGWS)])
c        fz = 1.0 / SQRT( 1.0 + t*TZICT)
c
c ---    Do not allow neutral scale to blow up! (set min zht=1 m)
         zz=AMAX1(zht,1.0)
c ---    Compute reciprocal timescale (1/s)
         tzict = tsigws/(.72*zz) + bvfs*1.851852
c ---    Compute initial travel time, t0, based on SIGZ0
         t0 = zero
         if(sigz0.gt.zerosig) then
            gamasq = (sigz0/tsigws)**2
            beta = gamasq*tzict*0.5
            t0 = beta+SQRT(beta*beta+gamasq)
         endif
c ---    Compute effective travel time, t
         t = dt + t0
c ---    Compute sigma
         if(dt.GT.zero) then
c ---       Compute fz function using CTDM form
            fz = 1.0 / SQRT( 1.0  +  t * tzict )
            sigz = tsigws * t * fz
         else
            sigz = sigz0
         endif
c
c ---    Assign Virtuals
         virtz = t
         virdz = t * uavgs * 0.001
c
      endif
c
      return
      end
c ---------------------------------------------------------------------
      function xvz (sz0,kst)                                            isc36640
c ---------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900216                    XVZ
c                R. Yamartino, SRC
c
c --- PURPOSE:  XVZ calculates the virtual distance necessary to        isc36660
c               account for the initial vertical dispersion.            isc36670
c               Based on Briggs urban dispersion coeffcients.           isc36680
c               Adapted directly from ISC6-8.
c
c
c --- INPUTS:
c
c               SZ0 - real    - Initial dispersion coefficient (m).
c               KST - integer - PGT stability index (1-6).
c
c     COMMON /CSIGMA/ variables:
c     Briggs urban coeffs. for each PGT class for URBAN conditions.
c             AZURB(6)  - real array - Urban Y coeffs. by PGT class.
c            XIZURB(6)  - real array - Reciprocal length scale (1/m)
c                                      for SIGZ for each PGT class.
c
c --- OUTPUTS:
c
c              XVZ  - real    - Pseudo-distance (km).
c
c
c ---   XVZ called by:  SIGTZ
c ---   XVZ calls:       none
c ---------------------------------------------------------------------
c                                                                       isc36650
      include 'csigma.puf'
c
c     dimension c(6),d(6)                                               isc36850
c     data c /1.e06,1.e06,.20,.14,.08,.08/                              isc36860
c     data d /1.e09,1.e09,0.,.0003,.0015,.0015/                         isc36870
      data third/0.3333333/
c
c --- Use above info to override values in /CSIGMA/
      c = azurb(kst)
      d = xizurb(kst)
      if(kst.le.2) then
         c = 1.0e06
         d = 1.0e09
         endif
      if(kst.eq.3) d = 0.0
c
c
c     Direct solution for urban dispersion                              isc36880
170   go to (180,180,190,200,200,200), kst                              isc36890
c     Solution to the cubic equation                                    isc36900
c     from CRC mathematical tables                                      isc36910
c     stability a&b (180)                                               isc36920
c
  180 a=-c * third
      b=(2./27.-(sz0/240.)**2) * d
      s=0.25*b**2 + a**3/27.
      if(s .lt. 0.) go to 185                                           isc36960
      s=sqrt(s)                                                         isc36970
c     e=1./3.                                                           isc36980
      if ((-b/2.+s) .lt. 0.0) go to 185                                 xxx36985
c     ba=(-b/2.+s)**e                                                   isc36990
      ba=(-b/2.+s)**third
c     bb=(-b/2.-s)**e                                                   isc37000
      bb=(-b/2.-s)**third
      y=ba+bb                                                           isc37010
182   xvz=y-1000. * third
      xvz=xvz * 0.001
      return                                                            isc37040
c 185 cs=(sz0/240.)**2*27./2.-1.                                        isc37050
  185 cs=13.5 * (sz0/240.)**2. - 1.
      th=acos(cs) * third
      y=2.* third * cos(th) * 1000.
      go to 182                                                         isc37080
c     stability c(190)                                                  isc37090
190   xvz=sz0/c                                                         isc37100
      xvz=xvz * 0.001
      return                                                            isc37120
c     stability d,e,&f (200)                                            isc37130
200   xvz=sz0 * (d*sz0 + sqrt( (d*sz0)**2 + 4.*c**2 ) ) / (2.*c**2)
      xvz=xvz * 0.001
      return                                                            isc37170
      end                                                               isc37180
c ---------------------------------------------------------------------
      function xvz2(sz0,kst)                                            isc36640
c ---------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040503                    XVZ
c                R. Yamartino, SRC
c
c --- PURPOSE:  XVZ calculates the virtual distance necessary to        isc36660
c               account for the initial vertical dispersion.            isc36670
c               Based on Briggs urban dispersion coeffcients.           isc36680
c               Adapted directly from ISC6-8.
c
c --- UPDATE
c --- V5.72-V5.721  040503  (DGS): recast algebraic solution to improve
c                                  single precision accuracy
c
c --- INPUTS:
c
c               SZ0 - real    - Initial dispersion coefficient (m).
c               KST - integer - PGT stability index (1-6).
c
c     COMMON /CSIGMA/ variables:
c     Briggs urban coeffs. for each PGT class for URBAN conditions.
c             AZURB(6)  - real array - Urban Y coeffs. by PGT class.
c            XIZURB(6)  - real array - Reciprocal length scale (1/m)
c                                      for SIGZ for each PGT class.
c
c --- OUTPUTS:
c
c              XVZ  - real    - Pseudo-distance (km).
c
c
c ---   XVZ called by:  SIGTZ
c ---   XVZ calls:       none
c ---------------------------------------------------------------------
c                                                                       isc36650
c    include 'csigma.puf'
c
      dimension azurb(6),xizurb(6)                                               isc36850
      data azurb/1.e06,1.e06,.20,.14,.08,.08/                              isc36860
      data xizurb/1.e09,1.e09,0.,.0003,.0015,.0015/                         isc36870
      data third/0.3333333/
c
c --- Use above info to override values in /CSIGMA/
      c = azurb(kst)
      d = xizurb(kst)
      if(kst.le.2) then
         c = 1.0e06
         d = 1.0e09
         endif
      if(kst.eq.3) d = 0.0
c
c
c     Direct solution for urban dispersion                              isc36880
170   go to (180,180,190,200,200,200), kst                              isc36890
c     Solution to the cubic equation                                    isc36900
c     from CRC mathematical tables                                      isc36910
c     stability a&b (180)                                               isc36920
c

c --- Solve for xvz in KM rather than M, using y**2=x+1
c --- substitution  (DGS)

  180 a=-1.0
      bby2=-sz0/(2.0*240.)
c --- s2=bby2**2 + a**3/27.
      s2=bby2**2 - 1.0/27.

      s=sqrt(ABS(s2))
      a3=-bby2+s
      b3=-bby2-s

      if(s2 .lt. 0.) go to 185                                          isc36960
      if (a3 .lt. 0.0) go to 185

      ba=a3**third
      bb=b3**third
      y=ba+bb                                                           isc37010
182   xvz2=y*y-1.0
      return                                                            isc37040
c --- cs=-(b/2)/SQRT(-a^3/27)
185   cs=-bby2*SQRT(27.)
      th=acos(cs) * third
c --- y=2.* SQRT(-a/3) * cos(th)
      y=2.* SQRT(third) * cos(th)
      go to 182                                                         isc37080

c     stability c(190)                                                  isc37090
190   xvz=sz0/c                                                         isc37100
      xvz2=xvz * 0.001
      return                                                            isc37120
c     stability d,e,&f (200)                                            isc37130
200   xvz=sz0 * (d*sz0 + sqrt( (d*sz0)**2 + 4.*c**2 ) ) / (2.*c**2)
      xvz2=xvz * 0.001
      return                                                            isc37170
      end                                                               isc37180
c-----------------------------------------------------------------------
      subroutine turbset(ldbhr,ustr,el,wstr,jdstab,dpbl,z0m,htmet,uatzi,
     &                   ws,wd,ix0,iy0,ilw,
     &                   tsigv,tsigw,idopty,idoptz)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 060309                 TURBSET
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Determines turbulence velocities and associated
c               dispersion options (backup if needed)
c
c --- UPDATE
c --- V5.751-V6.11  060309  (DGS): Add overwater SVMIN,SWMIN (ILW arg.)
c --- V5.75-V5.751  050805  (DGS): Add option to modify turbulence due
c                                  to advection-decay mechanism
c                                  (test implementation)
c --- V5.3-V5.75    050225  (DGS): Add AERMOD turbulence profiles, new
c                                  argument UATZI, and Zi(mech) estimate
c --- V5.0-V5.3     991222a (DGS): Do not extract sigw data from profile
c                                  when MTURBVW=1 or 4
c --- V5.0-V5.0     980722  (DGS): SVMIN & SWMIN by stability class
c --- V4.0-V5.0     971107  (DGS): skip call to XTPRF for nzprf=0
c
c --- INPUTS:
c         LDBHR - logical - Debug output (T,F)
c          USTR - real    - Friction velocity (m/s)
c            EL - real    - Monin-Obukhov length (m)
c          WSTR - real    - Convective velocity scale (m/s)
c        JDSTAB - integer - Stability class for puff
c          DPBL - real    - Depth of planetary boundary layer (current
c                           mixing height, m)
c           Z0M - real    - Roughness length (m)
c         HTMET - real    - Height for evaluating turbulence (m)
c         UATZI - real    - Wind speed at mixing layer top (m/s)
c            WS - real    - Wind speed at puff center (m/s)
c            WD - real    - Wind direction at puff center (deg)
c           IX0 - integer - Cell x-index for current turbulence
c           IY0 - integer - Cell y-index for current turbulence
c           ILW - integer - Current cell is land (1) or water (2)
c
c --- Parameters: IO6, MXPRFZ
c     Common block /COMPARM/ variables:
c            XMINZI, XMAXZI,SVMIN(6,2), SWMIN(6,2)
c     Common block /FLAGS/ variables:
c            MDISP, MDISP2, MTURBVW, MCTURB, MTAUADV
c     Common block /GRID/ variables:
c            NX, NY, DGRIDI
c     Common block /METHR/ variables:
c            NZPRF, SVPRF(mxprfz), SWPRF(mxprfz), ZPRF(mxprfz), PTG(2)
c            HTMIX(mxnx,mxny), XMONIN(mxnx,mxny),
c            USTAR(mxnx,mxny),WSTAR(mxnx,mxny)
c     Common block /METHD/ variables:
c            Z0(mxnx,mxny)
c
c --- OUTPUT:
c         TSIGV - real    - Sigma-v (m/s)
c         TSIGW - real    - Sigma-w (m/s)
c        IDOPTY - integer - Current dispersion option for sigma-y
c        IDOPTZ - integer - Current dispersion option for sigma-z
c
c --- TURBSET called by: COMP, RLSMET
c --- TURBSET calls:     SIGWV, XTPRF, AERSWV
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'comparm.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
c
      logical ldbhr,lproblm
      data deg2rad/0.0174533/

c --- Fix generic inverse coriolis parameter 1/f = 10000 for estimating
c --- mechanical BL height
      data finv/10000./
c
c --- Initialize
      tsigw=-999.
      tsigv=-999.
      idopty=mdisp
      idoptz=mdisp
c
c --- Reset turbulence velocities to calculated values for MDISP=2
      if(mdisp.EQ.2 .OR. mdisp2.EQ.2) then
         if(mcturb.EQ.1) then
            call SIGWV(io6,ldbhr,ustr,el,wstr,dpbl,htmet,tsigw,tsigv)
         elseif(mcturb.EQ.2) then
            ziconv=dpbl
            zimech=0.3*ustr*finv
            zimech=AMIN1(zimech,dpbl)
            call AERSWV(io6,ldbhr,ustr,el,wstr,dpbl,ziconv,zimech,
     &                  uatzi,htmet,tsigw,tsigv)
         else
            stop 'TURBSET:  invalid MCTURB (must be 1,2)'
         endif
c ---    Modify turbulence velocities for advection
         if(mtauadv.GT.10) then
            vvar=tsigv**2
            wvar=tsigw**2
            vmod=0.0
            wmod=0.0
            x0=ix0-0.5
            y0=iy0-0.5
            wdrad=deg2rad*wd
c ---       Set upwind range from center of current cell
            tmax=FLOAT(mtauadv)/0.7
            dmax=tmax*ws*dgridi
c ---       Resolve to 10 steps per cell
            n=10*NINT(dmax)+1
            dr=dmax/n
            dx=dr*sin(wdrad)
            dy=dr*cos(wdrad)
            ix=ix0
            iy=iy0
            do k=1,n
               x=x0+k*dx
               y=y0+k*dy
               i=x+1
               i=MAX(1,i)
               i=MIN(nx,i)
               j=y+1
               j=MAX(1,j)
               j=MIN(ny,j)
               if(i.NE.ix .OR. j.NE.iy) then
c ---             Crossed into new cell
                  ix=i
                  iy=j
c ---             Decay factor
                  factor=AMAX1(0.,1.-FLOAT(k)/FLOAT(n))
c ---             Cell properties
                  dpbla=AMAX1(htmix(ix,iy),xminzi)
                  dpbla=AMIN1(dpbla,xmaxzi)
                  ela=xmonin(ix,iy)
                  ustra=ustar(ix,iy)
                  wstra=wstar(ix,iy)
                  z0ma=z0(ix,iy)
c ---             Turbulence velocities
                  if(mcturb.EQ.1) then
                     call SIGWV(io6,ldbhr,ustra,ela,wstra,dpbla,
     &                          htmet,tsigwa,tsigva)
                  else
                     ziconv=dpbla
                     zimech=0.3*ustra*finv
                     zimech=AMIN1(zimech,dpbla)
                     call AERSWV(io6,ldbhr,ustra,ela,wstra,dpbla,
     &                           ziconv,zimech,uatzi,htmet,
     &                           tsigwa,tsigva)
                  endif
c ---             Keep largest increase in turbulence
                  if(tsigva.GT.tsigv) then
                     test=factor*(tsigva**2-vvar)
                     vmod=AMAX1(vmod,test)
                  endif
                  if(tsigwa.GT.tsigw) then
                     test=factor*(tsigwa**2-wvar)
                     wmod=AMAX1(wmod,test)
                  endif
               endif
            enddo
c ---       Compute modified turbulence
            if(vmod.GT.0.) tsigv=SQRT(vvar+vmod)
            if(wmod.GT.0.) tsigw=SQRT(wvar+wmod)

            if(ldbhr) then
               tv0=SQRT(vvar)
               tw0=SQRT(wvar)
               write(io6,*) 
               write(io6,*) 'TURBSET:  IX,IY = ',ix0,iy0
               write(io6,*) '  original sigv,sigw = ',tv0,tw0
               write(io6,*) '  modified sigv,sigw = ',tsigv,tsigw
            endif


         endif
      endif

c --- Set turbulence velocities from measured profiles for MDISP=1,5
      if(mdisp.EQ.1 .OR. mdisp.EQ.5) then
         sigw=-999.
         sigv=-999.
         if(nzprf.GT.0) then
            if(mturbvw.EQ.2 .OR. mturbvw.EQ.3) then
c ---          Use measured sigma-w data
               lproblm=.FALSE.
               call XTPRF(nzprf,swprf,zprf,htmet,'sig',z0m,el,dpbl,
     &                    jdstab,ptg,sigw,lproblm)
               if(lproblm) sigw=-999.
            endif
            if(mturbvw.NE.2) then
c ---          Use measured sigma-v data
               lproblm=.FALSE.
               call XTPRF(nzprf,svprf,zprf,htmet,'sig',z0m,el,dpbl,
     &                    jdstab,ptg,sigv,lproblm)
               if(lproblm) sigv=-999.
            endif
         endif
c ---    Use measured turbulence if good, or use backup dispersion
         if(sigw.GE.0.0) then
            tsigw=sigw
         else
            idoptz=mdisp2
         endif
         if(sigv.GE.0.0) then
            tsigv=sigv
         else
            idopty=mdisp2
         endif
      endif
c --- Impose lower limit on turbulence (-999. does not survive!)
      tsigv=AMAX1(tsigv,svmin(jdstab,ilw))
      tsigw=AMAX1(tsigw,swmin(jdstab,ilw))
c
      return
      end

c----------------------------------------------------------------------
      subroutine sigwv(io6,ldbhr,ustar,xl,wstar,zi,z,sigw,sigv)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950630                  SIGWV
c
c     ADAPTED from:
c --- URBDEP   Version 1.2   Level 870113  SIGWV by J. Scire, SRC
c
c --- PURPOSE:  For dispersion option IDOPT=2 compute the
c               standard deviation of vertical velocity (sigw) and the
c               horizontal crosswind velocity (sigv) based on
c               micrometeorological parameters.
c
c --- INPUTS:
c
c               IO6 - integer - Unit number for list file
c             LDBHR - logical - Debug output (T,F)
c             USTAR - real    - Friction velocity (m/s)
c             WSTAR - real    - Convective velocity scale (m/s)
c                XL - real    - Monin-Obukhov length (m)
c                ZI - real    - Mixing height (m)
c                 Z - real    - Plume height (m)
c
c --- OUTPUTS:
c
c              SIGW - real    - Standard deviation of vertical
c                               velocity (m/s)
c              SIGV - real    - Standard deviation of horizontal
c                               crosswind velocity (m/s)
c
c --- SIGWV called by:  TURBSET
c --- SIGWV calls:      none
c
c----------------------------------------------------------------------
c
      logical ldbhr
      data xlmn/1.e-2/
c
      sigv=0.0
      sigw=0.0
c
      zdh=z/zi
      if(zdh.le.1.2) then
c ---    Within MIXED/ENTRAINMENT layer, non-zero turbulence
c
         if(xl.gt.0.0) then
c ---       STABLE --> NEUTRAL section
c ---       (minimum Monin-Obukhov length to prevent numerical problems)
            zdl=z/amax1(xl,xlmn)
            zdh2=amin1(zdh,1.0)
            cs=(1.-zdh2)**0.75
            an=exp(-0.9*zdh)
c ---       Stable-neutral sigma w,v in surface layer
            t4i=1.0/(1.+zdl)
            sigw=1.3*ustar*(cs*zdl+an)*t4i
            sigv=ustar*(1.6*cs*zdl+1.8*an)*t4i
c
         else
c ---       UNSTABLE --> NEUTRAL section
            an2=(exp(-0.9*zdh))**2
c
            if(zdh.ge.0.8) then
c ---          Unstable-neutral sigma w,v in entrainment layer
c                                   (0.8 zi <= z <= 1.2 zi)
               if(zdh.lt.1.0)then
c ---             0.8 to 1.0 zi
                  ac12=(0.5+(zi-z)/(0.4*zi))**2
               else
c ---             1.0 to 1.2 zi
                  ac12=(0.3333333+(1.2*zi-z)/(1.2*zi))**2
               endif
               t1=ustar*ustar*an2
               t2=wstar*wstar
               sigw=sqrt(1.15*t1+0.35*t2*ac12)
               sigv=sqrt(4.0*t1+0.35*t2)
c
            elseif(zdh.ge.0.1) then
c ---          Unstable-neutral sigma w,v in mixed layer
c                                   (0.1 zi <= z <= 0.8 zi)
               t1=ustar*ustar*an2
               t3=0.35*wstar*wstar
               sigw=sqrt(1.15*t1+t3)
               sigv=sqrt(4.0*t1+t3)
c
            else
c ---          Unstable-neutral sigma w,v in surface layer
c                                   (0.0 zi <= z <= 0.1 zi)
c ---          (minimum M-O length to prevent numerical problems)
c ---          (Monin-Obukhov length is negative -- ensure z/xl < 0.0)
               zdl=-z/amax1(abs(xl),xlmn)
               sigw=ustar*sqrt(1.6*an2+2.9*(-zdl)**0.6666667)
               sigv=sqrt(4.0*ustar*ustar*an2+0.35*wstar*wstar)
c
            endif
         endif
c
      endif
c --- (above 1.2*zi, return zero turbulence)
c
      if(LDBHR) then
         write(io6,*)'SIGWV:  (MDISP = 2)'
         write(io6,*)'      el,ustar,wstar= ',xl,ustar,wstar
         write(io6,*)'      z,zi          = ',z,zi
         write(io6,*)'      sigv,sigw     = ',sigv,sigw
         write(io6,*)'      (before minimum values imposed)'
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine sigset
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                 SIGSET
c                R. Yamartino, J. Scire, SRC
c
c --- PURPOSE:  Computes several /CSIGMA/ common block variables during
c               the setup phase.
c
c --- UPDATES
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.1-V5.2     991104  (JSS): Error messages written to list
c                                  file as well as to screen
c --- V5.0-V5.1     990625b (DGS): PGTIME is from control file
c                   990625b (DGS): Move tests on AVET and PGTIME to
c                                  QAINP
c
c --- INPUTS:
c
c     Common Block /CSIGMA/ variables used:
c             AYPGT - real arr- PGT Y coeffs. for each PGT class.
c             BYPGT - real arr- PGT Y expons. for each PGT class.
c             AZPGT - real arr- PGT Z coeffs. for each PGT class.
c             BZPGT - real arr- PGT Z expons. for each PGT class.
c            NZBRUR - int. arr- Number segments per PGT class.
c            XZBRUR - real arr- Junction x's (km) per PGT class.
c             AZRUR - real arr- PGT Z coeffs. for each PGT class.
c             BZRUR - real arr- PGT Z expons. for each PGT class.
c     Common block /DISPDAT/ variables:
c          SYTDEP, AVET, PGTIME
c     Common block /PARAMS/ parameters:
c          IO6, MMODEL
c
c --- OUTPUTS:
c     Common block /CSIGMA/ variables:
c          SYH, AVEFAC, AVEFACI
c
c     Common Block /CSIGMA/ variables defined:
c            AYPGTI - real arr- Reciprocals of AYPGT(6).
c            BYPGTI - real arr- Reciprocals of BYPGT(6).
c            AZPGTI - real arr- Reciprocals of AZPGT(6).
c            BZPGTI - real arr- Reciprocals of BZPGT(6).
c       AZRURI(10,6)- real arr- Reciprocals of BZRUR(10,6).
c       BZRURI(10,6)- real arr- Reciprocals of BZRUR(10,6).
c       XZBRUR(10,6)- real arr- Junction x's (km) per PGT class.
c       SZBRUR(10,6)- real arr- Junction sigmas per PGT class.
c
c
c ---   SIGSET called by:  SETUP
c ---   SIGSET calls:       none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'csigma.puf'
      include 'dispdat.puf'
      include 'flags.puf'
      include 'methd.puf'
c
c --- Assign averaging time adjustment factor for PG sigma-y,
c --- based on the averaging time "avet" (minutes)
      avefac=(avet/pgtime)**0.2
      avefaci=1./avefac
c
c --- Adjust PG coefficients for roughness (if option selected)
c --- (Adapted in part from AUSPLUME subroutine Z0FIX)
      if(mrough.EQ.1) then
c ---    Use roughness length from cell (1,1) because this option is
c ---    used with PLMMET.DAT, which does not have gridded fields
         if(z0(1,1).LE.0.0) then
            write(io6,*)'Valid roughness (z0) not found in SIGSET',
     1       z0(1,1)
            write(*,*)
            stop 'Halted in SIGSET -- see list file.'
         endif
         power=0.0777+.0215*alog(z0(1,1))
         fackm=1.585*z0(1,1)**0.1301
         facm=fackm*(1000.**power)
c ---    Adjust the MESOPUFF rural coefficients (x in meters)
         do i=1,6
            azpgt(i)=azpgt(i)*facm
            bzpgt(i)=bzpgt(i)-power
         enddo
c ---    Adjust the ISCST rural coefficients (x in kilometers)
         do i=1,6
            jmax = nzbrur(i)
            do j=1,jmax
               azrur(j,i)=azrur(j,i)*fackm
               bzrur(j,i)=bzrur(j,i)-power
            enddo
         enddo
c ---    Fold roughness adjustment into averaging time factor for
c ---    PG sigma-y
         avefac=avefac*(z0(1,1)/.03)**0.2
         avefaci=1./avefac
      endif

c --- Compute all the reciprocals.
      do 10 i=1,6
      aypgti(i) = 1.0 / aypgt(i)
      bypgti(i) = 1.0 / bypgt(i)
      azpgti(i) = 1.0 / azpgt(i)
      bzpgti(i) = 1.0 / bzpgt(i)
c
      jmax = nzbrur(i)
      do 5 j=1,jmax
      azruri(j,i) = 1.0 / azrur(j,i)
      bzruri(j,i) = 1.0 / bzrur(j,i)
    5 continue
c
   10 continue
c
c --- Re-compute the sigma z  X-transition values
c     and the sigma Z values at these X values.
      do 20 i=1,6
      jmax = nzbrur(i) - 1
      if(jmax.eq.0) go to 20
c
      do 15 j=1,jmax
      jp1 = j+1
      arat = azrur(j,i) / azrur(jp1,i)
      bdiff = bzrur(jp1,i) - bzrur(j,i)
      xcut = 1.0e20
      if(bdiff.gt.0.0) xcut = arat**(1.0/bdiff)
      if(bdiff.lt.0.0) xcut = (1.0 / arat)**(-1.0/bdiff)
c     write(6,*) 'i,j,arat,bdiff,xcut = ',i,j,arat,bdiff,xcut
      xzbrur(j,i) = xcut
      szbrur(j,i) = azrur(j,i) * xcut**bzrur(j,i)
   15 continue
c
   20 continue
c
c --- Sigma-y at which Heffter growth begins can cause numerical
c --- problems if set too large: reset large values here
c --- Set largest value of SYTDEP(m) that is consistent with the final
c --- AVEFAC just computed, and with the largest value of sigma-y
c --- that can be computed for PG(rural) stability class F using
c --- the standard curves.  (syhmax=avefac*100000. to nearest 1000 m)
      imax=avefac*100.
      syhmax=imax*1000.
      if(sytdep.GT.syhmax) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  Sigma-y at Heffter transition is    --'
         write(io6,*)'--  too large.  SYTDEP has been RESET!  --'
         write(io6,*)'    Old Value (m): ',sytdep
         write(io6,*)'    New Value (m): ',syhmax
         write(io6,*)'------------------------------------------'
         write(io6,*)
         sytdep=syhmax
      endif
c --- Transfer SYTDEP from /DISPDAT/ to /CSIGMA/ as SYH
      syh = sytdep

      return
      end
c----------------------------------------------------------------------
      subroutine setcsig(idopty,idoptz,iru,uavg,kst,el,bvf,
     &                   tsigv,tsigw,symin,szmin,
     &                   zht,zmix)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050225                SETCSIG
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Set selected parameters for calls to sigma routines,
c               and place in /CSIGMA/
c
c --- UPDATES
c --- V5.7-V5.75    050225  (DGS): Add TAULY call for computing the
c                                  Lagrangian time scale for lateral
c                                  growth for Draxler Fy;
c                                  Pull MHFTSZ, MTAULY from /FLAGS/
c --- V5.4-V5.7     030402  (DGS): add virtual time for Heffter
c                                  transition for SIGMA-Y
c
c --- INPUTS:
c     IDOPTY - integer   - Dispersion method option for SIGY **
c     IDOPTZ - integer   - Dispersion method option for SIGZ **
c                          **  computed from:
c                               1,2 = SIGMA V,W
c                                 3 = PG curves (rural), MP (urban)
c                                 4 = MESOPUFF II curves (rural),
c                                     MP (urban)
c                                 5 = CTDM (neutral/stable),
c                                     IDOPT(1) (other)
c                               (All IDOPT - use Heffter eqns. for
c                                long travel times)
c        IRU - integer   - Rural cell indicator (rural=0 ; urban=1)
c       UAVG - real      - Mean transport speed (m/s)
c        KST - integer   - PGT stability class at puff
c         EL - real      - Current Monin-Obukhov length (m)
c        BVF - real      - Current Brunt-Vaisala freq (1/s)
c      TSIGV - real      - Current sigma-v velocity (m/s)
c      TSIGW - real      - Current sigma-w velocity (m/s)
c      SYMIN - real      - Minimum value of sigma-y (m)
c      SZMIN - real      - Minimum value of sigma-z (m)
c        ZHT - real      - Height above ground for TAULY (m)
c       ZMIX - real      - Mixing height for TAULY (m)
c
c       Common block /CSIGMA/ variables:
c             syh
c       Common block /FLAGS/ variables:
c             MHFTSZ - integer   - Flag indicating use of Heffter growth
c                                  for z
c                              (0: NO Heffter   1: Heffter)
c             MTAULY - integer   - Flag for calling TAULY subroutine
c                              (1: call TAULY   not 1: no call)
c
c
c --- OUTPUT:
c       Common block /CSIGMA/ variables:
c             idoptys,idoptzs,irus,uavgs,kstabs,els,bvfs,mhftszs,
c             tsigys,tsigzs,symins,szmins,thfty,
c             tyidr
c
c --- SETCSIG called by:  CALCSL, SLGRECS, PLGRECS, PUFRECS,
c                         POINTS1, LINES1, POINTS2, LINES2,
c                         SETPUF, SETSLG
c --- SETCSIG calls:      SIGTY, TAULY
c
c----------------------------------------------------------------------
c
c --- Include common blocks
      include 'csigma.puf'
      include 'flags.puf'

      logical ldb
      data zero/0.0/

c --- Set debug for TAULY
      ldb=.FALSE.
c      ldb=.TRUE.

c --- Assign input variables to names in /CSIGMA/
      idoptys=idopty
      idoptzs=idoptz
      irus   =iru
      uavgs  =uavg
      kstabs =kst
      els    =el
      bvfs   =bvf
      mhftszs=mhftsz
      tsigvs =tsigv
      tsigws =tsigw
      symins =symin
      szmins =szmin

c --- Condition stability class to 1-6
      if(kstabs.GT.6) kstabs=6

c --- Compute lateral time scale
      if(mtauly.EQ.1) then
         call TAULY(ldb,tsigv,tsigw,el,zmix,zht,tau)
         tyidr=1./(1.62*tau)
      endif

c --- Calculate virtuals at Heffter transition
c --- Process sigma-y; if vertical distribution is Gaussian and Heffter
c --- is used, sigma-z must be treated in call to HEFTRAN
      szh=syh
      call SIGTY(syh,zero,zero,dum,thfty,dhfty)

      return
      end
c----------------------------------------------------------------------
      subroutine heftran(meth,zht,sy,sz,tvz1,tvz2,tvy1,tvy2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                HEFTRAN
c                D. Strimaitis,  SRC
c
c --- PURPOSE:  Define sigmas and corresponding virtual times at which
c               transition to the Heffter time-based sigma functions
c               is made
c
c --- UPDATES
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c          METH - integer - Method used to obtain SZH:
c                            1 = Time to SYH
c                            2 = Scale distance along slug
c           ZHT - real    - Current puff/slug height above ground (m)
c         SY,SZ - real    - Current puff/slug sigmas (m)
c     TVZ1,TVZ2 - real    - Virtual time for sigma-z at older (1) and
c                           younger (2) ends of slug (s)
c     TVY1,TVY2 - real    - Virtual time for sigma-y at older (1) and
c                           younger (2) ends of slug (s)
c
c     Common block /CSIGMA/ variables:
c           SYH, SZH, AZT(6),
c           UAVGS, MHFTSZS, SZMINS, KSTABS
c     Parameters:
c           MXPUFF, IO6
c
c --- OUTPUT:
c     Common block /CSIGMA/ variables:
c           SZH, THFTY, THFTZ
c
c --- HEFTRAN called by:  SETPUF, SETSLG, SLGRECS
c --- HEFTRAN calls:      SIGTY, SIGTZ
c----------------------------------------------------------------------
c --- Notes:
c
c       The transition to the Heffter curves is made when sigma-y
c       grows to SYH, a value provided in the input file.  At this
c       point, BOTH sigma-y and sigma-z begin to follow the time-based
c       Heffter growth rate.  Because dispersion regimes may change
c       one or more times before SYH is attained, the virtual times
c       at the transition point for sigma-y and sigma-z can be very
c       different, and a wide range of "SZH" values may be associated
c       with the single SYH.
c
c       Two methods are needed for identifying SZH.  The FIRST adresses
c       the case in which the current sigma-y and sigma-z are known,
c       and we use the current sigma-y dispersion curve to identify the
c       time to reach SYH.  This time is then used to find SZH at the
c       same point.  The coresponding virtual times THFTY and THFTZ are
c       computed.
c
c       The SECOND addresses the case in which sigmas and the
c       corresponding virtuals (time/distance) are known at both
c       ends of a slug, and we must define the virtual time/distance
c       to the transition point along the axis of the slug.  The
c       length of the slug provides the metric for translating THFTY
c       to a position along the axis.  This position is then used to
c       obtain the corresponding THFTZ.  SZH is computed from THFTZ.
c ---------------------------------------------------------------------
c
      include 'params.puf'
      include 'csigma.puf'

      data zero/0.0/

c --- Store Heffter switch for sigma-z
      mhftsz=mhftszs

      if(meth.EQ.1) then
c ---    Compute THFTY, SZH, and THFTZ for /CSIGMA/
c ---    Assume SYH already valid in /CSIGMA/
c
c ---    Set the sigma-y virtuals at which Heffter puff growth begins
         call sigty(syh,zero,zero,dum,thfty,dhfty)
c ---    Find sigma-y virtuals for current "puff"
         call sigty(sy,zero,zero,dum,ty,dy)
c ---    Time to reach transition from this point
         thftr=thfty-ty
c
         if(mhftszs.EQ.0) then
c ---       Heffter NOT used: fill sigma-z values from sigma-y
            szh=syh
            thftz=thfty
         else
c ---       Find sigma-z and virtual time at Heffter transition
c ---       Calls to SIGTZ are for times before transition, so
c ---       temporarily set switch to OFF
            mhftszs=0
            if(thftr.GT.0.0) then
c ---          Puff is not within Heffter regime
c ---          Find sigma-z virtuals for current "puff"
               call sigtz(sz,zero,zero,zht,dumy,tz,dz)
c ---          Add time/distance(km) to reach transition from this point
               time=tz+thftr
               dkm=dz+thftr*uavgs*0.001
c ---          Compute sigma-z at transition (SZH)
               call sigtz(zero,dkm,time,zht,szh,dumz,dumz)
c ---          Set time to transition (THFTZ)
               thftz=time
            elseif(thftr.EQ.0.0) then
c ---          Puff is at the transition to the Heffter regime
               szh=sz
c ---          Find sigma-z virtuals for current "puff"
               call sigtz(sz,zero,zero,zht,dumy,thftz,dheftz)
            else
c ---          Puff is within Heffter regime (THFTR not positive)
               szhsq=sz*sz+thftr*(azt(kstabs))**2
               if(szhsq.GT.szmins**2) then
                  szh=sqrt(szhsq)
                  call sigtz(szh,zero,zero,zht,dumy,thftz,dhftz)
               else
c ---             Travel from current "time" back to transition is too
c ---             large for current rate of growth, so virtuals are zero
                  szh=szmins
                  thftz=zero
               endif
            endif
c ---       Restore switch setting
            mhftszs=mhftsz
         endif

      elseif(meth.EQ.2) then
c ---    Compute new THFTZ for /CSIGMA/ (will not need SZH)
c ---    Assume THFTY already valid in /CSIGMA/
         if(tvy1.NE.tvy2) then
            thftz=tvz2+(thfty-tvy2)*(tvz1-tvz2)/(tvy1-tvy2)
         else
c ---       Restore value consistent with SZH
c ---       Temporarily set switch to OFF
            mhftszs=0
            call sigtz(szh,zero,zero,zht,dumy,thftz,dhftz)
c ---       Restore switch setting
            mhftszs=mhftsz
         endif

      else
         write(io6,*) 'FATAL ERROR --- HEFTRAN'
         write(io6,*) 'Invalid Method: METH = ',meth
         write(*,*)
         stop 'Halted in HEFTRAN -- see list file.'
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine rombtin(lwflux,tlower,tupper,x,y,z,
     &                   zpr,tfacc,syb,sye,szrb,szre,hlid,eps,
     &                   ss1,ss2,ss3,ss4)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                ROMBTIN
c                R. Yamartino, SRC
c
c --- PURPOSE:  Performs ROMBerg Time INtegration of the sequence of
c               slug snapshots over the interval (TLOWER,TUPPER) via
c               calls to the slug quardrture routine TRAPSL.
c
c               Adapted to integration of multiple quantities from
c               QROMB Module of ISC2 Short Term Model - ISCST2
c
c               which performs Romberg Integration of Function Using
c               Polynomial Extrapolation for h=0 With h1(i)=h1(i-1)/4
c               Modifed To Use Variable Order Extrapolation
c
c               (as programmed on July 7, 1993 by:
c                    Jeff Wang, Roger Brode  and
c                    Adapted From Codes By Richard Strelitz, CSC)
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): add eps variable to calling args
c
c
c --- INPUTS:
c
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c            TLOWER - real    - Lower limit (m) for the integration.
c            TUPPER - real    - Upper limit (m) for the integration.
c                 X - real    - X coord. of receptor.
c                 Y - real    - Y coord. of receptor.
c                 Z - real    - Z coord. of receptor.
c               ZPR - real    - Height (m) of the slug above receptor
c                               terrain height (allowing for terr adj)
c           SYB,SYE - real    - Sigma Y at receptor at beginning and end
c                               of time period.
c         SZRB,SZRE - real    - Sigma Z at receptor at beginning and end
c                               of time period.
c              HLID - real    - Relevant mixing depth (m) at receptor.
c               EPS - real    - Tolerance limit for integral convergence
c
c
c --- OUTPUTS:
c
c            SS1    - real    - Coupling coeff. (s/m**3) #1 = CCQB
c              CCQB - real    - Coupling coefficient (s/m**3) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c            SS2    - real    - Coupling coeff. (s/m**3) #2 = CCDQ
c              CCDQ - real    - Coupling coefficient (s/m**3) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c            SS3    - real    - Coupling coeff. (s/m**2) #3 = CCIZQB
c            CCIZQB - real    - Z-integrated coefficient (s/m**2) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c            SS4    - real    - Coupling coeff. (s/m**2) #4 = CCIZDQ
c            CCIZDQ - real    - Z-integrated coefficient (s/m**2) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c
c
c --- ROMBTIN called by:  SLUGAVE
c --- ROMBTIN calls:      TRAPSL, POLINT
c----------------------------------------------------------------------

c --- Variable declarations
      PARAMETER (K1 = 5, JMAX1 =10, ITMAX =100, EPS2 = 1.0E-20)
c *** PARAMETER (K1 = 5, JMAX1 =10, ITMAX =100, EPS = 1.0E-4,
c ***&           EPS2 = 1.0E-20)
C**   K1    = Order of Extrapolating Polynomial
C**   JMAX1 = Maximum Number of Iterations in Halving Interval
C**   ITMAX = Maximum Number of Integral Iterations
C**   EPS   = Tolerance Limit for Convergence of the Integral
C**   EPS2  = Lower Threshold Limit for the Value of the Integral
      REAL S1(21), H1(21)
      real s2(21), s3(21), s4(21)
      logical lwflux
      data zero/0.0/

      h1(1) = 1
      s1(1) = zero
      s2(1) = zero
      s3(1) = zero
      s4(1) = zero
      call trapsl(lwflux,tlower,tupper,x,y,z,
     &            zpr,tfacc,syb,sye,szrb,szre,hlid,
     &            s1(1),s2(1),s3(1),s4(1),1)
      ss1 = s1(1)
      ss2 = s2(1)
      ss3 = s3(1)
      ss4 = s4(1)

      do j = 2,jmax1
         h1(j) = 0.25*h1(j-1)
c ---    Obtain samples for all four integrals at once.
         call trapsl(lwflux,tlower,tupper,x,y,z,
     &               zpr,tfacc,syb,sye,szrb,szre,hlid,
     &               s1(j),s2(j),s3(j),s4(j),j)
         kp = MIN0(j,k1)-1
c ---    Estimate all four integrals at once.
         call polint(h1(j-kp),s1(j-kp),kp+1,ss1,dss1)
         call polint(h1(j-kp),s2(j-kp),kp+1,ss2,dss2)
         call polint(h1(j-kp),s3(j-kp),kp+1,ss3,dss3)
         call polint(h1(j-kp),s4(j-kp),kp+1,ss4,dss4)
C***********************************************************************
C        Check The Convergence Criteria:
C        EPS is tolerance level for convergence of the integral,
C          initially set = 1.0E-4 in a PARAMETER statement in MAIN1.INC;
C        EPS2 is lower threshold for the integral, initially set = 1.0E-10
C          in a PARAMETER statement in MAIN1.INC;
C        J is number of halving intervals and must be at least 3 for
C          convergence criteria to be met.  Maximum number of intervals
C          is set by JMAX1 (=10).
C***********************************************************************
c ---    Consider the convergence of integrals 1 & 3
         if((abs(dss3).LE.eps*abs(ss3) .OR. abs(ss3*dss3).LE.eps2)
     &       .AND. j.GE.3) then
            if((abs(dss1).LE.eps*abs(ss1) .OR. abs(ss1*dss1).LE.eps2)
     &          .AND. j.GE.3) goto 999
         endif
      enddo

 999  return
      end
c----------------------------------------------------------------------
      subroutine trapsl(lwflux,tlower,tupper,x,y,z,
     &                  zpr,tfacc,syb,sye,szrb,szre,hlid,
     &                  val1,val2,val3,val4,n)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950321                 TRAPSL
c                R. Yamartino, SRC
c
c --- PURPOSE:  Performs Trapezoidal integration of polygon segment
c               in the upwind distance domain (TLOWER,TUPPER) via
c               calls to the slug snapshot routine SLUGSNP.
c
c               Adapted to integration of multiple quantities from
c               TRAPZD Module of ISC2 Short Term Model - ISCST2
c               which performs standard trapezoidal integration for 2-d
c               integrals.
c
c               (as programmed on July 7, 1993 by:
c                    Jeff Wang, Roger Brode  and
c                    Adapted From Codes By Richard Strelitz, CSC)
c
c
c --- INPUTS:
c
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c            TLOWER - real    - Lower limit (m) for the integration.
c            TUPPER - real    - Upper limit (m) for the integration.
c                 X - real    - X coord. of receptor.
c                 Y - real    - Y coord. of receptor.
c                 Z - real    - Z coord. of receptor.
c               ZPR - real    - Height (m) of the slug above receptor
c                               terrain height (allowing for terr adj)
c           SYB,SYE - real    - Sigma Y at receptor at beginning and end
c                               of time period.
c         SZRB,SZRE - real    - Sigma Z at receptor at beginning and end
c                               of time period.
c              HLID - real    - Relevant mixing depth (m) at receptor.
c                 N - integer - Order of the integration.
c
c --- OUTPUTS:
c
c           VAL1    - real    - Coupling coeff. (s/m**3) #1
c           VAL2    - real    - Coupling coeff. (s/m**3) #2
c           VAL3    - real    - Coupling coeff. (s/m**2) #3
c           VAL4    - real    - Coupling coeff. (s/m**2) #4
c
c --- TRAPSL called by:  ROMBTIN
c --- TRAPSL calls:      SLUGSNP
c----------------------------------------------------------------------

c --- Variable declarations
      real del, sum1, sum2, sum3, sum4, sval1, sval2, sval3, sval4
      save neval2, sval1, sval2, sval3, sval4
      logical lwflux
      data zero/0.0/

      if(n.EQ.1) then
         call slugsnp(lwflux,tupper,x,y,z,
     &                zpr,tfacc,sye,szre,hlid,dccizqb,vert)
         temp = dccizqb * vert
c ---    ccqb = ccqb + temp
         sum1 = temp
c ---    ccdq = ccdq + temp * tupper
         sum2 = temp * tupper
c ---    ccizqb = ccizqb + dccizqb
         sum3 = dccizqb
c ---    ccizdq = ccizdq + dccizqb * tupper
         sum4 = dccizqb * tupper
c
         call slugsnp(lwflux,tlower,x,y,z,
     &                zpr,tfacc,syb,szrb,hlid,dccizqb,vert)
         temp = dccizqb * vert
         sum1 = sum1 + temp
         sum2 = sum2 + temp * tlower
         sum3 = sum3 + dccizqb
         sum4 = sum4 + dccizqb * tlower
c
         del = tupper-tlower
         sval1 = zero
         sval2 = zero
         sval3 = zero
         sval4 = zero
         neval2 = 1
      else
         del = (tupper-tlower)/neval2
         t1 = tlower+del*0.5
c        sum = 0.0
         sum1 = zero
         sum2 = zero
         sum3 = zero
         sum4 = zero
c
         do i = 1,neval2
c ---       Interpolate the receptor specific sigmas.  8/31/94
            sy = syb   +  t1 * (sye  - syb )
            sz = szrb  +  t1 * (szre - szrb)
c
            call slugsnp(lwflux,t1,x,y,z,
     &                   zpr,tfacc,sy,sz,hlid,dccizqb,vert)
c
            temp = dccizqb * vert
            sum1 = sum1 + temp
            sum2 = sum2 + temp * tlower
            sum3 = sum3 + dccizqb
            sum4 = sum4 + dccizqb * tlower
c
            t1 = t1+del
         enddo
         neval2 = neval2*2
      endif
c
      val1 = 0.5 * (sval1 + del*sum1)
      sval1 = val1
c
      val2 = 0.5 * (sval2 + del*sum2)
      sval2 = val2
c
      val3 = 0.5 * (sval3 + del*sum3)
      sval3 = val3
c
      val4 = 0.5 * (sval4 + del*sum4)
      sval4 = val4
c
      return
      end
C----------------------------------------------------------------------
      subroutine slugave(ldbhr,lwflux,dt,x,y,z,zpr,
     x                   tfacc,syrb,szrb,syre,szre,hlid,
     x                   ccqb,ccdq,ccizqb,ccizdq)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                SLUGAVE
c                R. Yamartino, SRC
c                Modified 7/90 -- J. Scire, SRC
c                Polygon areas -- RJY 12/28/93
c                Modified for receptor specific sigmas -- RJY 8/31/94
c                                                         DGS 8/31/94
c                Adaptive time integration -- RJY 3/21/95
c                Remove area-source treatment -- DGS 6/30/95
c
c --- PURPOSE:  Computes the time-average coupling coefficients (s/m**3)
c               at the point (x,y,z) over the time period T to T+DT
c                (where DT is a time step and TDDT
c                is the fraction of DT that is elapsed).
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): add debug switch to SLUGINT call
c                   971107  (DGS): add /COMPARM/ with "eps" variable for
c                                  use in ROMBTIN
c                   971107  (DGS): pass ICODE to VCOUP from /CURRENT/
c --- V4.0-V4.07    971107  (DGS): add PDF logic for VCOUP calls
c --- V4.0-V5.0     971107  (DGS): package slug geometry in SLGFRAC
c
c
c --- INPUTS:
c
c             LDBHR - logical - Debug output? (T/F)
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c                DT - real    - Time elapsed in moving slug ends from
c                               (XB1,YB1,ZB1) to (XE1,YE1,ZE1) and
c                               (XB2,YB2,ZB2) to (XE2,YE2,ZE2) plus
c                               companion changes in end point sigmas.
c         (X, Y, Z) - real    - Coordinates of the receptor (m)
c               ZPR - real    - Height (m) of the slug above receptor
c                               terrain height (allowing for terr adj)
c             TFACC - real    - Cross-slug T factor to account for shear
c       (SYRB,SZRB) - real    - Sigmas at the receptor before T factor.
c                               At beginning of time step.
c       (SYRE,SZRE) - real    - Sigmas at the receptor before T factor.
c                               At end of time step.
c              HLID - real    - Relevant mixing depth (m) at receptor.
c
c     Common Block /COMPARM/ variables:
c        EPSSLUG
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1, SYB1, SZB1,
c        XE1, YE1, ZE1, SYE1, SZE1,
c        XB2, YB2, ZB2, SYB2, SZB2,
c        XE2, YE2, ZE2, SYE2, SZE2,
c        IAGE, SPEEDI, SRAT, TEMIS, ICODE
c     Common Block /PDF/ variables:
c        LPDF, SWUPF, SWDNF, SZUPB, SZDNB, WTUP, WTDN, ZUP, ZDN, RFACSQ
c     Parameters:
c        none
c
c --- OUTPUTS:
c
c              CCQB - real    - Coupling coefficient (s/m**3) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c              CCDQ - real    - Coupling coefficient (s/m**3) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c            CCIZQB - real    - Z-integrated coefficient (s/m**2) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c            CCIZDQ - real    - Z-integrated coefficient (s/m**2) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c
c --- SLUGAVE called by:  CALCSL
c --- SLUGAVE calls:      VCOUP, SLUGINT, SLGTLIM, SLUGSNP, XERFDIF, ERF
c                         ROMBTIN, SLGFRAC
c----------------------------------------------------------------------
c
c --- Include common blocks
      include 'params.puf'
      include 'comparm.puf'
      include 'current.puf'
      include 'pdf.puf'
c --- Some variables passed to LSSLINT via SLGLIN common block
      COMMON /SLGLIN/ DXY12,RDXY12
c
      logical ldbhr,lwflux
c
      data srthaf/0.7071/,half/0.5/,small/1.0e-10/
      data srt2pi/2.506628/,fourth/0.25/
      data erfcut/3.0/,sigcut/3.0/
c
      ccqb = 0.0
      ccdq = 0.0
      ccizqb = 0.0
      ccizdq = 0.0
c
c ----------------------------------------------------------------
c --- Consider the special case of the current period's emissions.
c ----------------------------------------------------------------
      IF(IAGE.EQ.0) THEN
c
c ---    Determine receptor position relative to final slug end-point
c ---    Note that there is no change in (X2,Y2) over time.
         call SLGFRAC(x,y,xe1,ye1,xb2,yb2,rhoa,rhoc,fracs,dxy12,rdxy12)
c ---    Constrain FRACS to be 0.0 to 1.0 for the actual slug.
         FRACS = AMAX1(0.0,FRACS)
         FRACS = AMIN1(1.0,FRACS)
c ---    Note that in x-y space the coordinates of the point (XP,YP,ZP)
c        corresponding to rhoc = 0 (i.e., rhoa along the slug axis) are
c        XP = X2  +  RHOA * SINOM  Not used
c        YP = Y2  +  RHOA * COSOM  Not used
c OR     XP = X2  +  FRACS * (X1 - X2)  IF WITHIN SLUG BOUNDS.
c OR     YP = Y2  +  FRACS * (Y1 - Y2)  IF WITHIN SLUG BOUNDS.
c
c ---    Note that for Z coordinates, we take receptor-specific value
         zp = zpr
c
c ***    Replace with actual values @ receptor. T factor=1.0 for IAGE=0
c ---    12/3/89 Protect against divide by sigma of zero.
         sy = amax1(syre,small)
         sz = amax1(szre,small)
c ***
c
c ***    All coordinates ready ! now compute coupling coefficient for
c        a unit source (Q = 1 ug/sec)
c
c ---    Check if any vertical coupling.
c        vcoup(icode,z,zp,sz,hlid) includes the 1/sqrt(2*pi) and
c        the sum over all reflection terms.
         if(LPDF) then
            szsq=sz**2
            szdn=SQRT(szsq*swdnf+szdnb*rfacsq)
            szup=SQRT(szsq*swupf+szupb*rfacsq)
            vert = wtdn*VCOUP(icode,z,zdn,szdn,hlid) +
     &             wtup*VCOUP(icode,z,zup,szup,hlid)
         else
            vert = vcoup(icode,z,zp,sz,hlid)
         endif
c*****
         if(ldbhr) then
            write(io6,*)'SLUGAVE -- New slug --'
            write(io6,*)'        sz,z,zp = ',sz,z,zp
            write(io6,*)'      hlid,vert = ',hlid,vert
         endif
c*****
c
c ---    No impact if no vertical coupling AND if wet flux not modeled
         if(.NOT.lwflux .and. vert.LT.small) return
c
c ---    Check if any cross-slug distance coupling.
         SRAT2 = SRAT * SRAT
         PHIC = RHOC / SY
         EXPY = 0.0
         IF(ABS(PHIC) .LE. SIGCUT) EXPY = EXP(-HALF*SRAT2*PHIC*PHIC)
c*****
         if(ldbhr) then
            write(io6,*)'        sy,rhoc = ',sy,rhoc
            write(io6,*)'      srat,expy = ',srat,expy
         endif
c*****
c
c ---    No impact if no significant cross-slug coupling
         IF(EXPY .LT. SMALL) RETURN
c
c ---    Check if any along-slug distance coupling.
c ---    12/3/89 Protect against divide by sigma of zero.
         PHIA2 = SRTHAF * RHOA / amax1(SYB2,small)
         ETA2 = SRTHAF * (RHOA - DXY12) / SY
c ---    For ETA1, I need the slug length at the beginning of the
c        time step.  This is usually zero but may not be if we allow
c        for prolonged steady-state releases somehow. however, this
c        would then require a mechanism for telling this routine
c        that IAGE > 0 but all conditions (e.g., met., source strength)
c        are unchanged. since this may never be implemented, assume zero
c        slug length and set ETA1 = PHIA2
c ***    Modify eta1 to use sigma y at receptor rather than at source
         eta1 = srthaf * rhoa / sy
c ***
c ---    Eliminate cases beyond the causal frontier.
c i.e.   IF(ETA1.GT.ERFCUT .AND. ETA2.GT.ERFCUT) RETURN for downwind
c        receptors, but in general (including upwind receptors)
c        consider the following approach.
         PROD = ETA2 * ETA1
c*****
c *** write(6,*)'average subr. -- eta1 = ',eta1,'  eta2 = ',eta2,
c ***1 '  prod = ',prod
c*****
C ***    SIGCUT in following is reset to ERFCUT 3/8/89
         IF(PROD.GT.0.0 .AND. ABS(ETA1).GT.ERFCUT .AND.
     X                        ABS(ETA2).GT.ERFCUT) RETURN
c
         ERFA2 = 1.0
         IF(PHIA2.LT.0.0) ERFA2 = -1.0
         IF(ABS(PHIA2) .LE. ERFCUT) ERFA2 = ERF(PHIA2)
c
c
c ---    Compute the causality factors FCAUS0 AND FCAUS1.
c ***    vmws = speedi * srat
c ***    coeff = sy / ( vmws * dt )
         coeff = SRTHAF/(eta1-eta2)
         coeff2 = coeff * coeff
         call xerfdif(eta2,eta1,xint0,xint1)
         fcaus0 = half * erfa2  +  srthaf * coeff * xint0
         fcaus1 = fourth * erfa2  -  coeff2 * xint1  +
     x            srthaf * coeff2 * ( rhoa / sy ) * xint0
c
c*****
c *** write(6,*)'average subr. -- fcaus = ',fcaus,'  erfa2 = ',erfa2,
c ***1 '  coeff = ',coeff,'  eta2 = ',eta2,'  erfet2 = ',erfet2,
c ***2 '  eta1 = ',eta1,'  erfet1 = ',erfet1,'  expet2 = ',expet2,
c ***3 '  expet1 = ',expet1,'  srtpi = ',srtpi
c*****
c
c ---    Compute the time-average conc. terms for unit emission rate !
         ccoup = expy  / (srt2pi * speedi * sy)
         if(ccoup .lt. small) return
c
         if(fcaus0 .gt. small) then
                               ccizqb = ccoup * fcaus0
                               ccqb = vert * ccizqb
                               endif
c
         if(fcaus1 .gt. small) then
                               ccizdq = ccoup * fcaus1
                               ccdq = vert * ccizdq
                               endif
c
c*****
c *** write(6,*)'SLUGAVE -- New slug -- vert = ',vert,
c ***1 '  expy = ',expy,'  speedi = ',speedi,'  sy = ',sy,
c ***2 '  sz = ',sz,'  iage = ',iage
c*****
c
         return
      endif
c
c ---------------------------------------------------------------
c
c --- The following section provides several methods to time average
c     the more general case of IAGE > 0.
c
c --- SLUGINT computes the average concentration CONC at the point
c     (X,Y,Z) over the time T to T+DT (where DT is a time step)
c
c --- Include the effect of the crosswind T factor on sy. 4/5/89
c     Note that the following statement allows sy to experience growth
c     but not shrinkage.  To allow shrinkage as well, one need only have
c     sy = syr * tfacc
c --- Note that tfacc is cumulative and therefore represents the effect
c     of all growths and shrinkages.
c --- NOTE same limitation used in SUBR. SLGXLIM
c
      syb = syrb * amax1(1.0,tfacc)
      sye = syre * amax1(1.0,tfacc)
      call slugint(ldbhr,iint,lwflux,x,y,z,
     X             zpr,tfacc,syb,szrb,sye,szre,hlid,
     X             ccqb,ccdq,ccizqb,ccizdq)
c
c --- IINT gives the status of the integration;
c          = -1 implies that numerical integration must be done.
c          =  0 implies that concs vanish and no further work be done.
c          = +1 implies that concs are correct as is.
c
c*****
      if(ldbhr) then
      write(io6,*)'SLUGINT result (-1:Do numerical; 0:No concs; 1:Done)'
      write(io6,*)'        IINT = ',iint
      endif
c*****
      if(iint.GE.0) return
c
c ---------------------------------------------------------------
c ---------------------------------------------------------------
c
c --- Do a numerical integration.
c
c --- SLGTLIM computes the integration start and stop times
c     over the time T to T+DT (where DT is a time step)
c     Use average sigma-y at receptor over the step
c
      symax=amax1(syb,sye)
      call slgtlim(x,y,symax,itf,tstart,tend)
c
c --- ITF gives the status of the time limits;
c          =  0 implies that CONC = 0 and do not integrate.
c          = +1 implies that the integration should be done
c               with limits    T + TSTART * DT
c               and            T + TEND * DT.
c*****
      if(ldbhr) then
      write(io6,*)'SLGTLIM result (1:Do numerical; 0:No concs)'
      write(io6,*)'     X,Y,SYMAX = ',x,y,symax
      write(io6,*)'           ITF = ',itf
      write(io6,*)'TSTART,TEND,DT = ',tstart,tend,dt
      endif
c*****
      if(itf.EQ.0) return
c
c --- Use the trapezoidal rule to integrate.
      ccqb = 0.0
      ccdq = 0.0
      ccizqb = 0.0
      ccizdq = 0.0
c
c --- Evaluate time integral for this interval. RJY            3/21/95
      call rombtin(lwflux,tstart,tend,x,y,z,
     &             zpr,tfacc,syb,sye,szrb,szre,hlid,epsslug,
     &             ccqb,ccdq,ccizqb,ccizdq)
c
c*****
c *** write(6,*)'SUBR. SLUGAVE -- CCQB = ',ccqb,' CCDQ = ',ccdq,
c ***1 ' CCIZQB = ',ccizqb,' CCIZDQ = ',ccizdq,' DSAMP = ',dsamp
c ****
c
      RETURN
      END
c----------------------------------------------------------------------
      subroutine slugsnp(lwflux,tddt,x,y,z,zpr,tfacc,syr,szr,hlid,
     x                   dccizqb,vert)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980918                SLUGSNP
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the instantaneous coupling coefficient
c               (s/m**3) at the point (x,y,z) at the time T + TDDT*DT
c               (where DT is a time step and TDDT
c               is the fraction of DT that is elapsed).
c
c --- UPDATE
c --- V5.0-V5.0     980918 (DGS) : add area source distribution factor
c --- V5.0-V5.0     980430 (DGS) : 'Use' TFACC (compiler warning)
c --- V4.0-V5.0     971107  (DGS): switch from slug-end sig-y to
c                                  receptor-specific sig-y in causality
c                   971107  (DGS): pass ICODE to VCOUP from /CURRENT/
c --- V4.0-V4.07    971107  (DGS): add PDF logic for VCOUP calls
c --- V4.0-V5.0     971107  (DGS): package slug geometry in SLGFRAC
c
c --- INPUTS:
c
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c              TDDT - real    - Fraction (0 to 1) of time step elapsed
c         (X, Y, Z) - real    - Coordinates of the receptor (m)
c               ZPR - real    - Height (m) of the slug above receptor
c                               terrain height.
c             TFACC - real    - Cross-slug T factor to account for shear
c         (SYR,SZR) - real    - Sigmas at the receptor (m).
c              HLID - real    - Relevant mixing depth (m) at receptor.
c
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1, SYB1, SZB1,
c        XE1, YE1, ZE1, SYE1, SZE1,
c        XB2, YB2, ZB2, SYB2, SZB2,
c        XE2, YE2, ZE2, SYE2, SZE2,
c        SPEEDI, SRAT, ICODE,
c     Common Block /PDF/ variables:
c        LPDF, SWUPF, SWDNF, SZUPB, SZDNB, WTUP, WTDN, ZUP, ZDN, RFACSQ
c     Parameters:
c        IO6
c
c --- OUTPUTS:
c
c           DCCIZQB - real    - Z-integrated coefficient (s/m**2)
c                               for an arbitrary source rate.
c              VERT - real    - The Z coupling coefficient (1/m).
c
c --- SLUGSNP called by:  SLUGAVE
c --- SLUGSNP calls:      VCOUP, ERF, SLGFRAC, ASDF
c----------------------------------------------------------------------
c
c --- Include common blocks
      include 'params.puf'
      include 'current.puf'
      include 'pdf.puf'
c
      logical lwflux,ldb
c
      data srthaf/0.7071/,half/0.5/,small/1.0e-10/
      data erfcut/3.0/,sigcut/3.0/,srt2pi/2.506628/

c --- Local control of debug output
      data ldb/.FALSE./

c --- Determine the current coordinates of the slug end-points.
      X1 = XB1 + TDDT * (XE1 - XB1)
      Y1 = YB1 + TDDT * (YE1 - YB1)
c
      X2 = XB2 + TDDT * (XE2 - XB2)
      Y2 = YB2 + TDDT * (YE2 - YB2)
c --- Determine the length and orientation of the slug, and
c --- define the position of the receptor relative to slug end 2
c --- Convert receptor position to along-slug and cross-slug units
      call SLGFRAC(x,y,x1,y1,x2,y2,rhoa,rhoc,fracs,dxy12,rdxy12)
c --- Constrain FRACS to be 0.0 to 1.0 for the actual slug.
      FRACS = AMAX1(0.0,FRACS)
      FRACS = AMIN1(1.0,FRACS)
c --- note that in x-y space the coordinates of the point (XP,YP,ZP)
c     corresponding to RHOC = 0 (i.e., RHOA along the slug axis) are
c     XP = X2  +  RHOA * SINOM  Not used
c     YP = Y2  +  RHOA * COSOM  Not used
c OR  XP = X2  +  FRACS * (X1 - X2)  if within slug bounds.
c OR  YP = Y2  +  FRACS * (Y1 - Y2)  if within slug bounds.
c
c --- Note that we use the receptor-specific slug height
      zp = zpr
c
c --- Use sigma values at receptor as interpolation done in SLUGAVE
c --- before call.
      sy=syr
      sz=szr
c
c --- Include the effect of the crosswind T factor on syint.
c     Note that the following statement allows sy to experience growth
c     but not shrinkage.  To allow shrinkage as well, one need only have
c     sy = syint * tfacc
c     sy = syint * amax1(1.0,tfacc)
c --- 'Use' TFACC without applying it to sy
      tfacc=tfacc
c *** All coordinates ready ! Now compute coupling coefficient for
c     a unit source (Q = 1 ug/sec)
      dccizqb = 0.0
c
c --- Check if any vertical coupling.
c     vert = vcoup(icode,z,zp,sz,hlid) includes the 1/sqrt(2*pi) and
c     the sum over all reflection terms.
      if(LPDF) then
         szsq=sz**2
         szdn=SQRT(szsq*swdnf+szdnb*rfacsq)
         szup=SQRT(szsq*swupf+szupb*rfacsq)
         vert = wtdn*VCOUP(icode,z,zdn,szdn,hlid) +
     &          wtup*VCOUP(icode,z,zup,szup,hlid)
      else
         vert = vcoup(icode,z,zp,sz,hlid)
      endif
c
c *** No longer always skip if no vertical coupling !!  11/12/88
      IF(.not.lwflux .and. vert .LT. SMALL) GO TO 100
c
c
      SRAT2 = SRAT * SRAT
c --- Check if any cross-slug distance coupling.
      PHIC = RHOC / SY
      EXPY = 0.0
      IF(ABS(PHIC) .LE. SIGCUT) EXPY = EXP(-HALF * SRAT2 * PHIC * PHIC)
      IF(EXPY .LT. SMALL) GO TO 100
c
c --- Check if any along-slug distance coupling.
      PHIA2 = SRTHAF * RHOA / SY
      PHIA1 = SRTHAF * (RHOA - DXY12) / SY
      PROD = PHIA2 * PHIA1

      IF(PROD.GT.0.0 .AND. ABS(PHIA1).GT.ERFCUT .AND.
     X                     ABS(PHIA2).GT.ERFCUT) GO TO 100
c
      ERFA1 = 1.0
      IF(PHIA1.LT.0.0) ERFA1 = -1.0
c     Note that for ERFCUT = 3, ERF(ERFCUT) = 0.999978
      IF(ABS(PHIA1) .LE. ERFCUT) ERFA1 = ERF(PHIA1)
c
      ERFA2 = 1.0
      IF(PHIA2.LT.0.0) ERFA2 = -1.0
      IF(ABS(PHIA2) .LE. ERFCUT) ERFA2 = ERF(PHIA2)
c --- Compute the causality factor FCAUS.
      FCAUS = HALF * (ERFA2 - ERFA1)

      IF(FCAUS .LT. SMALL) GO TO 100
c
c --- Compute the snapshot concentration for unit emission rate,
c --- including correction factor for cross-slug distribution from
c --- area sources
      dccizqb = ASDF(ldb,rhoc,sy)*EXPY*FCAUS/(srt2pi*SPEEDI*SY)

c --- Debug output
      if(LDB) then
         write(io6,*)'Snapshot -- slugsnp = ',dccizqb,'  vert = ',vert,
     &   '  expy = ',expy,'  fcaus = ',fcaus,
     &   '  speedi = ',speedi,'  sy = ',sy,'  sz = ',sz
      endif
c
c
  100 RETURN
      END
c----------------------------------------------------------------------
      SUBROUTINE SLGXLIM(ILOW,IHGH,JLOW,JHGH,tfacc)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                SLGXLIM
c                R. Yamartino, SRC
c                Modified by J. Scire, SRC 7/12/90
c                Generalized to polygon area sources 12/29/93
c
c --- PURPOSE:  For a given slug's initial and final positions, compute
c               the window of receptor space which should be examined.
c
c               This version computes such a window for both grided
c               and non-gridded receptors.
c
c --- UPDATE
c --- V4.0-V5.0     971107  (DGS): adjust istype range to recognize
c                                  variable line sources (6)
c --- V4.0-V5.0     971107  (DGS): revise limits on range of impact
c
c --- INPUTS:
c
c             TFACC - real    - Dimensionless lateral distortion factor
c
c     Common Block /CURRENT/ variables:
C        XB1, YB1, XE2, YE2, XB2, YB2, XE2, YE2
C        SYB1, SYE2, SYB2, SYE2
C        IAGE, SPEEDI, SRAT, TEMIS
c     Common Block /recgrd/ variables:
C        NX,DX,XLEFT,XRGHT,NY,DY,YBOT,YTOP
c
c --- OUTPUTS:
c
c             ILOW  - integer - Minimum x receptor no. to be considered.
c             IHGH  - integer - Maximum x receptor no. to be considered.
c             JLOW  - integer - Minimum y receptor no. to be considered.
c             JHGH  - integer - Maximum y receptor no. to be considered.
c
c     Common Block /SLGBND/ variables:
c        XLOW,XHGH,YLOW,YHGH
c
c --- SLGXLIM called by:  CALCSL
c --- SLGXLIM calls:       none
c----------------------------------------------------------------------
c
C --- SUPPLEMENTAL NOTES
C
C --- THIS SUBROUTINE RETURNS THE I,J RECEPTOR LOCATION BOUNDS THAT
C     NEED TO BE SEARCHED FOR SIGNIFICANT IMPACT.
C
C     These bounds are computed by looking at the slug endpoints and
C     adding an additional piece, SIGTRY, defined as
C              SIGTRY = SIGCUT * SY * tfaccl        ,
C     to ensure that receptors receiving only partial impacts are
C     included.  Note that SIGCUT is in a DATA statement and SY
C     represents the several relevant values.  The quantity, TFACCL,
C     accounts for any enhanced horizontal spreading due to shear by
C     considering the T factor, TFACC, and applying the condition,
C              tfaccl = amax1(1.0,tfacc)            .
C
C --- CORRESPONDING TO THE OUTPUT BOUNDS (ILOW,IHGH,JLOW,JHGH)
C     WILL ALSO BE THE COORDINATE BOUNDS (XLOW,XHGH,YLOW,YHGH)
C     FOR NON-GRIDDED RECEPTORS.  THIS INFO WILL BE IN /SLGBND/

      include 'params.puf'
      include 'current.puf'

      COMMON/SLGBND/ XLOW,XHGH,YLOW,YHGH
C
C --- ALSO ASSUME RECEPTOR GRID INFO IN /RECGRD/
      COMMON/RECGRD/ NX,DX,XLEFT,XRGHT,NY,DY,YBOT,YTOP
C
C --- SET SIGCUT AS THE MAX. NO. OF STD. DEVS.
      DATA SIGCUT/3.0/

c --- Set BIG number to use for initial high/low marker (m)
      data xbig/1.0e20/
c
c --- Limit local value of tfacc to .ge. one.  See SUBR. SLUGAVE
      tfaccl = amax1(1.0,tfacc)
C
C --- INITIALIZE BOUNDS AT UNPHYSICAL VALUES OFF GRID.
      XLOW =  xbig
      XHGH = -xbig
      YLOW =  xbig
      YHGH = -xbig
C
C --- WORK FIRST WITH THE OLDEST END (1) OF THE SLUG AT THE END
C     (NEW or E) OF THE TIME STEP, AS THIS END HAS THE LARGEST
C     SIGMAS AND HENCE IS LIKELY TO ESTABLISH THE LARGEST WINDOW
C     MOST QUICKLY AND THUS CUT DOWN ON THE AMOUNT OF COMPUTATION.
C --- N.B. J. SCIRE CONVENTION: 1 = OLD END OF PUFF } SAME AS RJY
C                               2 = NEW END OF PUFF }
C
      SIGTRY = SIGCUT * SYE1 * tfaccl
      XTRY = XE1 + SIGTRY
      IF(XTRY .GT. XHGH) XHGH = XTRY
      XTRY = XE1 - SIGTRY
      IF(XTRY .LT. XLOW) XLOW = XTRY
C
      YTRY = YE1 + SIGTRY
      IF(YTRY .GT. YHGH) YHGH = YTRY
      YTRY = YE1 - SIGTRY
      IF(YTRY .LT. YLOW) YLOW = YTRY
C
C --- NOW CONSIDER THE OLDEST END (1) OF THE SLUG AT THE BEGINNING
C     OF THE TIME STEP.  NOW SKIP EXPLICIT DEFINITION OF XTRY,YTRY
C     TO SAVE INSTRUCTIONS.
      SIGTRY = SIGCUT * SYB1 * tfaccl
      IF((XB1+SIGTRY) .GT. XHGH) XHGH = XB1+SIGTRY
      IF((XB1-SIGTRY) .LT. XLOW) XLOW = XB1-SIGTRY
      IF((YB1+SIGTRY) .GT. YHGH) YHGH = YB1+SIGTRY
      IF((YB1-SIGTRY) .LT. YLOW) YLOW = YB1-SIGTRY
C
C --- NOW CONSIDER THE NEWEST END (2) OF THE SLUG AT THE END
C     OF THE TIME STEP.  NOW SKIP EXPLICIT DEFINITION OF XTRY,YTRY
C     TO SAVE INSTRUCTIONS.
      SIGTRY = SIGCUT * SYE2 * tfaccl
      IF((XB2+SIGTRY) .GT. XHGH) XHGH = XE2+SIGTRY
      IF((XB2-SIGTRY) .LT. XLOW) XLOW = XE2-SIGTRY
      IF((YB2+SIGTRY) .GT. YHGH) YHGH = YE2+SIGTRY
      IF((YB2-SIGTRY) .LT. YLOW) YLOW = YE2-SIGTRY
C
C --- NOW CONSIDER THE NEWEST END (2) OF THE SLUG AT THE BEGINNING
C     OF THE TIME STEP ONLY IF THIS END NOT TIED TO SOURCE.
C     TO SAVE INSTRUCTIONS.
      IF(IAGE.GT.0) THEN
         SIGTRY = SIGCUT * SYB2 * tfaccl
         IF((XB2+SIGTRY) .GT. XHGH) XHGH = XB2+SIGTRY
         IF((XB2-SIGTRY) .LT. XLOW) XLOW = XB2-SIGTRY
         IF((YB2+SIGTRY) .GT. YHGH) YHGH = YB2+SIGTRY
         IF((YB2-SIGTRY) .LT. YLOW) YLOW = YB2-SIGTRY
                    ENDIF
c
c --- Now consider the effect of a polygon area source.    12/29/93
c     This is a very rough approx,  likely to overestimate the domain.
      if(iage.EQ.0 .AND. (istype.GE.3 .AND. istype.LE.6)) then
         xshft = vecmax(nside,xvert) - vecmin(nside,xvert)
         yshft = vecmax(nside,yvert) - vecmin(nside,yvert)
         xhgh = xhgh + xshft
         xlow = xlow - xshft
         yhgh = yhgh + yshft
         ylow = ylow - yshft
      endif

c --- Compute corresponding gridded receptor indicies
      ilow = NINT((xlow - xleft)/dx)+1
      ihgh = NINT((xhgh - xleft)/dx)+1
      jlow = NINT((ylow - ybot)/dy)+1
      jhgh = NINT((yhgh - ybot)/dy)+1

      if(ihgh.LT.1 .OR. jhgh.LT.1 .OR.
     &   ilow.GT.nx .OR. jlow.GT.ny) then
c ---    No overlap; set "high" index <0 and "low" index = 1
c ---    to deactivate do-loops in subsequent routines
         ihgh=-1
         jhgh=-1
         ilow= 1
         jlow= 1
      else
c ---    Impact zone overlaps gridded receptors, so trim to actual range
         if(ilow.LT.1)  ilow = 1
         if(ihgh.GT.nx) ihgh = nx
         if(jlow.LT.1)  jlow = 1
         if(jhgh.GT.ny) jhgh = ny
      endif

c*****
c *** write(6,*)
c *** write(6,*)'ILOW = ',ilow,' IHGH = ',ihgh
c *** write(6,*)'JLOW = ',jlow,' JHGH = ',jhgh
c*****
C
      RETURN
      END
c----------------------------------------------------------------------
      FUNCTION VCOUP(ICODE,ZR,ZS,SZ,HLID0)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                  VCOUP
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the vertical coupling coefficient for a source
c               at height ZS, to a receptor at height ZR given a plume
c               with sigma z of SZ and including reflections from the
c               ground and lid at height HLID.
c
c --- UPDATE
c --- V5.0-V5.7     030402  (DGS): Screen output for 'zero' sigma_z
c
c --- V4.0-V5.0     971107  (DGS): Invoke unlimited mixing when adjusted
c                                  puff ht exceeds the current relecting
c                                  lid ht (receptors below stack base
c                                  can result in effective ZS>HLID)
c                   971107  (DGS): Include puff code and associated
c                                  logic to treat well-mixed puffs
c
c
c --- INPUTS:
c
c             ICODE - integer - Puff code
c                                1,11: within mixed layer & Gaussian
c                                2,12: within mixed layer & uniform
c                                3,13: above mixed layer & Gaussian
c                                4,14: above mixed layer & uniform
c                                5,15: currently above mixed layer
c                                    (but previously below) & Gaussian
c                                6,16: currently above mixed layer
c                                    (but previously below) & uniform
c                                99:   off computational grid
c                ZR - real    - Z-coordinate of receptor (m)
c                ZS - real    - Z-coordinate of source (m)
c                SZ - real    - Z-sigma at receptor (m)
c             HLID0 - real    - Mixing depth at receptor (m)
c              Note that these input values must have same units.
c
c
c --- OUTPUTS:
c
c             VCOUP - real    - Vertical coupling coefficient (1/m)
c
c --- VCOUP called by:  VCBAR, SLUGAVE, SLUGSNP, SLUGINT
c                       LSSLINT, CALCPF
c --- VCOUP calls:      none
c----------------------------------------------------------------------
c
c --- All heights have same units.      1/26/89
c
      data small/1.0e-10/,srttpi/2.5066283/,pi/3.1415926/
      data zunlim/9.9e10/
c --- Set minimum sigma-z (m)
      data szcut/1.0e-2/

c --- Treat well-mixed puff/slug codes first
c ------------------------------------------
      iicode=icode
      if(iicode.GT.10) iicode=iicode-10
      if(iicode.EQ.2 .OR. iicode.EQ.6) then
c ---    Within past/present mixed layer and uniform
         vcoup=1./hlid0
         return
      elseif(iicode .EQ. 4) then
c ---    Above mixed layer and uniform (no ground-level concs)
         vcoup=0.
         return
      endif

c --- Distribution must be computed
c ---------------------------------
      vcoup = 0.0

c --- Screen for sigma_z that is 'zero'
      if(sz.LT.szcut) return

c
c --- Remove mixing lid if source ht > mixing ht
      if(zs.GT.hlid0) then
         hlid=zunlim
      else
         hlid=hlid0
      endif
c
c --- Check for significant trapping
      if((sz/hlid).gt.0.63) go to 15
c
c --- Sum the reflection terms
      sz1 = sz + small
      sz2 = sz*sz + small
      x = -0.5*(zr-zs)**2/sz2
      if(x.lt.-20.0) go to 20
      expz = exp(x)
      x = -0.5*(zr+zs)**2/sz2
      if(x.gt.-20.0) expz = expz + exp(x)
c
          do 10 j = -1 , +1 , 2
            zrefl = 2.0*float(j)*hlid
            x = -0.5*(zr+zs+zrefl)**2/sz2
            if(x.gt.-20.0) expz = expz + exp(x)
            x = -0.5*(zr-zs+zrefl)**2/sz2
            if(x.gt.-20.0) expz = expz + exp(x)
 10       continue
c
      vcoup = expz/(srttpi*sz1)
      go to 20
c
c --- Near uniform mixing using approximation of R. Yamartino
c     (JAPCA 27, 5, MAY 1977)
 15   szsb = -0.5*(pi*sz/hlid)**2
      if(szsb.gt.-20.0) then
         beta = exp(szsb)
         beta2 = beta*beta
         expz = (1.0-beta2)*(1.0+beta2+2.0*beta*cos(pi*zs/hlid)*
     *                                          cos(pi*zr/hlid))
      else
         expz = 1.0
      endif
      vcoup = expz/hlid
c
 20   return
      end
c----------------------------------------------------------------------
      function vcbar(ip,mfact0,hlid,ppcoef,lcalm)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                  VCBAR
c                R. Yamartino, D. Strimaitis
c
c --- PURPOSE:  Computes the space- and time-averaged vertical coupling
c               coefficient, via calls to VCOUP.  A slug is sampled at
c               each end, both at the start and end of the step.  A puff
c               is sampled at the start, mid-pt, and end of the step.
c               If terrain is modeled with MCTADJ=1/3, then the sampling
c               uses the terrain elevation array at these points.
c
c --- UPDATE
c --- V5.73-V6.22   070921  (DGS): Require LCALM=FALSE to disable the
c                                  'frozen puff' treatment, since this
c                                  feature was not fully implemented
c                                  due to unassigned value of LCALM
c --- V5.4-V5.73    040611  (DGS): add gravitational settling for one
c                                  particle size (plume tilt)
c --- V5.0-V5.4     000602  (DGS): add 'frozen puff' treatment for calms
c --- V4.0-V5.0     971107  (DGS): pass ICODE to VCOUP from /CURRENT/
c
c
c --- INPUTS:
c                IP - integer - Puff index
c            MFACT0 - integer - Puff/slug flag (0: puff)
c              HLID - real    - Mixing depth  (m AGL)
c            PPCOEF - real    - Plume Path Coefficient for partial
c                               height correction (MCTADJ = 3)
c             LCALM - logical - Denotes calm period when true
c
c     Common Block /FLAGS/ variables:
c        MCTADJ, MTILT
c     Common Block /GRID/ variables:
c        DGRIDI
c     Common Block /PUFF/ variables:
c        HT0(mxpuff), ELBASE(mxpuff)
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1, SZB1,
c                       SZM1,
c        XE1, YE1, ZE1, SZE1,
c        XB2, YB2, ZB2, SZB2,
c        XE2, YE2, ZE2, SZE2, ICODE,
c        TB1, TB2, TE1, TE2, VSETL
c
c
c --- OUTPUTS:
c
c             VCBAR - real    - Vertical coupling coefficient (1/m)
c
c --- VCBAR called by:  DRY
c --- VCBAR calls:      VCOUP, GETELEV, CTADJ
c----------------------------------------------------------------------
c
C --- SUPPLEMENTAL NOTES
c --- zgr = receptor height in terrain following coordinates
c     is assumed to be zero.
c --------------------------------------------------------------------
c
      include 'params.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'puff.puf'
      include 'current.puf'

      logical lcalm, ldbg

      data half/0.50/,third/0.3333333/,fourth/0.250/,zgr/0.0/

c --- Set list file output switch for testing
      ldbg=.FALSE.

c --- Require lcalm = false
      if(LCALM) then
         write(io6,*)'VCBAR: LCALM must be FALSE, LCALM = ',lcalm
         stop 'Halted in VCBAR -- See list file.'
      endif

      vcbar=0.0

      if(mfact0.EQ.0) then
c ---    PUFF !

         if(mtilt.EQ.1) then
c ---       Set heights with gravitational settling
c ---       Use full settling over puff age here (ht may be negative)
            zpb1=zfinal(ip)-tb1*vsetl
            zpe1=zfinal(ip)-te1*vsetl
         else
            zpb1=zb1
            zpe1=ze1
         endif

c ---    Middle of step
         zpm1=half*(zpb1+zpe1)
         zp=zpm1
         if(mctadj.EQ.1 .OR. mctadj.EQ.3) then
            xm1mg=half*(xb1+xe1)*dgridi
            ym1mg=half*(yb1+ye1)*dgridi
            call getelev(xm1mg,ym1mg,zrterr)
            call ctadj(zrterr,zpm1,ht0(ip),elbase(ip),ppcoef,zp)
         endif
c ---    Condition effective puff ht to be non-negative
         zp=AMAX1(zp,0.0)
         vcbar=vcbar+third*vcoup(icode,zgr,zp,szm1,hlid)

c ---    Special treatment for calm periods:
c ---    Use puff properties at the middle of the sampling period
         if(LCALM) then
            vcbar=3.*vcbar

         else

c ---       Beginning of step
            zp=zpb1
            if(mctadj.EQ.1 .OR. mctadj.EQ.3) then
               xb1mg=xb1*dgridi
               yb1mg=yb1*dgridi
               call getelev(xb1mg,yb1mg,zrterr)
               call ctadj(zrterr,zpb1,ht0(ip),elbase(ip),ppcoef,zp)
            endif
c ---       Condition effective puff ht to be non-negative
            zp=AMAX1(zp,0.0)
            vcbar=vcbar+third*vcoup(icode,zgr,zp,szb1,hlid)

c ---       End of step
            zp=zpe1
            if(mctadj.EQ.1 .OR. mctadj.EQ.3) then
               xe1mg=xe1*dgridi
               ye1mg=ye1*dgridi
               call getelev(xe1mg,ye1mg,zrterr)
               call ctadj(zrterr,zpe1,ht0(ip),elbase(ip),ppcoef,zp)
            endif
c ---       Condition effective puff ht to be non-negative
            zp=AMAX1(zp,0.0)
            vcbar=vcbar+third*vcoup(icode,zgr,zp,sze1,hlid)
         endif

         if(LDBG) then
           write(io6,*)'VCBAR --  plume tilt'
           write(io6,*)'zpb1,zpm1,zpe1   = ',zpb1,zpm1,zpe1
           write(io6,*)'tb1,te1          = ',tb1,te1
         endif

      else
c ---    SLUG !

         if(mtilt.EQ.1) then
c ---       Set heights with gravitational settling
c ---       Use full settling over puff age here (ht may be negative)
            zpb1=zfinal(ip)-tb1*vsetl
            zpe1=zfinal(ip)-te1*vsetl
            zpb2=zfinal(ip)-tb2*vsetl
            zpe2=zfinal(ip)-te2*vsetl
         else
            zpb1=zb1
            zpe1=ze1
            zpb2=zb2
            zpe2=ze2
         endif

         zp=zpb1
         if(mctadj.EQ.1 .OR. mctadj.EQ.3) then
            xb1mg=xb1*dgridi
            yb1mg=yb1*dgridi
            call getelev(xb1mg,yb1mg,zrterr)
            call ctadj(zrterr,zpb1,ht0(ip),elbase(ip),ppcoef,zp)
         endif
c ---    Condition effective puff ht to be non-negative
         zp=AMAX1(zp,0.0)
         vcbar=vcbar+fourth*vcoup(icode,zgr,zp,szb1,hlid)

         zp=zpb2
         if(mctadj.EQ.1 .OR. mctadj.EQ.3) then
            xb2mg=xb2*dgridi
            yb2mg=yb2*dgridi
            call getelev(xb2mg,yb2mg,zrterr)
            call ctadj(zrterr,zpb2,ht0(ip),elbase(ip),ppcoef,zp)
         endif
c ---    Condition effective puff ht to be non-negative
         zp=AMAX1(zp,0.0)
         vcbar=vcbar+fourth*vcoup(icode,zgr,zp,szb2,hlid)

         zp=zpe1
         if(mctadj.EQ.1 .OR. mctadj.EQ.3) then
            xe1mg=xe1*dgridi
            ye1mg=ye1*dgridi
            call getelev(xe1mg,ye1mg,zrterr)
            call ctadj(zrterr,zpe1,ht0(ip),elbase(ip),ppcoef,zp)
         endif
c ---    Condition effective puff ht to be non-negative
         zp=AMAX1(zp,0.0)
         vcbar=vcbar+fourth*vcoup(icode,zgr,zp,sze1,hlid)

         zp=zpe2
         if(mctadj.EQ.1 .OR. mctadj.EQ.3) then
            xe2mg=xe2*dgridi
            ye2mg=ye2*dgridi
            call getelev(xe2mg,ye2mg,zrterr)
            call ctadj(zrterr,zpe2,ht0(ip),elbase(ip),ppcoef,zp)
         endif
c ---    Condition effective puff ht to be non-negative
         zp=AMAX1(zp,0.0)
         vcbar=vcbar+fourth*vcoup(icode,zgr,zp,sze2,hlid)

         if(LDBG) then
           write(io6,*)'VCBAR --  plume tilt'
           write(io6,*)'zpb1,zpm1,zpe1   = ',zpb1,zpm1,zpe1
           write(io6,*)'tb1,te1          = ',tb1,te1
           write(io6,*)'zpb2,zpe2        = ',zpb2,zpe2
           write(io6,*)'tb2,te2          = ',tb2,te2
         endif

      endif

      return
      end
c----------------------------------------------------------------------
      SUBROUTINE SLGTLIM(X,Y,SYR,ITF,TSTART,TEND)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900228                SLGTLIM
c                R. Yamartino, SRC
c
c --- PURPOSE:  For a given slug and receptor combination for which a
c               numerical dose integration is about to be done,
c               determine the dimensionless time integration limits,
c               0.0 < TSTART,TEND < 1.0  , which will capture the
c               major part of the integrand's contribution.
c
c
c --- INPUTS:
c
c                 X - real    - X-coordinate of receptor (m)
c                 Y - real    - Y-coordinate of receptor (m)
c               SYR - real    - Time-independent Y-sigma at receptor (m)
c               ITF - integer - Return code
c                                   =  0 implies that conc = 0 and
c                                        do not integrate.
c                                   = +1 implies that the integration
c                                        should be done
c
c     Common Block /CURRENT/ variables:
c        XB1, YB1, XE2, YE2, XB2, YB2, XE2, YE2
c     Parameters:
c        IO6
c
c --- OUTPUTS:
c
c            TSTART - real    - Start of integrand sampling
c                               at time:  t + tstart * dt
c              TEND - real    - End of integrand sampling
c                               at time:  t + tend * dt
c
c --- SLGTLIM called by:  SLUGAVE
c --- SLGTLIM calls:      FINLINI, ROOT3, ROOT2
c----------------------------------------------------------------------
c
c --- SUPPLEMENTAL NOTES
c
C --- COMPUTES THE INTEGRATION START AND STOP TIMES
C     OVER THE TIME T TO T+DT (WHERE DT IS A TIME STEP)
C
C --- ITF GIVES THE STATUS OF THE TIME LIMITS;
C          =  0 IMPLIES THAT CONC = 0 AND DO NOT INTEGRATE.
C          = +1 IMPLIES THAT THE INTEGRATION SHOULD BE DONE
C               WITH LIMITS    T + TSTART * DT
C               AND            T + TEND * DT.
C
C --- (X,Y,Z) ARE RECEPTOR COORDINATES.
C
C --- (XB1,YB1,ZB1) ARE THE COORDS OF THE OLDEST END OF THE SLUG AT
C                   THE BEGINNING (B) OF THE TIME STEP (I.E., TIME = T).
C --- (XE1,YE1,ZE1) ARE THE COORDS OF THE OLDEST END OF THE SLUG AT
C                   THE END (E) OF THE TIME STEP (I.E., TIME = T+DT).
C --- (XB2,YB2,ZB2) ARE THE COORDS OF THE YOUNGEST END OF THE SLUG AT
C                   THE BEGINNING (B) OF THE TIME STEP (I.E., TIME = T).
C --- (XE2,YE2,ZE2) ARE THE COORDS OF THE YOUNGEST END OF THE SLUG AT
C                   THE END (E) OF THE TIME STEP (I.E., TIME = T+DT).
C
C     SYR IS THE TIME-INDEPENDENT Y SIGMA AT THE RECEPTOR.
C
C     ALL SPATIAL DIFFERENCES ARE COMPUTED TO 1 METER RESOLUTION
C
C
C --- SOME OF THE INPUT VARIABLES NEEDED ARE NOW IN /CURRENT/
c     common/current/xb1,yb1,zb1,syb1,szb1,
c    1              xe1,ye1,ze1,sye1,sze1,
c    2              xb2,yb2,zb2,syb2,szb2,
c    3              xe2,ye2,ze2,sye2,sze2,
c    4              iage,speedi,srat,temis
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'current.puf'
c
C
      DIMENSION RT(3)
      DATA TWO/2.0/,SIGCUT/3.0/,SMALL/1.0E-10/
C
C --- SET THE INFLUENCE RADIUS, R, AROUND THE RECEPTOR
      R = SIGCUT * SYR
      R2 = R * R
C
C --- INITIALIZE TMIN AND TMAX AT UNPHYSICAL VALUES.
      TMIN =  1.0E10
      TSTART =  -9.0
      TMAX = -1.0E10
      TEND =  -9.0
C
C
C $$$ DO SPECIAL CASES OF TIME LIMITS AT THEIR FROZEN EXTREMA FIRST.
C
C ### END POINT PENETRATIONS AT T=0 AND T=1
c     AX = XB2 - X
c     AY = YB2 - Y
c --- Condition differences to nearest 1.0m
      AX = FLOAT( NINT(XB2 - X) )
      AY = FLOAT( NINT(YB2 - Y) )
c --- Condition differences to nearest 0.1m
c     AX = 0.1*FLOAT( NINT(10.*(XB2 - X)) )
c     AY = 0.1*FLOAT( NINT(10.*(YB2 - Y)) )
C
      R2TEST = AX * AX  +  AY * AY
      IF(R2TEST.LT.R2) TMIN = -0.1
      R2TEST = (XB1 - X)**2  +  (YB1 - Y)**2
      IF(R2TEST.LT.R2) TMIN = -0.1
      R2TEST = (XE1 - X)**2  +  (YE1 - Y)**2
      IF(R2TEST.LT.R2) TMAX = 1.1
      R2TEST = (XE2 - X)**2  +  (YE2 - Y)**2
      IF(R2TEST.LT.R2) TMAX = 1.1
C
C     DO CONDITIONAL TEST ON TMIN,TMAX. IF THIS TEST PASSES, THEN THERE
C     IS END POINT PENETRATION AT BOTH THE BEGINNING AND END OF THE
C     TIME STEP (AND THUS FOR ALL INTERMEDIATE TIMES).
      IF(TMIN.LT.0.0 .AND. TMAX.GT.1.0) GO TO 100
C
C --- DEFINE NEEDED COORDINATE DIFFERENCES
c     BX = XB1 - XB2
c     BY = YB1 - YB2
c     CX = XE2 - XB2
c     CY = YE2 - YB2
c     EX = (XE1 - XE2) - (XB1 - XB2)
c     EY = (YE1 - YE2) - (YB1 - YB2)
c --- Condition differences to nearest 1.0m
      BX = FLOAT( NINT(XB1 - XB2) )
      BY = FLOAT( NINT(YB1 - YB2) )
      CX = FLOAT( NINT(XE2 - XB2) )
      CY = FLOAT( NINT(YE2 - YB2) )
      EX = FLOAT( NINT(XE1 - XE2 - XB1 + XB2) )
      EY = FLOAT( NINT(YE1 - YE2 - YB1 + YB2) )
c --- Condition differences to nearest 0.1m
c     BX = 0.1*FLOAT( NINT(10.*(XB1 - XB2)) )
c     BY = 0.1*FLOAT( NINT(10.*(YB1 - YB2)) )
c     CX = 0.1*FLOAT( NINT(10.*(XE2 - XB2)) )
c     CY = 0.1*FLOAT( NINT(10.*(YE2 - YB2)) )
c     EX = 0.1*FLOAT( NINT(10.*(XE1 - XE2 - XB1 + XB2)) )
c     EY = 0.1*FLOAT( NINT(10.*(YE1 - YE2 - YB1 + YB2)) )
C
C ### CHECK FOR TANGENTIAL (I.E., 0 < S < 1 ) PENETRATION AT T=0,1.
C
C --- CONSIDER FIRST THE T=0 SITUATION.
      A2 = BX * BX  +  BY * BY
      A1 = AX * BX  +  AY * BY
      S = -9.
      IF(ABS(A2).GT.SMALL) S = -A1 / A2
      IF(S .LT. 0.0) GO TO 10
      IF(S .GT. 1.0) GO TO 10
      AXS = AX + BX * S
      AYS = AY + BY * S
      R2TEST = AXS * AXS  + AYS * AYS
c     WRITE(*,1002) S,R2TEST
c     WRITE(io6,1002) S,R2TEST
c1002 FORMAT(' SLGTLIM:T0/TAN S,R2TEST=',2G12.4)
      IF(R2TEST.LT.R2) TMIN = -0.1
C
C
C --- CONSIDER NEXT THE T=1 SITUATION.
   10 AXT = AX + CX
      AYT = AY + CY
      BXT = BX + EX
      BYT = BY + EY
      A2 = BXT * BXT  +  BYT * BYT
      A1 = AXT * BXT  +  AYT * BYT
      S = -9.
      IF(ABS(A2).GT.SMALL) S = -A1 / A2
      IF(S .LT. 0.0) GO TO 20
      IF(S .GT. 1.0) GO TO 20
      AXS = AXT + BXT * S
      AYS = AYT + BYT * S
      R2TEST = AXS * AXS  + AYS * AYS
c     WRITE(*,1004) S,R2TEST
c     WRITE(io6,1004) S,R2TEST
c1004 FORMAT(' SLGTLIM:T1/TAN S,R2TEST=',2G12.4)
      IF(R2TEST.LT.R2) TMAX = 1.1
C
C     DO CONDITIONAL TEST ON TMIN,TMAX. IF THIS TEST PASSES,
C     THEN THERE IS PENETRATION OF THE CIRCLE BY THE FINITE SLUG
C     AT THE BEGINNING AND/OR END OF THE TIME STEP.
   20 IF(TMIN.LT.0.0 .AND. TMAX.GT.1.0) GO TO 100
C
C----------------------------------------------------------------
C $$$ IF WE'VE REACHED THIS POINT IN THE CODE THEN ANY INTRUSION
C     OF THE FINITE SLUG INTO THE CIRCLE OF RADIUS R ABOUT THE
C     RECEPTOR MUST BE A DYNAMIC FUNCTION OF TIME.
C
C ### END POINT PENETRATIONS AT  0 < T < 1.
C
C --- CONSIDER FIRST THE #2 (OR S=0) END OF THE SLUG.
C
      A2 = CX * CX  +  CY * CY
      A1 = TWO * (AX * CX  +  AY * CY)
      A0 = AX * AX  +  AY * AY  -  R2
      CALL ROOT2(A2,A1,A0,NR,RT)
c     WRITE(*,1001) NR,(RT(II),II=1,NR)
c     WRITE(io6,1001) NR,(RT(II),II=1,NR)
c1001 FORMAT(' SLGTLIM:S0/END NR,T(I) =',I3,3G12.4)
      IF(NR.GT.0) THEN
                  DO 30 I=1,NR
                  T = RT(I)
                  IF(T .LT. TMIN) TMIN = T
                  IF(T .GT. TMAX) TMAX = T
   30             CONTINUE
                  ENDIF
C
C
C --- CONSIDER NEXT THE #1 (OR S=1) END OF THE SLUG.
C
      AXS = AX + BX
      AYS = AY + BY
      CXS = CX + EX
      CYS = CY + EY
      A2 = CXS * CXS  +  CYS * CYS
      A1 = TWO * (AXS * CXS  +  AYS * CYS)
      A0 = AXS * AXS  +  AYS * AYS  -  R2
      CALL ROOT2(A2,A1,A0,NR,RT)
c     WRITE(*,1003) NR,(RT(II),II=1,NR)
c     WRITE(io6,1003) NR,(RT(II),II=1,NR)
c1003 FORMAT(' SLGTLIM:S1/END NR,T(I) =',I3,3G12.4)
      IF(NR.GT.0) THEN
                  DO 40 I=1,NR
                  T = RT(I)
                  IF(T .LT. TMIN) TMIN = T
                  IF(T .GT. TMAX) TMAX = T
   40             CONTINUE
                  ENDIF
C
C --- WE COULD DO CONDITIONAL TEST ON TMIN,TMAX. IF THIS TEST PASSES,
C I.E., IF(TMAX.GT.TMIN .AND. TMIN.LT.1.0 .AND. TMAX.GT.0.0) GO TO 100,
C     THEN THERE IS END POINT PENETRATION AT SOMETIME WITHIN THE
C     TIME STEP; HOWEVER, THERE IS NO GUARANTEE THAT THE END POINT
C     MADE THE FIRST PENETRATION.  THAT IS, THE FINITE PORTION OF THE
C     SLUG MAY HAVE MADE AN EARLIER PENETRATION OF THE CIRCLE.  THIS
C     PROBLEM THE CALLS FOR THE SOLUTION OF THE QUARTIC EQUATION
C     INVOLVING BOTH VARIABLE T AND S.
C ### TANGENTIAL PENETRATIONS AT  0 < T < 1.
C
C --- FORM NEEDED PRODUCTS.
      AB = AX * BY - AY * BX
      AD = AX * EY - AY * EX
      BD = BX * EX + BY * EY
      BB = BX * BX + BY * BY
      CB = CX * BY - CY * BX
      CD = CX * EY - CY * EX
      ADCB = AD + CB
      DD = EX * EX + EY * EY
C --- CONSIDER PENETRATION OF THE SQUARE WITH DIMENSION R INSTEAD,
C     AS THIS REDUCES THE PROBLEM TO A CUBIC.
C
C --- DETERMINE CUBIC COEFFS. FOR X INTERCEPTION AT +R.
      A3 = EY * CD
      PROD2 = EY * ADCB  +  BY * CD
      A2 = PROD2  +  R * DD
      PROD1 = BY * ADCB  +  EY * AB
      A1 = PROD1  +  TWO * R * BD
      A0 = BY * AB  +  R * BB
      CALL ROOT3(A3,A2,A1,A0,NR,RT)
c     CALL DROOT3(A3,A2,A1,A0,NR,RT)
C --- CHECK REAL ROOTS FOR FINITE LINE INTERCEPT.
      IF(NR.GT.0) THEN
                  DO 50 I=1,NR
                  T = RT(I)
                  CALL FINLINI(AX,BX,CX,EX,AY,BY,CY,EY,T,R2,TMIN,TMAX)
   50             CONTINUE
                  ENDIF
C
C
C --- DETERMINE CUBIC COEFFS. FOR X INTERCEPTION AT -R.
      A3 = EY * CD
      A2 = PROD2  -  R * DD
      A1 = PROD1  -  TWO * R * BD
      A0 = BY * AB  -  R * BB
      CALL ROOT3(A3,A2,A1,A0,NR,RT)
c     CALL DROOT3(A3,A2,A1,A0,NR,RT)
C --- CHECK REAL ROOTS FOR FINITE LINE INTERCEPT.
      IF(NR.GT.0) THEN
                  DO 60 I=1,NR
                  T = RT(I)
                  CALL FINLINI(AX,BX,CX,EX,AY,BY,CY,EY,T,R2,TMIN,TMAX)
   60             CONTINUE
                  ENDIF
C
C
C --- DETERMINE CUBIC COEFFS. FOR Y INTERCEPTION AT +R.
      A3 = EX * CD
      PROD2 = EX * ADCB  +  BX * CD
      A2 = PROD2  +  R * DD
      PROD1 = BX * ADCB  +  EX * AB
      A1 = PROD1  +  TWO * R * BD
      A0 = BX * AB  +  R * BB
      CALL ROOT3(A3,A2,A1,A0,NR,RT)
c     CALL DROOT3(A3,A2,A1,A0,NR,RT)
C --- CHECK REAL ROOTS FOR FINITE LINE INTERCEPT.
      IF(NR.GT.0) THEN
                  DO 70 I=1,NR
                  T = RT(I)
                  CALL FINLINI(AX,BX,CX,EX,AY,BY,CY,EY,T,R2,TMIN,TMAX)
   70             CONTINUE
                  ENDIF
C
C
C --- DETERMINE CUBIC COEFFS. FOR Y INTERCEPTION AT -R.
      A3 = EX * CD
      A2 = PROD2  -  R * DD
      A1 = PROD1  -  TWO * R * BD
      A0 = BX * AB  -  R * BB
      CALL ROOT3(A3,A2,A1,A0,NR,RT)
c     CALL DROOT3(A3,A2,A1,A0,NR,RT)
C --- CHECK REAL ROOTS FOR FINITE LINE INTERCEPT.
      IF(NR.GT.0) THEN
                  DO 80 I=1,NR
                  T = RT(I)
                  CALL FINLINI(AX,BX,CX,EX,AY,BY,CY,EY,T,R2,TMIN,TMAX)
   80             CONTINUE
                  ENDIF
C
C     DO CONDITIONAL TEST ON TMIN,TMAX. IF THIS TEST PASSES,
C     THEN THERE IS PENETRATION AT SOMETIME WITHIN THE
C     TIME STEP.
      IF(TMAX.GT.TMIN .AND. TMIN.LT.1.0 .AND. TMAX.GT.0.0) GO TO 100
C
C-------------------------------------------------------------------
C $$$ IF WE'VE REACHED THIS POINT AND NOT SATISFIED ANY OF THE ABOVE
C     CONDITIONS THEN FORGET ABOUT A NUMERICAL INTEGRATION AS THERE
C     IS NO SLUG PENETRATION OF THE REGION IN THE PERIOD OF INTEREST.
      ITF = 0
      RETURN
c*****
c *** write(io6,debug5)
c *** write(io6,debug6)
c*****
C
  100 ITF = 1
      TSTART = AMAX1(0.0,TMIN)
      TEND   = AMIN1(1.0,TMAX)
      RETURN
      END
c----------------------------------------------------------------------
      SUBROUTINE FINLINI(AX,BX,CX,EX,AY,BY,CY,EY,T,R2,TMIN,TMAX)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900228                FINLINI
c                R. Yamartino, SRC
c
c --- PURPOSE:  Check real roots for FInite LINe Intercept.
c               For a specific time T, this routine computes the point
c               on the line segment where the intersection with the
c               receptor perimeter(circle or square) occurs.
c               If that intercept yields an S such that 0 < S < 1, then
c               the intersection falls on the finite portion of the line
c               and is of interest. If S is outside this domain, we
c               RETURN without altering TMIN,TMAX integration limits.
c               12/18/87.
c
c
c --- INPUTS:
c
c                AX - real    - X-distance (m) from slug end 2 to
c                               receptor at time T=0. (m)
c                               AX = XB2 - X
c                BX - real    - X-distance (m) from slug end 2 to slug
c                               end 1 at time T=0. (m)
c                               BX = XB1 - XB2
c                CX - real    - X-distance (m) from slug end 2 at T=1 to
c                               slug end 2 at time T=0. (m)
c                               CX = XE2 - XB2
c                EX - real    - X-slug shear (m) defined as
c                               EX = XE1 - XE2 - (XB1 - XB2)
c                AY - real    - Y-distance (m) from slug end 2 to
c                               receptor at time T=0. (m)
c                               AY = YB2 - Y
c                BY - real    - Y-distance (m) from slug end 2 to slug
c                               end 1 at time T=0. (m)
c                               BY = YB1 - YB2
c                CY - real    - Y-distance (m) from slug end 2 at T=1 to
c                               slug end 2 at time T=0. (m)
c                               CY = YE2 - YB2
c                EY - real    - Y-slug shear (m), defined as
c                               EY = YE1 - YE2 - (YB1 - YB2)
c                 T - real    - Dimensionless current time: 0 < T < 1
c                R2 - real    - Radius squared of intercept circle
c                               about receptor (m**2)
c
c     Parameters:
c        IO6
c
c --- OUTPUTS:
c
c              TMIN - real    - Updated start of integrand sampling
c                               at time:  t + tstart * dt
c              TMAX - real    - Updated end of integrand sampling
c                               at time:  t + tend * dt
c
c --- FINLINI called by:  SLGTLIM
c --- FINLINI calls:      none
c----------------------------------------------------------------------
c
      DATA FR2/2.5/
C
      ALFX = AX  +  CX * T
      ALFY = AY  +  CY * T
      BETX = BX  +  EX * T
      BETY = BY  +  EY * T
      BET2 = BETX * BETX  +  BETY * BETY
      IF(BET2 .LT. 1.0E-30) BET2 = 1.0E-30
      SI = -(ALFX * BETX  +  ALFY * BETY) / BET2
      IF(SI .GT. 1.0) GO TO 50
      IF(SI .LT. 0.0) GO TO 50
C --- At this point 0 < SI < 1 and we have actual tangential
c     penetration of zone via the finite line segment.
c --- Check total length of perpendicular line from receptor.
c --- XL2 = QI**2  *  BET2
      XL2 = (ALFX * BETY  -  ALFY * BETX)**2 / BET2
      IF(XL2 .GT. (FR2*R2)) GO TO 50
C --- N.B.: The factor FR2 accounts for distance to a corner. Diagonal
C --- of (1.414*R)**2=2.0*R**2.  We use 2.5>2.0 to avoid roundoff.
c +++ Store adjusted TMIN,TMAX
      IF(T .LT. TMIN) TMIN = T
      IF(T .GT. TMAX) TMAX = T
c     WRITE(*,1001) SI,T
c     WRITE(io6,1001) SI,T
c1001 FORMAT(' FINLINI: SI,T =',2G12.4)
   50 RETURN
      END
c----------------------------------------------------------------------
      subroutine slugint(ldb,iint,lwflux,x,y,z,
     x           zpr,tfacc,syrb,szrb,syre,szre,hlid,
     x           ccqb,ccdq,ccizqb,ccizdq)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                SLUGINT
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the time-average coupling coefficients (s/m**3)
c               at the point (x,y,z) over the time period T to T+DT
c                (where DT is a time step and TDDT
c                is the fraction of DT that is elapsed).
c
c --- UPDATE
c --- V5.0-V5.4     000602  (DGS): recalculate exponentials after the
c                                  SIGCUT test for receptors that this
c                                  slug impacts
c --- V5.0-V5.0     980918  (DGS): add area source distribution factor
c --- V5.0-V5.0     980430  (DGS): 'Use' TFACC (compiler warning)
c --- V4.0-V5.0     971107  (DGS): add debug option
c                   971107  (DGS): add check for slug passing receptor
c                                  along slug-axis
c                   971107  (DGS): pass ICODE to VCOUP from /CURRENT/
c --- V4.0-V4.07    971107  (DGS): add PDF logic for VCOUP calls
c --- V4.0-V5.0     971107  (DGS): package slug geometry in SLGFRAC
c
c --- INPUTS:
c
c               LDB - logical - Report debug info when TRUE
c              IINT - logical - Gives the status of the integration;
c                               -1 : numerical integration must be done.
c                                0 : conc=0 and no further work be done.
c                               +1 : conc is correct as is.
c            LWFLUX - logical - Receptor specific wet deposition flag
c                                .true. if calculation is to be made
c                                .false. if not.
c         (X, Y, Z) - real    - Coordinates of the receptor (m)
c               ZPR - real    - Height (m) of the plume above receptor
c                               terrain height.
c             TFACC - real    - Cross-slug T factor to account for shear
c       (SYRB,SZRB) - real    - Sigmas at the receptor before T factor.
c                               At beginning of time step.
c       (SYRE,SZRE) - real    - Sigmas at the receptor before T factor.
c              HLID - real    - Relevant mixing depth (m) at receptor.
c
c     Common Block /CURRENT/ variables:
c        XB1, YB1, ZB1, SYB1, SZB1,
c        XE1, YE1, ZE1, SYE1, SZE1,
c        XB2, YB2, ZB2, SYB2, SZB2,
c        XE2, YE2, ZE2, SYE2, SZE2,
c        SPEEDI, SRAT, ICODE
c     Common Block /PDF/ variables:
c        LPDF, SWUPF, SWDNF, SZUPB, SZDNB, WTUP, WTDN, ZUP, ZDN, RFACSQ
c     Parameters:
c        none
c
c --- OUTPUTS:
c
c              CCQB - real    - Coupling coefficient (s/m**3) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c              CCDQ - real    - Coupling coefficient (s/m**3) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c            CCIZQB - real    - Z-integrated coefficient (s/m**2) for
c                               the source rate ,QB, at the
c                               beginning of the time step.
c            CCIZDQ - real    - Z-integrated coefficient (s/m**2) for
c                               the change in source rate, DQ, between
c                               the beginning and end of the time step.
c
c --- SLUGINT called by:  SLUGAVE
c --- SLUGINT calls:      VCOUP, ERF, SLGFRAC, ASDF
c----------------------------------------------------------------------
c
c --- Include common blocks
      include 'params.puf'
      include 'current.puf'
      include 'pdf.puf'
c
      logical lwflux,ldb
c
      DATA SRTHAF/0.7071/,HALF/0.5/,SMALL/1.0E-10/,VSMALL/1.0E-20/
      DATA SRT2PI/2.506628/,SRTPI/1.772454/
      DATA ERFCUT/3.0/,SIGCUT/3.0/,TOL/0.01/
C --- NOTE THAT TOL ALLOWS THE ALONGWIND CAUSALITY FACTOR
C     TO VARY AS MUCH AS THE FRACTION 2 * TOL.
c
c --- Set limit for argument of EXP (expmx=69.)
      data rtexpmx/8.3/
C
C --- DETERMINE THE CURRENT COORDINATES OF THE SLUG END-POINTS.
C     X1 = XB1 + TDDT * (XE1 - XB1)
C     Y1 = YB1 + TDDT * (YE1 - YB1)
C     Z1 = ZB1 + TDDT * (ZE1 - ZB1)
C
C     X2 = XB2 + TDDT * (XE2 - XB2)
C     Y2 = YB2 + TDDT * (YE2 - YB2)
C     Z2 = ZB2 + TDDT * (ZE2 - ZB2)
C --- DETERMINE THE LENGTH AND ORIENTATION OF THE SLUG
C --- DEFINE THE POSITION OF THE RECEPTOR RELATIVE TO SLUG END 2
C --- CONVERT RECEPTOR POSITION TO ALONG-SLUG AND CROSS-SLUG AXIS
C     AT TIMES T=0 (ENDS WITH B) AND T=1 (ENDS WITH E).
      call SLGFRAC(x,y,xb1,yb1,xb2,yb2,
     &             rhoab,rhocb,fracsb,dxy12b,rdxy12b)
      call SLGFRAC(x,y,xe1,ye1,xe2,ye2,
     &             rhoae,rhoce,fracse,dxy12e,rdxy12e)
C --- CONSTRAIN FRACS TO BE 0.0 TO 1.0 FOR THE ACTUAL SLUG.
      FRACSB = AMAX1(0.0,FRACSB)
      FRACSB = AMIN1(1.0,FRACSB)
      FRACSE = AMAX1(0.0,FRACSE)
      FRACSE = AMIN1(1.0,FRACSE)
C --- NOTE THAT IN X-Y SPACE THE COORDINATES OF THE POINT (XP,YP,ZP)
C     CORRESPONDING TO RHOC = 0 (I.E., RHOA ALONG THE SLUG AXIS) ARE
C     XP = X2  +  RHOA * SINOM
C     YP = Y2  +  RHOA * COSOM
C OR  XP = X2  +  FRACS * (X1 - X2)  IF WITHIN SLUG BOUNDS.
C OR  YP = Y2  +  FRACS * (Y1 - Y2)  IF WITHIN SLUG BOUNDS.
c
      RHOCPRO = RHOCB * RHOCE
      FRACT = 0.0
      IF(RHOCPRO.LT.0.0) FRACT=ABS(RHOCB/(ABS(RHOCB)+ABS(RHOCE)+SMALL))
      IF(RHOCPRO.GE.0.0 .AND. ABS(RHOCB).GT.ABS(RHOCE) ) FRACT = 1.0
      FRACT = AMAX1(0.0,FRACT)
      FRACT = AMIN1(1.0,FRACT)
      OMFRACT = 1.0 - FRACT
      IF(FRACT.EQ.1.0) OMFRACT = 0.0
c
      sy =  fract * syre  +  omfract * syrb
      sz =  fract * szre  +  omfract * szrb
      dy =  0.0
      if(rhocpro.GT.0.) dy = fract*rhoce + omfract*rhocb
c
c --- Include the effect of the crosswind T factor on syint.
c     Note that the following statement allows sy to experience growth
c     but not shrinkage.  To allow shrinkage as well, one need only have
c     sy = syint * tfacc
c     sy = syint * amax1(1.0,tfacc)
c --- 'Use' TFACC without applying it to sy
      tfacc=tfacc
c*****
      if(LDB) then
      write(io6,*)'------------------ slugint ---------------'
      write(io6,*)'        rhoab,rhocb = ',rhoab,rhocb
      write(io6,*)'        rhoae,rhoce = ',rhoae,rhoce
      write(io6,*)'      fracsb,fracse = ',fracsb,fracse
      write(io6,*)'          syrb,syre = ',syrb,syre
      write(io6,*)'           fract,dy = ',fract,dy
      write(io6,*)'              sy,sz = ',sy,sz
      endif
c*****
C
C
C *** ALL COORDINATES READY ! NOW COMPUTE COUPLING COEFFICIENT FOR
C     A UNIT SOURCE (Q = 1 UG/SEC)
      ccqb = 0.0
      ccdq = 0.0
      ccizqb = 0.0
      ccizdq = 0.0
      IINT = 0

c --- Screen out cases where slug moves across receptor along its axis
c --- This is a severe test for this case; more care could be taken!
      if(fracsb.EQ.1.0 .AND. fracse.EQ.0.0) then
c ---    Numerical treatment needed
         iint=-1
         goto 100
      endif

C
C --- CHECK IF ANY VERTICAL COUPLING.
c --- Note that we use receptor-specific slug height (m) now!
c     vertb = vcoup(icode,z,zpb,sz,hlid)
c     verte = vcoup(icode,z,zpe,sz,hlid)
      if(LPDF) then
         szsq=sz**2
         szdn=SQRT(szsq*swdnf+szdnb*rfacsq)
         szup=SQRT(szsq*swupf+szupb*rfacsq)
         vertb = wtdn*VCOUP(icode,z,zdn,szdn,hlid) +
     &           wtup*VCOUP(icode,z,zup,szup,hlid)
      else
         vertb = vcoup(icode,z,zpr,sz,hlid)
      endif
      verte = vertb
C --- Sum the contributions and test.  Average later.
      vert =  vertb + verte
      if(.not.lwflux  .and.  vert .lt. small) go to 100
C
C --- CHECK IF ANY CROSS-SLUG DISTANCE COUPLING.
      PHICB = RHOCB / SY
      PHICE = RHOCE / SY
C
      SRAT2 = SRAT * SRAT
      EXPYB = 0.0
      IF(ABS(PHICB) .LE. SIGCUT) EXPYB = EXP(-HALF * SRAT2 *PHICB*PHICB)
      EXPYE = 0.0
      IF(ABS(PHICE) .LE. SIGCUT) EXPYE = EXP(-HALF * SRAT2 *PHICE*PHICE)
C --- IF A CROSSOVER EXISTS THEN CONTRIBUTION TO INTEGRAL COULD COME
C     BETWEEN T=0 AND T=1 AND NOT PEAK AT ENDPOINT; HENCE,
      IF((PHICB * PHICE) .LE. 0.0) GO TO 20
      IF(EXPYB .LT. SMALL  .AND.  EXPYE .LT. SMALL) GO TO 100
C
C --- CHECK IF ANY ALONG-SLUG DISTANCE COUPLING.
   20 PHIA2B = SRTHAF * RHOAB / SYB2
      PHIA1B = SRTHAF * (RHOAB - DXY12B) / SYB1
      PRODB = PHIA2B * PHIA1B
      PHIA2E = SRTHAF * RHOAE / SYE2
      PHIA1E = SRTHAF * (RHOAE - DXY12E) / SYE1
      PRODE = PHIA2E * PHIA1E
C --- IF A CROSSOVER EXISTS THEN CONTRIBUTION TO INTEGRAL COULD COME
C     BETWEEN T=0 AND T=1 AND NOT PEAK AT ENDPOINT; HENCE,
      IF((PHIA1B * PHIA1E) .LE. 0.0) GO TO 30
      IF((PHIA2B * PHIA2E) .LE. 0.0) GO TO 30
C --- IF SLUG ALWAYS WELL AWAY FROM RECEPTOR (AND NO CROSSOVER
C     OCCURRED), THE CONTRIBUTION IS ZERO.
      IF(PRODB.GT.0.0           .AND.  PRODE.GT.0.0           .AND.
     X   ABS(PHIA1B).GT.ERFCUT  .AND.  ABS(PHIA2B).GT.ERFCUT  .AND.
     X   ABS(PHIA1E).GT.ERFCUT  .AND.  ABS(PHIA2E).GT.ERFCUT) GO TO 100
C
C --- ALL OBVIOUS CONC = 0 CASES HAVE NOW BEEN ELIMINATED SO CHECK
C     IF VERTICAL COUPLING AND ALONG-SLUG CAUSALITY FACTORS ARE TIME-
C     INDEPENDENT ENOUGH TO JUSTIFY ANALYTIC INTEGRATION (IINT = +1)
C     OR A NUMERICAL INTEGRATION (IINT = -1) MUST BE DONE.
 30   IINT = -1
C --- CHECK VERTICAL COUPLING.
      IF((ABS(VERTB-VERTE)/(VERT+SMALL)).GT.TOL) GO TO 100
      vert = half * vert
C
C --- CHECK ALONG-SLUG VARIABILITY.
      ERFA1B = 1.0
      IF(PHIA1B.LT.0.0) ERFA1B = -1.0
C     NOTE THAT FOR ERFCUT = 3, ERF(ERFCUT) = 0.999978
      IF(ABS(PHIA1B) .LE. ERFCUT) ERFA1B = ERF(PHIA1B)
      ERFA1E = 1.0
      IF(PHIA1E.LT.0.0) ERFA1E = -1.0
      IF(ABS(PHIA1E) .LE. ERFCUT) ERFA1E = ERF(PHIA1E)
      ERFSUM = ABS(ERFA1B) + ABS(ERFA1E) + SMALL
      IF((ABS(ERFA1B-ERFA1E)/ERFSUM).GT.TOL) GO TO 100
C
      ERFA2B = 1.0
      IF(PHIA2B.LT.0.0) ERFA2B = -1.0
      IF(ABS(PHIA2B) .LE. ERFCUT) ERFA2B = ERF(PHIA2B)
      ERFA2E = 1.0
      IF(PHIA2E.LT.0.0) ERFA2E = -1.0
      IF(ABS(PHIA2E) .LE. ERFCUT) ERFA2E = ERF(PHIA2E)
      ERFSUM = ABS(ERFA2B) + ABS(ERFA2E) + SMALL
      IF((ABS(ERFA2B-ERFA2E)/ERFSUM).GT.TOL) GO TO 100
C
C --- COMPUTE THE CAUSALITY FACTOR FCAUS.
      FCAUSB = HALF * (ERFA2B - ERFA1B)
      if(erfa2b .eq. erfa1b) fcausb = 0.0
c
      FCAUSE = HALF * (ERFA2E - ERFA1E)
      if(erfa2e .eq. erfa1e) fcause = 0.0
c
      ERFSUM = ABS(FCAUSB) + ABS(FCAUSE) + SMALL
      IF((ABS(ERFA1B-ERFA1E)/ERFSUM).GT.TOL) GO TO 100
c
c --- Add symmetric test to end #2  10/12/89
      if((abs(erfa2b-erfa2e)/erfsum).gt.tol) go to 100
c
      FCAUS = HALF * (FCAUSB + FCAUSE)
      IF(FCAUS .LT. SMALL) GO TO 100
C
C
C --- AT THIS POINT THE CAUSALITY FACTOR IS LARGE AND UNIFORM ENOUGH TO
C     REMOVE IT FROM THE INTEGRAL AND INTEGRATE JUST THE EXPONENTIAL
C     TERMS.
      IINT = +1
C ***************** INSERT THE INTEGRALS *****************************
C
c --- Insert the factor srat/sqrt(2) into PHI limits.
      PHICB = SRTHAF * SRAT * PHICB
      PHICE = SRTHAF * SRAT * PHICE
      phicd = phice - phicb
c
c --- Recompute the exponentials (expyb,expye) without SIGCUT limit
      if(ABS(phicb).LT.rtexpmx) expyb = EXP(-phicb*phicb)
      if(ABS(phice).LT.rtexpmx) expye = EXP(-phice*phice)
c
c
      expy0 = half * (expyb + expye)
c     The extra half in expy1 comes from half*t**2 from integral
      expy1 = half * expy0
c
c --- TOL=0.01 at large phi limits could cause up to a 4%
c     difference between expyb and expye and hence a 2% error in
c     the average.  Use of tol/2 should cut this back to 1% as desired;
c     however, erfdif accuracy drops off if phicd too small.  Hence,
c     stick with TOL.  2*TOL also tried but TOL appears good compromise.
c     if(abs(phicd).gt.(half*tol)) then
c     if(abs(phicd).gt.(2.0*tol))  then
      if(abs(phicd) .gt. tol)      then
                   expy0 = half * srtpi * erfdif(phice,phicb) / phicd
                   phicd2 = phicd * phicd
                   expy11 = half * (expyb - expye) / phicd2
                   expy1 = expy11  -  phicb * expy0 / phicd
                                    endif
c
c --- Compute the time-average conc. terms for unit emission rate,
c --- including correction factor for cross-slug distribution from
c --- area sources
      ccoup = ASDF(ldbhr,dy,sy) * fcaus  /  (srt2pi * speedi * sy)
c --- ccoup can legitimately get quite small (e.g., (e-4.5)/sy**2 or
c     of order small for sy=10 km), hence introduce vsmall.
      if(ccoup .lt. vsmall) go to 100
c
      if(expy0 .gt. small) then
                           ccizqb = ccoup * expy0
                           ccqb = vert * ccizqb
                           endif
      if(abs(expy1) .gt. small) then
                                ccizdq = ccoup * expy1
                                ccdq = vert * ccizdq
                                endif

c *** write(6,*)'Integrated -- slugint = ',slugint,'  vert = ',vert,
c ***1 '  expy = ',expy,'  fcaus = ',fcaus,'  twopi = ',twopi,
c ***2 '  speedi = ',speedi,'  sy = ',sy,'  sz = ',sz
c*****
C
C
  100 RETURN
      END
c----------------------------------------------------------------------
      SUBROUTINE XERFDIF(XU,XL,X0ERF,X1ERF)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040913                XERFDIF
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the integral of X**N * ERF(X) from XL to XU
c               for N = 0 the quantity X0ERF is computed and
c               for N = 1 the quantity X1ERF is computed.
c
c --- UPDATE
c --- 900228 - V5.741 040913 (DGS):  Fix bug that produces an error in
c                                    integral F1. This affects the 
c                                    analytic SLUG sampling when the
c                                    mass in a slug changes during a
c                                    sampling step. Analytic sampling
c                                    is done for emitting slugs
c                                    (youngest end is at the source).
c
c --- INPUTS:
c
c                XU - real    - Upper limit of integral (no units)
c                XL - real    - Lower limit of integral (no units)
c
c --- OUTPUTS:
c
c             X0ERF - real    - Integral of erf(X) over XL < X < XU
c             X1ERF - real    - Integral of X * erf(X) over XL < X < XU
c
c --- XERFDIF called by:  SLUGINT, SLUGAVE
c --- XERFDIF calls:      ERF
c----------------------------------------------------------------------
c
      data one/1.0/,half/0.5/,fourth/0.25/,zero/0.0/
      data erfcut/3.0/,srtpi/1.772454/
c
      expxu = zero
      erfxu = one
      if(xu.lt.0.0) erfxu = -one
c     Note that for erfcut = 3, erf(erfcut) = 0.999978
      if(abs(xu) .le. erfcut) then
                             erfxu = erf(xu)
                             expxu = exp(-xu * xu)
                             endif
c
      expxl = zero
      erfxl = one
      if(xl.lt.0.0) erfxl = -one
c     Note that for erfcut = 3, erf(erfcut) = 0.999978
      if(abs(xl) .le. erfcut) then
                             erfxl = erf(xl)
                             expxl = exp(-xl * xl)
                             endif
c
      x0erf = (xu*erfxu + expxu/srtpi) - (xl*erfxl + expxl/srtpi)
      x1erf = (half*xu*(xu*erfxu + expxu/srtpi) - fourth*erfxu) -
     &        (half*xl*(xl*erfxl + expxl/srtpi) - fourth*erfxl)
c
      return
      end
c----------------------------------------------------------------------
      FUNCTION ERFDIF(X1,X2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900228                 ERFDIF
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the difference: erfdif = erf(x1) - erf(x2).
c               Various methods are used to avoid roundoff errors
c               depending on the values of the two arguments.
c
c --- INPUTS:
c
c                X1 - real    - Argument 1 (no units)
c                X2 - real    - Argument 1 (no units)
c
c --- OUTPUTS:
c
c            ERFDIF - real    - erf(x1) - erf(x2)
c
c --- ERFDIF called by:  SLUGINT,SLUGAVE,SLUGSNP
c --- ERFDIF calls:      ERF,ERFC
c----------------------------------------------------------------------
C *** V3.21
c
      ERFDIF=0.0
      IF(X1.EQ.X2) GO TO 40
      IF((X1*X2).LE.0.0) GO TO 50
      XTEST=ABS(X2)
      IF(ABS(X1).LT.XTEST) XTEST=ABS(X1)
c --- Some compilers cannot handle reals .LT. 1.18e-38, so reset cut
c     IF(XTEST.GE.13.306) GO TO 40
      if(xtest .GE. 9.15) GO TO 40
      IF(XTEST.LT.0.47) GO TO 50
C     CAN ONLY REACH HERE WHEN X1 AND X2 HAVE SAME SIGN.
      ISIGN=1
      XX1=X1
      XX2=X2
      IF(X1.GT.0.0) GO TO 30
      ISIGN=-1
      XX1=-XX1
      XX2=-XX2
C  30 ERFDIF=ISIGN*(ERFC(XX2)-ERFC(XX1))
   30 ERFCX1=0.0
      ERFCX2=0.0
c --- Some compilers cannot handle reals .LT. 1.18e-38, so reset cut
c     IF(XX1.LT.13.306) ERFCX1=ERFC(XX1)
c     IF(XX2.LT.13.306) ERFCX2=ERFC(XX2)
      if(xx1 .LT. 9.15) erfcx1=ERFC(xx1)
      if(xx2 .LT. 9.15) erfcx2=ERFC(xx2)
      ERFDIF=ISIGN*(ERFCX2-ERFCX1)
c --- Protect against flakey LAHEY compiler 4/9/89
      if(erfcx2.eq.erfcx1) erfdif=0.0
   40 RETURN
   50 ERFDIF=ERF(X1)-ERF(X2)
      RETURN
      END
c-----------------------------------------------------------------------
      FUNCTION ERF(XX)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941228                     ERF
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the error function, erf(x).
c ---           This is the Quick medium accuracy ERROR FUNCTION from
c ---           NBS 55.  Using an approximation due to Hastings;
c ---           absolute error about 3e-7
c
c
c --- INPUTS:
c
c                XX - real    - Argument  (no units)
c
c --- OUTPUTS:
c
c               ERF - real    - error function of x
c
c --- ERF called by:  SLUGINT, SLUGAVE, SLUGSNP, ERFDIF, XERFDIF
c --- ERF calls:   no routines
c----------------------------------------------------------------------
c
      real x, xx ,t, t16, a(6)
      data a/0.0000430638, 0.0002765672, 0.0001520143,
     *       0.0092705272, 0.0422820123, 0.0705230784/
      data xcut/ 3.919206/
c
      x = abs(xx)
      if(x .gt. xcut) then
         t16 = 0.0
      else
c
         t = ((((((((( a(1)*x + a(2) ) * x ) + a(3) ) * x ) + a(4) ) *
     x                    x ) + a(5) ) * x ) + a(6) ) * x
c
         t = 1.0 / (t + 1.0)
c
         t16 = t * t * t * t
         t16 = t16 * t16 * t16 * t16
      endif
c
      if(xx .gt. 0.0) then
         erf =  1.0 - t16
      else
         erf =  t16 - 1.0
      endif
c
      return
      end
c-----------------------------------------------------------------------
      FUNCTION ERFC(XX)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 941228                    ERFC
c                R. Yamartino, SRC
c
c --- PURPOSE:  Computes the complementary error function, 1-erf(x).
c ---           This is the Quick medium accuracy COMP. ERROR FUNCTION
c ---           from NBS 55.  Using an approximation due to Hastings;
c ---           absolute error about 3e-7.  Asymptotic expression added
c ---           for large xx to reduce percent error.
c
c
c --- INPUTS:
c
c                XX - real    - Argument  (no units)
c
c --- OUTPUTS:
c
c              ERFC - real    - complementary error function of x
c
c --- ERFC called by:  ERFDIF
c --- ERFC calls:   no routines
c-----------------------------------------------------------------------
c
      real x, xx ,t, t16, a(6)
      data a/0.0000430638, 0.0002765672, 0.0001520143,
     *       0.0092705272, 0.0422820123, 0.0705230784/
      data xcutl/-3.919206/
      data xcuth/13.306   /
      data rtpii/0.5641896/
c
      if(xx .gt. xcuth) then
         erfc = 0.0
c
      elseif(xx .lt. xcutl) then
         erfc = 2.0
c
      elseif(xx .gt. 2.79) then
         x = abs(xx)
         z = 1.0 / x
         erfc = rtpii * z * exp(-x*x) * ( 1.0 - 0.5*z*z*(1.0-1.5*z*z) )
c
      else
         x = abs(xx)
         t = ((((((((( a(1)*x + a(2) ) * x ) + a(3) ) * x ) + a(4) ) *
     x                    x ) + a(5) ) * x ) + a(6) ) * x
c
         t = 1.0 / (t + 1.0)
c
c        erfc = t**16   for x > 0
         t16 = t * t * t * t
         t16 = t16 * t16 * t16 * t16
c
         if(xx .gt. 0.0) then
            erfc =  t16
         else
            erfc =  2.0 - t16
         endif
c
      endif
c
      return
      end
c----------------------------------------------------------------------
      SUBROUTINE ROOT3(AA3,AA2,AA1,AA0,NR,RT)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900228                  ROOT3
c                R. Yamartino, SRC
c
c --- PURPOSE:  Solves for NR multiple roots RT(I) of the cubic equation
c               AA3 * Z**3  +  AA2 * Z**2  +  AA1 * Z  +  AA0  =  0
c
c               Uses J. Scire's cubic routine modified to give all
c               all three roots.  This methodology is also described
c               in standard math handbooks such as,
c                      CRC STANDARD MATHEMATICAL TABLES
c                      W. H. Beyer, CRC Press, Boca Raton, Florida
c
c
c --- INPUTS:
c
c               AA3 - real    - Coefficient of Z**3 term (no units)
c               AA2 - real    - Coefficient of Z**2 term (no units)
c               AA1 - real    - Coefficient of Z**1 term (no units)
c               AA0 - real    - Coefficient of Z**0 term (no units)
c
c --- OUTPUTS:
c
c                NR - integer - Number of real roots found.
c                RT - real    - Array of real roots found.
c
c --- ROOT3 called by:  SLGTLIM
c --- ROOT3 calls:      none
c----------------------------------------------------------------------
      DIMENSION RT(3)
      DATA SMALL/1.0E-10/,TPID3/2.094395/,FPID3/4.188790/
      DATA ONE/1.0/,THIRD/0.3333333/
C
      IF(ABS(AA3).GT.SMALL) GO TO 5
      CALL ROOT2(AA2,AA1,AA0,NR,RT)
      RETURN
C
C --- CONVERT TO CUBIC'S NOTATION.
    5 AA3I = 1.0 / AA3
      A = AA2 * AA3I
      B = AA1 * AA3I
      C = AA0 * AA3I
C
C     SUBROUTINE CUBIC(A,B,C,Z)
C     SUBROUTINE CUBIC (VERSION 82102), PART OF BLP.
C      BLP   VERSION 4.1  LEVEL 800212     CUBIC
C     SOLVES FOR ONE ROOT OF THE CUBIC EQUATION:
C     Z**3 + A*Z**2 + B*Z + C = 0
C
      A3=A*THIRD
      AP=B-A*A3
      BP=A3*(2.*A3*A3 - B) + C
      AP3=AP*THIRD
      BP2=BP*0.5
      TROOT=BP2*BP2+AP3*AP3*AP3
      IF(TROOT.LE.0.0)GO TO 50
      TR=SQRT(TROOT)
C *** RJY PROTECTION AGAINST NEGATIVE RAISED TO REAL POWER.
      APV=(-BP2+TR)
c     IF(APV.LT.SMALL) WRITE(6,1001) APV,TR,BP2
c     IF(APV.LT.SMALL) WRITE(*,1001) APV,TR,BP2
c     APV = AMAX1(SMALL,APV)
 1001 format(' ***ROOT3: APV IS LT 0: APV,TR,BP2=',/,20X,3G12.5)
c *** APV=APV**THIRD  replaced with the following on 1/11/88
      SGN=SIGN(ONE,APV)
      APP=SGN*(ABS(APV))**THIRD
C********************************************************************
      BSV=-BP2-TR
      SGN=SIGN(ONE,BSV)
      BPP=SGN*(ABS(BSV))**THIRD
      Z=APP+BPP-A3
      RT(1) = Z
      NR = 1
      RETURN
C
50    CM=2.*SQRT(-AP3)
C *** pc modification
C     ALPHA=ARCOS(BP/(AP3*CM))*THIRD
      ALPHA=ACOS(BP/(AP3*CM))*THIRD
C ***
      Z = CM * COS(ALPHA) - A3
      RT(1) = Z
      Z = CM * COS(ALPHA + TPID3) - A3
      RT(2) = Z
      Z = CM * COS(ALPHA + FPID3) - A3
      RT(3) = Z
      NR = 3
      RETURN
      END
c----------------------------------------------------------------------
      SUBROUTINE DROOT3(AA3,AA2,AA1,AA0,NR,RT)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940831                 DROOT3
c                R. Yamartino, SRC
c                (Modified for double precision)
c
c --- PURPOSE:  Solves for NR multiple roots RT(I) of the cubic equation
c               AA3 * Z**3  +  AA2 * Z**2  +  AA1 * Z  +  AA0  =  0
c
c               Uses J. Scire's cubic routine modified to give all
c               all three roots.  This methodology is also described
c               in standard math handbooks such as,
c                      CRC STANDARD MATHEMATICAL TABLES
c                      W. H. Beyer, CRC Press, Boca Raton, Florida
c
c
c --- INPUTS:
c
c               AA3 - real    - Coefficient of Z**3 term (no units)
c               AA2 - real    - Coefficient of Z**2 term (no units)
c               AA1 - real    - Coefficient of Z**1 term (no units)
c               AA0 - real    - Coefficient of Z**0 term (no units)
c
c --- OUTPUTS:
c
c                NR - integer - Number of real roots found.
c                RT - real    - Array of real roots found.
c
c --- DROOT3 called by:  SLGTLIM
c --- DROOT3 calls:      none
c----------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-Z)
      real*4 RT(3),aa3,aa2,aa1,aa0,aa3i,small
      integer nr

      DATA SMALL/1.0E-10/
c     DATA DSMALL/1.0D-10/
      DATA ONE/1.D0/,two/2.D0/,THREE/3.D0/,pi/3.1415927D0/

      third=one/three
      tpid3=two*pi*third
      fpid3=two*tpid3
C
      IF(ABS(AA3).GT.SMALL) GO TO 5
      CALL ROOT2(AA2,AA1,AA0,NR,RT)
      RETURN
C
C --- CONVERT TO CUBIC'S NOTATION.
    5 AA3I = 1.0 / AA3
      A = DPROD(AA2 , AA3I)
      B = DPROD(AA1 , AA3I)
      C = DPROD(AA0 , AA3I)
C
C     SUBROUTINE CUBIC(A,B,C,Z)
C     SUBROUTINE CUBIC (VERSION 82102), PART OF BLP.
C      BLP   VERSION 4.1  LEVEL 800212     CUBIC
C     SOLVES FOR ONE ROOT OF THE CUBIC EQUATION:
C     Z**3 + A*Z**2 + B*Z + C = 0
C
      A3=A*THIRD
      AP=B-A*A3
      BP=A3*(2.D0*A3*A3 - B) + C
      AP3=AP*THIRD
      BP2=BP*0.5D0
      TROOT=BP2*BP2+AP3*AP3*AP3
      IF(TROOT.LE.0.D0)GO TO 50
      TR=DSQRT(TROOT)
C *** RJY PROTECTION AGAINST NEGATIVE RAISED TO REAL POWER.
      APV=(-BP2+TR)
c     IF(APV.LT.DSMALL) WRITE(6,1001) APV,TR,BP2
c     IF(APV.LT.DSMALL) WRITE(*,1001) APV,TR,BP2
c     APV = DAMAX1(DSMALL,APV)
 1001 format(' ***ROOT3: APV IS LT 0: APV,TR,BP2=',/,20X,3G12.5)
c *** APV=APV**THIRD  replaced with the following on 1/11/88
      SGN=DSIGN(ONE,APV)
      APP=SGN*(DABS(APV))**THIRD
C********************************************************************
      BSV=-BP2-TR
      SGN=DSIGN(ONE,BSV)
      BPP=SGN*(DABS(BSV))**THIRD
      Z=APP+BPP-A3
      RT(1) = Z
      NR = 1
      RETURN
C
50    CM=2.D0*DSQRT(-AP3)
C *** pc modification
      ALPHA=DACOS(BP/(AP3*CM))*THIRD
C ***
      Z = CM * DCOS(ALPHA) - A3
      RT(1) = Z
      Z = CM * DCOS(ALPHA + TPID3) - A3
      RT(2) = Z
      Z = CM * DCOS(ALPHA + FPID3) - A3
      RT(3) = Z
      NR = 3
      RETURN
      END
c----------------------------------------------------------------------
      SUBROUTINE ROOT2(AA2,AA1,AA0,NR,RT)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 900228                  ROOT2
c                R. Yamartino, SRC
c
c --- PURPOSE:  Solves for NR multiple roots RT(I) of the quadradic
c               AA2 * Z**2  +  AA1 * Z  +  AA0  =  0
c
c               Uses standard methodology as is described in
c               standard math handbooks such as,
c                      CRC STANDARD MATHEMATICAL TABLES
c                      W. H. Beyer, CRC Press, Boca Raton, Florida
c
c
c --- INPUTS:
c
c               AA2 - real    - Coefficient of Z**2 term (no units)
c               AA1 - real    - Coefficient of Z**1 term (no units)
c               AA0 - real    - Coefficient of Z**0 term (no units)
c
c --- OUTPUTS:
c
c                NR - integer - Number of real roots found.
c                RT - real    - Array of real roots found.
c
c --- ROOT2 called by:  SLGTLIM
c --- ROOT2 calls:      none
c----------------------------------------------------------------------
C
C
      DIMENSION RT(2)
      DATA SMALL/1.0E-10/,HALF/0.50/,FOUR/4.0/
C
      NR = 0
      IF(ABS(AA2).GT.SMALL) GO TO 5
C
      IF(ABS(AA1).GT.SMALL) THEN
                            RT(1) = -AA0 / AA1
                            NR = 1
                            ENDIF
C
      RETURN
C
C ********************************************
C --- CONSIDER TWO ROOTS.
    5 TROOT = AA1 * AA1  -  FOUR * AA2 * AA0
C --- QUIT IF IMAGINARY ROOTS.
      IF(TROOT.LE.0.0)GO TO 50
      TR=SQRT(TROOT)
      ALF = HALF / AA2
      TERM1 = -ALF * AA1
      TERM2 =  ALF * TR
      RT(1) = TERM1 + TERM2
      RT(2) = TERM1 - TERM2
      NR = 2
C
   50 RETURN
      END
c----------------------------------------------------------------------
      subroutine recspec0(rhoa,zrterr,zstak,zbase,ppcoef,
     &                    syr,szr,zpr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520               RECSPEC0
c                R. Yamartino, D. Strimaitis
c
c --- PURPOSE:  Computes the receptor-specific sigmas y and z,
c               and receptor-specific slug height (gradual rise)
c               with terrain adjustments, for the special case of the
c               unaged slug (IAGE = 0) from either an area source or
c               a line source
c
c --- UPDATE
c --- V6.11-V6.261  080520  (DGS): Replace individual LN1,LN2 rise
c                                  tables with /SRCTAB/ arrays from
c                                  Direct Access file
c --- V6.1-V6.11    060309  (DGS): turn OFF the debug output (LDBG)
c --- V5.73-V6.1    050915  (DGS): add emission step index to rise 
c                                  tables for variable sources
c --- V5.0-V5.73    040611  (DGS): add gravitational settling for one
c                                  particle size (plume tilt)
c --- V4.0-V5.0     971107  (DGS): add treatment for variable line
c                                  sources (istype=6)
c
c --- INPUTS:
c
c              RHOA - real    - Upwind receptor-source distance (m)
c            ZRTERR - real    - Terrain elevation (m MSL) at receptor
c             ZSTAK - real    - Stack height of source of puff (m)
c             ZBASE - real    - Stack base elevation MSL (m)
c            PPCOEF - real    - Plume path coefficient
c
c     Common Block /COMPARM/ variables:
c        SYMIN, SZMIN
c     Common Block /CURRENT/ variables:
c        XE1, YE1, ZE1, SYE1, SZE1,
c        XE2, YE2, ZE2, SYE2, SZE2,
c        te1,vsetl,
c        vtye1,vtze1,vtye2,vtze2,
c        vdye1,vdze1,vdye2,vdze2,
c        bidsq, IPNUM, ISNUM, ISTYPE, IQSTEP,
c        xupedge, xfrise, xshift, zfrise
c     Common Block /FLAGS/ variables:
c        MTRANS, MTILT
c     Common Block /PUFF/ variables:
c        IDW0
c     Common Block /SLGLIN/ variables:
c        DXY12,RDXY12
c     Common block /SRCTAB/ variables:
c           NTR, XTR(mxrise), ZTR(mxrise)
c
c     Parameters:
c
c --- OUTPUTS:
c
c               SYR - real    - Receptor sigma Y (m)
c               SZR - real    - Receptor sigma Z (m)
c               ZPR - real    - Receptor-specific slug height after any
c                               terrain adjustments (m)
c
c     Common Block /CURRENT/ variables revised "locally":
c        xfrise, xshift, zfrise
c
c --- RECSPEC0 called by:  CPTRAP
c --- RECSPEC0 calls:      HEFTRAN, SIGTY, SIGTZ, GRISE, CTADJ
c----------------------------------------------------------------------
c
c --- Include parameter block
      include 'params.puf'

c --- Include common blocks
      include 'comparm.puf'
      include 'pt1.puf'
      include 'flags.puf'
      include 'puff.puf'
      include 'current.puf'
      include 'srctab.puf'

      COMMON /SLGLIN/ DXY12,RDXY12

      logical ldbg

      data zero/0.0/

c --- Set list file output switch for testing
      ldbg=.FALSE.
c --- ldbg=.TRUE.

c -------------------------------------------------------------------
c --- Determine the spatial interpolation factor for along-slug
c --- positions
c -------------------------------------------------------------------
c
c --- Fully extended slug position  (FRACSF)
c
c --- DXY12 is projection of the slug length on the x-y plane.
c --- FRACSF is the fraction RHOA/DXY12 for the fully-extended slug
c --- FRACSF = 0 corresponds to the source location
c --- FRACSF = 1 corresponds to the slug end furthest downwind
      FRACSF = RHOA * RDXY12

c -------------------------------------------------------------------
c --- Find the receptor-specific sigmas for the fully-extended slug
c -------------------------------------------------------------------

c --- Do linear spatial interpolation of the virtual t,x but limit the
c --- virtual quantities to be positive via use of AMAX1.
      vty = vtye2 + fracsf * (vtye1 - vtye2)
      vty = amax1(vty,zero)
      vtz = vtze2 + fracsf * (vtze1 - vtze2)
      vtz = amax1(vtz,zero)
      vdy = vdye2 + fracsf * (vdye1 - vdye2)
      vdy = amax1(vdy,zero)
      vdz = vdze2 + fracsf * (vdze1 - vdze2)
      vdz = amax1(vdz,zero)
c
c -------------------------------------------------------------------
c --- Redefine line-source data for current source location ---
c --- (integrator dynamically breaks line sources into segments, so
c ---  that rise from these will differ from that in puff arrays)
c -------------------------------------------------------------------
c --- Save "real" /CURRENT/ values before altering them for rise
      xshifts=xshift
      xfrises=xfrise
      zfrises=zfrise
      if(istype.EQ.5 .OR. istype.EQ.6) then
c ---    Constant or variable line sources
c ---    Must have something in the rise arrays
         if(ntr.LE.0) then
            write(io6,*)
            write(io6,*) 'FATAL ERROR in RECSPEC0: invalid array'
            write(io6,*) 'Expected NTR greater than 0'
            write(io6,*) 'Found NTR = ',ntr
            write(io6,*)
            write(*,*)
            stop 'Halted in RECSPEC0 -- See list file'
         endif
         xshift=amax1(zero,xupedge-rhoa)
         if(xshift.GT.xtr(1)) xshift=xtr(1)
         if(xtr(1).GE.xtr(ntr)) then
c ---       Case 1:  Final rise reached before "full buoyancy" distance
            size=1.0-xshift/xtr(1)
            xfrise=xtr(ntr)*size
            zfrise=ztr(1)*size
         else
c ---       Case 2:  Final rise reached beyond "full buoyancy" distance
            xfrise=xtr(ntr)-xshift
            zfrise=ztr(ntr)-xshift*ztr(1)/xtr(1)
         endif
      endif

c --- Set final rise height for this source location
      hfinal=zstak+zfrise
c
c --- Reset Heffter transition for sigma-z for current slug
      call heftran(2,hfinal,zero,zero,vtze1,vtze2,vtye1,vtye2)
c
c --- Now compute the receptor-specific sigmas (syar,szar) via 'forward'
c --- calls to the sigma routines using the VIRTUALS as space/time step.
      call sigty(zero,vdy,vty,syar,dum1,dum2)
      call sigtz(zero,vdz,vtz,hfinal,szar,dum1,dum2)
c
c -------------------------------------------------------------------
c --- Compute the gradual rise for BID
c -------------------------------------------------------------------

c --- Initialize gradual rise plume height to final rise value
      hgr=hfinal
      if(zfrise.LE.zero) then
         grbid=zero
      else
         grbid=bidsq*(zfrise/zfrises)**2
      endif
c
c --- Check for gradual rise
      if(rhoa.LT.xfrise .AND. rhoa.GT.zero) then
c ---    Compute gradual rise
         if(idw0(ipnum).GT.0) then
c ---       Building downwash (line source -- no BID)
            call grise(rhoa,hgr,risefac)
            grbid=zero
         else
c ---       No building downwash (also, no stack-tip DW for these
c ---       sources either)
            call grise(rhoa,hgr,risefac)
            grbid=grbid*risefac**2
         endif
      elseif(rhoa.LE.zero) then
c ---    Receptor upwind
         hgr=zstak
         grbid=zero
      endif

c --- Adjust sigmas:  add contribution due to buoyancy enhancement
      syr=syar
      szr=szar
      if(grbid.GT.zero) then
         syr=sqrt(syar**2+grbid)
         szr=sqrt(szar**2+grbid)
      endif

c --- Set a "floor" to the sigma values equal to SYMIN, SZMIN
      if(syr .LE. symin) syr=symin
      if(szr .LE. szmin) szr=szmin

c -------------------------------------------------------------------
c --- Set slug height at receptor
c -------------------------------------------------------------------
c --- Use gradual rise height if requested, or if downwash is active
      if(mtrans.EQ.1 .OR. idw0(ipnum).GT.0) then
         zpr = hgr
      else
         zpr = hfinal
      endif

C --- Estimate slug height at receptor with gravitational settling
c --- (Initial Implementation!)
      if(mtilt.EQ.1) then
c ---    Travel time to end of slug (FRACSF=1) is te1 in /CURRENT/
         dzprg=-fracsf*te1*vsetl
         dzprg=AMIN1(0.0,dzprg)
      else
         dzprg=0.0
      endif
c --- Account for settling (may be negative)
      zpr=zpr+dzprg

      if(mctadj.eq.1 .OR. mctadj.eq.3) then
         call ctadj(zrterr,zpr,zstak,zbase,ppcoef,zpra)
         zpr=zpra
      endif

c --- Condition final effective puff ht to be non-negative
      zpr=AMAX1(zpr,0.0)

c***
      if(LDBG) then
         write(io6,*)'RECSPEC0: rhoa, xfrise = ',rhoa,xfrise
         write(io6,*)'              syr, szr = ',syr,szr
         write(io6,*)'        xshift, zfrise = ',xshift,zfrise
         write(io6,*)'      xshifts, zfrises = ',xshifts,zfrises
         write(io6,*)'      hfinal, hgr, zpr = ',hfinal,hgr,zpr
         write(io6,*)'    fracsf, te1, dzprg = ',fracsf,te1,dzprg
      endif
c***

c --- Restore "real" rise values to common /CURRENT/
      xshift=xshifts
      xfrise=xfrises
      zfrise=zfrises

      return
      end
c----------------------------------------------------------------------
      subroutine out(rarray,iarray,ityp,nsigd,ldate,messag,nx,ny)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                    OUT
c ---            J. Scire, SRC
c
c --- PURPOSE:  Write a gridded field of real or integer numbers
c
c --- UPDATE
c --- V5.4-V6.1     050915  (DGS): resolve times to the second and
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c                   000602  (DGS): increase format for cell IDs
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c
c --- INPUTS:
c     RARRAY(MXNX,MXNY) - Real array  - Array of real numbers to print
c                                       (used only if ITYP = 1)
c     IARRAY(MXNX,MXNY) - Int. array  - Array of integer numbers to
c                                       print (used only if ITYP = 2)
c                  ITYP - Integer     - Array type (1=real, 2=integer)
c                 NSIGD - Integer     - No. digits to print (valid range
c                                       for NSIGD is 1 to 5)
c                 LDATE - Logical     - Control variable for printing
c                                       of date (.true. = print date in
c                                       common /GEN/, .false. = do not
c                                       print date)
c                MESSAG - Char.*70    - Label of table
c                    NX - Integer     - No. X grid cells being used in
c                                       array
c                    NY - Integer     - No. Y grid cells being used in
c                                       array
c       Common block /DATEHR/ variables: - (Used only if LDATE=.true.)
c          NYRB, NMOB, NDAYB, NJULB, NHRB, NSECB,
c          NYRE, NMOE, NDAYE, NJULE, NHRE, NSECE
c       Parameters: MXNX, MXNY, IO6
c
c --- OUTPUT:  none
c
c --- OUT    called by:  MET1, CHEMI
c --- OUT    calls:      WRT, WRT2
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include date/hour common block
      include 'datehr.puf'
c
      real rarray(mxnx,mxny)
c
      integer iarray(mxnx,mxny),icol(5)
      integer iout(mxnx)
c
      logical ldate
c
      character*70 messag
      character*1 sign(mxnx),plus,minus
      character*24 form1(5)
      character*21 form2(5)
      character*18 form3(5)
c
      data icol /40,40,30,25,20/
      data plus,minus /'+','-'/
      data form1 /'(1x,i3,1x,1hI,40(i3,1x))',
     1            '(1x,i3,1x,1hI,40(i3,1x))',
     2            '(1x,i3,1x,1hI,40(i3,1x))',
     3            '(1x,i3,1x,1hI,40(i4,1x))',
     4            '(1x,i3,1x,1hI,40(i5,1x))'/
      data form2 /'(5x,1hI,40(2x,a1,1x))',
     1            '(5x,1hI,40(2x,a1,1x))',
     2            '(5x,1hI,40(2x,a1,1x))',
     3            '(5x,1hI,40(3x,a1,1x))',
     4            '(5x,1hI,40(4x,a1,1x))'/
      data form3 /'(6x,40(i3,1x))',
     1            '(6x,40(i3,1x))',
     2            '(6x,40(i3,1x))',
     3            '(6x,40(i4,1x))',
     4            '(6x,40(i5,1x))'/
c
c --- check that valid values of array type (ityp) and print digits
c --- (nsigd) have been passed to routine
      if(ityp.ne.1.and.ityp.ne.2)then
         write(io6,*)'ERROR in SUBR. OUT -- invalid value of ITYP -- ',
     1   'ITYP = ',ityp
         write(*,*)
         stop 'Halted in OUT -- see list file.'
      endif
      if(nsigd.lt.1.or.nsigd.gt.5)then
         write(io6,*)'ERROR in SUBR. OUT -- invalid value of NSIGD -- ',
     1   'NSIGD = ',nsigd
         write(*,*)
         stop 'Halted in OUT -- see list file.'
      endif
c
      icr=2
      if(nsigd.eq.1)icr=1
      if(mod(nx,icol(nsigd)).eq.0)then
         npass=nx/icol(nsigd)
      else
         npass=nx/icol(nsigd)+1
      endif
c
c --- real array -- find min. & max. values
      if(ityp.ne.1)go to 50
      xmax=-1.e-25
      xmin=1.e25
      do 10 i=1,nx
      do 10 j=1,ny
      if(rarray(i,j).gt.xmax)xmax=rarray(i,j)
      if(rarray(i,j).lt.xmin)xmin=rarray(i,j)
10    continue
      if(xmin.ne.0.0.or.xmax.ne.0.0)go to 12
      if(ldate)write(io6,94)messag,nyrb,nmob,ndayb,njulb,nhrb,nsecb,
     &                             nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,11)
11    format(1x,'GRID NOT PRINTED -- all values zero')
      return
c
12    continue
      xexp=xmax
      if(abs(xmin).gt.xmax)xexp=abs(xmin)
      iexp=alog10(xexp)
      if(xexp.lt.1.0)iexp=iexp-1
      nexp=iexp-(nsigd-icr)
      xscale=10.**(-nexp)
c
      ic2=0
      do 30 ipass=1,npass
c
      if(ldate)write(io6,94)messag,nyrb,nmob,ndayb,njulb,nhrb,nsecb,
     &                             nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,109)nexp
c
      ic1=ic2+1
      ic2=ic2+icol(nsigd)
      if(ic2.gt.nx)ic2=nx
c
         do 20 jj=ny,1,-1
         icnt=0
c
            do 18 i=ic1,ic2
            icnt=icnt+1
            if(rarray(i,jj).lt.0)then
               iout(icnt)=-(rarray(i,jj)*xscale-0.5)
               sign(icnt)=minus
            else
               iout(icnt)=rarray(i,jj)*xscale+0.5
               sign(icnt)=plus
            endif
18          continue
         call wrt(form1(nsigd),form2(nsigd),jj,iout,sign,icnt,io6)
20       continue
      nund=(nsigd+1)*icnt-1
      if(nsigd.eq.1)nund=(nsigd+2)*icnt-1
      write(io6,101)(minus,n=1,nund)
101   format(5x,128a1)
      call wrt2(form3(nsigd),ic1,ic2,io6)
30    continue
      return
c
c --- integer array -- find min. & max. values
50    continue
      kmax=-9999999
      kmin=9999999
      do 110 i=1,nx
      do 110 j=1,ny
      if(iarray(i,j).gt.kmax)kmax=iarray(i,j)
      if(iarray(i,j).lt.kmin)kmin=iarray(i,j)
110   continue
      if(kmin.ne.0.or.kmax.ne.0)go to 102
      if(ldate)write(io6,94)messag,nyrb,nmob,ndayb,njulb,nhrb,nsecb,
     &                             nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,11)
      return
c
102   continue
      xexp=kmax
      if(iabs(kmin).gt.kmax)xexp=iabs(kmin)
      iexp=alog10(xexp)
      if(xexp.lt.1.0)iexp=iexp-1
      nexp=iexp-(nsigd-icr)
      xscale=10.**(-nexp)
c
      ic2=0
      do 130 ipass=1,npass
c
      if(ldate)write(io6,94)messag,nyrb,nmob,ndayb,njulb,nhrb,nsecb,
     &                             nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,109)nexp
c
      ic1=ic2+1
      ic2=ic2+icol(nsigd)
      if(ic2.gt.nx)ic2=nx
c
         do 120 jj=ny,1,-1
         icnt=0
c
            do 118 i=ic1,ic2
            icnt=icnt+1
            if(iarray(i,jj).lt.0)then
               iout(icnt)=-(iarray(i,jj)*xscale-0.5)
               sign(icnt)=minus
            else
               iout(icnt)=iarray(i,jj)*xscale+0.5
               sign(icnt)=plus
            endif
118         continue
         call wrt(form1(nsigd),form2(nsigd),jj,iout,sign,icnt,io6)
120      continue
      nund=(nsigd+1)*icnt-1
      if(nsigd.eq.1)nund=(nsigd+2)*icnt-1
      write(io6,101)(minus,n=1,nund)
      call wrt2(form3(nsigd),ic1,ic2,io6)
130   continue
c
      return

94    format(/1x,a70,2x,'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     1       'Julian day: ',i3,2x,'hr: ',i2,2x,'sec: ',i4/,t70,
     2       'to year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     3       'Julian day: ',i3,2x,'hr: ',i2,2x,'sec: ',i4/)
95    format(/1x,a70/)
109   format(1x,'Multiply all values by 10 ** ',i3/)

      end
c----------------------------------------------------------------------
      subroutine wrt(form1,form2,jj,iout,sign,n,io6)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940430                    WRT
c ---            J. Scire, SRC
c
c --- PURPOSE:  Write one Y row of gridded data
c
c --- INPUTS:
c              FORM1 - Char.*24    - Format field for Y label and data
c                                    to be printed
c              FORM2 - Char.*21    - Format field for sign of data
c                 JJ - Integer     - Y grid cell number
c            IOUT(N) - Int. array  - Array of data to be printed
c                                    (one Y row)
c            SIGN(N) - Char.*1     - Array containing sign of data
c                                    ('+' or '-')
c                  N - Integer     - Number of cells in this row
c                IO6 - Integer     - Fortran unit no. of output
c
c --- OUTPUT:  none
c
c --- WRT called by:  OUT, OUTSAM
c --- WRT calls:      none
c----------------------------------------------------------------------
      integer iout(n)
c
      character*1 sign(n)
      character*24 form1
      character*21 form2
c
      write(io6,form1)jj,iout
      write(io6,form2)sign
c
      return
      end
c----------------------------------------------------------------------
      subroutine wrt2(form,n1,n2,io6)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940430                   WRT2
c ---            J. Scire, SRC
c
c --- PURPOSE:  Write a line labeling grid cell numbers
c
c --- INPUTS:
c               FORM - Char.*18    - Format field of data to be printed
c                 N1 - Integer     - Starting grid cell number
c                 N2 - Integer     - Ending grid cell number
c                IO6 - Integer     - Fortran unit no. of output
c
c --- OUTPUT:  none
c
c --- WRT2 called by:  OUT, OUTSAM
c --- WRT2 calls:      none
c----------------------------------------------------------------------
      character*18 form
c
      write(io6,form)(i,i=n1,n2)
      return
      end
c----------------------------------------------------------------------
      subroutine outsam(rarray,iarray,ityp,nsigd,ldate,messag,nx,ny)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                 OUTSAM
c ---            J. Scire, SRC
c
c --- PURPOSE:  Write a gridded field of real or integer numbers
c ---           Array dimensions sized for SAMPLING grid
c
c --- UPDATE
c --- V5.4-V6.1     050915  (DGS): resolve times to the second
c --- V5.2-V5.4     000602  (DGS): add message to "stop"
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c
c --- INPUTS:
c   RARRAY(MXNXG,MXNYG) - Real array  - Array of real numbers to print
c                                       (used only if ITYP = 1)
c   IARRAY(MXNXG,MXNYG) - Int. array  - Array of integer numbers to
c                                       print (used only if ITYP = 2)
c                  ITYP - Integer     - Array type (1=real, 2=integer)
c                 NSIGD - Integer     - No. digits to print (valid range
c                                       for NSIGD is 1 to 5)
c                 LDATE - Logical     - Control variable for printing
c                                       of date (.true. = print date in
c                                       common /GEN/, .false. = do not
c                                       print date)
c                MESSAG - Char.*70    - Label of table
c                    NX - Integer     - No. X grid cells being used in
c                                       array
c                    NY - Integer     - No. Y grid cells being used in
c                                       array
c       Common block /DATEHR/ variables: - (Used only if LDATE=.true.)
c          NYRAB, NMOAB, NDAYAB, NJULAB, NHRAB, NSECAB,
c          NYRE, NMOE, NDAYE, NJULE, NHRE, NSECE
c       Parameters: MXNXG, MXNYG, IO6
c
c --- OUTPUT:  none
c
c --- OUTSAM called by:  OUTPUT
c --- OUTSAM calls:      WRT, WRT2
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include date/hour common block
      include 'datehr.puf'
c
      real rarray(mxnxg,mxnyg)
c
      integer iarray(mxnxg,mxnyg),icol(5)
      integer iout(mxnxg)
c
      logical ldate
c
      character*70 messag
      character*1 sign(mxnxg),plus,minus
      character*24 form1(5)
      character*21 form2(5)
      character*18 form3(5)
c
      data icol /40,40,30,25,20/
      data plus,minus /'+','-'/
      data form1 /'(1x,i2,1x,1hI,40(i2,1x))',
     1            '(1x,i2,1x,1hI,40(i2,1x))',
     2            '(1x,i2,1x,1hI,40(i3,1x))',
     3            '(1x,i2,1x,1hI,40(i4,1x))',
     4            '(1x,i2,1x,1hI,40(i5,1x))'/
      data form2 /'(4x,1hI,40(1x,a1,1x))',
     1            '(4x,1hI,40(1x,a1,1x))',
     2            '(4x,1hI,40(2x,a1,1x))',
     3            '(4x,1hI,40(3x,a1,1x))',
     4            '(4x,1hI,40(4x,a1,1x))'/
      data form3 /'(5x,40(i2,1x))',
     1            '(5x,40(i2,1x))',
     2            '(5x,40(i3,1x))',
     3            '(5x,40(i4,1x))',
     4            '(5x,40(i5,1x))'/
c
c --- check that valid values of array type (ityp) and print digits
c --- (nsigd) have been passed to routine
      if(ityp.ne.1.and.ityp.ne.2)then
         write(io6,*)'ERROR in SUBR. OUTSAM -- invalid value of ITYP',
     1   ' -- ITYP = ',ityp
         write(*,*)
         stop 'Halted in OUTSAM -- see list file.'
      endif
      if(nsigd.lt.1.or.nsigd.gt.5)then
         write(io6,*)'ERROR in SUBR. OUTSAM -- invalid value of NSIGD',
     1   ' -- NSIGD = ',nsigd
         write(*,*)
         stop 'Halted in OUTSAM -- see list file.'
      endif
c
      icr=2
      if(nsigd.eq.1)icr=1
      if(mod(nx,icol(nsigd)).eq.0)then
         npass=nx/icol(nsigd)
      else
         npass=nx/icol(nsigd)+1
      endif
c
c --- real array -- find min. & max. values
      if(ityp.ne.1)go to 50
      xmax=-1.e-25
      xmin=1.e25
      do 10 i=1,nx
      do 10 j=1,ny
      if(rarray(i,j).gt.xmax)xmax=rarray(i,j)
      if(rarray(i,j).lt.xmin)xmin=rarray(i,j)
10    continue
      if(xmin.ne.0.0.or.xmax.ne.0.0)go to 12
      if(ldate)write(io6,94)messag,nyrab,nmoab,ndayab,njulab,nhrab,
     &                      nsecab,nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,11)
11    format(1x,'GRID NOT PRINTED -- all values zero')
      return
c
12    continue
      xexp=xmax
      if(abs(xmin).gt.xmax)xexp=abs(xmin)
      iexp=alog10(xexp)
      if(xexp.lt.1.0)iexp=iexp-1
      nexp=iexp-(nsigd-icr)
      xscale=10.**(-nexp)
c
      ic2=0
      do 30 ipass=1,npass
c
      if(ldate)write(io6,94)messag,nyrab,nmoab,ndayab,njulab,nhrab,
     &                      nsecab,nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,109)nexp
c
      ic1=ic2+1
      ic2=ic2+icol(nsigd)
      if(ic2.gt.nx)ic2=nx
c
         do 20 jj=ny,1,-1
         icnt=0
c
            do 18 i=ic1,ic2
            icnt=icnt+1
            if(rarray(i,jj).lt.0)then
               iout(icnt)=-(rarray(i,jj)*xscale-0.5)
               sign(icnt)=minus
            else
               iout(icnt)=rarray(i,jj)*xscale+0.5
               sign(icnt)=plus
            endif
18          continue
         call wrt(form1(nsigd),form2(nsigd),jj,iout,sign,icnt,io6)
20       continue
      nund=(nsigd+1)*icnt-1
      if(nsigd.eq.1)nund=(nsigd+2)*icnt-1
      write(io6,101)(minus,n=1,nund)
101   format(5x,128a1)
      call wrt2(form3(nsigd),ic1,ic2,io6)
30    continue
      return
c
c --- integer array -- find min. & max. values
50    continue
      kmax=-9999999
      kmin=9999999
      do 110 i=1,nx
      do 110 j=1,ny
      if(iarray(i,j).gt.kmax)kmax=iarray(i,j)
      if(iarray(i,j).lt.kmin)kmin=iarray(i,j)
110   continue
      if(kmin.ne.0.or.kmax.ne.0)go to 102
      if(ldate)write(io6,94)messag,nyrab,nmoab,ndayab,njulab,nhrab,
     &                      nsecab,nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,11)
      return
c
102   continue
      xexp=kmax
      if(iabs(kmin).gt.kmax)xexp=iabs(kmin)
      iexp=alog10(xexp)
      if(xexp.lt.1.0)iexp=iexp-1
      nexp=iexp-(nsigd-icr)
      xscale=10.**(-nexp)
c
      ic2=0
      do 130 ipass=1,npass
c
      if(ldate)write(io6,94)messag,nyrab,nmoab,ndayab,njulab,nhrab,
     &                      nsecab,nyre,nmoe,ndaye,njule,nhre,nsece
      if(.not.ldate)write(io6,95)messag
      write(io6,109)nexp
c
      ic1=ic2+1
      ic2=ic2+icol(nsigd)
      if(ic2.gt.nx)ic2=nx
c
         do 120 jj=ny,1,-1
         icnt=0
c
            do 118 i=ic1,ic2
            icnt=icnt+1
            if(iarray(i,jj).lt.0)then
               iout(icnt)=-(iarray(i,jj)*xscale-0.5)
               sign(icnt)=minus
            else
               iout(icnt)=iarray(i,jj)*xscale+0.5
               sign(icnt)=plus
            endif
118         continue
         call wrt(form1(nsigd),form2(nsigd),jj,iout,sign,icnt,io6)
120      continue
      nund=(nsigd+1)*icnt-1
      if(nsigd.eq.1)nund=(nsigd+2)*icnt-1
      write(io6,101)(minus,n=1,nund)
      call wrt2(form3(nsigd),ic1,ic2,io6)
130   continue
c
      return

94    format(/1x,a70,2x,'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     1       'Julian day: ',i3,2x,'hr: ',i2,2x,'sec: ',i4/,t71,
     2       'to year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     3       'Julian day: ',i3,2x,'hr: ',i2,2x,'sec: ',i4/)
95    format(/1x,a70/)
109   format(1x,'Multiply all values by 10 ** ',i3/)

      end
c----------------------------------------------------------------------
      subroutine rdi1d(iomet,mtver,idat,nwords,clabel,ndathrb,
     &                 nsecb,ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDI1D
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Read "NWORDS" of a one-dimensional integer array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second, and
c                                  include begin/end times
c                                  (remains compatible with
c                                  older end-time version)
c
c --- INPUTS:
c         IOMET - integer       - Fortran unit number of input file
c         MTVER - integer       - Time-mark flag
c                                 0: end-time (no seconds)
c                                 1: begin-time / end-time
c
c --- OUTPUT:
c  IDAT(nwords) - integer array - Array read from file
c        NWORDS - integer       - Number of words to read
c        CLABEL - character*8   - Variable name
c       NDATHRB - integer       - Beginning date and time (YYYYJJJHH)
c         NSECB - integer       - Beginning seconds (SSSS)
c       NDATHRE - integer       - Ending date and time (YYYYJJJHH)
c         NSECE - integer       - Ending seconds (SSSS)
c
c --- RDI1D called by:  RDMET
c --- RDI1D calls:      none
c----------------------------------------------------------------------
c
      integer idat(nwords)
      character*8 clabel
c
      if(mtver.EQ.1) then
         read(iomet)clabel,ndathrb,nsecb,ndathre,nsece,idat
      elseif(mtver.EQ.0) then
         read(iomet)clabel,ndathre,idat
         nsece=0
         ndathrb=0
         nsecb=0
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine rdi2d(iomet,mtver,idat,ibuf,mxnx,mxny,nx,ny,clabel,
     &                 ndathrb,nsecb,ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDI2D
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Read NX * NY words of a 2-D integer array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second, and
c                                  include begin/end times for CALMET
c                                  Version 6 (remains compatible with
c                                  older version of CALMET)
c
c --- INPUTS:
c               IOMET - integer       - Fortran unit number of input
c                                       file
c               MTVER - integer       - Time-mark flag
c                                       0: end-time (no seconds)
c                                       1: begin-time / end-time
c         IBUF(nx,ny) - integer array - Buffer to hold input data
c           MXNX,MXNY - integers      - Dimensions of data array
c               NX,NY - integers      - Actual size of grid to read
c
c --- OUTPUT:
c     IDAT(mxnx,mxny) - integer array - Input data array (padded if
c                                       necessary)
c              CLABEL - character*8   - Variable name
c             NDATHRB - integer       - Beginning date and time (YYYYJJJHH)
c               NSECB - integer       - Beginning seconds (SSSS)
c             NDATHRE - integer       - Ending date and time (YYYYJJJHH)
c               NSECE - integer       - Ending seconds (SSSS)
c
c --- RDI2D called by:  MET1, RDMET
c --- RDI2D calls:      none
c----------------------------------------------------------------------
      integer idat(mxnx,mxny),ibuf(nx,ny)
      character*8 clabel
c
      if(nx.eq.mxnx.and.ny.eq.mxny)then
c
c ---    entire array is being used -- read full grid
         if(mtver.EQ.1) then
            read(iomet)clabel,ndathrb,nsecb,ndathre,nsece,idat
         elseif(mtver.EQ.0) then
            read(iomet)clabel,ndathre,idat
            nsece=0
            ndathrb=0
            nsecb=0
         endif
      else
c
c ---    only a portion of grid being used -- read and
c ---    transfer from buffer
c
         if(mtver.EQ.1) then
            read(iomet)clabel,ndathrb,nsecb,ndathre,nsece,ibuf
         elseif(mtver.EQ.0) then
            read(iomet)clabel,ndathre,ibuf
            nsece=0
            ndathrb=0
            nsecb=0
         endif
c
         do 10 i=1,nx
         do 10 j=1,ny
         idat(i,j)=ibuf(i,j)
10       continue
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine rdr1d(iomet,mtver,x,nwords,clabel,
     &                 ndathrb,nsecb,ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262     Level: 050915                 RDR1D
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Read "NWORDS" of a one-dimensional real array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second, and
c                                  include begin/end times for CALMET
c                                  Version 6 (remains compatible with
c                                  older version of CALMET)
c
c --- INPUTS:
c         IOMET - integer     - Fortran unit number of input file
c         MTVER - integer     - Time-mark flag
c                               0: end-time (no seconds)
c                               1: begin-time / end-time
c
c --- OUTPUT:
c     X(nwords) - real array  - Array read from file
c        NWORDS - integer     - Number of words to read
c        CLABEL - character*8 - Variable name
c       NDATHRB - integer     - Beginning date and time (YYYYJJJHH)
c         NSECB - integer     - Beginning seconds (SSSS)
c       NDATHRE - integer     - Ending date and time (YYYYJJJHH)
c         NSECE - integer     - Ending seconds (SSSS)
c
c --- RDR1D called by:  MET1, RDMET
c --- RDR1D calls:      none
c----------------------------------------------------------------------
      real x(nwords)
      character*8 clabel
c
      if(mtver.EQ.1) then
         read(iomet)clabel,ndathrb,nsecb,ndathre,nsece,x
      elseif(mtver.EQ.0) then
         read(iomet)clabel,ndathre,x
         nsece=0
         ndathrb=0
         nsecb=0
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine rdr2d(iomet,mtver,x,xbuf,mxnx,mxny,nx,ny,clabel,
     &                 ndathrb,nsecb,ndathre,nsece,ieof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262     Level: 050915                 RDR2D
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Read NX * NY words of a 2-D real array
c
c --- UPDATE 
c --- V5.0-V6.1     050915  (DGS): resolve times to the second, and
c                                  include begin/end times for CALMET
c                                  Version 6 (remains compatible with
c                                  older version of CALMET)
c --- V5.0-V5.0     990228a (DGS): add IEOF to recover from end-of-file
c
c --- INPUTS:
c            IOMET - integer     - Fortran unit number of input file
c            MTVER - integer     - Time-mark flag
c                                  0: end-time (no seconds)
c                                  1: begin-time / end-time
c      XBUF(nx,ny) - real array  - Buffer to hold input data
c      MXNX,MXNY   - integers    - Dimensions of data array
c            NX,NY - integers    - Actual size of grid to read
c
c --- OUTPUT:
c     X(mxnx,mxny) - real array  - Input data array (padded if nec.)
c           CLABEL - character*8 - Variable name
c          NDATHRB - integer     - Beginning date and time (YYYYJJJHH)
c            NSECB - integer     - Beginning seconds (SSSS)
c          NDATHRE - integer     - Ending date and time (YYYYJJJHH)
c            NSECE - integer     - Ending seconds (SSSS)
c             IEOF - integer     - End-of-File status
c                                  0 = pointer within file
c                                  1 = EOF reached on read
c
c --- RDR2D called by:  MET1, RDMET
c --- RDR2D calls:      none
c----------------------------------------------------------------------
      real x(mxnx,mxny),xbuf(nx,ny)
      character*8 clabel

c --- Set EOF
      ieof=0
c
      if(nx.eq.mxnx.and.ny.eq.mxny)then
c
c ---    entire array is being used -- read full grid
         if(mtver.EQ.1) then
            read(iomet,end=999)clabel,ndathrb,nsecb,ndathre,nsece,x
         elseif(mtver.EQ.0) then
            read(iomet,end=999)clabel,ndathre,x
            nsece=0
            ndathrb=0
            nsecb=0
         endif
      else
c
c ---    only a portion of grid being used -- read and
c ---    transfer from buffer
         if(mtver.EQ.1) then
            read(iomet,end=999)clabel,ndathrb,nsecb,ndathre,nsece,xbuf
         elseif(mtver.EQ.0) then
            read(iomet,end=999)clabel,ndathre,xbuf
            nsece=0
            ndathrb=0
            nsecb=0
         endif
c
         do 10 i=1,nx
         do 10 j=1,ny
         x(i,j)=xbuf(i,j)
10       continue
      endif
c
      return

999   ieof=1
      return

      end
c----------------------------------------------------------------------
      subroutine initar(xvalue,nwords,xarr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950610                 INITAR
c                J. Scire, SRC
c
c --- PURPOSE:  Initialize an array with a constant value
c
c --- INPUTS:
c
c          XVALUE - real       - Value to used for initialization
c          NWORDS - integer    - Lengths of the data array (words)
c
c --- OUTPUT:
c
c    XARR(nwords) - real array - Array initialized
c
c --- INITAR called by:  RDISC, RDPLM
c --- INITAR calls:      none
c
c----------------------------------------------------------------------
c
      real xarr(nwords)
c
      x=xvalue
      do 10 i=1,nwords
      xarr(i)=x
10    continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine initai(ivalue,nwords,iarr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950610                 INITAI
c                J. Scire, SRC
c
c --- PURPOSE:  Initialize an integer array with a constant value
c
c --- INPUTS:
c
c          IVALUE - integer    - Value to used for initialization
c          NWORDS - integer    - Lengths of the data array (words)
c
c --- OUTPUT:
c
c    IARR(nwords) - int. array - Array initialized
c
c --- INITAI called by:  RDISC, RDPLM
c --- INITAI calls:      none
c
c----------------------------------------------------------------------
c
      integer iarr(nwords)
c
      ival=ivalue
      do 10 i=1,nwords
      iarr(i)=ival
10    continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine initr2d(xvalue,mx1,mx2,n1,n2,xarr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950610                INITR2D
c                J. Scire, SRC
c
c --- PURPOSE:  Initialize all or a portion of a REAL 2-D array
c               with a constant value
c
c --- INPUTS:
c
c          XVALUE - real       - Value to used for initialization
c          MX1    - integer    - Maximum first dimension of array
c          MX2    - integer    - Maximum second dimension of array
c          N1     - integer    - Number of 1st dim. elements to
c                                initialize
c          N2     - integer    - Number of 2nd dim. elements to
c                                initialize
c
c --- OUTPUT:
c
c   XARR(mx1,mx2) - real array - Array initialized with XVALUE -
c                                Elements (1-N1, 1-N2) are initialized
c
c --- INITR2D called by:  COMP, MET2, MET3, RDISC, RDPLM
c --- INITR2D calls:      none
c
c----------------------------------------------------------------------
c
      real xarr(mx1,mx2)
c
      x=xvalue
      do 10 i=1,n1
      do 10 j=1,n2
         xarr(i,j)=x
10    continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine initi2d(ivalue,mx1,mx2,n1,n2,iarr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 950610                INITI2D
c                J. Scire, SRC
c
c --- PURPOSE:  Initialize an integer array with a constant value
c
c --- INPUTS:
c
c          IVALUE - integer    - Value to used for initialization
c          MX1    - integer    - Maximum first dimension of array
c          MX2    - integer    - Maximum second dimension of array
c          N1     - integer    - Number of 1st dim. elements to
c                                initialize
c          N2     - integer    - Number of 2nd dim. elements to
c                                initialize
c
c --- OUTPUT:
c
c   IARR(mx1,mx2) - int. array - Array initialized with IVALUE -
c                                Elements (1-N1, 1-N2) are initialized
c
c --- INITI2D called by:  COMP, MET2, MET3, RDISC, RDPLM
c --- INITI2D calls:      none
c
c----------------------------------------------------------------------
c
      integer iarr(mx1,mx2)
c
      ival=ivalue
      do 10 i=1,n1
      do 10 j=1,n2
         iarr(i,j)=ival
10    continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine track(ip,idatm,isec,hlid0,jdstab)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  TRACK
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Write selected puff/slug data to a file to track
c               evolution in time
c
c --- UPDATE
c --- V5.3-V6.1     050915  (DGS): report end-time including seconds
c --- V5.2-V5.3     991222  (DGS): move write format to format statements
c --- V5.0-V5.2     991104  (DGS): report date-time with YYYY format
c --- V5.0-V5.0     980731  (DGS): add jdstab to output
c --- V4.0-V5.0     971107  (DGS): replace ZFINAL array with ZPB,ZPE
c
c --- INPUTS:
c              IP - integer    - Puff/slug index
c           IDATM - integer    - Ending date/time (yyyyjjjhh)
c            ISEC - integer    - Ending seconds (ssss)
c           HLID0 - real       - Mixing height (m) before change to
c                                reflecting height, zi
c          JDSTAB - integer    - Stability class used for puff
c
c --- OUTPUT:     (directed to file)
c
c
c --- TRACK called by:  COMP
c --- TRACK calls:      none
c
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'grid.puf'
      include 'puff.puf'
      include 'slug.puf'
c
      if(ipufcd(ip).EQ.99) return
c ---   (Puff/slug off computational grid)

      if(ipufcd(ip).GT.10) then
c ---    Slug
         slen=dgrid*SQRT((xpe(ip)-xpb(ip))**2+(ype(ip)-ypb(ip))**2)
         write(io30,101)
     &         idatm,isec,ip,ipufcd(ip),zpe(ip),xpe(ip),ype(ip),
     &         sigye(ip),sigze(ip),qm(1,ip),qu(1,ip),
     &         zimax(ip),ziold(ip),hlid0,jdstab,slen
      else
c ---    Puff
         write(io30,102)
     &         idatm,isec,ip,ipufcd(ip),zpb(ip),xpb(ip),ypb(ip),
     &         sigyb(ip),sigzb(ip),qm(1,ip),qu(1,ip),
     &         zimax(ip),ziold(ip),hlid0,jdstab
      endif
c
      return

101   format(i9,i5,i8,i3,f7.1,2f10.4,2f9.1,1p2e12.4,0p3f8.1,i4,3x,f8.1)
102   format(i9,i5,i8,i3,f7.1,2f10.4,2f9.1,1p2e12.4,0p3f8.1,i4)

      end
c----------------------------------------------------------------------
      subroutine wet(ixs,iys,nspec,tsamp,jp,tempk,ldbhr,xlam,fracwet)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                    WET
c                J. Scire
c
c --- PURPOSE:  Compute the scavenging ratios as a function of species
c               for wet removal
c --- UPDATE:
c --- V6.101-V6.22  070921  (DGS): Initialize variables for debug
c                                  output that may not be computed
c --- V5.7-V6.101   051020  (DGS): Multiply XLAM by the precipitation
c                                  rate to produce the scavenging ratio
c --- V5.5-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c
c --- INPUTS:
c              IXS - integer - X index of the closest met. grid point
c                              to the puff/slug center
c              IYS - integer - Y index of the closest met. grid point
c                              to the puff/slug center
c            NSPEC - integer - Number of modeled species
c            TSAMP - real    - Sampling step (s)
c               JP - integer - Puff number of current puff
c            TEMPK - real    - Air temperature (deg. K)
c            LDBHR - logical - Flag activating debug write statements
c                              (T = write, F = do not write)
c
c     Common Block /METHD/ variables:
c        I2DMET, NEARS(mxnx,mxny)
c     Common Block /METHR/ variables:
c        RMM(mxnx,mxny), IPCODE(mxss),IPCODE2D(mxnx,mxny)
c     Common Block /PUFF/ variables:
c        QM(mxspec,mxpuff), QU(mxspec,mxpuff)
c     Common Block /WETDAT/ variables:
c        WA(2,mxspec)
c     Parameters:
c        MXNX, MXNY, MXNZ, MXSS, MXUS, MXPS, MXNZP1, MXPUFF,
c        MXSPEC, IO6
c
c --- OUTPUT:
c      XLAM(nspec) - real    - Scavenging ratio (1/s) for each species
c   FRACWET(nspec) - real    - Fraction of puff mass remaining after
c                              consideration of wet removal effects
c     Common Block /PUFF/ variables:
c        QM(mxspec,mxpuff), QU(mxspec,mxpuff)
c
c --- WET called by:  COMP
c --- WET calls:      none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common blocks
      include 'methd.puf'
      include 'methr.puf'
      include 'puff.puf'
      include 'wetdat.puf'
c
      real fracwet(nspec),xlam(nspec)
      logical ldbhr
c
c --- Missing value indicators for integer, real variables
      data imiss/9999/

c --- Initialize variables written as debug output that may not
c --- be assigned
      ista=0
      ilq=0
      iprecip=0

c --- If no precipitation, no wet removal
      if(rmm(ixs,iys).eq.0.)then
         do i=1,nspec
            xlam(i)=0.0
            fracwet(i)=1.0
         enddo
         go to 101
      endif
c
c --- Determine if precipitation is liquid (ILQ=1) or frozen (ILQ=2)
c frr (09/01)- Use 2D arrays if available in CALMET

      if(i2dmet.EQ.1) then
         iprecip=ipcode2d(ixs,iys)
      elseif(i2dmet.EQ.0) then
         ista=nears(ixs,iys)
         iprecip=ipcode(ista)
      else
         write(*,*)'Subr. WET:  Invalid I2DMET = ',i2dmet
         stop
      endif

      if(iprecip.eq.imiss.or.iprecip.eq.0)then
c
c ---    Precip. code is unavailable due to missing data or no precip.
c ---    at time of obs. at surface station, therefore, determine
c ---    precip. type based on the air temperature
c
c ---    Assume liquid precip. if temp. > freezing, otherwise,
c ---    assume frozen precip.
         if(tempk.gt.273.15)then
            ilq=1
         else
            ilq=2
         endif
      else if(iprecip.le.18)then
c
c ---    Liquid precipitation type
         ilq=1
      else
c
c ---    Frozen precipitation type
         ilq=2
      endif
c
c --- Determine the amount of pollutant mass remaining after wet
c --- removal
      do i=1,nspec
         xlam(i)=wa(ilq,i)*rmm(ixs,iys)
         fracwet(i)=exp(-xlam(i)*tsamp)
         qu(i,jp)=fracwet(i)*qu(i,jp)
         qm(i,jp)=fracwet(i)*qm(i,jp)
      enddo
c
101   continue
c*****
      if(ldbhr)then
         write(io6,111)ixs,iys,ista,iprecip,tempk,ilq,rmm(ixs,iys),
     1   (xlam(n),n=1,nspec)
         write(io6,112)(fracwet(n),n=1,nspec)
111      format(15x,'WET REMOVAL -- IXS = ',i3,2x,'IYS = ',i3,2x,
     1   'ISTA = ',i4/17x,'Precip. code = ',i4,3x,'TEMPK = ',f6.2,
     2   2x,'ILQ = ',i2,2x,'RMM (mm/hr) = ',f7.2/17x,
     3   'Scav. Ratio   = ',2x,5(1pe11.3,1x))
112      format(17x,'Fraction left = ',2x,5(f11.3,1x))
      endif
c*****
      return
      end
c----------------------------------------------------------------------
      subroutine wrout1(title)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                 WROUT1
c                J. Scire
c
c --- PURPOSE:  Write the header records to the concentration,
c               dry flux, wet flux, and visibility output files
c                Concentration file: CONC.DAT (IO8)
c                Dry flux file:      DFLX.DAT (IO9)
c                Wet flux file:      WFLX.DAT (IO10)
c                Visibility files:   VISB.DAT (IO11)
c                                    TK2D.DAT (IO13)
c                                    RHO2D.DAT (IO14)
c               and to other output files
c                FOG data file:      FOG.DAT  (IO12)
c                NUMRISE data file:  RISE.DAT (IO38)
c
c --- UPDATE
c --- V6.1-V6.26    080430  (DGS): Add numerical rise output file
c                                  (RISE.DAT)
c                                  Create comment0 instead of comment1
c                                  for first comment record
c                   080430  (DGS): Do not close scratch file, just
c                                  rewind for later use
c --- V5.725-V6.1   050915  (DGS): IAVG processed in READCF, so do not
c                                  set here
c --- V5.72-V5.725  050128  (DGS): Add TK2D.DAT and RHO2D.DAT files
c                   050128  (DGS): Add call to COORDSVER and write info
c                                  to output file headers
c --- V5.7-V5.72    031017  (DGS): Revise format for source contribution
c                                  output option; use full begin/end
c                                  times as hour and second
c                                  (Dataset Version 2.1)
c --- V5.5-V5.7     030402  (DGS): Add list file unit to JULDAY call
c                   030402  (DGS): Revised header format with control
c                                  file images, and /MAP/ variables
c                   010901  (FRR): Add i2dmet for VISB.DAT header
c --- V5.0-V5.4     000602_2(DGS): Add LCOMPRS for FOG.DAT header
c --- V5.0-V5.4     000602  (DGS): IGRDVL changed to NVL2
c                   000602  (DGS): add FOG-model file (FOG.DAT)
c --- V4.0-V5.0     971107  (DGS): uses species-groups
c                   971107  (DGS): add number of lines from LNEMARB.DAT
c
c --- INPUTS:
c             TITLE(3) - Char.*80    - Run title (3 lines of
c                                      80 char. each)
c       Common block /AR1/ variables:
c             NAR1,CNAMAR1(mxarea)
c       Common block /AR2/ variables:
c             NAR2,CID3(mxarea)
c       Common block /CTSGDAT/ variables:
c             NHILL, NCTREC, XRCT(mxrect), YRCT(mxrect),
c             ELRECT(mxrect), IHILL(mxrect)
c       Common block /DATEHR/ variables:
c             XBTZ
c       Common block /FOG/ variables:
c             (all)
c       Common block /GEN/ variables:
c             IBYR, IBMO, IBDY, IBHR, IRLG, IBCOMP, JBCOMP, IECOMP,
c             JECOMP, IBSAMP, JBSAMP, IESAMP, JESAMP, MESHDN,
c             NGRUP, CGRUP(mxgrup)
c       Common block /GRID/ variables:
c             NX, NY, NZ, DGRID, XORIG, YORIG
c       Common block /LN1/ variables:
c             NLINES,CNAMLN1(mxlines)
c       Common block /LN2/ variables:
c             NLN2,CID5(mxlines)
c       Common block /MAP/ variables:
c             iutmzn,feast,fnorth,rnlat0,relon0,xlat1,xlat2,
c             pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2
c       Common block /METHD/ variables:
c             NSSTA, NEARS(mxnx,mxny), XSSTA(mxss), YSSTA(mxss), I2DMET
c       Common block /NONGRD/ variables:
c             NREC
c       Common block /OUTPT/ variables:
c             ICON, IDRY, IWET, IVIS, IT2D, IRHO, IOUTOP(7,mxspec),
c             LCOMPRS, IPRU, IFOG, INRISE, MSOURCE
c       Common block /PT1/ variables:
c             NPT1,CNAMPT1(mxpt1)
c       Common block /PT2/ variables:
c             NPT2,CID2(mxpt2)
c       Common block /QA/ variables:
c             VER, LEVEL, NCOMMOUT
c       Common block /VOL1/ variables:
c             NVL1,CNAMVL1(mxvol)
c       Common block /VOL2/ variables:
c             NVL2,CID4(mxvol)
c       Common block /WRKSPC/ variables:
c             TMP3(mxrec), TMP4(mxrec), TMP5(mxrect), TMP6(mxrect)
c       Parameters:
c             MXNZ, MXNZP1, MXGRUP, MXNZMP1,  MXPT1, MXPT2, MXREC,
c             MXNX, MXNY, MXSS, MXHILL, MXRECT,
c             MXPT1,MXPT2,MXAREA,MXLINES,MXVOL,
c             IO6, IO8, IO9, IO10, IO11, IO12, IO13, IO14, IO38
c             MMODEL, IOX
c
c --- OUTPUT:  none
c
c --- WROUT1 called by:  SETUP
c --- WROUT1 calls:      JULDAY, INCR, COORDSVER,
c                        XTRACT, XTRACTI, WRDAT, WRINT
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'ar1.puf'
      include 'ar2.puf'
      include 'ctsgdat.puf'
      include 'datehr.puf'
      include 'fog.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'map.puf'
      include 'methd.puf'
      include 'nongrd.puf'
      include 'outpt.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'qa.puf'
      include 'vol1.puf'
      include 'vol2.puf'
      include 'wrkspc.puf'
c
      real xkmsta(mxss),ykmsta(mxss)
      integer itmp(mxnx,mxny)
      character*80 title(3)
      character*15 csout(mxgrup),cdfout(mxgrup),cwfout(mxgrup)
      character*15 cvsout(1),ct2out,crhoout
      character*15 cname
c
      character*4 xyunit
      character*8 abtz
      character*16 conset,dryset,wetset,visset,dataver
      character*16 t2dset,rhoset
      character*16 risset,risever
      character*33 blank33
      character*64 datamod,risemod
      character*132 comment0,comment1,blank
c
      character*50 verdoc

      data ione/1/
      data xyunit/'KM  '/

      data blank33/'                                 '/

c --- Configure output documentation
      data conset/'CONC.DAT'/, dataver/'2.1'/
      data dryset/'DFLX.DAT'/, wetset/'WFLX.DAT'/
      data visset/'VISB.DAT'/, t2dset/'TK2D.DAT'/, rhoset/'RHO2D.DAT'/
      data datamod/'No-Obs file structure with embedded control file'/
      data risset/'RISE.DAT'/, risever/'1.0'/
      data risemod/'File structure with embedded control file'/
      data comment0/'Produced by CALPUFF Version: '/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Construct the version-level comment string
      j=30
      do i=1,8
         if(ver(i:i).NE.' ') then
            comment0(j:j)=ver(i:i)
            j=j+1
         endif
      enddo
      j=j+1
      comment0(j:j+7)=' Level: '
      j=j+8
      do i=1,8
         if(level(i:i).NE.' ') then
            comment0(j:j)=level(i:i)
            j=j+1
         endif
      enddo

c --- Obtain COORDS version information
      call COORDSVER(io6,verdoc)

c --- Set internal variables for output
      call JULDAY(io6,ibyr,ibmo,ibdy,ibjul)
      xorigkm=0.001*xorig
      yorigkm=0.001*yorig
      dgridkm=0.001*dgrid
      dxkm=dgridkm
      dykm=dgridkm
c --- NSPOUT, NDFOUT, and NWFOUT are the number of species stored in the
c --- concentration, dry flux, and wet flux output files, respectively
c --- NVSOUT is the number of visibility-related parameters in the
c --- visibility output file
c --- NT2OUT is number of parameters (1) in 2D Temperature output file
c --- NRHOOUT is number of parameters (1) in 2D Density output file
      nspout=0
      ndfout=0
      nwfout=0
      nvsout=1
      nt2out=1
      nrhoout=1
      do 10 i=1,ngrup
      if(ioutop(2,i).eq.1)nspout=nspout+1
      if(ioutop(4,i).eq.1)ndfout=ndfout+1
      if(ioutop(6,i).eq.1)nwfout=nwfout+1
10    continue

c --- Skip out if no output files are generated
      isum=icon+idry+iwet
      if(isum.eq.0)go to 100

c -----------------------------------
c --- Add dataset and comment records
c -----------------------------------
c
c --- Record #1 - File Declaration -- 24 words
      if(ICON.eq.1)write(io8) conset,dataver,datamod
      if(IDRY.eq.1)write(io9) dryset,dataver,datamod
      if(IWET.eq.1)write(io10) wetset,dataver,datamod
      if(IVIS.eq.1)write(io11) visset,dataver,datamod
      if(IT2D.eq.1)write(io13) t2dset,dataver,datamod
      if(IRHO.eq.1)write(io14) rhoset,dataver,datamod
c
c --- Record #2 - Number of comment lines -- 1 word
      ncom=ncommout+2
      if(ICON.eq.1)write(io8) ncom
      if(IDRY.eq.1)write(io9) ncom
      if(IWET.eq.1)write(io10) ncom
      if(IVIS.eq.1)write(io11) ncom
      if(IT2D.eq.1)write(io13) ncom
      if(IRHO.eq.1)write(io14) ncom
c
c --- Record #3 to NCOM+2 (Comment record section) -- 33 words each
      if(ICON.eq.1)write(io8) comment0
      if(IDRY.eq.1)write(io9) comment0
      if(IWET.eq.1)write(io10) comment0
      if(IVIS.eq.1)write(io11) comment0
      if(IT2D.eq.1)write(io13) comment0
      if(IRHO.eq.1)write(io14) comment0
c --- Report COORDS version
      comment1=blank
      comment1(1:36)='Internal Coordinate Transformations '
      comment1(37:86)=verdoc
      if(ICON.eq.1)write(io8) comment1
      if(IDRY.eq.1)write(io9) comment1
      if(IWET.eq.1)write(io10) comment1
      if(IVIS.eq.1)write(io11) comment1
      if(IT2D.eq.1)write(io13) comment1
      if(IRHO.eq.1)write(io14) comment1

c --- Go to beginning of the scratch file with the control file image
      REWIND(iox)
c --- Loop over records
      do i=1,ncommout
         comment1=blank
         read(iox,'(a132)') comment1
         if(ICON.eq.1)write(io8) comment1
         if(IDRY.eq.1)write(io9) comment1
         if(IWET.eq.1)write(io10) comment1
         if(IVIS.eq.1)write(io11) comment1
         if(IT2D.eq.1)write(io13) comment1
         if(IRHO.eq.1)write(io14) comment1
      enddo
c -------------------------------------------------------------------
c --- Previous header structure follows, with old record #1 augmented
c --- to include i2dmet and /MAP/ variables
c frr Additional flag i2dmet: if =1: 2D array of RH
c --- Add TIME to seconds; source counts by type; and MSOURCE option
c -------------------------------------------------------------------
c
c --- HEADER RECORD #NCOM+3 -- General run parameters
      if(ICON.eq.1)write(io8)mmodel,ver,level,ibyr,ibjul,ibhr,ibsec,
     1 xbtz,irlg,iavg,nsecdt,nx,ny,dxkm,dykm,ione,xorigkm,yorigkm,nssta,
     2 ibcomp,iecomp,jbcomp,jecomp,ibsamp,jbsamp,iesamp,jesamp,
     3 meshdn,npt1,npt2,nar1,nar2,nlines,nln2,nvl1,nvl2,msource,
     4 nrec,nctrec,lsamp,nspout,lcomprs,i2dmet,
     5 iutmzn,feast,fnorth,rnlat0,relon0,xlat1,xlat2,
     6 pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2

      if(IDRY.eq.1)write(io9)mmodel,ver,level,ibyr,ibjul,ibhr,ibsec,
     1 xbtz,irlg,iavg,nsecdt,nx,ny,dxkm,dykm,ione,xorigkm,yorigkm,nssta,
     2 ibcomp,iecomp,jbcomp,jecomp,ibsamp,jbsamp,iesamp,jesamp,
     3 meshdn,npt1,npt2,nar1,nar2,nlines,nln2,nvl1,nvl2,msource,
     4 nrec,nctrec,lsamp,ndfout,lcomprs,i2dmet,
     5 iutmzn,feast,fnorth,rnlat0,relon0,xlat1,xlat2,
     6 pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2

      if(IWET.eq.1)write(io10)mmodel,ver,level,ibyr,ibjul,ibhr,ibsec,
     1 xbtz,irlg,iavg,nsecdt,nx,ny,dxkm,dykm,ione,xorigkm,yorigkm,nssta,
     2 ibcomp,iecomp,jbcomp,jecomp,ibsamp,jbsamp,iesamp,jesamp,
     3 meshdn,npt1,npt2,nar1,nar2,nlines,nln2,nvl1,nvl2,msource,
     4 nrec,nctrec,lsamp,nwfout,lcomprs,i2dmet,
     5 iutmzn,feast,fnorth,rnlat0,relon0,xlat1,xlat2,
     6 pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2

      if(IVIS.eq.1)write(io11)mmodel,ver,level,ibyr,ibjul,ibhr,ibsec,
     1 xbtz,irlg,iavg,nsecdt,nx,ny,dxkm,dykm,ione,xorigkm,yorigkm,nssta,
     2 ibcomp,iecomp,jbcomp,jecomp,ibsamp,jbsamp,iesamp,jesamp,
     3 meshdn,npt1,npt2,nar1,nar2,nlines,nln2,nvl1,nvl2,msource,
     4 nrec,nctrec,lsamp,nvsout,lcomprs,i2dmet,
     5 iutmzn,feast,fnorth,rnlat0,relon0,xlat1,xlat2,
     6 pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2

      if(IT2D.eq.1)write(io13)mmodel,ver,level,ibyr,ibjul,ibhr,ibsec,
     1 xbtz,irlg,iavg,nsecdt,nx,ny,dxkm,dykm,ione,xorigkm,yorigkm,nssta,
     2 ibcomp,iecomp,jbcomp,jecomp,ibsamp,jbsamp,iesamp,jesamp,
     3 meshdn,npt1,npt2,nar1,nar2,nlines,nln2,nvl1,nvl2,msource,
     4 nrec,nctrec,lsamp,nt2out,lcomprs,i2dmet,
     5 iutmzn,feast,fnorth,rnlat0,relon0,xlat1,xlat2,
     6 pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2

      if(IRHO.eq.1)write(io14)mmodel,ver,level,ibyr,ibjul,ibhr,ibsec,
     1 xbtz,irlg,iavg,nsecdt,nx,ny,dxkm,dykm,ione,xorigkm,yorigkm,nssta,
     2 ibcomp,iecomp,jbcomp,jecomp,ibsamp,jbsamp,iesamp,jesamp,
     3 meshdn,npt1,npt2,nar1,nar2,nlines,nln2,nvl1,nvl2,msource,
     4 nrec,nctrec,lsamp,nrhoout,lcomprs,i2dmet,
     5 iutmzn,feast,fnorth,rnlat0,relon0,xlat1,xlat2,
     6 pmap,utmhem,datum,daten,clat0,clon0,clat1,clat2

c
c --- HEADER RECORD #NCOM+4 -- Run title
      if(ICON.eq.1)write(io8)title
      if(IDRY.eq.1)write(io9)title
      if(IWET.eq.1)write(io10)title
      if(IVIS.eq.1)write(io11)title
      if(IT2D.eq.1)write(io13)title
      if(IRHO.eq.1)write(io14)title
c
c --- HEADER RECORD #NCOM+5 -- List of species-groups output
      nc=0
      nd=0
      nw=0
      do 20 k=1,ngrup
c
c --- Set output concentration/layer labels
      if(ioutop(2,k).eq.1)then
         nc=nc+1
         write(csout(nc)(1:12),'(a12)')cgrup(k)
         csout(nc)(13:15)='  1'
      endif
c
c --- Set output dry flux labels
      if(ioutop(4,k).eq.1)then
         nd=nd+1
         write(cdfout(nd)(1:12),'(a12)')cgrup(k)
         cdfout(nd)(13:15)=' DF'
      endif
c
c --- Set output wet flux labels
      if(ioutop(6,k).eq.1)then
         nw=nw+1
         write(cwfout(nw)(1:12),'(a12)')cgrup(k)
         cwfout(nw)(13:15)=' WF'
      endif
20    continue
c
c --- Set output visibility labels
      nv=1
      write(cvsout(nv)(1:12),'(a12)') ' REL HUM (%)   '
      write(ct2out(1:12),'(a12)') ' TEMP 2D (K)   '
      write(crhoout(1:12),'(a12)') ' RHO 2D (K)    '
c
      if(ICON.eq.1)write(io8)(csout(n),n=1,nspout)
      if(IDRY.eq.1)write(io9)(cdfout(n),n=1,ndfout)
      if(IWET.eq.1)write(io10)(cwfout(n),n=1,nwfout)
      if(IVIS.eq.1)write(io11)(cvsout(n),n=1,nvsout)
      if(IT2D.eq.1)write(io13)(ct2out)
      if(IRHO.eq.1)write(io14)(crhoout)
c
c --- HEADER RECORD #NCOM+6 -- Discrete (non-gridded) receptor data
c
c --- Convert receptor coordinates from grid units back to UTM (km)
      if(nrec.gt.0)then
            do 30 i=1,nrec
            tmp3(i)=xng(i)*dgridkm+xorigkm
            tmp4(i)=yng(i)*dgridkm+yorigkm
30          continue
c
         if(ICON.eq.1)write(io8)(tmp3(n),n=1,nrec),
     1    (tmp4(n2),n2=1,nrec),(elevng(n3),n3=1,nrec)
         if(IDRY.eq.1)write(io9)(tmp3(n),n=1,nrec),
     1    (tmp4(n2),n2=1,nrec),(elevng(n3),n3=1,nrec)
         if(IWET.eq.1)write(io10)(tmp3(n),n=1,nrec),
     1    (tmp4(n2),n2=1,nrec),(elevng(n3),n3=1,nrec)
         if(IVIS.eq.1)write(io11)(tmp3(n),n=1,nrec),
     1    (tmp4(n2),n2=1,nrec),(elevng(n3),n3=1,nrec)
         if(IT2D.eq.1)write(io13)(tmp3(n),n=1,nrec),
     1    (tmp4(n2),n2=1,nrec),(elevng(n3),n3=1,nrec)
         if(IRHO.eq.1)write(io14)(tmp3(n),n=1,nrec),
     1    (tmp4(n2),n2=1,nrec),(elevng(n3),n3=1,nrec)
      endif
c
c --- HEADER RECORD #NCOM+7 -- Complex terrain receptor data
c
c --- Convert CTSG receptor coordinates from grid units back to UTM (km)
      if(nctrec.gt.0)then
            do 40 i=1,nctrec
            tmp5(i)=xrct(i)*dgridkm+xorigkm
            tmp6(i)=yrct(i)*dgridkm+yorigkm
40          continue
c
         if(ICON.eq.1)write(io8)(tmp5(n),n=1,nctrec),
     1    (tmp6(n2),n2=1,nctrec),(elrect(n3),n3=1,nctrec),
     2    (ihill(n4),n4=1,nctrec)
         if(IDRY.eq.1)write(io9)(tmp5(n),n=1,nctrec),
     1    (tmp6(n2),n2=1,nctrec),(elrect(n3),n3=1,nctrec),
     2    (ihill(n4),n4=1,nctrec)
         if(IWET.eq.1)write(io10)(tmp5(n),n=1,nctrec),
     1    (tmp6(n2),n2=1,nctrec),(elrect(n3),n3=1,nctrec),
     2    (ihill(n4),n4=1,nctrec)
         if(IVIS.eq.1)write(io11)(tmp5(n),n=1,nctrec),
     1    (tmp6(n2),n2=1,nctrec),(elrect(n3),n3=1,nctrec),
     2    (ihill(n4),n4=1,nctrec)
         if(IT2D.eq.1)write(io13)(tmp5(n),n=1,nctrec),
     1    (tmp6(n2),n2=1,nctrec),(elrect(n3),n3=1,nctrec),
     2    (ihill(n4),n4=1,nctrec)
         if(IRHO.eq.1)write(io14)(tmp5(n),n=1,nctrec),
     1    (tmp6(n2),n2=1,nctrec),(elrect(n3),n3=1,nctrec),
     2    (ihill(n4),n4=1,nctrec)
      endif
c
c
c --- HEADER RECORDs #NCOM+8 to 15 -- Source names
c     (not written to VISIBILITY files)
c
      if(npt1.GT.0) then
         itype=1
         if(ICON.eq.1)write(io8) itype,(cnampt1(n),n=1,npt1)
         if(IDRY.eq.1)write(io9) itype,(cnampt1(n),n=1,npt1)
         if(IWET.eq.1)write(io10) itype,(cnampt1(n),n=1,npt1)
      endif
c
      if(npt2.GT.0) then
         itype=2
         if(ICON.eq.1)write(io8) itype,(cid2(n),n=1,npt2)
         if(IDRY.eq.1)write(io9) itype,(cid2(n),n=1,npt2)
         if(IWET.eq.1)write(io10) itype,(cid2(n),n=1,npt2)
      endif
c
      if(nar1.GT.0) then
         itype=3
         if(ICON.eq.1)write(io8) itype,(cnamar1(n),n=1,nar1)
         if(IDRY.eq.1)write(io9) itype,(cnamar1(n),n=1,nar1)
         if(IWET.eq.1)write(io10) itype,(cnamar1(n),n=1,nar1)
      endif
c
      if(nar2.GT.0) then
         itype=4
         if(ICON.eq.1)write(io8) itype,(cid3(n),n=1,nar2)
         if(IDRY.eq.1)write(io9) itype,(cid3(n),n=1,nar2)
         if(IWET.eq.1)write(io10) itype,(cid3(n),n=1,nar2)
      endif
c
      if(nlines.GT.0) then
         itype=5
         if(ICON.eq.1)write(io8) itype,(cnamln1(n),n=1,nlines)
         if(IDRY.eq.1)write(io9) itype,(cnamln1(n),n=1,nlines)
         if(IWET.eq.1)write(io10) itype,(cnamln1(n),n=1,nlines)
      endif
c
      if(nln2.GT.0) then
         itype=6
         if(ICON.eq.1)write(io8) itype,(cid5(n),n=1,nln2)
         if(IDRY.eq.1)write(io9) itype,(cid5(n),n=1,nln2)
         if(IWET.eq.1)write(io10) itype,(cid5(n),n=1,nln2)
      endif
c
      if(nvl1.GT.0) then
         itype=7
         if(ICON.eq.1)write(io8) itype,(cnamvl1(n),n=1,nvl1)
         if(IDRY.eq.1)write(io9) itype,(cnamvl1(n),n=1,nvl1)
         if(IWET.eq.1)write(io10) itype,(cnamvl1(n),n=1,nvl1)
      endif
c
      if(nvl2.GT.0) then
         itype=8
         if(ICON.eq.1)write(io8) itype,(cid4(n),n=1,nvl2)
         if(IDRY.eq.1)write(io9) itype,(cid4(n),n=1,nvl2)
         if(IWET.eq.1)write(io10) itype,(cid4(n),n=1,nvl2)
      endif
c
c
c --- HEADER RECORDS
c ---     #NCOM+8 -- Nearest Surface Station for VISIBILITY ONLY
c ---     #NCOM+9 -- X coord (UTM) of stations for VISIBILITY ONLY
c ---    #NCOM+10 -- Y coord (UTM) of stations for VISIBILITY ONLY
c
c frr (4/02) if 2D RH file, no need for nearest station info (nssta can
c            be =0)
c
c            
c ---
c      if(IVIS.eq.1)then
      if((IVIS.eq.1 .OR. IT2D.eq.1 .OR. IRHO.eq.1)
     &                            .and. i2dmet.eq.0 )then
c
c ---    Check if active portion of the MET grid is less than the full
c ---    dimension (active portion is extracted for output purposes)
         ifullm=0
         if(nx.eq.mxnx.and.ny.eq.mxny)then
            ifullm=1
         endif
c ---    Nearest Station Array (rec #6)
         cname=' NEARS         '
         if(ifullm.eq.1)then
            if(IVIS.eq.1)call wrint(io11,cname,nears,nx,ny)
            if(IT2D.eq.1)call wrint(io13,cname,nears,nx,ny)
            if(IRHO.eq.1)call wrint(io14,cname,nears,nx,ny)
         else
            call xtracti(nears,mxnx,mxny,nx,ny,itmp)
            if(IVIS.eq.1)call wrint(io11,cname,itmp,nx,ny)
            if(IT2D.eq.1)call wrint(io13,cname,itmp,nx,ny)
            if(IRHO.eq.1)call wrint(io14,cname,itmp,nx,ny)
         endif
c ---    Convert station coordinates to UTM from meters relative to
c ---    met grid origin
         do is=1,nssta
            xkmsta(is)=xorigkm+0.001*xssta(is)
            ykmsta(is)=yorigkm+0.001*yssta(is)
         enddo
c ---    X-coord (km) of each surface station (rec #7)
         cname=' XSSTA-UTM     '
         if(IVIS.eq.1)call wrdat(io11,cname,xkmsta,nssta,1)
         if(IT2D.eq.1)call wrdat(io13,cname,xkmsta,nssta,1)
         if(IRHO.eq.1)call wrdat(io14,cname,xkmsta,nssta,1)
c ---    Y-coord (km) of each surface station (rec #8)
         cname=' YSSTA-UTM     '
         if(IVIS.eq.1)call wrdat(io11,cname,ykmsta,nssta,1)
         if(IT2D.eq.1)call wrdat(io13,cname,ykmsta,nssta,1)
         if(IRHO.eq.1)call wrdat(io14,cname,ykmsta,nssta,1)
      endif
c
100   continue

c --- Section for FOG.DAT (binary)
c -------------------------------
      if(IFOG.GT.0) then
         if(LPMODE) then
c ---       Plume mode: write second header record with
c ---       downwind distances in meters from source
            write(io12) ftitle,nfrec,nfpts,ipcp,ifyr,ifdays,lpmode
            write(io12) lcomprs,xrfog
         else
            write(io12) ftitle,nfrec,nfpts,ipcp,ifyr,ifdays,lpmode
            write(io12) lcomprs
         endif
      endif

c --- Section for RISE.DAT (ASCII)
c --------------------------------
      if(inrise.GT.0) then

c ---    Initial header records

c ---    Record #1 - File Declaration
         write(io38,'(2a16,a64)') risset,risever,risemod
c ---    Record #2 - Number of comment lines
         ncom=ncommout+2
         write(io38,*) ncom
c ---    Record #3 to NCOM+2 (Comment record section)
         write(io38,'(a132)') comment0
c ---    Report COORDS version
         comment1=blank
         comment1(1:36)='Internal Coordinate Transformations '
         comment1(37:86)=verdoc
         write(io38,'(a132)') comment1

c ---    Control file image
c ---    Go to beginning of the scratch file with the control file image
         REWIND(iox)
c ---    Loop over control file records
         do i=1,ncommout
            comment1=blank
            read(iox,'(a132)') comment1
            write(io38,'(a132)') comment1
         enddo

c ---    Map
         write(io38,'(a8)')pmap
         if(LUTM) then
            write(io38,'(i4,a4)')  iutmzn,utmhem
         elseif(LLCC) then
            write(io38,'(4a16)')  clat0,clon0,clat1,clat2
         elseif(LPS) then
            write(io38,'(3a16)')  clat0,clon0,clat1
         elseif(LEM.or.LLAZA.or.LTTM) then
            write(io38,'(2a16)')  clat0,clon0
         endif
c ---    Map false Easting/Northing
         if(LLCC.or.LLAZA.or.LTTM) then
            write(io38,*) feast,fnorth
         endif
c ---    Map DATUM and date
         write(io38,'(a8,a12)')  datum,daten
c ---    Units
         write(io38,'(a4)')  xyunit
c ---    Time zone
         abtz='UTC+0000'
         ibtz00=-100*(NINT(xbtz))
         if(ibtz00.LT.0) then
            write(abtz(4:8),'(i5.4)')ibtz00
         else
            write(abtz(5:8),'(i4.4)')ibtz00
         endif
         write(io38,'(a8)')abtz

c ---    Source information
c ---    Number by type
         write(io38,*) 1,npt1,2,npt2,3,nar1,4,nar2,
     &                 5,nlines,6,nln2,7,nvl1,8,nvl2
c ---    Names
         if(npt1.GT.0) then
            itype=1
            write(io38,*) itype,(cnampt1(n),n=1,npt1)
         endif
         if(npt2.GT.0) then
            itype=2
            write(io38,*) itype,(cid2(n),n=1,npt2)
         endif
         if(nar1.GT.0) then
            itype=3
            write(io38,*) itype,(cnamar1(n),n=1,nar1)
         endif
         if(nar2.GT.0) then
            itype=4
            write(io38,*) itype,(cid3(n),n=1,nar2)
         endif
         if(nlines.GT.0) then
            itype=5
            write(io38,*) itype,(cnamln1(n),n=1,nlines)
         endif
         if(nln2.GT.0) then
            itype=6
            write(io8,*) itype,(cid5(n),n=1,nln2)
         endif
         if(nvl1.GT.0) then
            itype=7
            write(io38,*) itype,(cnamvl1(n),n=1,nvl1)
         endif
         if(nvl2.GT.0) then
            itype=8
            write(io38,*) itype,(cid4(n),n=1,nvl2)
         endif

c ---    Restrict number of sources to ONE for this output to limit
c ---    the size of the output file
         nqa=npt1+npt2+nar1+nar2+nlines+nln2+nvl1+nvl2
         if(nqa.NE.1) then
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'----------------------------------------------'
            write(io6,*)'          FATAL FLAW  !! '
            write(io6,*)'----------------------------------------------'
            write(io6,*)'Selection of RISE.DAT file output is currently'
            write(io6,*)'restricted to one source.  Number of sources'
            write(io6,*)'found = ',nqa
            write(io6,*)'----------------------------------------------'
            stop 'Halted in WROUT1 --- see list file'
         endif
      endif

c --- Finished with scratch file image of documentation records
      REWIND(iox)

      return
      end
c----------------------------------------------------------------------
      subroutine output(istep,isrcmode,ktype,ksource)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                 OUTPUT
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Output concentration, dry & wet deposition flux
c               fields
c
c               Print concentrations every "ICFRQ" hours (if ICPRT=1)
c               Print dry fluxes every "IDFRQ" hours (if IDPRT=1)
c               Print wet fluxes every "IWFRQ" hours (if IWPRT=1)
c
c               Write specified concentrations and fluxes to disk
c               hourly -- concentration file (IO8), dry flux file (IO9),
c               wet flux file (IO10)
c
c --- UPDATE
c --- V5.725-V6.1   050915  (DGS): Update /DATEHR/ variables
c                           (DGS): Add emission step to AR2,VOL2,LN2
c                                  arrays
c --- V5.72-V5.725  050128  (DGS): Add TK2D.DAT & RHO2D.DAT output files
c --- V5.7-V5.72    031017  (DGS): Add ISRCMODE switch to distinguish
c                                  between source contribution output
c                                  and total output;
c                                  Augment time record with both begin
c                                  and end times;
c                                  Add new record with source name and
c                                  location
c --- V5.2-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c --- V5.0-V5.0     990228d (DGS): add mass balance output
c --- V5.0-V5.0     990228c (DGS): add mass flux output
c --- V5.0-V5.0     981025  (DGS): full list-file output for fluxes
c --- V4.0-V5.0     971107  (DGS): add user-units in LIST output
c                   971107  (DGS): change from species list to
c                                  species-groups for output
c
c --- INPUTS:
c              ISTEP   - integer    - Time step number
c           ISRCMODE   - integer    - Source contribution mode
c                                     0: output for all sources
c                                     1: source contribution output
c              KTYPE   - integer    - Source type
c            KSOURCE   - integer    - Source number
c
c     Common block /AR1/ variables:
c          NAR1,CNAMAR1(mxarea),NVERT1(mxarea),
c          XAR1GRD(mxvertp1,mxarea),YAR1GRD(mxvertp1,mxarea)
c     Common block /AR2/ variables:
c          NAR2,CID3(mxarea),NVERT2(mxarea),
c          XAR2GRD(mxvertp1,mxqstep,mxarea),
c          YAR2GRD(mxvertp1,mxqstep,mxarea)
c     Common block /CHIFLX/ variables
c          CHISAM(mxnxg,mxnyg,mxspec), DFSAM(mxnxg,mxnyg,mxspec),
c          WFSAM(mxnxg,mxnyg,mxspec), CHIREC(mxrec,mxspec),
c          DFREC(mxrec,mxspec), WFREC(mxrec,mxspec),
c          CHICT(mxrect,mxspec)
c     Common block /CTSGDAT/ variables
c          NCTREC, XRCT(mxrect), YRCT(mxrect), ELRECT(mxrect),
c          IHILL(mxrect)
c       Common block /DATEHR/ variables
c          NYRAB, NMOAB, NDAYAB, NJULAB, NHRAB, NSECAB,
c          NYRE, NMOE, NDAYE, NJULE, NHRE, NSECE
c     Common block /GEN/ variables
c          NSPEC, CSPEC(mxgrup),
c          NGRUP, CGRUP(mxgrup), ISPGRP(mxspec)
c     Common block /GRID/ variables
c          DGRID, XORIG, YORIG,
c          NXSAM, NYSAM, LSAMP
c     Common block /LN1/ variables:
c          NLINES,CNAMLN1(mxlines),XL1BEGGRD(mxlines),YL1BEGGRD(mxlines)
c          XL1ENDGRD(mxlines),YL1ENDGRD(mxlines)
c     Common block /LN2/ variables:
c          NLN2,CID5(mxlines),
c          XL2BEGGRD(mxqstep,mxlines),YL2BEGGRD(mxqstep,mxlines),
c          XL2ENDGRD(mxqstep,mxlines),YL2ENDGRD(mxqstep,mxlines)
c     Common block /METHD/ variables
c          NSSTA, I2DMET , NXM, NYM
c     Common block /METHR/ variables
c          IRHSS(mxss), IRH2D(mxnx,mxny),
c          TEMPSS(mxss), TEMP2D(mxnx,mxny)
c     Common block /NONGRD/ variables
c          NREC
c     Common block /OUTPT/ variables
c          ICON, IDRY, IWET, ICPRT, IDPRT, IWPRT, ICFRQ, IDFRQ, IWFRQ,
c          IVIS, IT2D, IRHO,
c          IOUTOP(7,mxspec), LCOMPRS, IPRTU, IMFLX, IMBAL
c     Common block /PT1/ variables:
c          NPT1,CNAMPT1(mxpt1),,XPT1GRD(mxpt1),YPT1GRD(pt1)
c     Common block /PT2/ variables:
c          NPT2,CID2(mxpt2),TIEM2(8,mxpt2)
c     Common block /VOL1/ variables:
c          NVL1,CNAMVL1(mxvol),XVL1GRD(mxvol),YVL1GRD(mxvol)
c     Common block /VOL2/ variables:
c          NVL2,CID4(mxvol),
c          XVL2GRD(mxqstep,mxvol),YVL2GRD(mxqstep,mxvol)
c     Common block /WRKSPC/ variables
c          TMP1(mxnx,mxny),
c          TMP3(mxrec),TMP5(mxrect),TMP7(mxnxg,mxnyg),TMP8(mxnxg,mxnyg)
c
c     Parameters: MXNXG, MXNYG, MXSPEC, MXREC, MXRECT, MXNZP1, MXSS,
c                 MXPT1,MXPT2,MXAREA,MXLINES,MXVOL,  MXNX,MXNY
c                 IO6, IO8, IO9, IO10, IO11, IO13, IO14
c
c --- OUTPUT:  none
c
c --- OUTPUT called by: COMP
c --- OUTPUT calls:     OUTSAM, WRDAT, COMPRS, MFLXGRP,
c                       MFLXOUT, MBALOUT
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      real xtmp(mxspec),rprtu(5)
      integer istore(mxgrup)
      character*70 messag
      character*16 csrcnam
      character*15 cname
      character*15 cnameRh, cnameTK, cnameDN
      character*13 cunits,funits
      character*12 cspecsv(mxspec)
      character*1  cprtu(4)
      logical ldate
c
c frr(09/01)
      integer itmp(mxnx,mxny)

      include 'chiflx.puf'
      include 'ctsgdat.puf'
      include 'datehr.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'nongrd.puf'
      include 'outpt.puf'
      include 'wrkspc.puf'

c --- Include source commons for source names
      include 'ar1.puf'
      include 'ar2.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'vol1.puf'
      include 'vol2.puf'
c
      data ldate/.true./
c
c --- Set character for scale of output units (m:milli,u:micro,n:nano)
      data cprtu/' ','m','u','n'/
c --- Set units conversion factor
      data rprtu/1.0,1.0e3,1.0e6,1.0e9,1.0/

c --- Construct units name for concentrations (list file)
      cunits='(Odour Units)'
      if(iprtu.LT.5) then
         cunits='( g/m**3)    '
         cunits(2:2)=cprtu(iprtu)
      endif

c --- Set grid coordinates in km
      xorigkm=0.001*xorig
      yorigkm=0.001*yorig
      dgridkm=0.001*dgrid

c --- Identify source
c --- (Use position of current emission step 1 for moving sources)
      csrcnam='                '
      if(isrcmode.EQ.1) then
c ---    Output for a specific source
         if(ktype.EQ.1) then
            csrcnam=cnampt1(ksource)
            xmapkm=xpt1grd(ksource)*dgridkm+xorigkm
            ymapkm=ypt1grd(ksource)*dgridkm+yorigkm
         elseif(ktype.EQ.2) then
            csrcnam=cid2(ksource)
            xmapkm=tiem2(1,ksource)*dgridkm+xorigkm
            ymapkm=tiem2(2,ksource)*dgridkm+yorigkm
         elseif(ktype.EQ.3) then
            csrcnam=cnamar1(ksource)
            xmapkm=xar1grd(1+nvert1(ksource),ksource)*dgridkm+xorigkm
            ymapkm=yar1grd(1+nvert1(ksource),ksource)*dgridkm+yorigkm
         elseif(ktype.EQ.4) then
            csrcnam=cid3(ksource)
            xmapkm=xar2grd(1+nvert2(ksource),1,ksource)*dgridkm+xorigkm
            ymapkm=yar2grd(1+nvert2(ksource),1,ksource)*dgridkm+yorigkm
         elseif(ktype.EQ.5) then
            csrcnam=cnamln1(ksource)
            xgrd=0.5*(xlbeggrd(ksource)+xlendgrd(ksource))
            ygrd=0.5*(ylbeggrd(ksource)+ylendgrd(ksource))
            xmapkm=xgrd*dgridkm+xorigkm
            ymapkm=ygrd*dgridkm+yorigkm
         elseif(ktype.EQ.6) then
            csrcnam=cid5(ksource)
            xgrd=0.5*(xl2beggrd(1,ksource)+xl2endgrd(1,ksource))
            ygrd=0.5*(yl2beggrd(1,ksource)+yl2endgrd(1,ksource))
            xmapkm=xgrd*dgridkm+xorigkm
            ymapkm=ygrd*dgridkm+yorigkm
         elseif(ktype.EQ.7) then
            csrcnam=cnamvl1(ksource)
            xmapkm=xvl1grd(ksource)*dgridkm+xorigkm
            ymapkm=yvl1grd(ksource)*dgridkm+yorigkm
         elseif(ktype.EQ.8) then
            csrcnam=cid4(ksource)
            xmapkm=xvl2grd(1,ksource)*dgridkm+xorigkm
            ymapkm=yvl2grd(1,ksource)*dgridkm+yorigkm
         else
            write(io6,*) 'FATAL error in OUTPUT - invalid source'
            write(io6,*) 'Source Type and number = ',ktype,ksource
            stop 'Subr. OUTPUT:  Invalid Source'
         endif
      else
c ---    Output for all sources (total)
         if(ktype.EQ.0 .AND. ksource.EQ.1) then
            csrcnam='TOTAL           '
            xmapkm=xorigkm
            ymapkm=yorigkm
         else
            write(io6,*) 'FATAL error in OUTPUT - invalid source'
            write(io6,*) 'Source Type and number = ',ktype,ksource
            stop 'Subr. OUTPUT:  Invalid Source'
         endif
      endif

c --- Construct units name for fluxes  (list file)
      funits='(-----------)'
      if(iprtu.LT.5) then
         funits='( g/m**2/s)  '
         funits(2:2)=cprtu(iprtu)
      endif
c
c --- Check if active portion of the sampling arrays is less than
c --- the full dimension (if so, active portion is extracted for
c --- output purposes
      ifull=0
      if(lsamp) then
         if(nxsam.eq.mxnxg.and.nysam.eq.mxnyg)then
            ifull=1
         endif
      endif

c ---------------------------------------------------------
c --- PROCESS OUTPUT SPECIES-GROUPS
c ---------------------------------------------------------
c --- Conc/flux data for each species that are in a group are summed
c --- prior to output, and given the name of the species-group.  The
c --- summation is done at the array location of the first species
c --- in the group.
c
c --- Definitions ---
c --- ISPGRP(i)       :group index for species i
c --- CGRUP(j)        :output species name for group j
c --- ISTORE(j)       :index of conc/flux arrays used to store
c                      summed results for group j
c ---------------------------------------------------------
c --- Clear istore array
      do is=1,nspec
         istore(is)=0
      enddo

c --- Group species and store
      do is=1,nspec
         if(istore(ispgrp(is)).EQ.0) then
c ---       First species in this group; just store array location
            istore(ispgrp(is))=is
         else
c ---       Add results for this species to the existing sum
c ---       Gridded receptors
            if(LSAMP) then
               do iy=1,nysam
                  do ix=1,nxsam
                     chisam(ix,iy,istore(ispgrp(is)))=
     &               chisam(ix,iy,istore(ispgrp(is)))+chisam(ix,iy,is)
                     dfsam(ix,iy,istore(ispgrp(is)))=
     &               dfsam(ix,iy,istore(ispgrp(is)))+dfsam(ix,iy,is)
                     wfsam(ix,iy,istore(ispgrp(is)))=
     &               wfsam(ix,iy,istore(ispgrp(is)))+wfsam(ix,iy,is)
                  enddo
               enddo
            endif
c ---       Discrete receptors
            do ir=1,nrec
               chirec(ir,istore(ispgrp(is)))=
     &         chirec(ir,istore(ispgrp(is)))+chirec(ir,is)
               dfrec(ir,istore(ispgrp(is)))=
     &         dfrec(ir,istore(ispgrp(is)))+dfrec(ir,is)
               wfrec(ir,istore(ispgrp(is)))=
     &         wfrec(ir,istore(ispgrp(is)))+wfrec(ir,is)
            enddo
c ---       CTSG receptors
            do ir=1,nctrec
               chict(ir,istore(ispgrp(is)))=
     &         chict(ir,istore(ispgrp(is)))+chict(ir,is)
            enddo
c ---       Mass flux arrays
            if(imflx.EQ.1 .AND. isrcmode.NE.1) call MFLXGRP(istore
     &                                             (ispgrp(is)),is)
         endif
      enddo

c ---------------------------------------------------------
c --- WRITE CONCENTRATIONS TO DISK   (g/m**3)
c ---------------------------------------------------------
c
c --- Output date/hour times use 0-23 convention so that hour 24
c --- of day 12 starts at 23 0000 on day 12 and ends at 00 0000
c --- on day 13.
      if(icon.ne.1)go to 492
c
c --- Write date/time and source data records
      write(io8)nyrab,njulab,nhrab,nsecab,nyre,njule,nhre,nsece
      write(io8)ktype,ksource,csrcnam,xmapkm,ymapkm
c
      do 400 ig=1,ngrup
c --- Identify array storage location for this group
      i=istore(ig)
c
c --- Only species-groups specified are stored on disk
      if(ioutop(2,ig).eq.1)then
         cname=cgrup(ig)
         cname(13:15)='  1'
c
c ---    Gridded receptor concentrations
         if(lsamp) then
            if(ifull.eq.1)then
               if(lcomprs)then
c ---             Write compressed data records
                  call comprs(chisam(1,1,i),mxnxyg,tmp8,mxnxyg,
     1              cname,io8)
               else
c ---             Write uncompressed data record
                  call wrdat(io8,cname,chisam(1,1,i),nxsam,nysam)
               endif
            else
               call xtract(chisam(1,1,i),mxnxg,mxnyg,nxsam,nysam,tmp7)
               if(lcomprs)then
c ---             Write compressed data records
                  nwords=nxsam*nysam
                  call comprs(tmp7,nwords,tmp8,mxnxyg,cname,io8)
               else
c ---             Write uncompressed data record
                  call wrdat(io8,cname,tmp7,nxsam,nysam)
               endif
            endif
         endif
c
c ---    Discrete receptor concentrations
         if(nrec .GT. 0) then
            if(lcomprs)then
c ---          Write compressed data records
               call comprs(chirec(1,i),nrec,tmp3,mxrec,cname,io8)
            else
c ---          Write uncompressed data record
               call wrdat(io8,cname,chirec(1,i),nrec,1)
            endif
         endif
c
c ---    Discrete CTSG receptor concentrations
         if(nctrec .GT. 0) then
            if(lcomprs)then
c ---          Write compressed data records
               call comprs(chict(1,i),nctrec,tmp5,mxrect,cname,io8)
            else
c ---          Write uncompressed data record
               call wrdat(io8,cname,chict(1,i),nctrec,1)
            endif
         endif
      endif
400   continue
492   continue
c ---------------------------------------------------------
c --- WRITE DRY FLUXES TO DISK  (g/m**2/s)
c ---------------------------------------------------------
c
c --- Output date/hour times use 0-23 convention so that hour 24
c --- of day 12 starts at 23 0000 on day 12 and ends at 00 0000
c --- on day 13.
      if(idry.ne.1)go to 592
c
c --- Write date/time and source data records
      write(io9)nyrab,njulab,nhrab,nsecab,nyre,njule,nhre,nsece
      write(io9)ktype,ksource,csrcnam,xmapkm,ymapkm
c
      do 500 ig=1,ngrup
c --- Identify array storage location for this group
      i=istore(ig)
c
c --- Only species specified are stored on disk
      if(ioutop(4,ig).eq.1)then
         cname=cgrup(ig)
         cname(13:15)=' DF'
c
c ---    Gridded receptor dry fluxes
         if(lsamp) then
            if(ifull.eq.1)then
               if(lcomprs)then
c ---             Write compressed data records
                  call comprs(dfsam(1,1,i),mxnxyg,tmp8,mxnxyg,
     1              cname,io9)
               else
c ---             Write uncompressed data record
                  call wrdat(io9,cname,dfsam(1,1,i),nxsam,nysam)
               endif
            else
               call xtract(dfsam(1,1,i),mxnxg,mxnyg,nxsam,nysam,tmp7)
               if(lcomprs)then
c ---             Write compressed data records
                  nwords=nxsam*nysam
                  call comprs(tmp7,nwords,tmp8,mxnxyg,cname,io9)
               else
c ---             Write uncompressed data record
                  call wrdat(io9,cname,tmp7,nxsam,nysam)
               endif
            endif
         endif
c
c ---    Discrete receptor dry fluxes
         if(nrec .GT. 0) then
            if(lcomprs)then
c ---          Write compressed data records
               call comprs(dfrec(1,i),nrec,tmp3,mxrec,cname,io9)
            else
c ---          Write uncompressed data record
               call wrdat(io9,cname,dfrec(1,i),nrec,1)
            endif
         endif
      endif
500   continue
592   continue
c ---------------------------------------------------------
c --- WRITE WET FLUXES TO DISK  (g/m**2/s)
c ---------------------------------------------------------
c
c --- Output date/hour times use 0-23 convention so that hour 24
c --- of day 12 starts at 23 0000 on day 12 and ends at 00 0000
c --- on day 13.
      if(iwet.ne.1)go to 692
c
c --- Write date/time and source data records
      write(io10)nyrab,njulab,nhrab,nsecab,nyre,njule,nhre,nsece
      write(io10)ktype,ksource,csrcnam,xmapkm,ymapkm
c
      do 600 ig=1,ngrup
c --- Identify array storage location for this group
      i=istore(ig)
c
c --- Only species specified are stored on disk
      if(ioutop(6,ig).eq.1)then
         cname=cgrup(ig)
         cname(13:15)=' WF'
c
c ---    Gridded receptor wet fluxes
         if(lsamp) then
            if(ifull.eq.1)then
               if(lcomprs)then
c ---             Write compressed data records
                  call comprs(wfsam(1,1,i),mxnxyg,tmp8,mxnxyg,
     1              cname,io10)
               else
c ---             Write uncompressed data record
                  call wrdat(io10,cname,wfsam(1,1,i),nxsam,nysam)
               endif
            else
               call xtract(wfsam(1,1,i),mxnxg,mxnyg,nxsam,nysam,tmp7)
               if(lcomprs)then
c ---             Write compressed data records
                  nwords=nxsam*nysam
                  call comprs(tmp7,nwords,tmp8,mxnxyg,cname,io10)
               else
c ---             Write uncompressed data record
                  call wrdat(io10,cname,tmp7,nxsam,nysam)
               endif
            endif
         endif
c
c ---    Discrete receptor wet fluxes
         if(nrec .GT. 0) then
            if(lcomprs)then
c ---          Write compressed data records
               call comprs(wfrec(1,i),nrec,tmp3,mxrec,cname,io10)
            else
c ---          Write uncompressed data record
               call wrdat(io10,cname,wfrec(1,i),nrec,1)
            endif
         endif
      endif
600   continue
692   continue
c
c ---------------------------------------------------------
c --- WRITE VISIBILITY-RELATED DATA TO DISK (RH, T2D)
c ---------------------------------------------------------
c
c --- Output date/hour times use 0-23 convention so that hour 24
c --- of day 12 starts at 23 0000 on day 12 and ends at 00 0000
c --- on day 13.
      if((IVIS.ne.1 .AND. IT2D.ne.1 .AND. IRHO.ne.1)
     &                           .OR. isrcmode.NE.0)go to 792
c
c --- Write date/time data record
      if(IVIS.eq.1)write(io11)nyrab,njulab,nhrab,nsecab,
     &                        nyre,njule,nhre,nsece
      if(IT2D.eq.1)write(io13)nyrab,njulab,nhrab,nsecab,
     &                        nyre,njule,nhre,nsece
      if(IRHO.eq.1)write(io14)nyrab,njulab,nhrab,nsecab,
     &                        nyre,njule,nhre,nsece
c
c --- Set variable names
      cnameRH=' REL HUM (%)   '
      cnameTK=' TEMP 2D (K)   '
      cnameDN=' RHO 2D (kg/m3)'
c
c frr (09/01) new calmet format (2D RH)
      if(i2dmet.eq.1) then
         if(IVIS.eq.1) then
c ---       Reported RH at CALMET gridpoints
            call xtracti(irh2d,mxnx,mxny,nxm,nym,itmp)
            call wrint(io11,cnameRH,itmp,nxm,nym)
         endif
         if(IT2D.eq.1) then
c ---       Reported TK at CALMET gridpoints
            call xtract(temp2d,mxnx,mxny,nxm,nym,tmp1)
            call wrdat(io13,cnameTK,tmp1,nxm,nym)
         endif
         if(IRHO.eq.1) then
c ---       Reported Rho at CALMET gridpoints
            call xtract(rho2d,mxnx,mxny,nxm,nym,tmp1)
            call wrdat(io14,cnameDN,tmp1,nxm,nym)
         endif
      elseif(i2dmet.eq.0) then
         if(IVIS.eq.1) then
c ---       Reported RH at surface stations
            call wrint(io11,cnameRH,irhss,nssta,1)
         endif
         if(IT2D.eq.1) then
c ---       Reported TK at surface stations
            call wrdat(io13,cnameTK,tempss,nssta,1)
         endif
         if(IRHO.eq.1) then
c ---       Reported Rho at surface stations
            call wrdat(io14,cnameDN,rhoss,nssta,1)
         endif
      else
         write(*,*)'Subr. OUTPUT:  Invalid I2DMET = ',i2dmet
         stop
      endif

c      call wrint(io11,cname,irhss,nssta,1)
c
792   continue


c --- Set format for List-File heading text
1050  format(//,'------ Contribution from Source: ',a16,//)
1051  format(//,'------ Contribution from ALL Sources',//)

c ---------------------------------------------------------
c --- PRINT CONCENTRATIONS TO LIST FILE  (user units)
c ---------------------------------------------------------
      if(icprt.ne.1)go to 192
      if(mod(istep,icfrq).ne.0)go to 192
      if(.not.LSAMP)go to 101
c
c --- Gridded receptor concentrations
c -----------------------------------
      messag='CONCENTRATIONS '
      messag(16:28)=cunits
      messag(31:38)='SPECIES:'
c
      do 100 ig=1,ngrup
c --- Identify array storage location for this group
      i=istore(ig)
c
      if(ioutop(1,ig).eq.1)then

         if(isrcmode.EQ.1) then
            write(io6,1050) csrcnam
         else
            write(io6,1051)
         endif

         write(messag(40:51),'(a12)')cgrup(ig)
c ---    Scale units for IPRTU=2,3,4
         if(iprtu.GT.1 .AND. iprtu.LT.5) then
            do iy=1,nysam
               do ix=1,nxsam
                  chisam(ix,iy,i)=chisam(ix,iy,i)*rprtu(iprtu)
               enddo
            enddo
         endif
         call outsam(chisam(1,1,i),idum,1,5,ldate,messag,nxsam,nysam)
      endif
100   continue
101   continue
      if(nrec.eq.0)go to 111
c
c --- Discrete receptor concentrations
c ------------------------------------
c --- Create label of species to be printed
      ns=0
      do ig=1,ngrup
         if(ioutop(1,ig).eq.1)then
            ns=ns+1
            cspecsv(ns)=cgrup(ig)
         endif
      enddo
      if(ns.EQ.0) goto 111

      if(isrcmode.EQ.1) then
         write(io6,1050) csrcnam
      else
         write(io6,1051)
      endif

      write(io6,106)cunits,nyrab,nmoab,ndayab,njulab,nhrab,
     1              nsecab,nyre,nmoe,ndaye,njule,nhre,nsece,
     2              (cspecsv(n),n=1,ns)
106   format(//1x,'DISCRETE RECEPTOR CONCENTRATIONS ',a13,t71,
     1 'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,' Julian day: ',i3,
     2 2x,'hour: ',i2,2x,'sec: ',i4/,t68,'to ',
     3 'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,' Julian day: ',i3,
     4 2x,'hour: ',i2,2x,'sec: ',i4/,1x,'Receptor No.',5x,10a12)
c
      do 110 ir=1,nrec
c ---    Scale & store only those groups to be printed in a work array
         ns=0
         do ig=1,ngrup
            if(ioutop(1,ig).eq.1)then
               ns=ns+1
               xtmp(ns)=chirec(ir,istore(ig))*rprtu(iprtu)
            endif
         enddo
c
c ---    Write the discrete receptor concentrations
         write(io6,108)ir,(xtmp(n),n=1,ns)
108      format(1x,i6,8x,10(1pe11.4,1x))
110   continue
111   continue
      if(nctrec.eq.0)goto 192
c
c --- Complex terrain (CTSG) receptor concentrations
c --------------------------------------------------
c --- Create label of species to be printed
      ns=0
      do ig=1,ngrup
         if(ioutop(1,ig).eq.1)then
            ns=ns+1
            cspecsv(ns)=cgrup(ig)
         endif
      enddo
      if(ns.EQ.0) goto 192

      if(isrcmode.EQ.1) then
         write(io6,1050) csrcnam
      else
         write(io6,1051)
      endif

      write(io6,116)cunits,nyrab,nmoab,ndayab,njulab,nhrab,
     1              nsecab,nyre,nmoe,ndaye,njule,nhre,nsece,
     2              (cspecsv(n),n=1,ns)
116   format(//1x,'CTSG RECEPTOR CONCENTRATIONS ',a13,t71,
     1 'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,' Julian day: ',i3,
     2 2x,'hour: ',i2,2x,'sec: ',i4/,t68,'to ',
     3 'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,' Julian day: ',i3,
     4 2x,'hour: ',i2,2x,'sec: ',i4/,4x,'No.',4x,'X met',5x,'Y met',4x,
     5 'ELEV.',4x,'Hill No.',3x,10a12)

      do 120 i=1,nctrec
c ---    Scale & store only those groups to be printed in a work array
         ns=0
         do ig=1,ngrup
            if(ioutop(1,ig).eq.1)then
               ns=ns+1
               xtmp(ns)=chict(i,istore(ig))*rprtu(iprtu)
            endif
         enddo
         write(io6,118)i,xrct(i),yrct(i),elrect(i),ihill(i),
     1    (xtmp(n),n=1,ns)
118      format(1x,i5,3x,f7.3,3x,f7.3,3x,f6.1,3x,i5,6x,10(1pe11.4,1x))
120   continue

192   continue
c ---------------------------------------------------------
c --- PRINT DRY FLUXES TO LIST FILE
c ---------------------------------------------------------
      if(idprt.ne.1)go to 292
      if(mod(istep,idfrq).ne.0)go to 292
c
      if(LSAMP) then
c ---    Gridded receptors
c ------------------------
         messag='DRY FLUXES '
         messag(12:24)=funits
         messag(31:38)='SPECIES:'
c
         do ig=1,ngrup
c ---       Identify array storage location for this group
            i=istore(ig)
            if(ioutop(3,ig).eq.1)then

               if(isrcmode.EQ.1) then
                  write(io6,1050) csrcnam
               else
                  write(io6,1051)
               endif

               write(messag(40:51),'(a12)')cgrup(ig)
c ---          Scale units for IPRTU=2,3,4
               if(iprtu.GT.1 .AND. iprtu.LT.5) then
                  do iy=1,nysam
                     do ix=1,nxsam
                        dfsam(ix,iy,i)=dfsam(ix,iy,i)*rprtu(iprtu)
                     enddo
                  enddo
               endif
               call outsam(dfsam(1,1,i),idum,1,5,ldate,messag,nxsam,
     &                     nysam)
            endif
         enddo
      endif
c
      if(nrec.GT.0) then
c ---    Discrete receptors
c -------------------------
c ---    Create label of species to be printed
         ns=0
         do ig=1,ngrup
            if(ioutop(3,ig).eq.1)then
               ns=ns+1
               cspecsv(ns)=cgrup(ig)
            endif
         enddo
         if(ns.GT.0) then

            if(isrcmode.EQ.1) then
               write(io6,1050) csrcnam
            else
               write(io6,1051)
            endif

            write(io6,206)funits,nyrab,nmoab,ndayab,njulab,nhrab,
     1                    nsecab,nyre,nmoe,ndaye,njule,nhre,nsece,
     2                   (cspecsv(n),n=1,ns)
206         format(//1x,'DISCRETE RECEPTOR DRY FLUXES ',a13,t71,
     1      'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     2      ' Julian day: ',i3,2x,'hour: ',i2,2x,'sec: ',i4/,t68,'to ',
     3      'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     4      ' Julian day: ',i3,2x,'hour: ',i2,2x,'sec: ',i4/
     5      ,1x,'Receptor No.',5x,10a12)
c
            do ir=1,nrec
c ---          Scale & store only those groups to be printed
               is=0
               do ig=1,ngrup
                  if(ioutop(3,ig).eq.1)then
                     is=is+1
                     xtmp(is)=dfrec(ir,istore(ig))*rprtu(iprtu)
                  endif
               enddo
c ---          Write the discrete receptor dry fluxes
               write(io6,208)ir,(xtmp(n),n=1,ns)
208            format(1x,i6,8x,10(1pe11.4,1x))
            enddo
         endif
      endif

292   continue
c ---------------------------------------------------------
c --- PRINT WET FLUXES TO LIST FILE
c ---------------------------------------------------------
      if(iwprt.ne.1)go to 392
      if(mod(istep,iwfrq).ne.0)go to 392
c
      if(LSAMP) then
c ---    Gridded receptors
c ------------------------
         messag='WET FLUXES '
         messag(12:24)=funits
         messag(31:38)='SPECIES:'
c
         do ig=1,ngrup
c ---       Identify array storage location for this group
            i=istore(ig)
            if(ioutop(5,ig).eq.1)then

               if(isrcmode.EQ.1) then
                  write(io6,1050) csrcnam
               else
                  write(io6,1051)
               endif

               write(messag(40:51),'(a12)')cgrup(ig)
c ---          Scale units for IPRTU=2,3,4
               if(iprtu.GT.1 .AND. iprtu.LT.5) then
                  do iy=1,nysam
                     do ix=1,nxsam
                        wfsam(ix,iy,i)=wfsam(ix,iy,i)*rprtu(iprtu)
                     enddo
                  enddo
               endif
               call outsam(wfsam(1,1,i),idum,1,5,ldate,messag,nxsam,
     &                     nysam)
            endif
         enddo
      endif
c
      if(nrec.GT.0) then
c ---    Discrete receptors
c -------------------------
c ---    Create label of species to be printed
         ns=0
         do ig=1,ngrup
            if(ioutop(5,ig).eq.1)then
               ns=ns+1
               cspecsv(ns)=cgrup(ig)
            endif
         enddo
         if(ns.GT.0) then

            if(isrcmode.EQ.1) then
               write(io6,1050) csrcnam
            else
               write(io6,1051)
            endif

            write(io6,306)funits,nyrab,nmoab,ndayab,njulab,nhrab,
     1                    nsecab,nyre,nmoe,ndaye,njule,nhre,nsece,
     2                   (cspecsv(n),n=1,ns)
306         format(//1x,'DISCRETE RECEPTOR WET FLUXES ',a13,t71,
     1      'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     2      ' Julian day: ',i3,2x,'hour: ',i2,2x,'sec: ',i4/,t68,'to ',
     3      'year: ',i4,2x,'month: ',i2,2x,'day: ',i2,2x,
     4      ' Julian day: ',i3,2x,'hour: ',i2,2x,'sec: ',i4/
     5      ,1x,'Receptor No.',5x,10a12)
c
            do ir=1,nrec
c ---          Scale & store only those groups to be printed
               is=0
               do ig=1,ngrup
                  if(ioutop(5,ig).eq.1)then
                     is=is+1
                     xtmp(is)=wfrec(ir,istore(ig))*rprtu(iprtu)
                  endif
               enddo
c ---          Write the discrete receptor wet fluxes
               write(io6,208)ir,(xtmp(n),n=1,ns)
308            format(1x,i6,8x,10(1pe11.4,1x))
            enddo
         endif
      endif

392   continue

c ------------------------------------------------------------
c --- Write MASS FLUXES for species-groups to MASSFLX.DAT file
c ------------------------------------------------------------
      if(imflx.EQ.1 .AND. isrcmode.EQ.0) call MFLXOUT(istore)

c ------------------------------------------------------------
c --- Write MASS BALANCE for species to MASSBAL.DAT file
c ------------------------------------------------------------
      if(imbal.EQ.1 .AND. isrcmode.EQ.0) call MBALOUT

      return
      end
c----------------------------------------------------------------------
      subroutine wrdat(iounit,cname,outarr,nx,ny)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940430                  WRDAT
c                J. Scire, SRC
c
c --- PURPOSE:  Write a gridded concentration or dry/wet
c               flux data record
c               (one 15-character identifier and a 2-D data array)
c
c --- INPUTS:
c          IOUNIT - integer      - Fortran unit no. of output file
c           CNAME - character*15 - Species identifier
c   OUTARR(nx,ny) - real array   - Array of concentration data (g/m**3)
c                                  or dry/wet flux data (g/m**2/s)
c              NX - integer      - Number of sampling grid points in the
c                                  X direction
c              NY - integer      - Number of sampling grid points in the
c                                  Y direction
c
c --- OUTPUT:  none
c
c --- WRDAT called by:  OUTPUT
c --- WRDAT calls:      none
c
c----------------------------------------------------------------------
c
      real outarr(nx,ny)
      character*15 cname
c
      write(iounit)cname,outarr
c
      return
      end
c----------------------------------------------------------------------
      subroutine wrint(iounit,cname,ioutarr,nx,ny)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 940430                  WRINT
c                J. Scire, SRC
c
c --- PURPOSE:  Write a gridded field of integers to binary file
c               (one 15-character identifier and a 2-D data array)
c
c --- INPUTS:
c          IOUNIT - integer      - Fortran unit no. of output file
c           CNAME - character*15 - Data identifier/name
c  IOUTARI(nx,ny) - int. array   - Data array
c              NX - integer      - Number of grid points in the
c                                  X direction
c              NY - integer      - Number of grid points in the
c                                  Y direction
c
c --- OUTPUT:  none
c
c --- WRINT called by:
c --- WRINT calls:      none
c
c----------------------------------------------------------------------
c
      integer ioutarr(nx,ny)
      character*15 cname
c
      write(iounit)cname,ioutarr
c
      return
      end
c----------------------------------------------------------------------
      subroutine xtract(datarr,nxmax,nymax,nxact,nyact,outarr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                 XTRACT
c                J. Scire, SRC
c
c --- PURPOSE:  Extract the active portion of a 2-D array
c
c --- UPDATE
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V4.0-V5.0     971107  (DGS): NYACT compared to NYMAX (not NXMAX)
c
c --- INPUTS:
c   DATARR(nxmax,nymax) - real    - Full data array
c                 NXMAX - integer - First dimension of data array
c                 NYMAX - integer - Second dimension of data array
c                 NXACT - integer - Number of active elements of the
c                                   array (first dimension)
c                 NYACT - integer - Number of active elements of the
c                                   array (second dimension)
c        Parameters:
c           IO6
c
c --- OUTPUT:
c   OUTARR(nxact,nyact) - real    - Output array consisting only
c                                   of the active elements of the
c                                   full input array
c
c --- XTRACT called by:  OUTPUT
c --- XTRACT calls:      none
c
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      real datarr(nxmax,nymax),outarr(nxact,nyact)
c
c --- Check that values of array dimensions are reasonable
      if(nxact.le.0.or.nxact.gt.nxmax.or.
     1   nyact.le.0.or.nyact.gt.nymax)then
            write(io6,*)'ERROR in subr. XTRACT -- Invalid values ',
     1      'of array dimensions input -- NXACT = ',nxact,' NYACT = ',
     2      nyact,' NXMAX = ',nxmax,' NYMAX = ',nymax
            write(*,*)
            stop 'Halted in XTRACT -- see list file.'
      endif
c
c --- Extract the active portion of the input data array
      do 100 i=1,nxact
      do 100 j=1,nyact
      outarr(i,j)=datarr(i,j)
100   continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine xtracti(idatarr,nxmax,nymax,nxact,nyact,ioutarr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                XTRACTI
c                J. Scire, SRC
c
c --- PURPOSE:  Extract the active portion of a 2-D integer array
c
c --- UPDATE
c --- V5.0-V5.4     000602  (DGS): add message to "stop"
c --- V4.0-V5.0     971107  (DGS): NYACT compared to NYMAX (not NXMAX)
c
c --- INPUTS:
c  IDATARR(nxmax,nymax) - integer - Full data array
c                 NXMAX - integer - First dimension of data array
c                 NYMAX - integer - Second dimension of data array
c                 NXACT - integer - Number of active elements of the
c                                   array (first dimension)
c                 NYACT - integer - Number of active elements of the
c                                   array (second dimension)
c        Parameters:
c           IO6
c
c --- OUTPUT:
c  IOUTARR(nxact,nyact) - integer - Output array consisting only
c                                   of the active elements of the
c                                   full input array
c
c --- XTRACTI called by:
c --- XTRACTI calls:      none
c
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      integer idatarr(nxmax,nymax),ioutarr(nxact,nyact)
c
c --- Check that values of array dimensions are reasonable
      if(nxact.le.0.or.nxact.gt.nxmax.or.
     1   nyact.le.0.or.nyact.gt.nymax)then
            write(io6,*)'ERROR in subr. XTRACTI -- Invalid values ',
     1      'of array dimensions input -- NXACT = ',nxact,' NYACT = ',
     2      nyact,' NXMAX = ',nxmax,' NYMAX = ',nymax
            write(*,*)
            stop 'Halted in XTRACTI -- see list file.'
      endif
c
c --- Extract the active portion of the input data array
      do 100 i=1,nxact
      do 100 j=1,nyact
      ioutarr(i,j)=idatarr(i,j)
100   continue
c
      return
      end
c----------------------------------------------------------------------
      subroutine comprs(xdat,nwords,xwork,nwork,clabel,io)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                 COMPRS
c                J. Scire, EARTH TECH
c
c --- PURPOSE:  Compress an array of concentrations, dry fluxes,
c               or wet fluxes by replacing strings of zero values
c               with a negative code indicating the number of zero
c               values
c
c --- UPDATE
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c        XDAT(nwords) - real array - Array of uncompressed data to be
c                                    output
c              NWORDS - integer    - Number of values in data array
c        XWORK(nwork) - real array - Work array to temporarily store
c                                    compressed array
c               NWORK - integer    - Dimension of work array - NWORK
c                                    must be >= NWORDS
c              CLABEL - char*15    - Character record header
c                  IO - integer    - Unit number of output file
c
c     Parameters: IO6
c
c --- OUTPUT:  none
c
c --- COMPRS called by: OUTPUT
c --- COMPRS calls:     WRDAT
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      real xdat(nwords),xwork(nwork)
      character*15 clabel
c
c --- Check that work array is sized large enough
      if(nwork.lt.nwords)then
         write(io6,*)'ERROR in Subr. COMPRS -- Work array ',
     1   'dimension is too small -- NWORK = ',nwork,' NWORDS = ',
     2   nwords
         write(*,*)
         stop 'Halted in COMPRS -- see list file.'
      endif
c
c --- Replace all zeroes with negative coded integer
      nzero=0
      ii=0
      do 100 i=1,nwords
c
         if(xdat(i).eq.0.0)then
            nzero=nzero+1
            go to 100
         else if(xdat(i).lt.0.0)then
            write(io6,*)'ERROR in Subr. COMPRS -- Negative value ',
     1      'encountered with COMPRESS option on -- I = ',i,
     2      ' XDAT(i) = ',xdat(i)
            write(io6,*)'COMPRESS option cannot be used when data ',
     1      'values are negative'
            write(*,*)
            stop 'Halted in COMPRS -- see list file.'
         endif
c
         if(nzero.eq.0)then
            ii=ii+1
            xwork(ii)=xdat(i)
         else
            ii=ii+1
            xwork(ii)=-(float(nzero)+0.0001)
            nzero=0
            ii=ii+1
            xwork(ii)=xdat(i)
         endif
100   continue
c
      if(nzero.gt.0)then
         ii=ii+1
         xwork(ii)=-(float(nzero)+0.0001)
      endif
c
c --- Write the data records (header, compressed data record)
      write(io)ii
      call wrdat(io,clabel,xwork,ii,1)
c
      return
      end
c-----------------------------------------------------------------------
c --- Section for SLATEC routines used in puff model
c-----------------------------------------------------------------------
*DECK SNSQE
c-----------------------------------------------------------------------
      SUBROUTINE SNSQE (FCN, JAC, IOPT, N, X, FVEC, TOL, NPRINT, INFO,
     +   WA, LWA)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 951204                   SNSQE
C***BEGIN PROLOGUE  SNSQE
C***PURPOSE  An easy-to-use code to find a zero of a system of N
C            nonlinear functions in N variables by a modification of
C            the Powell hybrid method.
C***LIBRARY   SLATEC
C***CATEGORY  F2A
C***TYPE      SINGLE PRECISION (SNSQE-S, DNSQE-D)
C***KEYWORDS  EASY-TO-USE, NONLINEAR SQUARE SYSTEM,
C             POWELL HYBRID METHOD, ZEROS
C***AUTHOR  Hiebert, K. L., (SNLA)
C***DESCRIPTION
C
C 1. Purpose.
C
C
C       The purpose of SNSQE is to find a zero of a system of N non-
C       linear functions in N variables by a modification of the Powell
C       hybrid method.  This is done by using the more general nonlinear
C       equation solver SNSQ.  The user must provide a subroutine which
C       calculates the functions.  The user has the option of either to
C       provide a subroutine which calculates the Jacobian or to let the
C       code calculate it by a forward-difference approximation.  This
C       code is the combination of the MINPACK codes (Argonne) HYBRD1
C       and HYBRJ1.
C
C
C 2. Subroutine and Type Statements.
C
C       SUBROUTINE SNSQE(FCN,JAC,IOPT,N,X,FVEC,TOL,NPRINT,INFO,
C      *                  WA,LWA)
C       INTEGER IOPT,N,NPRINT,INFO,LWA
C       REAL TOL
C       REAL X(N),FVEC(N),WA(LWA)
C       EXTERNAL FCN,JAC
C
C
C 3. Parameters.
C
C       Parameters designated as input parameters must be specified on
C       entry to SNSQE and are not changed on exit, while parameters
C       designated as output parameters need not be specified on entry
C       and are set to appropriate values on exit from SNSQE.
C
C       FCN is the name of the user-supplied subroutine which calculates
C         the functions.  FCN must be declared in an EXTERNAL statement
C         in the user calling program, and should be written as follows.
C
C         SUBROUTINE FCN(N,X,FVEC,IFLAG)
C         INTEGER N,IFLAG
C         REAL X(N),FVEC(N)
C         ----------
C         Calculate the functions at X and
C         return this vector in FVEC.
C         ----------
C         RETURN
C         END
C
C         The value of IFLAG should not be changed by FCN unless the
C         user wants to terminate execution of SNSQE.  In this case, set
C         IFLAG to a negative integer.
C
C       JAC is the name of the user-supplied subroutine which calculates
C         the Jacobian.  If IOPT=1, then JAC must be declared in an
C         EXTERNAL statement in the user calling program, and should be
C         written as follows.
C
C         SUBROUTINE JAC(N,X,FVEC,FJAC,LDFJAC,IFLAG)
C         INTEGER N,LDFJAC,IFLAG
C         REAL X(N),FVEC(N),FJAC(LDFJAC,N)
C         ----------
C         Calculate the Jacobian at X and return this
C         matrix in FJAC.  FVEC contains the function
C         values at X and should not be altered.
C         ----------
C         RETURN
C         END
C
C         The value of IFLAG should not be changed by JAC unless the
C         user wants to terminate execution of SNSQE.  In this case, set
C         IFLAG to a negative integer.
C
C         If IOPT=2, JAC can be ignored (treat it as a dummy argument).
C
C       IOPT is an input variable which specifies how the Jacobian will
C         be calculated.  If IOPT=1, then the user must supply the
C         Jacobian through the subroutine JAC.  If IOPT=2, then the
C         code will approximate the Jacobian by forward-differencing.
C
C       N is a positive integer input variable set to the number of
C         functions and variables.
C
C       X is an array of length N.  On input, X must contain an initial
C         estimate of the solution vector.  On output, X contains the
C         final estimate of the solution vector.
C
C       FVEC is an output array of length N which contains the functions
C         evaluated at the output X.
C
C       TOL is a non-negative input variable.  Termination occurs when
C         the algorithm estimates that the relative error between X and
C         the solution is at most TOL.  Section 4 contains more details
C         about TOL.
C
C       NPRINT is an integer input variable that enables controlled
C         printing of iterates if it is positive.  In this case, FCN is
C         called with IFLAG = 0 at the beginning of the first iteration
C         and every NPRINT iteration thereafter and immediately prior
C         to return, with X and FVEC available for printing. Appropriate
C         print statements must be added to FCN (see example). If NPRINT
C         is not positive, no special calls of FCN with IFLAG = 0 are
C         made.
C
C       INFO is an integer output variable.  If the user has terminated
C         execution, INFO is set to the (negative) value of IFLAG.  See
C         description of FCN and JAC. Otherwise, INFO is set as follows.
C
C         INFO = 0  improper input parameters.
C
C         INFO = 1  algorithm estimates that the relative error between
C                   X and the solution is at most TOL.
C
C         INFO = 2  number of calls to FCN has reached or exceeded
C                   100*(N+1) for IOPT=1 or 200*(N+1) for IOPT=2.
C
C         INFO = 3  TOL is too small.  No further improvement in the
C                   approximate solution X is possible.
C
C         INFO = 4  iteration is not making good progress.
C
C         Sections 4 and 5 contain more details about INFO.
C
C       WA is a work array of length LWA.
C
C       LWA is a positive integer input variable not less than
C         (3*N**2+13*N))/2.
C
C
C 4. Successful Completion.
C
C       The accuracy of SNSQE is controlled by the convergence parame-
C       ter TOL.  This parameter is used in a test which makes a compar-
C       ison between the approximation X and a solution XSOL.  SNSQE
C       terminates when the test is satisfied.  If TOL is less than the
C       machine precision (as defined by the function R1MACH(4)), then
C       SNSQE attempts only to satisfy the test defined by the machine
C       precision.  Further progress is not usually possible.  Unless
C       high precision solutions are required, the recommended value
C       for TOL is the square root of the machine precision.
C
C       The test assumes that the functions are reasonably well behaved,
C       and, if the Jacobian is supplied by the user, that the functions
C       and the Jacobian  coded consistently.  If these conditions
C       are not satisfied, SNSQE may incorrectly indicate convergence.
C       The coding of the Jacobian can be checked by the subroutine
C       CHKDER.  If the Jacobian is coded correctly or IOPT=2, then
C       the validity of the answer can be checked, for example, by
C       rerunning SNSQE with a tighter tolerance.
C
C       Convergence Test.  If ENORM(Z) denotes the Euclidean norm of a
C         vector Z, then this test attempts to guarantee that
C
C               ENORM(X-XSOL) .LE.  TOL*ENORM(XSOL).
C
C         If this condition is satisfied with TOL = 10**(-K), then the
C         larger components of X have K significant decimal digits and
C         INFO is set to 1.  There is a danger that the smaller compo-
C         nents of X may have large relative errors, but the fast rate
C         of convergence of SNSQE usually avoids this possibility.
C
C
C 5. Unsuccessful Completion.
C
C       Unsuccessful termination of SNSQE can be due to improper input
C       parameters, arithmetic interrupts, an excessive number of func-
C       tion evaluations, errors in the functions, or lack of good prog-
C       ress.
C
C       Improper Input Parameters.  INFO is set to 0 if IOPT .LT. 1, or
C         IOPT .GT. 2, or N .LE. 0, or TOL .LT. 0.E0, or
C         LWA .LT. (3*N**2+13*N)/2.
C
C       Arithmetic Interrupts.  If these interrupts occur in the FCN
C         subroutine during an early stage of the computation, they may
C         be caused by an unacceptable choice of X by SNSQE.  In this
C         case, it may be possible to remedy the situation by not evalu-
C         ating the functions here, but instead setting the components
C         of FVEC to numbers that exceed those in the initial FVEC.
C
C       Excessive Number of Function Evaluations.  If the number of
C         calls to FCN reaches 100*(N+1) for IOPT=1 or 200*(N+1) for
C         IOPT=2, then this indicates that the routine is converging
C         very slowly as measured by the progress of FVEC, and INFO is
C         set to 2.  This situation should be unusual because, as
C         indicated below, lack of good progress is usually diagnosed
C         earlier by SNSQE, causing termination with INFO = 4.
C
C       Errors in the Functions.  When IOPT=2, the choice of step length
C         in the forward-difference approximation to the Jacobian
C         assumes that the relative errors in the functions are of the
C         order of the machine precision.  If this is not the case,
C         SNSQE may fail (usually with INFO = 4).  The user should
C         then either use SNSQ and set the step length or use IOPT=1
C         and supply the Jacobian.
C
C       Lack of Good Progress.  SNSQE searches for a zero of the system
C         by minimizing the sum of the squares of the functions.  In so
C         doing, it can become trapped in a region where the minimum
C         does not correspond to a zero of the system and, in this situ-
C         ation, the iteration eventually fails to make good progress.
C         In particular, this will happen if the system does not have a
C         zero.  If the system has a zero, rerunning SNSQE from a dif-
C         ferent starting point may be helpful.
C
C
C 6. Characteristics of the Algorithm.
C
C       SNSQE is a modification of the Powell hybrid method.  Two of
C       its main characteristics involve the choice of the correction as
C       a convex combination of the Newton and scaled gradient direc-
C       tions, and the updating of the Jacobian by the rank-1 method of
C       Broyden.  The choice of the correction guarantees (under reason-
C       able conditions) global convergence for starting points far from
C       the solution and a fast rate of convergence.  The Jacobian is
C       calculated at the starting point by either the user-supplied
C       subroutine or a forward-difference approximation, but it is not
C       recalculated until the rank-1 method fails to produce satis-
C       factory progress.
C
C       Timing.  The time required by SNSQE to solve a given problem
C         depends on N, the behavior of the functions, the accuracy
C         requested, and the starting point.  The number of arithmetic
C         operations needed by SNSQE is about 11.5*(N**2) to process
C         each evaluation of the functions (call to FCN) and 1.3*(N**3)
C         to process each evaluation of the Jacobian (call to JAC,
C         if IOPT = 1).  Unless FCN and JAC can be evaluated quickly,
C         the timing of SNSQE will be strongly influenced by the time
C         spent in FCN and JAC.
C
C       Storage.  SNSQE requires (3*N**2 + 17*N)/2 single precision
C         storage locations, in addition to the storage required by the
C         program.  There are no internally declared storage arrays.
C
C
C 7. Example.
C
C       The problem is to determine the values of X(1), X(2), ..., X(9),
C       which solve the system of tridiagonal equations
C
C       (3-2*X(1))*X(1)           -2*X(2)                   = -1
C               -X(I-1) + (3-2*X(I))*X(I)         -2*X(I+1) = -1, I=2-8
C                                   -X(8) + (3-2*X(9))*X(9) = -1
C
C       **********
C
C       PROGRAM TEST
C C
C C     Driver for SNSQE example.
C C
C       INTEGER J,N,IOPT,NPRINT,INFO,LWA,NWRITE
C       REAL TOL,FNORM
C       REAL X(9),FVEC(9),WA(180)
C       REAL ENORM,R1MACH
C       EXTERNAL FCN
C       DATA NWRITE /6/
C C
C       IOPT = 2
C       N = 9
C C
C C     The following starting values provide a rough solution.
C C
C       DO 10 J = 1, 9
C          X(J) = -1.E0
C    10    CONTINUE
C
C       LWA = 180
C       NPRINT = 0
C C
C C     Set TOL to the square root of the machine precision.
C C     Unless high precision solutions are required,
C C     this is the recommended setting.
C C
C       TOL = SQRT(R1MACH(4))
C C
C       CALL SNSQE(FCN,JAC,IOPT,N,X,FVEC,TOL,NPRINT,INFO,WA,LWA)
C       FNORM = ENORM(N,FVEC)
C       WRITE (NWRITE,1000) FNORM,INFO,(X(J),J=1,N)
C       STOP
C  1000 FORMAT (5X,' FINAL L2 NORM OF THE RESIDUALS',E15.7 //
C      *        5X,' EXIT PARAMETER',16X,I10 //
C      *        5X,' FINAL APPROXIMATE SOLUTION' // (5X,3E15.7))
C       END
C       SUBROUTINE FCN(N,X,FVEC,IFLAG)
C       INTEGER N,IFLAG
C       REAL X(N),FVEC(N)
C       INTEGER K
C       REAL ONE,TEMP,TEMP1,TEMP2,THREE,TWO,ZERO
C       DATA ZERO,ONE,TWO,THREE /0.E0,1.E0,2.E0,3.E0/
C C
C       DO 10 K = 1, N
C          TEMP = (THREE - TWO*X(K))*X(K)
C          TEMP1 = ZERO
C          IF (K .NE. 1) TEMP1 = X(K-1)
C          TEMP2 = ZERO
C          IF (K .NE. N) TEMP2 = X(K+1)
C          FVEC(K) = TEMP - TEMP1 - TWO*TEMP2 + ONE
C    10    CONTINUE
C       RETURN
C       END
C
C       Results obtained with different compilers or machines
C       may be slightly different.
C
C       FINAL L2 NORM OF THE RESIDUALS  0.1192636E-07
C
C       EXIT PARAMETER                         1
C
C       FINAL APPROXIMATE SOLUTION
C
C       -0.5706545E+00 -0.6816283E+00 -0.7017325E+00
C       -0.7042129E+00 -0.7013690E+00 -0.6918656E+00
C       -0.6657920E+00 -0.5960342E+00 -0.4164121E+00
C
C***REFERENCES  M. J. D. Powell, A hybrid method for nonlinear equa-
C                 tions. In Numerical Methods for Nonlinear Algebraic
C                 Equations, P. Rabinowitz, Editor.  Gordon and Breach,
C                 1988.
C***ROUTINES CALLED  SNSQ, XERMSG
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890831  Modified array declarations.  (WRB)
C   890831  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  SNSQE
      INTEGER IOPT,N,NPRINT,INFO,LWA
      REAL TOL
      REAL X(*),FVEC(*),WA(LWA)
      EXTERNAL FCN, JAC
      INTEGER INDEX,J,LR,MAXFEV,ML,MODE,MU,NFEV,NJEV
      REAL EPSFCN,FACTOR,ONE,XTOL,ZERO
      SAVE FACTOR, ONE, ZERO
      DATA FACTOR,ONE,ZERO /1.0E2,1.0E0,0.0E0/
C***FIRST EXECUTABLE STATEMENT  SNSQE
      INFO = 0
C
C     CHECK THE INPUT PARAMETERS FOR ERRORS.
C
      IF (IOPT .LT. 1 .OR. IOPT .GT. 2 .OR. N .LE. 0
     1    .OR. TOL .LT. ZERO .OR. LWA .LT. (3*N**2 +13*N)/2)
     2   GO TO 20
C
C     CALL SNSQ.
C
      MAXFEV = 100*(N + 1)
      IF (IOPT .EQ. 2) MAXFEV = 2*MAXFEV
      XTOL = TOL
      ML = N - 1
      MU = N - 1
      EPSFCN = ZERO
      MODE = 2
      DO 10 J = 1, N
         WA(J) = ONE
   10    CONTINUE
      LR = (N*(N + 1))/2
      INDEX=6*N+LR
      CALL SNSQ(FCN,JAC,IOPT,N,X,FVEC,WA(INDEX+1),N,XTOL,MAXFEV,ML,MU,
     1           EPSFCN,WA(1),MODE,FACTOR,NPRINT,INFO,NFEV,NJEV,
     2           WA(6*N+1),LR,WA(N+1),WA(2*N+1),WA(3*N+1),WA(4*N+1),
     3           WA(5*N+1))
      IF (INFO .EQ. 5) INFO = 4
   20 CONTINUE
      IF (INFO .EQ. 0) CALL XERMSG ('SLATEC', 'SNSQE',
     +   'INVALID INPUT PARAMETER.', 2, 1)
      RETURN
C
C     LAST CARD OF SUBROUTINE SNSQE.
C
      END
*DECK SNSQ
      SUBROUTINE SNSQ (FCN, JAC, IOPT, N, X, FVEC, FJAC, LDFJAC, XTOL,
     +   MAXFEV, ML, MU, EPSFCN, DIAG, MODE, FACTOR, NPRINT, INFO, NFEV,
     +   NJEV, R, LR, QTF, WA1, WA2, WA3, WA4)
C***BEGIN PROLOGUE  SNSQ
C***PURPOSE  Find a zero of a system of a N nonlinear functions in N
C            variables by a modification of the Powell hybrid method.
C***LIBRARY   SLATEC
C***CATEGORY  F2A
C***TYPE      SINGLE PRECISION (SNSQ-S, DNSQ-D)
C***KEYWORDS  NONLINEAR SQUARE SYSTEM, POWELL HYBRID METHOD, ZEROS
C***AUTHOR  Hiebert, K. L., (SNLA)
C***DESCRIPTION
C
C 1. Purpose.
C
C       The purpose of SNSQ is to find a zero of a system of N non-
C       linear functions in N variables by a modification of the Powell
C       hybrid method.  The user must provide a subroutine which calcu-
C       lates the functions.  The user has the option of either to
C       provide a subroutine which calculates the Jacobian or to let the
C       code calculate it by a forward-difference approximation.
C       This code is the combination of the MINPACK codes (Argonne)
C       HYBRD and HYBRDJ.
C
C
C 2. Subroutine and Type Statements.
C
C       SUBROUTINE SNSQ(FCN,JAC,IOPT,N,X,FVEC,FJAC,LDFJAC,XTOL,MAXFEV,
C      *                 ML,MU,EPSFCN,DIAG,MODE,FACTOR,NPRINT,INFO,NFEV,
C      *                 NJEV,R,LR,QTF,WA1,WA2,WA3,WA4)
C       INTEGER IOPT,N,MAXFEV,ML,MU,MODE,NPRINT,INFO,NFEV,LDFJAC,NJEV,LR
C       REAL XTOL,EPSFCN,FACTOR
C       REAL X(N),FVEC(N),DIAG(N),FJAC(LDFJAC,N),R(LR),QTF(N),
C      *     WA1(N),WA2(N),WA3(N),WA4(N)
C       EXTERNAL FCN,JAC
C
C
C 3. Parameters.
C
C       Parameters designated as input parameters must be specified on
C       entry to SNSQ and are not changed on exit, while parameters
C       designated as output parameters need not be specified on entry
C       and are set to appropriate values on exit from SNSQ.
C
C       FCN is the name of the user-supplied subroutine which calculates
C         the functions.  FCN must be declared in an EXTERNAL statement
C         in the user calling program, and should be written as follows.
C
C         SUBROUTINE FCN(N,X,FVEC,IFLAG)
C         INTEGER N,IFLAG
C         REAL X(N),FVEC(N)
C         ----------
C         Calculate the functions at X and
C         return this vector in FVEC.
C         ----------
C         RETURN
C         END
C
C         The value of IFLAG should not be changed by FCN unless the
C         user wants to terminate execution of SNSQ.  In this case, set
C         IFLAG to a negative integer.
C
C       JAC is the name of the user-supplied subroutine which calculates
C         the Jacobian.  If IOPT=1, then JAC must be declared in an
C         EXTERNAL statement in the user calling program, and should be
C         written as follows.
C
C         SUBROUTINE JAC(N,X,FVEC,FJAC,LDFJAC,IFLAG)
C         INTEGER N,LDFJAC,IFLAG
C         REAL X(N),FVEC(N),FJAC(LDFJAC,N)
C         ----------
C         Calculate the Jacobian at X and return this
C         matrix in FJAC.  FVEC contains the function
C         values at X and should not be altered.
C         ----------
C         RETURN
C         END
C
C         The value of IFLAG should not be changed by JAC unless the
C         user wants to terminate execution of SNSQ.  In this case, set
C         IFLAG to a negative integer.
C
C         If IOPT=2, JAC can be ignored (treat it as a dummy argument).
C
C       IOPT is an input variable which specifies how the Jacobian will
C         be calculated.  If IOPT=1, then the user must supply the
C         Jacobian through the subroutine JAC.  If IOPT=2, then the
C         code will approximate the Jacobian by forward-differencing.
C
C       N is a positive integer input variable set to the number of
C         functions and variables.
C
C       X is an array of length N.  On input, X must contain an initial
C         estimate of the solution vector.  On output, X contains the
C         final estimate of the solution vector.
C
C       FVEC is an output array of length N which contains the functions
C         evaluated at the output X.
C
C       FJAC is an output N by N array which contains the orthogonal
C         matrix Q produced by the QR factorization of the final approx-
C         imate Jacobian.
C
C       LDFJAC is a positive integer input variable not less than N
C         which specifies the leading dimension of the array FJAC.
C
C       XTOL is a non-negative input variable.  Termination occurs when
C         the relative error between two consecutive iterates is at most
C         XTOL.  Therefore, XTOL measures the relative error desired in
C         the approximate solution.  Section 4 contains more details
C         about XTOL.
C
C       MAXFEV is a positive integer input variable.  Termination occurs
C         when the number of calls to FCN is at least MAXFEV by the end
C         of an iteration.
C
C       ML is a non-negative integer input variable which specifies the
C         number of subdiagonals within the band of the Jacobian matrix.
C         If the Jacobian is not banded or IOPT=1, set ML to at
C         least N - 1.
C
C       MU is a non-negative integer input variable which specifies the
C         number of superdiagonals within the band of the Jacobian
C         matrix.  If the Jacobian is not banded or IOPT=1, set MU to at
C         least N - 1.
C
C       EPSFCN is an input variable used in determining a suitable step
C         for the forward-difference approximation.  This approximation
C         assumes that the relative errors in the functions are of the
C         order of EPSFCN.  If EPSFCN is less than the machine preci-
C         sion, it is assumed that the relative errors in the functions
C         are of the order of the machine precision.  If IOPT=1, then
C         EPSFCN can be ignored (treat it as a dummy argument).
C
C       DIAG is an array of length N.  If MODE = 1 (see below), DIAG is
C         internally set.  If MODE = 2, DIAG must contain positive
C         entries that serve as implicit (multiplicative) scale factors
C         for the variables.
C
C       MODE is an integer input variable.  If MODE = 1, the variables
C         will be scaled internally.  If MODE = 2, the scaling is speci-
C         fied by the input DIAG.  Other values of MODE are equivalent
C         to MODE = 1.
C
C       FACTOR is a positive input variable used in determining the ini-
C         tial step bound.  This bound is set to the product of FACTOR
C         and the Euclidean norm of DIAG*X if nonzero, or else to FACTOR
C         itself.  In most cases FACTOR should lie in the interval
C         (.1,100.).  100. is a generally recommended value.
C
C       NPRINT is an integer input variable that enables controlled
C         printing of iterates if it is positive.  In this case, FCN is
C         called with IFLAG = 0 at the beginning of the first iteration
C         and every NPRINT iteration thereafter and immediately prior
C         to return, with X and FVEC available for printing. Appropriate
C         print statements must be added to FCN(see example).  If NPRINT
C         is not positive, no special calls of FCN with IFLAG = 0 are
C         made.
C
C       INFO is an integer output variable.  If the user has terminated
C         execution, INFO is set to the (negative) value of IFLAG.  See
C         description of FCN and JAC. Otherwise, INFO is set as follows.
C
C         INFO = 0  improper input parameters.
C
C         INFO = 1  relative error between two consecutive iterates is
C                   at most XTOL.
C
C         INFO = 2  number of calls to FCN has reached or exceeded
C                   MAXFEV.
C
C         INFO = 3  XTOL is too small.  No further improvement in the
C                   approximate solution X is possible.
C
C         INFO = 4  iteration is not making good progress, as measured
C                   by the improvement from the last five Jacobian eval-
C                   uations.
C
C         INFO = 5  iteration is not making good progress, as measured
C                   by the improvement from the last ten iterations.
C
C         Sections 4 and 5 contain more details about INFO.
C
C       NFEV is an integer output variable set to the number of calls to
C         FCN.
C
C       NJEV is an integer output variable set to the number of calls to
C         JAC. (If IOPT=2, then NJEV is set to zero.)
C
C       R is an output array of length LR which contains the upper
C         triangular matrix produced by the QR factorization of the
C         final approximate Jacobian, stored rowwise.
C
C       LR is a positive integer input variable not less than
C         (N*(N+1))/2.
C
C       QTF is an output array of length N which contains the vector
C         (Q TRANSPOSE)*FVEC.
C
C       WA1, WA2, WA3, and WA4 are work arrays of length N.
C
C
C 4. Successful Completion.
C
C       The accuracy of SNSQ is controlled by the convergence parameter
C       XTOL.  This parameter is used in a test which makes a comparison
C       between the approximation X and a solution XSOL.  SNSQ termi-
C       nates when the test is satisfied.  If the convergence parameter
C       is less than the machine precision (as defined by the function
C       R1MACH(4)), then SNSQ only attempts to satisfy the test
C       defined by the machine precision.  Further progress is not
C       usually possible.
C
C       The test assumes that the functions are reasonably well behaved,
C       and, if the Jacobian is supplied by the user, that the functions
C       and the Jacobian are coded consistently.  If these conditions
C       are not satisfied, then SNSQ may incorrectly indicate conver-
C       gence.  The coding of the Jacobian can be checked by the
C       subroutine CHKDER. If the Jacobian is coded correctly or IOPT=2,
C       then the validity of the answer can be checked, for example, by
C       rerunning SNSQ with a tighter tolerance.
C
C       Convergence Test.  If ENORM(Z) denotes the Euclidean norm of a
C         vector Z and D is the diagonal matrix whose entries are
C         defined by the array DIAG, then this test attempts to guaran-
C         tee that
C
C               ENORM(D*(X-XSOL)) .LE. XTOL*ENORM(D*XSOL).
C
C         If this condition is satisfied with XTOL = 10**(-K), then the
C         larger components of D*X have K significant decimal digits and
C         INFO is set to 1.  There is a danger that the smaller compo-
C         nents of D*X may have large relative errors, but the fast rate
C         of convergence of SNSQ usually avoids this possibility.
C         Unless high precision solutions are required, the recommended
C         value for XTOL is the square root of the machine precision.
C
C
C 5. Unsuccessful Completion.
C
C       Unsuccessful termination of SNSQ can be due to improper input
C       parameters, arithmetic interrupts, an excessive number of func-
C       tion evaluations, or lack of good progress.
C
C       Improper Input Parameters.  INFO is set to 0 if IOPT .LT. 1,
C         or IOPT .GT. 2, or N .LE. 0, or LDFJAC .LT. N, or
C         XTOL .LT. 0.E0, or MAXFEV .LE. 0, or ML .LT. 0, or MU .LT. 0,
C         or FACTOR .LE. 0.E0, or LR .LT. (N*(N+1))/2.
C
C       Arithmetic Interrupts.  If these interrupts occur in the FCN
C         subroutine during an early stage of the computation, they may
C         be caused by an unacceptable choice of X by SNSQ.  In this
C         case, it may be possible to remedy the situation by rerunning
C         SNSQ with a smaller value of FACTOR.
C
C       Excessive Number of Function Evaluations.  A reasonable value
C         for MAXFEV is 100*(N+1) for IOPT=1 and 200*(N+1) for IOPT=2.
C         If the number of calls to FCN reaches MAXFEV, then this
C         indicates that the routine is converging very slowly as
C         measured by the progress of FVEC, and INFO is set to 2.  This
C         situation should be unusual because, as indicated below, lack
C         of good progress is usually diagnosed earlier by SNSQ,
C         causing termination with INFO = 4 or INFO = 5.
C
C       Lack of Good Progress.  SNSQ searches for a zero of the system
C         by minimizing the sum of the squares of the functions.  In so
C         doing, it can become trapped in a region where the minimum
C         does not correspond to a zero of the system and, in this situ-
C         ation, the iteration eventually fails to make good progress.
C         In particular, this will happen if the system does not have a
C         zero.  If the system has a zero, rerunning SNSQ from a dif-
C         ferent starting point may be helpful.
C
C
C 6. Characteristics of the Algorithm.
C
C       SNSQ is a modification of the Powell hybrid method.  Two of its
C       main characteristics involve the choice of the correction as a
C       convex combination of the Newton and scaled gradient directions,
C       and the updating of the Jacobian by the rank-1 method of Broy-
C       den.  The choice of the correction guarantees (under reasonable
C       conditions) global convergence for starting points far from the
C       solution and a fast rate of convergence.  The Jacobian is
C       calculated at the starting point by either the user-supplied
C       subroutine or a forward-difference approximation, but it is not
C       recalculated until the rank-1 method fails to produce satis-
C       factory progress.
C
C       Timing.  The time required by SNSQ to solve a given problem
C         depends on N, the behavior of the functions, the accuracy
C         requested, and the starting point.  The number of arithmetic
C         operations needed by SNSQ is about 11.5*(N**2) to process
C         each evaluation of the functions (call to FCN) and 1.3*(N**3)
C         to process each evaluation of the Jacobian (call to JAC,
C         if IOPT = 1).  Unless FCN and JAC can be evaluated quickly,
C         the timing of SNSQ will be strongly influenced by the time
C         spent in FCN and JAC.
C
C       Storage.  SNSQ requires (3*N**2 + 17*N)/2 single precision
C         storage locations, in addition to the storage required by the
C         program.  There are no internally declared storage arrays.
C
C
C 7. Example.
C
C       The problem is to determine the values of X(1), X(2), ..., X(9),
C       which solve the system of tridiagonal equations
C
C       (3-2*X(1))*X(1)           -2*X(2)                   = -1
C               -X(I-1) + (3-2*X(I))*X(I)         -2*X(I+1) = -1, I=2-8
C                                   -X(8) + (3-2*X(9))*X(9) = -1
C C     **********
C
C       PROGRAM TEST
C C
C C     Driver for SNSQ example.
C C
C       INTEGER J,IOPT,N,MAXFEV,ML,MU,MODE,NPRINT,INFO,NFEV,LDFJAC,LR,
C      *        NWRITE
C       REAL XTOL,EPSFCN,FACTOR,FNORM
C       REAL X(9),FVEC(9),DIAG(9),FJAC(9,9),R(45),QTF(9),
C      *     WA1(9),WA2(9),WA3(9),WA4(9)
C       REAL ENORM,R1MACH
C       EXTERNAL FCN
C       DATA NWRITE /6/
C C
C       IOPT = 2
C       N = 9
C C
C C     The following starting values provide a rough solution.
C C
C       DO 10 J = 1, 9
C          X(J) = -1.E0
C    10    CONTINUE
C C
C       LDFJAC = 9
C       LR = 45
C C
C C     Set XTOL to the square root of the machine precision.
C C     Unless high precision solutions are required,
C C     this is the recommended setting.
C C
C       XTOL = SQRT(R1MACH(4))
C C
C       MAXFEV = 2000
C       ML = 1
C       MU = 1
C       EPSFCN = 0.E0
C       MODE = 2
C       DO 20 J = 1, 9
C          DIAG(J) = 1.E0
C    20    CONTINUE
C       FACTOR = 1.E2
C       NPRINT = 0
C C
C       CALL SNSQ(FCN,JAC,IOPT,N,X,FVEC,FJAC,LDFJAC,XTOL,MAXFEV,ML,MU,
C      *           EPSFCN,DIAG,MODE,FACTOR,NPRINT,INFO,NFEV,NJEV,
C      *           R,LR,QTF,WA1,WA2,WA3,WA4)
C       FNORM = ENORM(N,FVEC)
C       WRITE (NWRITE,1000) FNORM,NFEV,INFO,(X(J),J=1,N)
C       STOP
C  1000 FORMAT (5X,' FINAL L2 NORM OF THE RESIDUALS',E15.7 //
C      *        5X,' NUMBER OF FUNCTION EVALUATIONS',I10 //
C      *        5X,' EXIT PARAMETER',16X,I10 //
C      *        5X,' FINAL APPROXIMATE SOLUTION' // (5X,3E15.7))
C       END
C       SUBROUTINE FCN(N,X,FVEC,IFLAG)
C       INTEGER N,IFLAG
C       REAL X(N),FVEC(N)
C       INTEGER K
C       REAL ONE,TEMP,TEMP1,TEMP2,THREE,TWO,ZERO
C       DATA ZERO,ONE,TWO,THREE /0.E0,1.E0,2.E0,3.E0/
C C
C       IF (IFLAG .NE. 0) GO TO 5
C C
C C     Insert print statements here when NPRINT is positive.
C C
C       RETURN
C     5 CONTINUE
C       DO 10 K = 1, N
C          TEMP = (THREE - TWO*X(K))*X(K)
C          TEMP1 = ZERO
C          IF (K .NE. 1) TEMP1 = X(K-1)
C          TEMP2 = ZERO
C          IF (K .NE. N) TEMP2 = X(K+1)
C          FVEC(K) = TEMP - TEMP1 - TWO*TEMP2 + ONE
C    10    CONTINUE
C       RETURN
C       END
C
C       Results obtained with different compilers or machines
C       may be slightly different.
C
C       FINAL L2 NORM OF THE RESIDUALS  0.1192636E-07
C
C       NUMBER OF FUNCTION EVALUATIONS        14
C
C       EXIT PARAMETER                         1
C
C       FINAL APPROXIMATE SOLUTION
C
C       -0.5706545E+00 -0.6816283E+00 -0.7017325E+00
C       -0.7042129E+00 -0.7013690E+00 -0.6918656E+00
C       -0.6657920E+00 -0.5960342E+00 -0.4164121E+00
C
C***REFERENCES  M. J. D. Powell, A hybrid method for nonlinear equa-
C                 tions. In Numerical Methods for Nonlinear Algebraic
C                 Equations, P. Rabinowitz, Editor.  Gordon and Breach,
C                 1988.
C***ROUTINES CALLED  DOGLEG, ENORM, FDJAC1, QFORM, QRFAC, R1MACH,
C                    R1MPYQ, R1UPDT, XERMSG
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890531  Changed all specific intrinsics to generic.  (WRB)
C   890831  Modified array declarations.  (WRB)
C   890831  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  SNSQ
      INTEGER IOPT,N,MAXFEV,ML,MU,MODE,NPRINT,INFO,NFEV,LDFJAC,LR,NJEV
      REAL XTOL,EPSFCN,FACTOR
      REAL X(*),FVEC(*),DIAG(*),FJAC(LDFJAC,*),R(LR),QTF(*),WA1(*),
     1     WA2(*),WA3(*),WA4(*)
      EXTERNAL FCN
      INTEGER I,IFLAG,ITER,J,JM1,L,NCFAIL,NCSUC,NSLOW1,NSLOW2
      INTEGER IWA(1)
      LOGICAL JEVAL,SING
      REAL ACTRED,DELTA,EPSMCH,FNORM,FNORM1,ONE,PNORM,PRERED,P1,P5,
     1     P001,P0001,RATIO,SUM,TEMP,XNORM,ZERO
      REAL R1MACH,ENORM
      SAVE ONE, P1, P5, P001, P0001, ZERO
      DATA ONE,P1,P5,P001,P0001,ZERO
     1     /1.0E0,1.0E-1,5.0E-1,1.0E-3,1.0E-4,0.0E0/
C
C***FIRST EXECUTABLE STATEMENT  SNSQ
      EPSMCH = R1MACH(4)
C
      INFO = 0
      IFLAG = 0
      NFEV = 0
      NJEV = 0
C
C     CHECK THE INPUT PARAMETERS FOR ERRORS.
C
      IF (IOPT .LT. 1 .OR. IOPT .GT. 2 .OR.
     1    N .LE. 0 .OR. XTOL .LT. ZERO .OR. MAXFEV .LE. 0
     2    .OR. ML .LT. 0 .OR. MU .LT. 0 .OR. FACTOR .LE. ZERO
     3    .OR. LDFJAC .LT. N .OR. LR .LT. (N*(N + 1))/2) GO TO 300
      IF (MODE .NE. 2) GO TO 20
      DO 10 J = 1, N
         IF (DIAG(J) .LE. ZERO) GO TO 300
   10    CONTINUE
   20 CONTINUE
C
C     EVALUATE THE FUNCTION AT THE STARTING POINT
C     AND CALCULATE ITS NORM.
C
      IFLAG = 1
      CALL FCN(N,X,FVEC,IFLAG)
      NFEV = 1
      IF (IFLAG .LT. 0) GO TO 300
      FNORM = ENORM(N,FVEC)
C
C     INITIALIZE ITERATION COUNTER AND MONITORS.
C
      ITER = 1
      NCSUC = 0
      NCFAIL = 0
      NSLOW1 = 0
      NSLOW2 = 0
C
C     BEGINNING OF THE OUTER LOOP.
C
   30 CONTINUE
         JEVAL = .TRUE.
C
C        CALCULATE THE JACOBIAN MATRIX.
C
         IF (IOPT .EQ. 2) GO TO 31
C
C        USER SUPPLIES JACOBIAN
C
            CALL JAC(N,X,FVEC,FJAC,LDFJAC,IFLAG)
            NJEV = NJEV+1
            GO TO 32
C
C        CODE APPROXIMATES THE JACOBIAN
C
   31       IFLAG = 2
            CALL FDJAC1(FCN,N,X,FVEC,FJAC,LDFJAC,IFLAG,ML,MU,EPSFCN,WA1,
     1               WA2)
            NFEV = NFEV + MIN0(ML+MU+1,N)
C
   32    IF (IFLAG .LT. 0) GO TO 300
C
C        COMPUTE THE QR FACTORIZATION OF THE JACOBIAN.
C
         CALL QRFAC(N,N,FJAC,LDFJAC,.FALSE.,IWA,1,WA1,WA2,WA3)
C
C        ON THE FIRST ITERATION AND IF MODE IS 1, SCALE ACCORDING
C        TO THE NORMS OF THE COLUMNS OF THE INITIAL JACOBIAN.
C
         IF (ITER .NE. 1) GO TO 70
         IF (MODE .EQ. 2) GO TO 50
         DO 40 J = 1, N
            DIAG(J) = WA2(J)
            IF (WA2(J) .EQ. ZERO) DIAG(J) = ONE
   40       CONTINUE
   50    CONTINUE
C
C        ON THE FIRST ITERATION, CALCULATE THE NORM OF THE SCALED X
C        AND INITIALIZE THE STEP BOUND DELTA.
C
         DO 60 J = 1, N
            WA3(J) = DIAG(J)*X(J)
   60       CONTINUE
         XNORM = ENORM(N,WA3)
         DELTA = FACTOR*XNORM
         IF (DELTA .EQ. ZERO) DELTA = FACTOR
   70    CONTINUE
C
C        FORM (Q TRANSPOSE)*FVEC AND STORE IN QTF.
C
         DO 80 I = 1, N
            QTF(I) = FVEC(I)
   80       CONTINUE
         DO 120 J = 1, N
            IF (FJAC(J,J) .EQ. ZERO) GO TO 110
            SUM = ZERO
            DO 90 I = J, N
               SUM = SUM + FJAC(I,J)*QTF(I)
   90          CONTINUE
            TEMP = -SUM/FJAC(J,J)
            DO 100 I = J, N
               QTF(I) = QTF(I) + FJAC(I,J)*TEMP
  100          CONTINUE
  110       CONTINUE
  120       CONTINUE
C
C        COPY THE TRIANGULAR FACTOR OF THE QR FACTORIZATION INTO R.
C
         SING = .FALSE.
         DO 150 J = 1, N
            L = J
            JM1 = J - 1
            IF (JM1 .LT. 1) GO TO 140
            DO 130 I = 1, JM1
               R(L) = FJAC(I,J)
               L = L + N - I
  130          CONTINUE
  140       CONTINUE
            R(L) = WA1(J)
            IF (WA1(J) .EQ. ZERO) SING = .TRUE.
  150       CONTINUE
C
C        ACCUMULATE THE ORTHOGONAL FACTOR IN FJAC.
C
         CALL QFORM(N,N,FJAC,LDFJAC,WA1)
C
C        RESCALE IF NECESSARY.
C
         IF (MODE .EQ. 2) GO TO 170
         DO 160 J = 1, N
            DIAG(J) = MAX(DIAG(J),WA2(J))
  160       CONTINUE
  170    CONTINUE
C
C        BEGINNING OF THE INNER LOOP.
C
  180    CONTINUE
C
C           IF REQUESTED, CALL FCN TO ENABLE PRINTING OF ITERATES.
C
            IF (NPRINT .LE. 0) GO TO 190
            IFLAG = 0
            IF (MOD(ITER-1,NPRINT) .EQ. 0) CALL FCN(N,X,FVEC,IFLAG)
            IF (IFLAG .LT. 0) GO TO 300
  190       CONTINUE
C
C           DETERMINE THE DIRECTION P.
C
            CALL DOGLEG(N,R,LR,DIAG,QTF,DELTA,WA1,WA2,WA3)
C
C           STORE THE DIRECTION P AND X + P. CALCULATE THE NORM OF P.
C
            DO 200 J = 1, N
               WA1(J) = -WA1(J)
               WA2(J) = X(J) + WA1(J)
               WA3(J) = DIAG(J)*WA1(J)
  200          CONTINUE
            PNORM = ENORM(N,WA3)
C
C           ON THE FIRST ITERATION, ADJUST THE INITIAL STEP BOUND.
C
            IF (ITER .EQ. 1) DELTA = MIN(DELTA,PNORM)
C
C           EVALUATE THE FUNCTION AT X + P AND CALCULATE ITS NORM.
C
            IFLAG = 1
            CALL FCN(N,WA2,WA4,IFLAG)
            NFEV = NFEV + 1
            IF (IFLAG .LT. 0) GO TO 300
            FNORM1 = ENORM(N,WA4)
C
C           COMPUTE THE SCALED ACTUAL REDUCTION.
C
            ACTRED = -ONE
            IF (FNORM1 .LT. FNORM) ACTRED = ONE - (FNORM1/FNORM)**2
C
C           COMPUTE THE SCALED PREDICTED REDUCTION.
C
            L = 1
            DO 220 I = 1, N
               SUM = ZERO
               DO 210 J = I, N
                  SUM = SUM + R(L)*WA1(J)
                  L = L + 1
  210             CONTINUE
               WA3(I) = QTF(I) + SUM
  220          CONTINUE
            TEMP = ENORM(N,WA3)
            PRERED = ZERO
            IF (TEMP .LT. FNORM) PRERED = ONE - (TEMP/FNORM)**2
C
C           COMPUTE THE RATIO OF THE ACTUAL TO THE PREDICTED
C           REDUCTION.
C
            RATIO = ZERO
            IF (PRERED .GT. ZERO) RATIO = ACTRED/PRERED
C
C           UPDATE THE STEP BOUND.
C
            IF (RATIO .GE. P1) GO TO 230
               NCSUC = 0
               NCFAIL = NCFAIL + 1
               DELTA = P5*DELTA
               GO TO 240
  230       CONTINUE
               NCFAIL = 0
               NCSUC = NCSUC + 1
               IF (RATIO .GE. P5 .OR. NCSUC .GT. 1)
     1            DELTA = MAX(DELTA,PNORM/P5)
               IF (ABS(RATIO-ONE) .LE. P1) DELTA = PNORM/P5
  240       CONTINUE
C
C           TEST FOR SUCCESSFUL ITERATION.
C
            IF (RATIO .LT. P0001) GO TO 260
C
C           SUCCESSFUL ITERATION. UPDATE X, FVEC, AND THEIR NORMS.
C
            DO 250 J = 1, N
               X(J) = WA2(J)
               WA2(J) = DIAG(J)*X(J)
               FVEC(J) = WA4(J)
  250          CONTINUE
            XNORM = ENORM(N,WA2)
            FNORM = FNORM1
            ITER = ITER + 1
  260       CONTINUE
C
C           DETERMINE THE PROGRESS OF THE ITERATION.
C
            NSLOW1 = NSLOW1 + 1
            IF (ACTRED .GE. P001) NSLOW1 = 0
            IF (JEVAL) NSLOW2 = NSLOW2 + 1
            IF (ACTRED .GE. P1) NSLOW2 = 0
C
C           TEST FOR CONVERGENCE.
C
            IF (DELTA .LE. XTOL*XNORM .OR. FNORM .EQ. ZERO) INFO = 1
            IF (INFO .NE. 0) GO TO 300
C
C           TESTS FOR TERMINATION AND STRINGENT TOLERANCES.
C
            IF (NFEV .GE. MAXFEV) INFO = 2
            IF (P1*MAX(P1*DELTA,PNORM) .LE. EPSMCH*XNORM) INFO = 3
            IF (NSLOW2 .EQ. 5) INFO = 4
            IF (NSLOW1 .EQ. 10) INFO = 5
            IF (INFO .NE. 0) GO TO 300
C
C           CRITERION FOR RECALCULATING JACOBIAN
C
            IF (NCFAIL .EQ. 2) GO TO 290
C
C           CALCULATE THE RANK ONE MODIFICATION TO THE JACOBIAN
C           AND UPDATE QTF IF NECESSARY.
C
            DO 280 J = 1, N
               SUM = ZERO
               DO 270 I = 1, N
                  SUM = SUM + FJAC(I,J)*WA4(I)
  270             CONTINUE
               WA2(J) = (SUM - WA3(J))/PNORM
               WA1(J) = DIAG(J)*((DIAG(J)*WA1(J))/PNORM)
               IF (RATIO .GE. P0001) QTF(J) = SUM
  280          CONTINUE
C
C           COMPUTE THE QR FACTORIZATION OF THE UPDATED JACOBIAN.
C
            CALL R1UPDT(N,N,R,LR,WA1,WA2,WA3,SING)
            CALL R1MPYQ(N,N,FJAC,LDFJAC,WA2,WA3)
            CALL R1MPYQ(1,N,QTF,1,WA2,WA3)
C
C           END OF THE INNER LOOP.
C
            JEVAL = .FALSE.
            GO TO 180
  290    CONTINUE
C
C        END OF THE OUTER LOOP.
C
         GO TO 30
  300 CONTINUE
C
C     TERMINATION, EITHER NORMAL OR USER IMPOSED.
C
      IF (IFLAG .LT. 0) INFO = IFLAG
      IFLAG = 0
      IF (NPRINT .GT. 0) CALL FCN(N,X,FVEC,IFLAG)
      IF (INFO .LT. 0) CALL XERMSG ('SLATEC', 'SNSQ',
     +   'EXECUTION TERMINATED BECAUSE USER SET IFLAG NEGATIVE.', 1, 1)
      IF (INFO .EQ. 0) CALL XERMSG ('SLATEC', 'SNSQ',
     +   'INVALID INPUT PARAMETER.', 2, 1)
      IF (INFO .EQ. 2) CALL XERMSG ('SLATEC', 'SNSQ',
     +   'TOO MANY FUNCTION EVALUATIONS.', 9, 1)
      IF (INFO .EQ. 3) CALL XERMSG ('SLATEC', 'SNSQ',
     +   'XTOL TOO SMALL. NO FURTHER IMPROVEMENT POSSIBLE.', 3, 1)
      IF (INFO .GT. 4) CALL XERMSG ('SLATEC', 'SNSQ',
     +   'ITERATION NOT MAKING GOOD PROGRESS.', 1, 1)
      RETURN
C
C     LAST CARD OF SUBROUTINE SNSQ.
C
      END
*DECK DOGLEG
      SUBROUTINE DOGLEG (N, R, LR, DIAG, QTB, DELTA, X, WA1, WA2)
C***BEGIN PROLOGUE  DOGLEG
C***SUBSIDIARY
C***PURPOSE  Subsidiary to SNSQ and SNSQE
C***LIBRARY   SLATEC
C***TYPE      SINGLE PRECISION (DOGLEG-S, DDOGLG-D)
C***AUTHOR  (UNKNOWN)
C***DESCRIPTION
C
C     Given an M by N matrix A, an N by N nonsingular DIAGONAL
C     matrix D, an M-vector B, and a positive number DELTA, the
C     problem is to determine the convex combination X of the
C     Gauss-Newton and scaled gradient directions that minimizes
C     (A*X - B) in the least squares sense, subject to the
C     restriction that the Euclidean norm of D*X be at most DELTA.
C
C     This subroutine completes the solution of the problem
C     if it is provided with the necessary information from the
C     QR factorization of A. That is, if A = Q*R, where Q has
C     orthogonal columns and R is an upper triangular matrix,
C     then DOGLEG expects the full upper triangle of R and
C     the first N components of (Q TRANSPOSE)*B.
C
C     The subroutine statement is
C
C       SUBROUTINE DOGLEG(N,R,LR,DIAG,QTB,DELTA,X,WA1,WA2)
C
C     where
C
C       N is a positive integer input variable set to the order of R.
C
C       R is an input array of length LR which must contain the upper
C         triangular matrix R stored by rows.
C
C       LR is a positive integer input variable not less than
C         (N*(N+1))/2.
C
C       DIAG is an input array of length N which must contain the
C         diagonal elements of the matrix D.
C
C       QTB is an input array of length N which must contain the first
C         N elements of the vector (Q TRANSPOSE)*B.
C
C       DELTA is a positive input variable which specifies an upper
C         bound on the Euclidean norm of D*X.
C
C       X is an output array of length N which contains the desired
C         convex combination of the Gauss-Newton direction and the
C         scaled gradient direction.
C
C       WA1 and WA2 are work arrays of length N.
C
C***SEE ALSO  SNSQ, SNSQE
C***ROUTINES CALLED  ENORM, R1MACH
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890531  Changed all specific intrinsics to generic.  (WRB)
C   890831  Modified array declarations.  (WRB)
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900326  Removed duplicate information from DESCRIPTION section.
C           (WRB)
C   900328  Added TYPE section.  (WRB)
C***END PROLOGUE  DOGLEG
      INTEGER N,LR
      REAL DELTA
      REAL R(LR),DIAG(*),QTB(*),X(*),WA1(*),WA2(*)
      INTEGER I,J,JJ,JP1,K,L
      REAL ALPHA,BNORM,EPSMCH,GNORM,ONE,QNORM,SGNORM,SUM,TEMP,ZERO
      REAL R1MACH,ENORM
      SAVE ONE, ZERO
      DATA ONE,ZERO /1.0E0,0.0E0/
C***FIRST EXECUTABLE STATEMENT  DOGLEG
      EPSMCH = R1MACH(4)
C
C     FIRST, CALCULATE THE GAUSS-NEWTON DIRECTION.
C
      JJ = (N*(N + 1))/2 + 1
      DO 50 K = 1, N
         J = N - K + 1
         JP1 = J + 1
         JJ = JJ - K
         L = JJ + 1
         SUM = ZERO
         IF (N .LT. JP1) GO TO 20
         DO 10 I = JP1, N
            SUM = SUM + R(L)*X(I)
            L = L + 1
   10       CONTINUE
   20    CONTINUE
         TEMP = R(JJ)
         IF (TEMP .NE. ZERO) GO TO 40
         L = J
         DO 30 I = 1, J
            TEMP = MAX(TEMP,ABS(R(L)))
            L = L + N - I
   30       CONTINUE
         TEMP = EPSMCH*TEMP
         IF (TEMP .EQ. ZERO) TEMP = EPSMCH
   40    CONTINUE
         X(J) = (QTB(J) - SUM)/TEMP
   50    CONTINUE
C
C     TEST WHETHER THE GAUSS-NEWTON DIRECTION IS ACCEPTABLE.
C
      DO 60 J = 1, N
         WA1(J) = ZERO
         WA2(J) = DIAG(J)*X(J)
   60    CONTINUE
      QNORM = ENORM(N,WA2)
      IF (QNORM .LE. DELTA) GO TO 140
C
C     THE GAUSS-NEWTON DIRECTION IS NOT ACCEPTABLE.
C     NEXT, CALCULATE THE SCALED GRADIENT DIRECTION.
C
      L = 1
      DO 80 J = 1, N
         TEMP = QTB(J)
         DO 70 I = J, N
            WA1(I) = WA1(I) + R(L)*TEMP
            L = L + 1
   70       CONTINUE
         WA1(J) = WA1(J)/DIAG(J)
   80    CONTINUE
C
C     CALCULATE THE NORM OF THE SCALED GRADIENT DIRECTION,
C     NORMALIZE, AND RESCALE THE GRADIENT.
C
      GNORM = ENORM(N,WA1)
      SGNORM = ZERO
      ALPHA = DELTA/QNORM
      IF (GNORM .EQ. ZERO) GO TO 120
      DO 90 J = 1, N
         WA1(J) = (WA1(J)/GNORM)/DIAG(J)
   90    CONTINUE
C
C     CALCULATE THE POINT ALONG THE SCALED GRADIENT
C     AT WHICH THE QUADRATIC IS MINIMIZED.
C
      L = 1
      DO 110 J = 1, N
         SUM = ZERO
         DO 100 I = J, N
            SUM = SUM + R(L)*WA1(I)
            L = L + 1
  100       CONTINUE
         WA2(J) = SUM
  110    CONTINUE
      TEMP = ENORM(N,WA2)
      SGNORM = (GNORM/TEMP)/TEMP
C
C     TEST WHETHER THE SCALED GRADIENT DIRECTION IS ACCEPTABLE.
C
      ALPHA = ZERO
      IF (SGNORM .GE. DELTA) GO TO 120
C
C     THE SCALED GRADIENT DIRECTION IS NOT ACCEPTABLE.
C     FINALLY, CALCULATE THE POINT ALONG THE DOGLEG
C     AT WHICH THE QUADRATIC IS MINIMIZED.
C
      BNORM = ENORM(N,QTB)
      TEMP = (BNORM/GNORM)*(BNORM/QNORM)*(SGNORM/DELTA)
      TEMP = TEMP - (DELTA/QNORM)*(SGNORM/DELTA)**2
     1       + SQRT((TEMP-(DELTA/QNORM))**2
     2              +(ONE-(DELTA/QNORM)**2)*(ONE-(SGNORM/DELTA)**2))
      ALPHA = ((DELTA/QNORM)*(ONE - (SGNORM/DELTA)**2))/TEMP
  120 CONTINUE
C
C     FORM APPROPRIATE CONVEX COMBINATION OF THE GAUSS-NEWTON
C     DIRECTION AND THE SCALED GRADIENT DIRECTION.
C
      TEMP = (ONE - ALPHA)*MIN(SGNORM,DELTA)
      DO 130 J = 1, N
         X(J) = TEMP*WA1(J) + ALPHA*X(J)
  130    CONTINUE
  140 CONTINUE
      RETURN
C
C     LAST CARD OF SUBROUTINE DOGLEG.
C
      END
*DECK ENORM
      REAL FUNCTION ENORM (N, X)
C***BEGIN PROLOGUE  ENORM
C***SUBSIDIARY
C***PURPOSE  Subsidiary to SNLS1, SNLS1E, SNSQ and SNSQE
C***LIBRARY   SLATEC
C***TYPE      SINGLE PRECISION (ENORM-S, DENORM-D)
C***AUTHOR  (UNKNOWN)
C***DESCRIPTION
C
C     Given an N-vector X, this function calculates the
C     Euclidean norm of X.
C
C     The Euclidean norm is computed by accumulating the sum of
C     squares in three different sums. The sums of squares for the
C     small and large components are scaled so that no overflows
C     occur. Non-destructive underflows are permitted. Underflows
C     and overflows do not occur in the computation of the unscaled
C     sum of squares for the intermediate components.
C     The definitions of small, intermediate and large components
C     depend on two constants, RDWARF and RGIANT. The main
C     restrictions on these constants are that RDWARF**2 not
C     underflow and RGIANT**2 not overflow. The constants
C     given here are suitable for every known computer.
C
C     The function statement is
C
C       REAL FUNCTION ENORM(N,X)
C
C     where
C
C       N is a positive integer input variable.
C
C       X is an input array of length N.
C
C***SEE ALSO  SNLS1, SNLS1E, SNSQ, SNSQE
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890831  Modified array declarations.  (WRB)
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900326  Removed duplicate information from DESCRIPTION section.
C           (WRB)
C   900328  Added TYPE section.  (WRB)
C***END PROLOGUE  ENORM
      INTEGER N
      REAL X(*)
      INTEGER I
      REAL AGIANT,FLOATN,ONE,RDWARF,RGIANT,S1,S2,S3,XABS,X1MAX,X3MAX,
     1     ZERO
      SAVE ONE, ZERO, RDWARF, RGIANT
      DATA ONE,ZERO,RDWARF,RGIANT /1.0E0,0.0E0,3.834E-20,1.304E19/
C***FIRST EXECUTABLE STATEMENT  ENORM
      S1 = ZERO
      S2 = ZERO
      S3 = ZERO
      X1MAX = ZERO
      X3MAX = ZERO
      FLOATN = N
      AGIANT = RGIANT/FLOATN
      DO 90 I = 1, N
         XABS = ABS(X(I))
         IF (XABS .GT. RDWARF .AND. XABS .LT. AGIANT) GO TO 70
            IF (XABS .LE. RDWARF) GO TO 30
C
C              SUM FOR LARGE COMPONENTS.
C
               IF (XABS .LE. X1MAX) GO TO 10
                  S1 = ONE + S1*(X1MAX/XABS)**2
                  X1MAX = XABS
                  GO TO 20
   10          CONTINUE
                  S1 = S1 + (XABS/X1MAX)**2
   20          CONTINUE
               GO TO 60
   30       CONTINUE
C
C              SUM FOR SMALL COMPONENTS.
C
               IF (XABS .LE. X3MAX) GO TO 40
                  S3 = ONE + S3*(X3MAX/XABS)**2
                  X3MAX = XABS
                  GO TO 50
   40          CONTINUE
                  IF (XABS .NE. ZERO) S3 = S3 + (XABS/X3MAX)**2
   50          CONTINUE
   60       CONTINUE
            GO TO 80
   70    CONTINUE
C
C           SUM FOR INTERMEDIATE COMPONENTS.
C
            S2 = S2 + XABS**2
   80    CONTINUE
   90    CONTINUE
C
C     CALCULATION OF NORM.
C
      IF (S1 .EQ. ZERO) GO TO 100
         ENORM = X1MAX*SQRT(S1+(S2/X1MAX)/X1MAX)
         GO TO 130
  100 CONTINUE
         IF (S2 .EQ. ZERO) GO TO 110
            IF (S2 .GE. X3MAX)
     1         ENORM = SQRT(S2*(ONE+(X3MAX/S2)*(X3MAX*S3)))
            IF (S2 .LT. X3MAX)
     1         ENORM = SQRT(X3MAX*((S2/X3MAX)+(X3MAX*S3)))
            GO TO 120
  110    CONTINUE
            ENORM = X3MAX*SQRT(S3)
  120    CONTINUE
  130 CONTINUE
      RETURN
C
C     LAST CARD OF FUNCTION ENORM.
C
      END
*DECK FDJAC1
      SUBROUTINE FDJAC1 (FCN, N, X, FVEC, FJAC, LDFJAC, IFLAG, ML, MU,
     +   EPSFCN, WA1, WA2)
C***BEGIN PROLOGUE  FDJAC1
C***SUBSIDIARY
C***PURPOSE  Subsidiary to SNSQ and SNSQE
C***LIBRARY   SLATEC
C***TYPE      SINGLE PRECISION (FDJAC1-S, DFDJC1-D)
C***AUTHOR  (UNKNOWN)
C***DESCRIPTION
C
C     This subroutine computes a forward-difference approximation
C     to the N by N Jacobian matrix associated with a specified
C     problem of N functions in N VARIABLES. If the Jacobian has
C     a banded form, then function evaluations are saved by only
C     approximating the nonzero terms.
C
C     The subroutine statement is
C
C       SUBROUTINE FDJAC1(FCN,N,X,FVEC,FJAC,LDFJAC,IFLAG,ML,MU,EPSFCN,
C                         WA1,WA2)
C
C     where
C
C       FCN is the name of the user-supplied subroutine which
C         calculates the functions. FCN must be declared
C         in an external statement in the user calling
C         program, and should be written as follows.
C
C         SUBROUTINE FCN(N,X,FVEC,IFLAG)
C         INTEGER N,IFLAG
C         REAL X(N),FVEC(N)
C         ----------
C         Calculate the functions at X and
C         return this vector in FVEC.
C         ----------
C         RETURN
C         END
C
C         The value of IFLAG should not be changed by FCN unless
C         the user wants to terminate execution of FDJAC1.
C         In this case set IFLAG to a negative integer.
C
C       N Is a positive integer input variable set to the number
C         of functions and variables.
C
C       X is an input array of length N.
C
C       FVEC is an input array of length N which must contain the
C         functions evaluated at X.
C
C       FJAC is an output N by N array which contains the
C         approximation to the Jacobian matrix evaluated at X.
C
C       LDFJAC is a positive integer input variable not less than N
C         which specifies the leading dimension of the array FJAC.
C
C       IFLAG is an integer variable which can be used to terminate
C         the execution of FDJAC1. See description of FCN.
C
C       ML is a nonnegative integer input variable which specifies
C         the number of subdiagonals within the band of the
C         Jacobian matrix. If the Jacobian is not banded, set
C         ML to at least N - 1.
C
C       EPSFCN is an input variable used in determining a suitable
C         step length for the forward-difference approximation. This
C         approximation assumes that the relative errors in the
C         functions are of the order of EPSFCN. If EPSFCN is less
C         than the machine precision, it is assumed that the relative
C         errors in the functions are of the order of the machine
C         precision.
C
C       MU is a nonnegative integer input variable which specifies
C         the number of superdiagonals within the band of the
C         Jacobian matrix. If the Jacobian is not banded, set
C         MU to at least N - 1.
C
C       WA1 and WA2 are work arrays of length N. If ML + MU + 1 is at
C         least N, then the Jacobian is considered dense, and WA2 is
C         not referenced.
C
C***SEE ALSO  SNSQ, SNSQE
C***ROUTINES CALLED  R1MACH
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890531  Changed all specific intrinsics to generic.  (WRB)
C   890831  Modified array declarations.  (WRB)
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900326  Removed duplicate information from DESCRIPTION section.
C           (WRB)
C   900328  Added TYPE section.  (WRB)
C***END PROLOGUE  FDJAC1
      INTEGER N,LDFJAC,IFLAG,ML,MU
      REAL EPSFCN
      REAL X(*),FVEC(*),FJAC(LDFJAC,*),WA1(*),WA2(*)
      INTEGER I,J,K,MSUM
      REAL EPS,EPSMCH,H,TEMP,ZERO
      REAL R1MACH
      SAVE ZERO
      DATA ZERO /0.0E0/
C***FIRST EXECUTABLE STATEMENT  FDJAC1
      EPSMCH = R1MACH(4)
C
      EPS = SQRT(MAX(EPSFCN,EPSMCH))
      MSUM = ML + MU + 1
      IF (MSUM .LT. N) GO TO 40
C
C        COMPUTATION OF DENSE APPROXIMATE JACOBIAN.
C
         DO 20 J = 1, N
            TEMP = X(J)
            H = EPS*ABS(TEMP)
            IF (H .EQ. ZERO) H = EPS
            X(J) = TEMP + H
            CALL FCN(N,X,WA1,IFLAG)
            IF (IFLAG .LT. 0) GO TO 30
            X(J) = TEMP
            DO 10 I = 1, N
               FJAC(I,J) = (WA1(I) - FVEC(I))/H
   10          CONTINUE
   20       CONTINUE
   30    CONTINUE
         GO TO 110
   40 CONTINUE
C
C        COMPUTATION OF BANDED APPROXIMATE JACOBIAN.
C
         DO 90 K = 1, MSUM
            DO 60 J = K, N, MSUM
               WA2(J) = X(J)
               H = EPS*ABS(WA2(J))
               IF (H .EQ. ZERO) H = EPS
               X(J) = WA2(J) + H
   60          CONTINUE
            CALL FCN(N,X,WA1,IFLAG)
            IF (IFLAG .LT. 0) GO TO 100
            DO 80 J = K, N, MSUM
               X(J) = WA2(J)
               H = EPS*ABS(WA2(J))
               IF (H .EQ. ZERO) H = EPS
               DO 70 I = 1, N
                  FJAC(I,J) = ZERO
                  IF (I .GE. J - MU .AND. I .LE. J + ML)
     1               FJAC(I,J) = (WA1(I) - FVEC(I))/H
   70             CONTINUE
   80          CONTINUE
   90       CONTINUE
  100    CONTINUE
  110 CONTINUE
      RETURN
C
C     LAST CARD OF SUBROUTINE FDJAC1.
C
      END
*DECK FDUMP
      SUBROUTINE FDUMP
C***BEGIN PROLOGUE  FDUMP
C***PURPOSE  Symbolic dump (should be locally written).
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3
C***TYPE      ALL (FDUMP-A)
C***KEYWORDS  ERROR, XERMSG
C***AUTHOR  Jones, R. E., (SNLA)
C***DESCRIPTION
C
C        ***Note*** Machine Dependent Routine
C        FDUMP is intended to be replaced by a locally written
C        version which produces a symbolic dump.  Failing this,
C        it should be replaced by a version which prints the
C        subprogram nesting list.  Note that this dump must be
C        printed on each of up to five files, as indicated by the
C        XGETUA routine.  See XSETUA and XGETUA for details.
C
C     Written by Ron Jones, with SLATEC Common Math Library Subcommittee
C
C***REFERENCES  (NONE)
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C***END PROLOGUE  FDUMP
C***FIRST EXECUTABLE STATEMENT  FDUMP
      RETURN
      END
*DECK I1MACH
      INTEGER FUNCTION I1MACH (I)
C***BEGIN PROLOGUE  I1MACH
C***PURPOSE  Return integer machine dependent constants.
C***LIBRARY   SLATEC
C***CATEGORY  R1
C***TYPE      INTEGER (I1MACH-I)
C***KEYWORDS  MACHINE CONSTANTS
C***AUTHOR  Fox, P. A., (Bell Labs)
C           Hall, A. D., (Bell Labs)
C           Schryer, N. L., (Bell Labs)
C***DESCRIPTION
C
C   I1MACH can be used to obtain machine-dependent parameters for the
C   local machine environment.  It is a function subprogram with one
C   (input) argument and can be referenced as follows:
C
C        K = I1MACH(I)
C
C   where I=1,...,16.  The (output) value of K above is determined by
C   the (input) value of I.  The results for various values of I are
C   discussed below.
C
C   I/O unit numbers:
C     I1MACH( 1) = the standard input unit.
C     I1MACH( 2) = the standard output unit.
C     I1MACH( 3) = the standard punch unit.
C     I1MACH( 4) = the standard error message unit.
C
C   Words:
C     I1MACH( 5) = the number of bits per integer storage unit.
C     I1MACH( 6) = the number of characters per integer storage unit.
C
C   Integers:
C     assume integers are represented in the S-digit, base-A form
C
C                sign ( X(S-1)*A**(S-1) + ... + X(1)*A + X(0) )
C
C                where 0 .LE. X(I) .LT. A for I=0,...,S-1.
C     I1MACH( 7) = A, the base.
C     I1MACH( 8) = S, the number of base-A digits.
C     I1MACH( 9) = A**S - 1, the largest magnitude.
C
C   Floating-Point Numbers:
C     Assume floating-point numbers are represented in the T-digit,
C     base-B form
C                sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C
C                where 0 .LE. X(I) .LT. B for I=1,...,T,
C                0 .LT. X(1), and EMIN .LE. E .LE. EMAX.
C     I1MACH(10) = B, the base.
C
C   Single-Precision:
C     I1MACH(11) = T, the number of base-B digits.
C     I1MACH(12) = EMIN, the smallest exponent E.
C     I1MACH(13) = EMAX, the largest exponent E.
C
C   Double-Precision:
C     I1MACH(14) = T, the number of base-B digits.
C     I1MACH(15) = EMIN, the smallest exponent E.
C     I1MACH(16) = EMAX, the largest exponent E.
C
C   To alter this function for a particular environment, the desired
C   set of DATA statements should be activated by removing the C from
C   column 1.  Also, the values of I1MACH(1) - I1MACH(4) should be
C   checked for consistency with the local operating system.
C
C***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for
C                 a portable library, ACM Transactions on Mathematical
C                 Software 4, 2 (June 1978), pp. 177-188.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   750101  DATE WRITTEN
C   891012  Added VAX G-floating constants.  (WRB)
C   891012  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900618  Added DEC RISC constants.  (WRB)
C   900723  Added IBM RS 6000 constants.  (WRB)
C   901009  Correct I1MACH(7) for IBM Mainframes. Should be 2 not 16.
C           (RWC)
C   910710  Added HP 730 constants.  (SMR)
C   911114  Added Convex IEEE constants.  (WRB)
C   920121  Added SUN -r8 compiler option constants.  (WRB)
C   920229  Added Touchstone Delta i860 constants.  (WRB)
C   920501  Reformatted the REFERENCES section.  (WRB)
C   920625  Added Convex -p8 and -pd8 compiler option constants.
C           (BKS, WRB)
C   930201  Added DEC Alpha and SGI constants.  (RWC and WRB)
C   930618  Corrected I1MACH(5) for Convex -p8 and -pd8 compiler
C           options.  (DWL, RWC and WRB).
C***END PROLOGUE  I1MACH
C
      INTEGER IMACH(16),OUTPUT
      SAVE IMACH
      EQUIVALENCE (IMACH(4),OUTPUT)
C
C     MACHINE CONSTANTS FOR THE AMIGA
C     ABSOFT COMPILER
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1022 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE APOLLO
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        129 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1025 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM
C
C     DATA IMACH( 1) /          7 /
C     DATA IMACH( 2) /          2 /
C     DATA IMACH( 3) /          2 /
C     DATA IMACH( 4) /          2 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         33 /
C     DATA IMACH( 9) / Z1FFFFFFFF /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -256 /
C     DATA IMACH(13) /        255 /
C     DATA IMACH(14) /         60 /
C     DATA IMACH(15) /       -256 /
C     DATA IMACH(16) /        255 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         48 /
C     DATA IMACH( 6) /          6 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /          8 /
C     DATA IMACH(11) /         13 /
C     DATA IMACH(12) /        -50 /
C     DATA IMACH(13) /         76 /
C     DATA IMACH(14) /         26 /
C     DATA IMACH(15) /        -50 /
C     DATA IMACH(16) /         76 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         48 /
C     DATA IMACH( 6) /          6 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /          8 /
C     DATA IMACH(11) /         13 /
C     DATA IMACH(12) /        -50 /
C     DATA IMACH(13) /         76 /
C     DATA IMACH(14) /         26 /
C     DATA IMACH(15) /     -32754 /
C     DATA IMACH(16) /      32780 /
C
C     MACHINE CONSTANTS FOR THE CDC 170/180 SERIES USING NOS/VE
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          8 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 9223372036854775807 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /      -4095 /
C     DATA IMACH(13) /       4094 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /      -4095 /
C     DATA IMACH(16) /       4094 /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /    6LOUTPUT/
C     DATA IMACH( 5) /         60 /
C     DATA IMACH( 6) /         10 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         48 /
C     DATA IMACH( 9) / 00007777777777777777B /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /       -929 /
C     DATA IMACH(13) /       1070 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /       -929 /
C     DATA IMACH(16) /       1069 /
C
C     MACHINE CONSTANTS FOR THE CELERITY C1260
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          0 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / Z'7FFFFFFF' /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1022 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -fn COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -fi COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -p8 COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 9223372036854775807 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         53 /
C     DATA IMACH(12) /      -1023 /
C     DATA IMACH(13) /       1023 /
C     DATA IMACH(14) /        113 /
C     DATA IMACH(15) /     -16383 /
C     DATA IMACH(16) /      16383 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -pd8 COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 9223372036854775807 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         53 /
C     DATA IMACH(12) /      -1023 /
C     DATA IMACH(13) /       1023 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE CRAY
C     USING THE 46 BIT INTEGER COMPILER OPTION
C
C     DATA IMACH( 1) /        100 /
C     DATA IMACH( 2) /        101 /
C     DATA IMACH( 3) /        102 /
C     DATA IMACH( 4) /        101 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          8 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         46 /
C     DATA IMACH( 9) / 1777777777777777B /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /      -8189 /
C     DATA IMACH(13) /       8190 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /      -8099 /
C     DATA IMACH(16) /       8190 /
C
C     MACHINE CONSTANTS FOR THE CRAY
C     USING THE 64 BIT INTEGER COMPILER OPTION
C
C     DATA IMACH( 1) /        100 /
C     DATA IMACH( 2) /        101 /
C     DATA IMACH( 3) /        102 /
C     DATA IMACH( 4) /        101 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          8 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 777777777777777777777B /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /      -8189 /
C     DATA IMACH(13) /       8190 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /      -8099 /
C     DATA IMACH(16) /       8190 /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C
C     DATA IMACH( 1) /         11 /
C     DATA IMACH( 2) /         12 /
C     DATA IMACH( 3) /          8 /
C     DATA IMACH( 4) /         10 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /         16 /
C     DATA IMACH(11) /          6 /
C     DATA IMACH(12) /        -64 /
C     DATA IMACH(13) /         63 /
C     DATA IMACH(14) /         14 /
C     DATA IMACH(15) /        -64 /
C     DATA IMACH(16) /         63 /
C
C     MACHINE CONSTANTS FOR THE DEC ALPHA
C     USING G_FLOAT
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE DEC ALPHA
C     USING IEEE_FLOAT
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE DEC RISC
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE DEC VAX
C     USING D_FLOATING
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE DEC VAX
C     USING G_FLOATING
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE ELXSI 6400
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         32 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1022 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE HARRIS 220
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          0 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         24 /
C     DATA IMACH( 6) /          3 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         23 /
C     DATA IMACH( 9) /    8388607 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         23 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         38 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /         43 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          6 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         63 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HP 730
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     3 WORD DOUBLE PRECISION OPTION WITH FTN4
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          4 /
C     DATA IMACH( 4) /          1 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         23 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         39 /
C     DATA IMACH(15) /       -128 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     4 WORD DOUBLE PRECISION OPTION WITH FTN4
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          4 /
C     DATA IMACH( 4) /          1 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         23 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         55 /
C     DATA IMACH(15) /       -128 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HP 9000
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          7 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         32 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1015 /
C     DATA IMACH(16) /       1017 /
C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86, AND
C     THE PERKIN ELMER (INTERDATA) 7/32.
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) /  Z7FFFFFFF /
C     DATA IMACH(10) /         16 /
C     DATA IMACH(11) /          6 /
C     DATA IMACH(12) /        -64 /
C     DATA IMACH(13) /         63 /
C     DATA IMACH(14) /         14 /
C     DATA IMACH(15) /        -64 /
C     DATA IMACH(16) /         63 /
C
C     MACHINE CONSTANTS FOR THE IBM PC
C
      DATA IMACH( 1) /          5 /
      DATA IMACH( 2) /          6 /
      DATA IMACH( 3) /          0 /
      DATA IMACH( 4) /          0 /
      DATA IMACH( 5) /         32 /
      DATA IMACH( 6) /          4 /
      DATA IMACH( 7) /          2 /
      DATA IMACH( 8) /         31 /
      DATA IMACH( 9) / 2147483647 /
      DATA IMACH(10) /          2 /
      DATA IMACH(11) /         24 /
      DATA IMACH(12) /       -125 /
      DATA IMACH(13) /        127 /
      DATA IMACH(14) /         53 /
      DATA IMACH(15) /      -1021 /
      DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE IBM RS 6000
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          0 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE INTEL i860
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR)
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          5 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / "377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         54 /
C     DATA IMACH(15) /       -101 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR)
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          5 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / "377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         62 /
C     DATA IMACH(15) /       -128 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C     32-BIT INTEGER ARITHMETIC.
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C     16-BIT INTEGER ARITHMETIC.
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE SILICON GRAPHICS
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE SUN
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE SUN
C     USING THE -r8 COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         53 /
C     DATA IMACH(12) /      -1021 /
C     DATA IMACH(13) /       1024 /
C     DATA IMACH(14) /        113 /
C     DATA IMACH(15) /     -16381 /
C     DATA IMACH(16) /      16384 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES FTN COMPILER
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          1 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         60 /
C     DATA IMACH(15) /      -1024 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE Z80 MICROPROCESSOR
C
C     DATA IMACH( 1) /          1 /
C     DATA IMACH( 2) /          1 /
C     DATA IMACH( 3) /          0 /
C     DATA IMACH( 4) /          1 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C***FIRST EXECUTABLE STATEMENT  I1MACH
      IF (I .LT. 1  .OR.  I .GT. 16) GO TO 10
C
      I1MACH = IMACH(I)
      RETURN
C
   10 CONTINUE
      WRITE (UNIT = OUTPUT, FMT = 9000)
 9000 FORMAT ('1ERROR    1 IN I1MACH - I OUT OF BOUNDS')
C
C     CALL FDUMP
C
      STOP
      END
*DECK J4SAVE
      FUNCTION J4SAVE (IWHICH, IVALUE, ISET)
C***BEGIN PROLOGUE  J4SAVE
C***SUBSIDIARY
C***PURPOSE  Save or recall global variables needed by error
C            handling routines.
C***LIBRARY   SLATEC (XERROR)
C***TYPE      INTEGER (J4SAVE-I)
C***KEYWORDS  ERROR MESSAGES, ERROR NUMBER, RECALL, SAVE, XERROR
C***AUTHOR  Jones, R. E., (SNLA)
C***DESCRIPTION
C
C     Abstract
C        J4SAVE saves and recalls several global variables needed
C        by the library error handling routines.
C
C     Description of Parameters
C      --Input--
C        IWHICH - Index of item desired.
C                = 1 Refers to current error number.
C                = 2 Refers to current error control flag.
C                = 3 Refers to current unit number to which error
C                    messages are to be sent.  (0 means use standard.)
C                = 4 Refers to the maximum number of times any
C                     message is to be printed (as set by XERMAX).
C                = 5 Refers to the total number of units to which
C                     each error message is to be written.
C                = 6 Refers to the 2nd unit for error messages
C                = 7 Refers to the 3rd unit for error messages
C                = 8 Refers to the 4th unit for error messages
C                = 9 Refers to the 5th unit for error messages
C        IVALUE - The value to be set for the IWHICH-th parameter,
C                 if ISET is .TRUE. .
C        ISET   - If ISET=.TRUE., the IWHICH-th parameter will BE
C                 given the value, IVALUE.  If ISET=.FALSE., the
C                 IWHICH-th parameter will be unchanged, and IVALUE
C                 is a dummy parameter.
C      --Output--
C        The (old) value of the IWHICH-th parameter will be returned
C        in the function value, J4SAVE.
C
C***SEE ALSO  XERMSG
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900205  Minor modifications to prologue.  (WRB)
C   900402  Added TYPE section.  (WRB)
C   910411  Added KEYWORDS section.  (WRB)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  J4SAVE
      LOGICAL ISET
      INTEGER IPARAM(9)
      SAVE IPARAM
      DATA IPARAM(1),IPARAM(2),IPARAM(3),IPARAM(4)/0,2,0,10/
      DATA IPARAM(5)/1/
      DATA IPARAM(6),IPARAM(7),IPARAM(8),IPARAM(9)/0,0,0,0/
C***FIRST EXECUTABLE STATEMENT  J4SAVE
      J4SAVE = IPARAM(IWHICH)
      IF (ISET) IPARAM(IWHICH) = IVALUE
      RETURN
      END
*DECK QFORM
      SUBROUTINE QFORM (M, N, Q, LDQ, WA)
C***BEGIN PROLOGUE  QFORM
C***SUBSIDIARY
C***PURPOSE  Subsidiary to SNSQ and SNSQE
C***LIBRARY   SLATEC
C***TYPE      SINGLE PRECISION (QFORM-S, DQFORM-D)
C***AUTHOR  (UNKNOWN)
C***DESCRIPTION
C
C     This subroutine proceeds from the computed QR factorization of
C     an M by N matrix A to accumulate the M by M orthogonal matrix
C     Q from its factored form.
C
C     The subroutine statement is
C
C       SUBROUTINE QFORM(M,N,Q,LDQ,WA)
C
C     where
C
C       M is a positive integer input variable set to the number
C         of rows of A and the order of Q.
C
C       N is a positive integer input variable set to the number
C         of columns of A.
C
C       Q is an M by M array. On input the full lower trapezoid in
C         the first min(M,N) columns of Q contains the factored form.
C         On output Q has been accumulated into a square matrix.
C
C       LDQ is a positive integer input variable not less than M
C         which specifies the leading dimension of the array Q.
C
C       WA is a work array of length M.
C
C***SEE ALSO  SNSQ, SNSQE
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890531  Changed all specific intrinsics to generic.  (WRB)
C   890831  Modified array declarations.  (WRB)
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900326  Removed duplicate information from DESCRIPTION section.
C           (WRB)
C   900328  Added TYPE section.  (WRB)
C***END PROLOGUE  QFORM
      INTEGER M,N,LDQ
      REAL Q(LDQ,*),WA(*)
      INTEGER I,J,JM1,K,L,MINMN,NP1
      REAL ONE,SUM,TEMP,ZERO
      SAVE ONE, ZERO
      DATA ONE,ZERO /1.0E0,0.0E0/
C***FIRST EXECUTABLE STATEMENT  QFORM
      MINMN = MIN(M,N)
      IF (MINMN .LT. 2) GO TO 30
      DO 20 J = 2, MINMN
         JM1 = J - 1
         DO 10 I = 1, JM1
            Q(I,J) = ZERO
   10       CONTINUE
   20    CONTINUE
   30 CONTINUE
C
C     INITIALIZE REMAINING COLUMNS TO THOSE OF THE IDENTITY MATRIX.
C
      NP1 = N + 1
      IF (M .LT. NP1) GO TO 60
      DO 50 J = NP1, M
         DO 40 I = 1, M
            Q(I,J) = ZERO
   40       CONTINUE
         Q(J,J) = ONE
   50    CONTINUE
   60 CONTINUE
C
C     ACCUMULATE Q FROM ITS FACTORED FORM.
C
      DO 120 L = 1, MINMN
         K = MINMN - L + 1
         DO 70 I = K, M
            WA(I) = Q(I,K)
            Q(I,K) = ZERO
   70       CONTINUE
         Q(K,K) = ONE
         IF (WA(K) .EQ. ZERO) GO TO 110
         DO 100 J = K, M
            SUM = ZERO
            DO 80 I = K, M
               SUM = SUM + Q(I,J)*WA(I)
   80          CONTINUE
            TEMP = SUM/WA(K)
            DO 90 I = K, M
               Q(I,J) = Q(I,J) - TEMP*WA(I)
   90          CONTINUE
  100       CONTINUE
  110    CONTINUE
  120    CONTINUE
      RETURN
C
C     LAST CARD OF SUBROUTINE QFORM.
C
      END
*DECK QRFAC
      SUBROUTINE QRFAC (M, N, A, LDA, PIVOT, IPVT, LIPVT, SIGMA, ACNORM,
     +   WA)
C***BEGIN PROLOGUE  QRFAC
C***SUBSIDIARY
C***PURPOSE  Subsidiary to SNLS1, SNLS1E, SNSQ and SNSQE
C***LIBRARY   SLATEC
C***TYPE      SINGLE PRECISION (QRFAC-S, DQRFAC-D)
C***AUTHOR  (UNKNOWN)
C***DESCRIPTION
C
C     This subroutine uses Householder transformations with column
C     pivoting (optional) to compute a QR factorization of the
C     M by N matrix A. That is, QRFAC determines an orthogonal
C     matrix Q, a permutation matrix P, and an upper trapezoidal
C     matrix R with diagonal elements of nonincreasing magnitude,
C     such that A*P = Q*R. The Householder transformation for
C     column K, K = 1,2,...,MIN(M,N), is of the form
C
C                           T
C           I - (1/U(K))*U*U
C
C     where U has zeros in the first K-1 positions. The form of
C     this transformation and the method of pivoting first
C     appeared in the corresponding LINPACK subroutine.
C
C     The subroutine statement is
C
C       SUBROUTINE QRFAC(M,N,A,LDA,PIVOT,IPVT,LIPVT,SIGMA,ACNORM,WA)
C
C     where
C
C       M is a positive integer input variable set to the number
C         of rows of A.
C
C       N is a positive integer input variable set to the number
C         of columns of A.
C
C       A is an M by N array. On input A contains the matrix for
C         which the QR factorization is to be computed. On output
C         the strict upper trapezoidal part of A contains the strict
C         upper trapezoidal part of R, and the lower trapezoidal
C         part of A contains a factored form of Q (the non-trivial
C         elements of the U vectors described above).
C
C       LDA is a positive integer input variable not less than M
C         which specifies the leading dimension of the array A.
C
C       PIVOT is a logical input variable. If pivot is set .TRUE.,
C         then column pivoting is enforced. If pivot is set .FALSE.,
C         then no column pivoting is done.
C
C       IPVT is an integer output array of length LIPVT. IPVT
C         defines the permutation matrix P such that A*P = Q*R.
C         Column J of P is column IPVT(J) of the identity matrix.
C         If pivot is .FALSE., IPVT is not referenced.
C
C       LIPVT is a positive integer input variable. If PIVOT is
C             .FALSE., then LIPVT may be as small as 1. If PIVOT is
C             .TRUE., then LIPVT must be at least N.
C
C       SIGMA is an output array of length N which contains the
C         diagonal elements of R.
C
C       ACNORM is an output array of length N which contains the
C         norms of the corresponding columns of the input matrix A.
C         If this information is not needed, then ACNORM can coincide
C         with SIGMA.
C
C       WA is a work array of length N. If pivot is .FALSE., then WA
C         can coincide with SIGMA.
C
C***SEE ALSO  SNLS1, SNLS1E, SNSQ, SNSQE
C***ROUTINES CALLED  ENORM, R1MACH
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890531  Changed all specific intrinsics to generic.  (WRB)
C   890831  Modified array declarations.  (WRB)
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900326  Removed duplicate information from DESCRIPTION section.
C           (WRB)
C   900328  Added TYPE section.  (WRB)
C***END PROLOGUE  QRFAC
      INTEGER M,N,LDA,LIPVT
      INTEGER IPVT(*)
      LOGICAL PIVOT
      REAL A(LDA,*),SIGMA(*),ACNORM(*),WA(*)
      INTEGER I,J,JP1,K,KMAX,MINMN
      REAL AJNORM,EPSMCH,ONE,P05,SUM,TEMP,ZERO
      REAL R1MACH,ENORM
      SAVE ONE, P05, ZERO
      DATA ONE,P05,ZERO /1.0E0,5.0E-2,0.0E0/
C***FIRST EXECUTABLE STATEMENT  QRFAC
      EPSMCH = R1MACH(4)
C
C     COMPUTE THE INITIAL COLUMN NORMS AND INITIALIZE SEVERAL ARRAYS.
C
      DO 10 J = 1, N
         ACNORM(J) = ENORM(M,A(1,J))
         SIGMA(J) = ACNORM(J)
         WA(J) = SIGMA(J)
         IF (PIVOT) IPVT(J) = J
   10    CONTINUE
C
C     REDUCE A TO R WITH HOUSEHOLDER TRANSFORMATIONS.
C
      MINMN = MIN(M,N)
      DO 110 J = 1, MINMN
         IF (.NOT.PIVOT) GO TO 40
C
C        BRING THE COLUMN OF LARGEST NORM INTO THE PIVOT POSITION.
C
         KMAX = J
         DO 20 K = J, N
            IF (SIGMA(K) .GT. SIGMA(KMAX)) KMAX = K
   20       CONTINUE
         IF (KMAX .EQ. J) GO TO 40
         DO 30 I = 1, M
            TEMP = A(I,J)
            A(I,J) = A(I,KMAX)
            A(I,KMAX) = TEMP
   30       CONTINUE
         SIGMA(KMAX) = SIGMA(J)
         WA(KMAX) = WA(J)
         K = IPVT(J)
         IPVT(J) = IPVT(KMAX)
         IPVT(KMAX) = K
   40    CONTINUE
C
C        COMPUTE THE HOUSEHOLDER TRANSFORMATION TO REDUCE THE
C        J-TH COLUMN OF A TO A MULTIPLE OF THE J-TH UNIT VECTOR.
C
         AJNORM = ENORM(M-J+1,A(J,J))
         IF (AJNORM .EQ. ZERO) GO TO 100
         IF (A(J,J) .LT. ZERO) AJNORM = -AJNORM
         DO 50 I = J, M
            A(I,J) = A(I,J)/AJNORM
   50       CONTINUE
         A(J,J) = A(J,J) + ONE
C
C        APPLY THE TRANSFORMATION TO THE REMAINING COLUMNS
C        AND UPDATE THE NORMS.
C
         JP1 = J + 1
         IF (N .LT. JP1) GO TO 100
         DO 90 K = JP1, N
            SUM = ZERO
            DO 60 I = J, M
               SUM = SUM + A(I,J)*A(I,K)
   60          CONTINUE
            TEMP = SUM/A(J,J)
            DO 70 I = J, M
               A(I,K) = A(I,K) - TEMP*A(I,J)
   70          CONTINUE
            IF (.NOT.PIVOT .OR. SIGMA(K) .EQ. ZERO) GO TO 80
            TEMP = A(J,K)/SIGMA(K)
            SIGMA(K) = SIGMA(K)*SQRT(MAX(ZERO,ONE-TEMP**2))
            IF (P05*(SIGMA(K)/WA(K))**2 .GT. EPSMCH) GO TO 80
            SIGMA(K) = ENORM(M-J,A(JP1,K))
            WA(K) = SIGMA(K)
   80       CONTINUE
   90       CONTINUE
  100    CONTINUE
         SIGMA(J) = -AJNORM
  110    CONTINUE
      RETURN
C
C     LAST CARD OF SUBROUTINE QRFAC.
C
      END
*DECK R1MACH
      REAL FUNCTION R1MACH (I)
C***BEGIN PROLOGUE  R1MACH
C***PURPOSE  Return floating point machine dependent constants.
C***LIBRARY   SLATEC
C***CATEGORY  R1
C***TYPE      SINGLE PRECISION (R1MACH-S, D1MACH-D)
C***KEYWORDS  MACHINE CONSTANTS
C***AUTHOR  Fox, P. A., (Bell Labs)
C           Hall, A. D., (Bell Labs)
C           Schryer, N. L., (Bell Labs)
C***DESCRIPTION
C
C   R1MACH can be used to obtain machine-dependent parameters for the
C   local machine environment.  It is a function subprogram with one
C   (input) argument, and can be referenced as follows:
C
C        A = R1MACH(I)
C
C   where I=1,...,5.  The (output) value of A above is determined by
C   the (input) value of I.  The results for various values of I are
C   discussed below.
C
C   R1MACH(1) = B**(EMIN-1), the smallest positive magnitude.
C   R1MACH(2) = B**EMAX*(1 - B**(-T)), the largest magnitude.
C   R1MACH(3) = B**(-T), the smallest relative spacing.
C   R1MACH(4) = B**(1-T), the largest relative spacing.
C   R1MACH(5) = LOG10(B)
C
C   Assume single precision numbers are represented in the T-digit,
C   base-B form
C
C              sign (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C
C   where 0 .LE. X(I) .LT. B for I=1,...,T, 0 .LT. X(1), and
C   EMIN .LE. E .LE. EMAX.
C
C   The values of B, T, EMIN and EMAX are provided in I1MACH as
C   follows:
C   I1MACH(10) = B, the base.
C   I1MACH(11) = T, the number of base-B digits.
C   I1MACH(12) = EMIN, the smallest exponent E.
C   I1MACH(13) = EMAX, the largest exponent E.
C
C   To alter this function for a particular environment, the desired
C   set of DATA statements should be activated by removing the C from
C   column 1.  Also, the values of R1MACH(1) - R1MACH(4) should be
C   checked for consistency with the local operating system.
C
C***REFERENCES  P. A. Fox, A. D. Hall and N. L. Schryer, Framework for
C                 a portable library, ACM Transactions on Mathematical
C                 Software 4, 2 (June 1978), pp. 177-188.
C***ROUTINES CALLED  XERMSG
C***REVISION HISTORY  (YYMMDD)
C   790101  DATE WRITTEN
C   890213  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ)
C   900618  Added DEC RISC constants.  (WRB)
C   900723  Added IBM RS 6000 constants.  (WRB)
C   910710  Added HP 730 constants.  (SMR)
C   911114  Added Convex IEEE constants.  (WRB)
C   920121  Added SUN -r8 compiler option constants.  (WRB)
C   920229  Added Touchstone Delta i860 constants.  (WRB)
C   920501  Reformatted the REFERENCES section.  (WRB)
C   920625  Added CONVEX -p8 and -pd8 compiler option constants.
C           (BKS, WRB)
C   930201  Added DEC Alpha and SGI constants.  (RWC and WRB)
C***END PROLOGUE  R1MACH
C
c --- Set up for IBM PC: declare as reals   ..........(DGS)
c     INTEGER SMALL(2)
c     INTEGER LARGE(2)
c     INTEGER RIGHT(2)
c     INTEGER DIVER(2)
c     INTEGER LOG10(2)
      real SMALL(2)
      real LARGE(2)
      real RIGHT(2)
      real DIVER(2)
      real LOG10(2)
c --- Set up for IBM PC: declare as reals   ..........(DGS)
C
      REAL RMACH(5)
      SAVE RMACH
C
      EQUIVALENCE (RMACH(1),SMALL(1))
      EQUIVALENCE (RMACH(2),LARGE(1))
      EQUIVALENCE (RMACH(3),RIGHT(1))
      EQUIVALENCE (RMACH(4),DIVER(1))
      EQUIVALENCE (RMACH(5),LOG10(1))
C
C     MACHINE CONSTANTS FOR THE AMIGA
C     ABSOFT FORTRAN COMPILER USING THE 68020/68881 COMPILER OPTION
C
C     DATA SMALL(1) / Z'00800000' /
C     DATA LARGE(1) / Z'7F7FFFFF' /
C     DATA RIGHT(1) / Z'33800000' /
C     DATA DIVER(1) / Z'34000000' /
C     DATA LOG10(1) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE AMIGA
C     ABSOFT FORTRAN COMPILER USING SOFTWARE FLOATING POINT
C
C     DATA SMALL(1) / Z'00800000' /
C     DATA LARGE(1) / Z'7EFFFFFF' /
C     DATA RIGHT(1) / Z'33800000' /
C     DATA DIVER(1) / Z'34000000' /
C     DATA LOG10(1) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE APOLLO
C
C     DATA SMALL(1) / 16#00800000 /
C     DATA LARGE(1) / 16#7FFFFFFF /
C     DATA RIGHT(1) / 16#33800000 /
C     DATA DIVER(1) / 16#34000000 /
C     DATA LOG10(1) / 16#3E9A209B /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM
C
C     DATA RMACH(1) / Z400800000 /
C     DATA RMACH(2) / Z5FFFFFFFF /
C     DATA RMACH(3) / Z4E9800000 /
C     DATA RMACH(4) / Z4EA800000 /
C     DATA RMACH(5) / Z500E730E8 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700/6700/7700 SYSTEMS
C
C     DATA RMACH(1) / O1771000000000000 /
C     DATA RMACH(2) / O0777777777777777 /
C     DATA RMACH(3) / O1311000000000000 /
C     DATA RMACH(4) / O1301000000000000 /
C     DATA RMACH(5) / O1157163034761675 /
C
C     MACHINE CONSTANTS FOR THE CDC 170/180 SERIES USING NOS/VE
C
C     DATA RMACH(1) / Z"3001800000000000" /
C     DATA RMACH(2) / Z"4FFEFFFFFFFFFFFE" /
C     DATA RMACH(3) / Z"3FD2800000000000" /
C     DATA RMACH(4) / Z"3FD3800000000000" /
C     DATA RMACH(5) / Z"3FFF9A209A84FBCF" /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES
C
C     DATA RMACH(1) / 00564000000000000000B /
C     DATA RMACH(2) / 37767777777777777776B /
C     DATA RMACH(3) / 16414000000000000000B /
C     DATA RMACH(4) / 16424000000000000000B /
C     DATA RMACH(5) / 17164642023241175720B /
C
C     MACHINE CONSTANTS FOR THE CELERITY C1260
C
C     DATA SMALL(1) / Z'00800000' /
C     DATA LARGE(1) / Z'7F7FFFFF' /
C     DATA RIGHT(1) / Z'33800000' /
C     DATA DIVER(1) / Z'34000000' /
C     DATA LOG10(1) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -fn COMPILER OPTION
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7FFFFFFF' /
C     DATA RMACH(3) / Z'34800000' /
C     DATA RMACH(4) / Z'35000000' /
C     DATA RMACH(5) / Z'3F9A209B' /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -fi COMPILER OPTION
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7F7FFFFF' /
C     DATA RMACH(3) / Z'33800000' /
C     DATA RMACH(4) / Z'34000000' /
C     DATA RMACH(5) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -p8 OR -pd8 COMPILER OPTION
C
C     DATA RMACH(1) / Z'0010000000000000' /
C     DATA RMACH(2) / Z'7FFFFFFFFFFFFFFF' /
C     DATA RMACH(3) / Z'3CC0000000000000' /
C     DATA RMACH(4) / Z'3CD0000000000000' /
C     DATA RMACH(5) / Z'3FF34413509F79FF' /
C
C     MACHINE CONSTANTS FOR THE CRAY
C
C     DATA RMACH(1) / 200034000000000000000B /
C     DATA RMACH(2) / 577767777777777777776B /
C     DATA RMACH(3) / 377224000000000000000B /
C     DATA RMACH(4) / 377234000000000000000B /
C     DATA RMACH(5) / 377774642023241175720B /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING CARD -
C     STATIC RMACH(5)
C
C     DATA SMALL /    20K,       0 /
C     DATA LARGE / 77777K, 177777K /
C     DATA RIGHT / 35420K,       0 /
C     DATA DIVER / 36020K,       0 /
C     DATA LOG10 / 40423K,  42023K /
C
C     MACHINE CONSTANTS FOR THE DEC ALPHA
C     USING G_FLOAT
C
C     DATA RMACH(1) / '00000080'X /
C     DATA RMACH(2) / 'FFFF7FFF'X /
C     DATA RMACH(3) / '00003480'X /
C     DATA RMACH(4) / '00003500'X /
C     DATA RMACH(5) / '209B3F9A'X /
C
C     MACHINE CONSTANTS FOR THE DEC ALPHA
C     USING IEEE_FLOAT
C
C     DATA RMACH(1) / '00800000'X /
C     DATA RMACH(2) / '7F7FFFFF'X /
C     DATA RMACH(3) / '33800000'X /
C     DATA RMACH(4) / '34000000'X /
C     DATA RMACH(5) / '3E9A209B'X /
C
C     MACHINE CONSTANTS FOR THE DEC RISC
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7F7FFFFF' /
C     DATA RMACH(3) / Z'33800000' /
C     DATA RMACH(4) / Z'34000000' /
C     DATA RMACH(5) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE DEC VAX
C     (EXPRESSED IN INTEGER AND HEXADECIMAL)
C     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSTEMS
C     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS
C
C     DATA SMALL(1) /       128 /
C     DATA LARGE(1) /    -32769 /
C     DATA RIGHT(1) /     13440 /
C     DATA DIVER(1) /     13568 /
C     DATA LOG10(1) / 547045274 /
C
C     DATA SMALL(1) / Z00000080 /
C     DATA LARGE(1) / ZFFFF7FFF /
C     DATA RIGHT(1) / Z00003480 /
C     DATA DIVER(1) / Z00003500 /
C     DATA LOG10(1) / Z209B3F9A /
C
C     MACHINE CONSTANTS FOR THE ELXSI 6400
C     (ASSUMING REAL*4 IS THE DEFAULT REAL)
C
C     DATA SMALL(1) / '00800000'X /
C     DATA LARGE(1) / '7F7FFFFF'X /
C     DATA RIGHT(1) / '33800000'X /
C     DATA DIVER(1) / '34000000'X /
C     DATA LOG10(1) / '3E9A209B'X /
C
C     MACHINE CONSTANTS FOR THE HARRIS 220
C
C     DATA SMALL(1), SMALL(2) / '20000000, '00000201 /
C     DATA LARGE(1), LARGE(2) / '37777777, '00000177 /
C     DATA RIGHT(1), RIGHT(2) / '20000000, '00000352 /
C     DATA DIVER(1), DIVER(2) / '20000000, '00000353 /
C     DATA LOG10(1), LOG10(2) / '23210115, '00000377 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES
C
C     DATA RMACH(1) / O402400000000 /
C     DATA RMACH(2) / O376777777777 /
C     DATA RMACH(3) / O714400000000 /
C     DATA RMACH(4) / O716400000000 /
C     DATA RMACH(5) / O776464202324 /
C
C     MACHINE CONSTANTS FOR THE HP 730
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7F7FFFFF' /
C     DATA RMACH(3) / Z'33800000' /
C     DATA RMACH(4) / Z'34000000' /
C     DATA RMACH(5) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     3 WORD DOUBLE PRECISION WITH FTN4
C
C     DATA SMALL(1), SMALL(2) / 40000B,       1 /
C     DATA LARGE(1), LARGE(2) / 77777B, 177776B /
C     DATA RIGHT(1), RIGHT(2) / 40000B,    325B /
C     DATA DIVER(1), DIVER(2) / 40000B,    327B /
C     DATA LOG10(1), LOG10(2) / 46420B,  46777B /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     4 WORD DOUBLE PRECISION WITH FTN4
C
C     DATA SMALL(1), SMALL(2) / 40000B,       1 /
C     DATA LARGE(1), LARGE(2) / 77777B, 177776B /
C     DATA RIGHT(1), RIGHT(2) / 40000B,    325B /
C     DATA DIVER(1), DIVER(2) / 40000B,    327B /
C     DATA LOG10(1), LOG10(2) / 46420B,  46777B /
C
C     MACHINE CONSTANTS FOR THE HP 9000
C
C     DATA SMALL(1) / 00004000000B /
C     DATA LARGE(1) / 17677777777B /
C     DATA RIGHT(1) / 06340000000B /
C     DATA DIVER(1) / 06400000000B /
C     DATA LOG10(1) / 07646420233B /
C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86  AND
C     THE PERKIN ELMER (INTERDATA) 7/32.
C
C     DATA RMACH(1) / Z00100000 /
C     DATA RMACH(2) / Z7FFFFFFF /
C     DATA RMACH(3) / Z3B100000 /
C     DATA RMACH(4) / Z3C100000 /
C     DATA RMACH(5) / Z41134413 /
C
C     MACHINE CONSTANTS FOR THE IBM PC
C
      DATA SMALL(1) / 1.18E-38      /
      DATA LARGE(1) / 3.40E+38      /
      DATA RIGHT(1) / 0.595E-07     /
      DATA DIVER(1) / 1.19E-07      /
      DATA LOG10(1) / 0.30102999566 /
C
C     MACHINE CONSTANTS FOR THE IBM RS 6000
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7F7FFFFF' /
C     DATA RMACH(3) / Z'33800000' /
C     DATA RMACH(4) / Z'34000000' /
C     DATA RMACH(5) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE INTEL i860
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7F7FFFFF' /
C     DATA RMACH(3) / Z'33800000' /
C     DATA RMACH(4) / Z'34000000' /
C     DATA RMACH(5) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA OR KI PROCESSOR)
C
C     DATA RMACH(1) / "000400000000 /
C     DATA RMACH(2) / "377777777777 /
C     DATA RMACH(3) / "146400000000 /
C     DATA RMACH(4) / "147400000000 /
C     DATA RMACH(5) / "177464202324 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
C
C     DATA SMALL(1) /    8388608 /
C     DATA LARGE(1) / 2147483647 /
C     DATA RIGHT(1) /  880803840 /
C     DATA DIVER(1) /  889192448 /
C     DATA LOG10(1) / 1067065499 /
C
C     DATA RMACH(1) / O00040000000 /
C     DATA RMACH(2) / O17777777777 /
C     DATA RMACH(3) / O06440000000 /
C     DATA RMACH(4) / O06500000000 /
C     DATA RMACH(5) / O07746420233 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C     16-BIT INTEGERS  (EXPRESSED IN INTEGER AND OCTAL).
C
C     DATA SMALL(1), SMALL(2) /   128,     0 /
C     DATA LARGE(1), LARGE(2) / 32767,    -1 /
C     DATA RIGHT(1), RIGHT(2) / 13440,     0 /
C     DATA DIVER(1), DIVER(2) / 13568,     0 /
C     DATA LOG10(1), LOG10(2) / 16282,  8347 /
C
C     DATA SMALL(1), SMALL(2) / O000200, O000000 /
C     DATA LARGE(1), LARGE(2) / O077777, O177777 /
C     DATA RIGHT(1), RIGHT(2) / O032200, O000000 /
C     DATA DIVER(1), DIVER(2) / O032400, O000000 /
C     DATA LOG10(1), LOG10(2) / O037632, O020233 /
C
C     MACHINE CONSTANTS FOR THE SILICON GRAPHICS
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7F7FFFFF' /
C     DATA RMACH(3) / Z'33800000' /
C     DATA RMACH(4) / Z'34000000' /
C     DATA RMACH(5) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE SUN
C
C     DATA RMACH(1) / Z'00800000' /
C     DATA RMACH(2) / Z'7F7FFFFF' /
C     DATA RMACH(3) / Z'33800000' /
C     DATA RMACH(4) / Z'34000000' /
C     DATA RMACH(5) / Z'3E9A209B' /
C
C     MACHINE CONSTANTS FOR THE SUN
C     USING THE -r8 COMPILER OPTION
C
C     DATA RMACH(1) / Z'0010000000000000' /
C     DATA RMACH(2) / Z'7FEFFFFFFFFFFFFF' /
C     DATA RMACH(3) / Z'3CA0000000000000' /
C     DATA RMACH(4) / Z'3CB0000000000000' /
C     DATA RMACH(5) / Z'3FD34413509F79FF' /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES
C
C     DATA RMACH(1) / O000400000000 /
C     DATA RMACH(2) / O377777777777 /
C     DATA RMACH(3) / O146400000000 /
C     DATA RMACH(4) / O147400000000 /
C     DATA RMACH(5) / O177464202324 /
C
C     MACHINE CONSTANTS FOR THE Z80 MICROPROCESSOR
C
C     DATA SMALL(1), SMALL(2) /     0,    256/
C     DATA LARGE(1), LARGE(2) /    -1,   -129/
C     DATA RIGHT(1), RIGHT(2) /     0,  26880/
C     DATA DIVER(1), DIVER(2) /     0,  27136/
C     DATA LOG10(1), LOG10(2) /  8347,  32538/
C
C***FIRST EXECUTABLE STATEMENT  R1MACH
      IF (I .LT. 1 .OR. I .GT. 5) CALL XERMSG ('SLATEC', 'R1MACH',
     +   'I OUT OF BOUNDS', 1, 2)
C
      R1MACH = RMACH(I)
      RETURN
C
      END
*DECK R1MPYQ
      SUBROUTINE R1MPYQ (M, N, A, LDA, V, W)
C***BEGIN PROLOGUE  R1MPYQ
C***SUBSIDIARY
C***PURPOSE  Subsidiary to SNSQ and SNSQE
C***LIBRARY   SLATEC
C***TYPE      SINGLE PRECISION (R1MPYQ-S, D1MPYQ-D)
C***AUTHOR  (UNKNOWN)
C***DESCRIPTION
C
C     Given an M by N matrix A, this subroutine computes A*Q where
C     Q is the product of 2*(N - 1) transformations
C
C           GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1)
C
C     and GV(I), GW(I) are Givens rotations in the (I,N) plane which
C     eliminate elements in the I-th and N-th planes, respectively.
C     Q itself is not given, rather the information to recover the
C     GV, GW rotations is supplied.
C
C     The subroutine statement is
C
C       SUBROUTINE R1MPYQ(M,N,A,LDA,V,W)
C
C     where
C
C       M is a positive integer input variable set to the number
C         of rows of A.
C
C       N is a positive integer input variable set to the number
C         of columns of A.
C
C       A is an M by N ARRAY. On input A must contain the matrix
C         to be postmultiplied by the orthogonal matrix Q
C         described above. On output A*Q has replaced A.
C
C       LDA is a positive integer input variable not less than M
C         which specifies the leading dimension of the array A.
C
C       V is an input array of length N. V(I) must contain the
C         information necessary to recover the Givens rotation GV(I)
C         described above.
C
C       W is an input array of length N. W(I) must contain the
C         information necessary to recover the Givens rotation GW(I)
C         described above.
C
C***SEE ALSO  SNSQ, SNSQE
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890831  Modified array declarations.  (WRB)
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900326  Removed duplicate information from DESCRIPTION section.
C           (WRB)
C   900328  Added TYPE section.  (WRB)
C***END PROLOGUE  R1MPYQ
      INTEGER M,N,LDA
      REAL A(LDA,*),V(*),W(*)
      INTEGER I,J,NMJ,NM1
      REAL COS,ONE,SIN,TEMP
      SAVE ONE
      DATA ONE /1.0E0/
C***FIRST EXECUTABLE STATEMENT  R1MPYQ
      NM1 = N - 1
      IF (NM1 .LT. 1) GO TO 50
      DO 20 NMJ = 1, NM1
         J = N - NMJ
         IF (ABS(V(J)) .GT. ONE) COS = ONE/V(J)
         IF (ABS(V(J)) .GT. ONE) SIN = SQRT(ONE-COS**2)
         IF (ABS(V(J)) .LE. ONE) SIN = V(J)
         IF (ABS(V(J)) .LE. ONE) COS = SQRT(ONE-SIN**2)
         DO 10 I = 1, M
            TEMP = COS*A(I,J) - SIN*A(I,N)
            A(I,N) = SIN*A(I,J) + COS*A(I,N)
            A(I,J) = TEMP
   10       CONTINUE
   20    CONTINUE
C
C     APPLY THE SECOND SET OF GIVENS ROTATIONS TO A.
C
      DO 40 J = 1, NM1
         IF (ABS(W(J)) .GT. ONE) COS = ONE/W(J)
         IF (ABS(W(J)) .GT. ONE) SIN = SQRT(ONE-COS**2)
         IF (ABS(W(J)) .LE. ONE) SIN = W(J)
         IF (ABS(W(J)) .LE. ONE) COS = SQRT(ONE-SIN**2)
         DO 30 I = 1, M
            TEMP = COS*A(I,J) + SIN*A(I,N)
            A(I,N) = -SIN*A(I,J) + COS*A(I,N)
            A(I,J) = TEMP
   30       CONTINUE
   40    CONTINUE
   50 CONTINUE
      RETURN
C
C     LAST CARD OF SUBROUTINE R1MPYQ.
C
      END
*DECK R1UPDT
      SUBROUTINE R1UPDT (M, N, S, LS, U, V, W, SING)
C***BEGIN PROLOGUE  R1UPDT
C***SUBSIDIARY
C***PURPOSE  Subsidiary to SNSQ and SNSQE
C***LIBRARY   SLATEC
C***TYPE      SINGLE PRECISION (R1UPDT-S, D1UPDT-D)
C***AUTHOR  (UNKNOWN)
C***DESCRIPTION
C
C     Given an M by N lower trapezoidal matrix S, an M-vector U,
C     and an N-vector V, the problem is to determine an
C     orthogonal matrix Q such that
C
C                   T
C           (S + U*V )*Q
C
C     is again lower trapezoidal.
C
C     This subroutine determines Q as the product of 2*(N - 1)
C     transformations
C
C           GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1)
C
C     where GV(I), GW(I) are Givens rotations in the (I,N) plane
C     which eliminate elements in the I-th and N-th planes,
C     respectively. Q Itself is not accumulated, rather the
C     information to recover the GV, GW rotations is returned.
C
C     The subroutine statement is
C
C       SUBROUTINE R1UPDT(M,N,S,LS,U,V,W,SING)
C
C     where
C
C       M is a positive integer input variable set to the number
C         of rows of S.
C
C       N is a positive integer input variable set to the number
C         of columns of S. N must not exceed M.
C
C       S is an array of length LS. On input S must contain the lower
C         trapezoidal matrix S stored by columns. On output S contains
C         the lower trapezoidal matrix produced as described above.
C
C       LS is a positive integer input variable not less than
C         (N*(2*M-N+1))/2.
C
C       U is an input array of length M which must contain the
C         vector U.
C
C       V is an array of length N. On input V must contain the vector
C         V. On output V(I) contains the information necessary to
C         recover the Givens rotation GV(I) described above.
C
C       W is an output array of length M. W(I) contains information
C         necessary to recover the Givens rotation GW(I) described
C         above.
C
C       SING is a logical output variable. SING is set .TRUE. if any
C         of the diagonal elements of the output S are zero. Otherwise
C         SING is set .FALSE.
C
C***SEE ALSO  SNSQ, SNSQE
C***ROUTINES CALLED  R1MACH
C***REVISION HISTORY  (YYMMDD)
C   800301  DATE WRITTEN
C   890831  Modified array declarations.  (WRB)
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900326  Removed duplicate information from DESCRIPTION section.
C           (WRB)
C   900328  Added TYPE section.  (WRB)
C***END PROLOGUE  R1UPDT
      INTEGER M,N,LS
      LOGICAL SING
      REAL S(*),U(*),V(*),W(*)
      INTEGER I,J,JJ,L,NMJ,NM1
      REAL COS,COTAN,GIANT,ONE,P5,P25,SIN,TAN,TAU,TEMP,ZERO
      REAL R1MACH
      SAVE ONE, P5, P25, ZERO
      DATA ONE,P5,P25,ZERO /1.0E0,5.0E-1,2.5E-1,0.0E0/
C***FIRST EXECUTABLE STATEMENT  R1UPDT
      GIANT = R1MACH(2)
C
C     INITIALIZE THE DIAGONAL ELEMENT POINTER.
C
      JJ = (N*(2*M - N + 1))/2 - (M - N)
C
C     MOVE THE NONTRIVIAL PART OF THE LAST COLUMN OF S INTO W.
C
      L = JJ
      DO 10 I = N, M
         W(I) = S(L)
         L = L + 1
   10    CONTINUE
C
C     ROTATE THE VECTOR V INTO A MULTIPLE OF THE N-TH UNIT VECTOR
C     IN SUCH A WAY THAT A SPIKE IS INTRODUCED INTO W.
C
      NM1 = N - 1
      IF (NM1 .LT. 1) GO TO 70
      DO 60 NMJ = 1, NM1
         J = N - NMJ
         JJ = JJ - (M - J + 1)
         W(J) = ZERO
         IF (V(J) .EQ. ZERO) GO TO 50
C
C        DETERMINE A GIVENS ROTATION WHICH ELIMINATES THE
C        J-TH ELEMENT OF V.
C
         IF (ABS(V(N)) .GE. ABS(V(J))) GO TO 20
            COTAN = V(N)/V(J)
            SIN = P5/SQRT(P25+P25*COTAN**2)
            COS = SIN*COTAN
            TAU = ONE
            IF (ABS(COS)*GIANT .GT. ONE) TAU = ONE/COS
            GO TO 30
   20    CONTINUE
            TAN = V(J)/V(N)
            COS = P5/SQRT(P25+P25*TAN**2)
            SIN = COS*TAN
            TAU = SIN
   30    CONTINUE
C
C        APPLY THE TRANSFORMATION TO V AND STORE THE INFORMATION
C        NECESSARY TO RECOVER THE GIVENS ROTATION.
C
         V(N) = SIN*V(J) + COS*V(N)
         V(J) = TAU
C
C        APPLY THE TRANSFORMATION TO S AND EXTEND THE SPIKE IN W.
C
         L = JJ
         DO 40 I = J, M
            TEMP = COS*S(L) - SIN*W(I)
            W(I) = SIN*S(L) + COS*W(I)
            S(L) = TEMP
            L = L + 1
   40       CONTINUE
   50    CONTINUE
   60    CONTINUE
   70 CONTINUE
C
C     ADD THE SPIKE FROM THE RANK 1 UPDATE TO W.
C
      DO 80 I = 1, M
         W(I) = W(I) + V(N)*U(I)
   80    CONTINUE
C
C     ELIMINATE THE SPIKE.
C
      SING = .FALSE.
      IF (NM1 .LT. 1) GO TO 140
      DO 130 J = 1, NM1
         IF (W(J) .EQ. ZERO) GO TO 120
C
C        DETERMINE A GIVENS ROTATION WHICH ELIMINATES THE
C        J-TH ELEMENT OF THE SPIKE.
C
         IF (ABS(S(JJ)) .GE. ABS(W(J))) GO TO 90
            COTAN = S(JJ)/W(J)
            SIN = P5/SQRT(P25+P25*COTAN**2)
            COS = SIN*COTAN
            TAU = ONE
            IF (ABS(COS)*GIANT .GT. ONE) TAU = ONE/COS
            GO TO 100
   90    CONTINUE
            TAN = W(J)/S(JJ)
            COS = P5/SQRT(P25+P25*TAN**2)
            SIN = COS*TAN
            TAU = SIN
  100    CONTINUE
C
C        APPLY THE TRANSFORMATION TO S AND REDUCE THE SPIKE IN W.
C
         L = JJ
         DO 110 I = J, M
            TEMP = COS*S(L) + SIN*W(I)
            W(I) = -SIN*S(L) + COS*W(I)
            S(L) = TEMP
            L = L + 1
  110       CONTINUE
C
C        STORE THE INFORMATION NECESSARY TO RECOVER THE
C        GIVENS ROTATION.
C
         W(J) = TAU
  120    CONTINUE
C
C        TEST FOR ZERO DIAGONAL ELEMENTS IN THE OUTPUT S.
C
         IF (S(JJ) .EQ. ZERO) SING = .TRUE.
         JJ = JJ + (M - J + 1)
  130    CONTINUE
  140 CONTINUE
C
C     MOVE W BACK INTO THE LAST COLUMN OF THE OUTPUT S.
C
      L = JJ
      DO 150 I = N, M
         S(L) = W(I)
         L = L + 1
  150    CONTINUE
      IF (S(JJ) .EQ. ZERO) SING = .TRUE.
      RETURN
C
C     LAST CARD OF SUBROUTINE R1UPDT.
C
      END
*DECK XERCNT
      SUBROUTINE XERCNT (LIBRAR, SUBROU, MESSG, NERR, LEVEL, KONTRL)
C***BEGIN PROLOGUE  XERCNT
C***SUBSIDIARY
C***PURPOSE  Allow user control over handling of errors.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERCNT-A)
C***KEYWORDS  ERROR, XERROR
C***AUTHOR  Jones, R. E., (SNLA)
C***DESCRIPTION
C
C     Abstract
C        Allows user control over handling of individual errors.
C        Just after each message is recorded, but before it is
C        processed any further (i.e., before it is printed or
C        a decision to abort is made), a call is made to XERCNT.
C        If the user has provided his own version of XERCNT, he
C        can then override the value of KONTROL used in processing
C        this message by redefining its value.
C        KONTRL may be set to any value from -2 to 2.
C        The meanings for KONTRL are the same as in XSETF, except
C        that the value of KONTRL changes only for this message.
C        If KONTRL is set to a value outside the range from -2 to 2,
C        it will be moved back into that range.
C
C     Description of Parameters
C
C      --Input--
C        LIBRAR - the library that the routine is in.
C        SUBROU - the subroutine that XERMSG is being called from
C        MESSG  - the first 20 characters of the error message.
C        NERR   - same as in the call to XERMSG.
C        LEVEL  - same as in the call to XERMSG.
C        KONTRL - the current value of the control flag as set
C                 by a call to XSETF.
C
C      --Output--
C        KONTRL - the new value of KONTRL.  If KONTRL is not
C                 defined, it will remain at its original value.
C                 This changed value of control affects only
C                 the current occurrence of the current message.
C
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900206  Routine changed from user-callable to subsidiary.  (WRB)
C   900510  Changed calling sequence to include LIBRARY and SUBROUTINE
C           names, changed routine name from XERCTL to XERCNT.  (RWC)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  XERCNT
      CHARACTER*(*) LIBRAR, SUBROU, MESSG
C***FIRST EXECUTABLE STATEMENT  XERCNT
      RETURN
      END
*DECK XERHLT
      SUBROUTINE XERHLT (MESSG)
C***BEGIN PROLOGUE  XERHLT
C***SUBSIDIARY
C***PURPOSE  Abort program execution and print error message.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERHLT-A)
C***KEYWORDS  ABORT PROGRAM EXECUTION, ERROR, XERROR
C***AUTHOR  Jones, R. E., (SNLA)
C***DESCRIPTION
C
C     Abstract
C        ***Note*** machine dependent routine
C        XERHLT aborts the execution of the program.
C        The error message causing the abort is given in the calling
C        sequence, in case one needs it for printing on a dayfile,
C        for example.
C
C     Description of Parameters
C        MESSG is as in XERMSG.
C
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900206  Routine changed from user-callable to subsidiary.  (WRB)
C   900510  Changed calling sequence to delete length of character
C           and changed routine name from XERABT to XERHLT.  (RWC)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  XERHLT
      CHARACTER*(*) MESSG
C***FIRST EXECUTABLE STATEMENT  XERHLT
      STOP
      END
*DECK XERMSG
      SUBROUTINE XERMSG (LIBRAR, SUBROU, MESSG, NERR, LEVEL)
C***BEGIN PROLOGUE  XERMSG
C***PURPOSE  Process error messages for SLATEC and other libraries.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERMSG-A)
C***KEYWORDS  ERROR MESSAGE, XERROR
C***AUTHOR  Fong, Kirby, (NMFECC at LLNL)
C***DESCRIPTION
C
C   XERMSG processes a diagnostic message in a manner determined by the
C   value of LEVEL and the current value of the library error control
C   flag, KONTRL.  See subroutine XSETF for details.
C
C    LIBRAR   A character constant (or character variable) with the name
C             of the library.  This will be 'SLATEC' for the SLATEC
C             Common Math Library.  The error handling package is
C             general enough to be used by many libraries
C             simultaneously, so it is desirable for the routine that
C             detects and reports an error to identify the library name
C             as well as the routine name.
C
C    SUBROU   A character constant (or character variable) with the name
C             of the routine that detected the error.  Usually it is the
C             name of the routine that is calling XERMSG.  There are
C             some instances where a user callable library routine calls
C             lower level subsidiary routines where the error is
C             detected.  In such cases it may be more informative to
C             supply the name of the routine the user called rather than
C             the name of the subsidiary routine that detected the
C             error.
C
C    MESSG    A character constant (or character variable) with the text
C             of the error or warning message.  In the example below,
C             the message is a character constant that contains a
C             generic message.
C
C                   CALL XERMSG ('SLATEC', 'MMPY',
C                  *'THE ORDER OF THE MATRIX EXCEEDS THE ROW DIMENSION',
C                  *3, 1)
C
C             It is possible (and is sometimes desirable) to generate a
C             specific message--e.g., one that contains actual numeric
C             values.  Specific numeric values can be converted into
C             character strings using formatted WRITE statements into
C             character variables.  This is called standard Fortran
C             internal file I/O and is exemplified in the first three
C             lines of the following example.  You can also catenate
C             substrings of characters to construct the error message.
C             Here is an example showing the use of both writing to
C             an internal file and catenating character strings.
C
C                   CHARACTER*5 CHARN, CHARL
C                   WRITE (CHARN,10) N
C                   WRITE (CHARL,10) LDA
C                10 FORMAT(I5)
C                   CALL XERMSG ('SLATEC', 'MMPY', 'THE ORDER'//CHARN//
C                  *   ' OF THE MATRIX EXCEEDS ITS ROW DIMENSION OF'//
C                  *   CHARL, 3, 1)
C
C             There are two subtleties worth mentioning.  One is that
C             the // for character catenation is used to construct the
C             error message so that no single character constant is
C             continued to the next line.  This avoids confusion as to
C             whether there are trailing blanks at the end of the line.
C             The second is that by catenating the parts of the message
C             as an actual argument rather than encoding the entire
C             message into one large character variable, we avoid
C             having to know how long the message will be in order to
C             declare an adequate length for that large character
C             variable.  XERMSG calls XERPRN to print the message using
C             multiple lines if necessary.  If the message is very long,
C             XERPRN will break it into pieces of 72 characters (as
C             requested by XERMSG) for printing on multiple lines.
C             Also, XERMSG asks XERPRN to prefix each line with ' *  '
C             so that the total line length could be 76 characters.
C             Note also that XERPRN scans the error message backwards
C             to ignore trailing blanks.  Another feature is that
C             the substring '$$' is treated as a new line sentinel
C             by XERPRN.  If you want to construct a multiline
C             message without having to count out multiples of 72
C             characters, just use '$$' as a separator.  '$$'
C             obviously must occur within 72 characters of the
C             start of each line to have its intended effect since
C             XERPRN is asked to wrap around at 72 characters in
C             addition to looking for '$$'.
C
C    NERR     An integer value that is chosen by the library routine's
C             author.  It must be in the range -99 to 999 (three
C             printable digits).  Each distinct error should have its
C             own error number.  These error numbers should be described
C             in the machine readable documentation for the routine.
C             The error numbers need be unique only within each routine,
C             so it is reasonable for each routine to start enumerating
C             errors from 1 and proceeding to the next integer.
C
C    LEVEL    An integer value in the range 0 to 2 that indicates the
C             level (severity) of the error.  Their meanings are
C
C            -1  A warning message.  This is used if it is not clear
C                that there really is an error, but the user's attention
C                may be needed.  An attempt is made to only print this
C                message once.
C
C             0  A warning message.  This is used if it is not clear
C                that there really is an error, but the user's attention
C                may be needed.
C
C             1  A recoverable error.  This is used even if the error is
C                so serious that the routine cannot return any useful
C                answer.  If the user has told the error package to
C                return after recoverable errors, then XERMSG will
C                return to the Library routine which can then return to
C                the user's routine.  The user may also permit the error
C                package to terminate the program upon encountering a
C                recoverable error.
C
C             2  A fatal error.  XERMSG will not return to its caller
C                after it receives a fatal error.  This level should
C                hardly ever be used; it is much better to allow the
C                user a chance to recover.  An example of one of the few
C                cases in which it is permissible to declare a level 2
C                error is a reverse communication Library routine that
C                is likely to be called repeatedly until it integrates
C                across some interval.  If there is a serious error in
C                the input such that another step cannot be taken and
C                the Library routine is called again without the input
C                error having been corrected by the caller, the Library
C                routine will probably be called forever with improper
C                input.  In this case, it is reasonable to declare the
C                error to be fatal.
C
C    Each of the arguments to XERMSG is input; none will be modified by
C    XERMSG.  A routine may make multiple calls to XERMSG with warning
C    level messages; however, after a call to XERMSG with a recoverable
C    error, the routine should return to the user.  Do not try to call
C    XERMSG with a second recoverable error after the first recoverable
C    error because the error package saves the error number.  The user
C    can retrieve this error number by calling another entry point in
C    the error handling package and then clear the error number when
C    recovering from the error.  Calling XERMSG in succession causes the
C    old error number to be overwritten by the latest error number.
C    This is considered harmless for error numbers associated with
C    warning messages but must not be done for error numbers of serious
C    errors.  After a call to XERMSG with a recoverable error, the user
C    must be given a chance to call NUMXER or XERCLR to retrieve or
C    clear the error number.
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  FDUMP, J4SAVE, XERCNT, XERHLT, XERPRN, XERSVE
C***REVISION HISTORY  (YYMMDD)
C   880101  DATE WRITTEN
C   880621  REVISED AS DIRECTED AT SLATEC CML MEETING OF FEBRUARY 1988.
C           THERE ARE TWO BASIC CHANGES.
C           1.  A NEW ROUTINE, XERPRN, IS USED INSTEAD OF XERPRT TO
C               PRINT MESSAGES.  THIS ROUTINE WILL BREAK LONG MESSAGES
C               INTO PIECES FOR PRINTING ON MULTIPLE LINES.  '$$' IS
C               ACCEPTED AS A NEW LINE SENTINEL.  A PREFIX CAN BE
C               ADDED TO EACH LINE TO BE PRINTED.  XERMSG USES EITHER
C               ' ***' OR ' *  ' AND LONG MESSAGES ARE BROKEN EVERY
C               72 CHARACTERS (AT MOST) SO THAT THE MAXIMUM LINE
C               LENGTH OUTPUT CAN NOW BE AS GREAT AS 76.
C           2.  THE TEXT OF ALL MESSAGES IS NOW IN UPPER CASE SINCE THE
C               FORTRAN STANDARD DOCUMENT DOES NOT ADMIT THE EXISTENCE
C               OF LOWER CASE.
C   880708  REVISED AFTER THE SLATEC CML MEETING OF JUNE 29 AND 30.
C           THE PRINCIPAL CHANGES ARE
C           1.  CLARIFY COMMENTS IN THE PROLOGUES
C           2.  RENAME XRPRNT TO XERPRN
C           3.  REWORK HANDLING OF '$$' IN XERPRN TO HANDLE BLANK LINES
C               SIMILAR TO THE WAY FORMAT STATEMENTS HANDLE THE /
C               CHARACTER FOR NEW RECORDS.
C   890706  REVISED WITH THE HELP OF FRED FRITSCH AND REG CLEMENS TO
C           CLEAN UP THE CODING.
C   890721  REVISED TO USE NEW FEATURE IN XERPRN TO COUNT CHARACTERS IN
C           PREFIX.
C   891013  REVISED TO CORRECT COMMENTS.
C   891214  Prologue converted to Version 4.0 format.  (WRB)
C   900510  Changed test on NERR to be -9999999 < NERR < 99999999, but
C           NERR .ne. 0, and on LEVEL to be -2 < LEVEL < 3.  Added
C           LEVEL=-1 logic, changed calls to XERSAV to XERSVE, and
C           XERCTL to XERCNT.  (RWC)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  XERMSG
      CHARACTER*(*) LIBRAR, SUBROU, MESSG
      CHARACTER*8 XLIBR, XSUBR
      CHARACTER*72  TEMP
      CHARACTER*20  LFIRST
C***FIRST EXECUTABLE STATEMENT  XERMSG
      LKNTRL = J4SAVE (2, 0, .FALSE.)
      MAXMES = J4SAVE (4, 0, .FALSE.)
C
C       LKNTRL IS A LOCAL COPY OF THE CONTROL FLAG KONTRL.
C       MAXMES IS THE MAXIMUM NUMBER OF TIMES ANY PARTICULAR MESSAGE
C          SHOULD BE PRINTED.
C
C       WE PRINT A FATAL ERROR MESSAGE AND TERMINATE FOR AN ERROR IN
C          CALLING XERMSG.  THE ERROR NUMBER SHOULD BE POSITIVE,
C          AND THE LEVEL SHOULD BE BETWEEN 0 AND 2.
C
      IF (NERR.LT.-9999999 .OR. NERR.GT.99999999 .OR. NERR.EQ.0 .OR.
     *   LEVEL.LT.-1 .OR. LEVEL.GT.2) THEN
         CALL XERPRN (' ***', -1, 'FATAL ERROR IN...$$ ' //
     *      'XERMSG -- INVALID ERROR NUMBER OR LEVEL$$ '//
     *      'JOB ABORT DUE TO FATAL ERROR.', 72)
         CALL XERSVE (' ', ' ', ' ', 0, 0, 0, KDUMMY)
         CALL XERHLT (' ***XERMSG -- INVALID INPUT')
         RETURN
      ENDIF
C
C       RECORD THE MESSAGE.
C
      I = J4SAVE (1, NERR, .TRUE.)
      CALL XERSVE (LIBRAR, SUBROU, MESSG, 1, NERR, LEVEL, KOUNT)
C
C       HANDLE PRINT-ONCE WARNING MESSAGES.
C
      IF (LEVEL.EQ.-1 .AND. KOUNT.GT.1) RETURN
C
C       ALLOW TEMPORARY USER OVERRIDE OF THE CONTROL FLAG.
C
      XLIBR  = LIBRAR
      XSUBR  = SUBROU
      LFIRST = MESSG
      LERR   = NERR
      LLEVEL = LEVEL
      CALL XERCNT (XLIBR, XSUBR, LFIRST, LERR, LLEVEL, LKNTRL)
C
      LKNTRL = MAX(-2, MIN(2,LKNTRL))
      MKNTRL = ABS(LKNTRL)
C
C       SKIP PRINTING IF THE CONTROL FLAG VALUE AS RESET IN XERCNT IS
C       ZERO AND THE ERROR IS NOT FATAL.
C
      IF (LEVEL.LT.2 .AND. LKNTRL.EQ.0) GO TO 30
      IF (LEVEL.EQ.0 .AND. KOUNT.GT.MAXMES) GO TO 30
      IF (LEVEL.EQ.1 .AND. KOUNT.GT.MAXMES .AND. MKNTRL.EQ.1) GO TO 30
      IF (LEVEL.EQ.2 .AND. KOUNT.GT.MAX(1,MAXMES)) GO TO 30
C
C       ANNOUNCE THE NAMES OF THE LIBRARY AND SUBROUTINE BY BUILDING A
C       MESSAGE IN CHARACTER VARIABLE TEMP (NOT EXCEEDING 66 CHARACTERS)
C       AND SENDING IT OUT VIA XERPRN.  PRINT ONLY IF CONTROL FLAG
C       IS NOT ZERO.
C
      IF (LKNTRL .NE. 0) THEN
         TEMP(1:21) = 'MESSAGE FROM ROUTINE '
         I = MIN(LEN(SUBROU), 16)
         TEMP(22:21+I) = SUBROU(1:I)
         TEMP(22+I:33+I) = ' IN LIBRARY '
         LTEMP = 33 + I
         I = MIN(LEN(LIBRAR), 16)
         TEMP(LTEMP+1:LTEMP+I) = LIBRAR (1:I)
         TEMP(LTEMP+I+1:LTEMP+I+1) = '.'
         LTEMP = LTEMP + I + 1
         CALL XERPRN (' ***', -1, TEMP(1:LTEMP), 72)
      ENDIF
C
C       IF LKNTRL IS POSITIVE, PRINT AN INTRODUCTORY LINE BEFORE
C       PRINTING THE MESSAGE.  THE INTRODUCTORY LINE TELLS THE CHOICE
C       FROM EACH OF THE FOLLOWING THREE OPTIONS.
C       1.  LEVEL OF THE MESSAGE
C              'INFORMATIVE MESSAGE'
C              'POTENTIALLY RECOVERABLE ERROR'
C              'FATAL ERROR'
C       2.  WHETHER CONTROL FLAG WILL ALLOW PROGRAM TO CONTINUE
C              'PROG CONTINUES'
C              'PROG ABORTED'
C       3.  WHETHER OR NOT A TRACEBACK WAS REQUESTED.  (THE TRACEBACK
C           MAY NOT BE IMPLEMENTED AT SOME SITES, SO THIS ONLY TELLS
C           WHAT WAS REQUESTED, NOT WHAT WAS DELIVERED.)
C              'TRACEBACK REQUESTED'
C              'TRACEBACK NOT REQUESTED'
C       NOTICE THAT THE LINE INCLUDING FOUR PREFIX CHARACTERS WILL NOT
C       EXCEED 74 CHARACTERS.
C       WE SKIP THE NEXT BLOCK IF THE INTRODUCTORY LINE IS NOT NEEDED.
C
      IF (LKNTRL .GT. 0) THEN
C
C       THE FIRST PART OF THE MESSAGE TELLS ABOUT THE LEVEL.
C
         IF (LEVEL .LE. 0) THEN
            TEMP(1:20) = 'INFORMATIVE MESSAGE,'
            LTEMP = 20
         ELSEIF (LEVEL .EQ. 1) THEN
            TEMP(1:30) = 'POTENTIALLY RECOVERABLE ERROR,'
            LTEMP = 30
         ELSE
            TEMP(1:12) = 'FATAL ERROR,'
            LTEMP = 12
         ENDIF
C
C       THEN WHETHER THE PROGRAM WILL CONTINUE.
C
         IF ((MKNTRL.EQ.2 .AND. LEVEL.GE.1) .OR.
     *       (MKNTRL.EQ.1 .AND. LEVEL.EQ.2)) THEN
            TEMP(LTEMP+1:LTEMP+14) = ' PROG ABORTED,'
            LTEMP = LTEMP + 14
         ELSE
            TEMP(LTEMP+1:LTEMP+16) = ' PROG CONTINUES,'
            LTEMP = LTEMP + 16
         ENDIF
C
C       FINALLY TELL WHETHER THERE SHOULD BE A TRACEBACK.
C
         IF (LKNTRL .GT. 0) THEN
            TEMP(LTEMP+1:LTEMP+20) = ' TRACEBACK REQUESTED'
            LTEMP = LTEMP + 20
         ELSE
            TEMP(LTEMP+1:LTEMP+24) = ' TRACEBACK NOT REQUESTED'
            LTEMP = LTEMP + 24
         ENDIF
         CALL XERPRN (' ***', -1, TEMP(1:LTEMP), 72)
      ENDIF
C
C       NOW SEND OUT THE MESSAGE.
C
      CALL XERPRN (' *  ', -1, MESSG, 72)
C
C       IF LKNTRL IS POSITIVE, WRITE THE ERROR NUMBER AND REQUEST A
C          TRACEBACK.
C
      IF (LKNTRL .GT. 0) THEN
         WRITE (TEMP, '(''ERROR NUMBER = '', I8)') NERR
         DO 10 I=16,22
            IF (TEMP(I:I) .NE. ' ') GO TO 20
   10    CONTINUE
C
   20    CALL XERPRN (' *  ', -1, TEMP(1:15) // TEMP(I:23), 72)
         CALL FDUMP
      ENDIF
C
C       IF LKNTRL IS NOT ZERO, PRINT A BLANK LINE AND AN END OF MESSAGE.
C
      IF (LKNTRL .NE. 0) THEN
         CALL XERPRN (' *  ', -1, ' ', 72)
         CALL XERPRN (' ***', -1, 'END OF MESSAGE', 72)
         CALL XERPRN ('    ',  0, ' ', 72)
      ENDIF
C
C       IF THE ERROR IS NOT FATAL OR THE ERROR IS RECOVERABLE AND THE
C       CONTROL FLAG IS SET FOR RECOVERY, THEN RETURN.
C
   30 IF (LEVEL.LE.0 .OR. (LEVEL.EQ.1 .AND. MKNTRL.LE.1)) RETURN
C
C       THE PROGRAM WILL BE STOPPED DUE TO AN UNRECOVERED ERROR OR A
C       FATAL ERROR.  PRINT THE REASON FOR THE ABORT AND THE ERROR
C       SUMMARY IF THE CONTROL FLAG AND THE MAXIMUM ERROR COUNT PERMIT.
C
      IF (LKNTRL.GT.0 .AND. KOUNT.LT.MAX(1,MAXMES)) THEN
         IF (LEVEL .EQ. 1) THEN
            CALL XERPRN
     *         (' ***', -1, 'JOB ABORT DUE TO UNRECOVERED ERROR.', 72)
         ELSE
            CALL XERPRN(' ***', -1, 'JOB ABORT DUE TO FATAL ERROR.', 72)
         ENDIF
         CALL XERSVE (' ', ' ', ' ', -1, 0, 0, KDUMMY)
         CALL XERHLT (' ')
      ELSE
         CALL XERHLT (MESSG)
      ENDIF
      RETURN
      END
*DECK XERPRN
      SUBROUTINE XERPRN (PREFIX, NPREF, MESSG, NWRAP)
C***BEGIN PROLOGUE  XERPRN
C***SUBSIDIARY
C***PURPOSE  Print error messages processed by XERMSG.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERPRN-A)
C***KEYWORDS  ERROR MESSAGES, PRINTING, XERROR
C***AUTHOR  Fong, Kirby, (NMFECC at LLNL)
C***DESCRIPTION
C
C This routine sends one or more lines to each of the (up to five)
C logical units to which error messages are to be sent.  This routine
C is called several times by XERMSG, sometimes with a single line to
C print and sometimes with a (potentially very long) message that may
C wrap around into multiple lines.
C
C PREFIX  Input argument of type CHARACTER.  This argument contains
C         characters to be put at the beginning of each line before
C         the body of the message.  No more than 16 characters of
C         PREFIX will be used.
C
C NPREF   Input argument of type INTEGER.  This argument is the number
C         of characters to use from PREFIX.  If it is negative, the
C         intrinsic function LEN is used to determine its length.  If
C         it is zero, PREFIX is not used.  If it exceeds 16 or if
C         LEN(PREFIX) exceeds 16, only the first 16 characters will be
C         used.  If NPREF is positive and the length of PREFIX is less
C         than NPREF, a copy of PREFIX extended with blanks to length
C         NPREF will be used.
C
C MESSG   Input argument of type CHARACTER.  This is the text of a
C         message to be printed.  If it is a long message, it will be
C         broken into pieces for printing on multiple lines.  Each line
C         will start with the appropriate prefix and be followed by a
C         piece of the message.  NWRAP is the number of characters per
C         piece; that is, after each NWRAP characters, we break and
C         start a new line.  In addition the characters '$$' embedded
C         in MESSG are a sentinel for a new line.  The counting of
C         characters up to NWRAP starts over for each new line.  The
C         value of NWRAP typically used by XERMSG is 72 since many
C         older error messages in the SLATEC Library are laid out to
C         rely on wrap-around every 72 characters.
C
C NWRAP   Input argument of type INTEGER.  This gives the maximum size
C         piece into which to break MESSG for printing on multiple
C         lines.  An embedded '$$' ends a line, and the count restarts
C         at the following character.  If a line break does not occur
C         on a blank (it would split a word) that word is moved to the
C         next line.  Values of NWRAP less than 16 will be treated as
C         16.  Values of NWRAP greater than 132 will be treated as 132.
C         The actual line length will be NPREF + NWRAP after NPREF has
C         been adjusted to fall between 0 and 16 and NWRAP has been
C         adjusted to fall between 16 and 132.
C
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  I1MACH, XGETUA
C***REVISION HISTORY  (YYMMDD)
C   880621  DATE WRITTEN
C   880708  REVISED AFTER THE SLATEC CML SUBCOMMITTEE MEETING OF
C           JUNE 29 AND 30 TO CHANGE THE NAME TO XERPRN AND TO REWORK
C           THE HANDLING OF THE NEW LINE SENTINEL TO BEHAVE LIKE THE
C           SLASH CHARACTER IN FORMAT STATEMENTS.
C   890706  REVISED WITH THE HELP OF FRED FRITSCH AND REG CLEMENS TO
C           STREAMLINE THE CODING AND FIX A BUG THAT CAUSED EXTRA BLANK
C           LINES TO BE PRINTED.
C   890721  REVISED TO ADD A NEW FEATURE.  A NEGATIVE VALUE OF NPREF
C           CAUSES LEN(PREFIX) TO BE USED AS THE LENGTH.
C   891013  REVISED TO CORRECT ERROR IN CALCULATING PREFIX LENGTH.
C   891214  Prologue converted to Version 4.0 format.  (WRB)
C   900510  Added code to break messages between words.  (RWC)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  XERPRN
      CHARACTER*(*) PREFIX, MESSG
      INTEGER NPREF, NWRAP
      CHARACTER*148 CBUFF
      INTEGER IU(5), NUNIT
      CHARACTER*2 NEWLIN
      PARAMETER (NEWLIN = '$$')
C***FIRST EXECUTABLE STATEMENT  XERPRN
      CALL XGETUA(IU,NUNIT)
C
C       A ZERO VALUE FOR A LOGICAL UNIT NUMBER MEANS TO USE THE STANDARD
C       ERROR MESSAGE UNIT INSTEAD.  I1MACH(4) RETRIEVES THE STANDARD
C       ERROR MESSAGE UNIT.
C
      N = I1MACH(4)
      DO 10 I=1,NUNIT
         IF (IU(I) .EQ. 0) IU(I) = N
   10 CONTINUE
C
C       LPREF IS THE LENGTH OF THE PREFIX.  THE PREFIX IS PLACED AT THE
C       BEGINNING OF CBUFF, THE CHARACTER BUFFER, AND KEPT THERE DURING
C       THE REST OF THIS ROUTINE.
C
      IF ( NPREF .LT. 0 ) THEN
         LPREF = LEN(PREFIX)
      ELSE
         LPREF = NPREF
      ENDIF
      LPREF = MIN(16, LPREF)
      IF (LPREF .NE. 0) CBUFF(1:LPREF) = PREFIX
C
C       LWRAP IS THE MAXIMUM NUMBER OF CHARACTERS WE WANT TO TAKE AT ONE
C       TIME FROM MESSG TO PRINT ON ONE LINE.
C
      LWRAP = MAX(16, MIN(132, NWRAP))
C
C       SET LENMSG TO THE LENGTH OF MESSG, IGNORE ANY TRAILING BLANKS.
C
      LENMSG = LEN(MESSG)
      N = LENMSG
      DO 20 I=1,N
         IF (MESSG(LENMSG:LENMSG) .NE. ' ') GO TO 30
         LENMSG = LENMSG - 1
   20 CONTINUE
   30 CONTINUE
C
C       IF THE MESSAGE IS ALL BLANKS, THEN PRINT ONE BLANK LINE.
C
      IF (LENMSG .EQ. 0) THEN
         CBUFF(LPREF+1:LPREF+1) = ' '
         DO 40 I=1,NUNIT
            WRITE(IU(I), '(A)') CBUFF(1:LPREF+1)
   40    CONTINUE
         RETURN
      ENDIF
C
C       SET NEXTC TO THE POSITION IN MESSG WHERE THE NEXT SUBSTRING
C       STARTS.  FROM THIS POSITION WE SCAN FOR THE NEW LINE SENTINEL.
C       WHEN NEXTC EXCEEDS LENMSG, THERE IS NO MORE TO PRINT.
C       WE LOOP BACK TO LABEL 50 UNTIL ALL PIECES HAVE BEEN PRINTED.
C
C       WE LOOK FOR THE NEXT OCCURRENCE OF THE NEW LINE SENTINEL.  THE
C       INDEX INTRINSIC FUNCTION RETURNS ZERO IF THERE IS NO OCCURRENCE
C       OR IF THE LENGTH OF THE FIRST ARGUMENT IS LESS THAN THE LENGTH
C       OF THE SECOND ARGUMENT.
C
C       THERE ARE SEVERAL CASES WHICH SHOULD BE CHECKED FOR IN THE
C       FOLLOWING ORDER.  WE ARE ATTEMPTING TO SET LPIECE TO THE NUMBER
C       OF CHARACTERS THAT SHOULD BE TAKEN FROM MESSG STARTING AT
C       POSITION NEXTC.
C
C       LPIECE .EQ. 0   THE NEW LINE SENTINEL DOES NOT OCCUR IN THE
C                       REMAINDER OF THE CHARACTER STRING.  LPIECE
C                       SHOULD BE SET TO LWRAP OR LENMSG+1-NEXTC,
C                       WHICHEVER IS LESS.
C
C       LPIECE .EQ. 1   THE NEW LINE SENTINEL STARTS AT MESSG(NEXTC:
C                       NEXTC).  LPIECE IS EFFECTIVELY ZERO, AND WE
C                       PRINT NOTHING TO AVOID PRODUCING UNNECESSARY
C                       BLANK LINES.  THIS TAKES CARE OF THE SITUATION
C                       WHERE THE LIBRARY ROUTINE HAS A MESSAGE OF
C                       EXACTLY 72 CHARACTERS FOLLOWED BY A NEW LINE
C                       SENTINEL FOLLOWED BY MORE CHARACTERS.  NEXTC
C                       SHOULD BE INCREMENTED BY 2.
C
C       LPIECE .GT. LWRAP+1  REDUCE LPIECE TO LWRAP.
C
C       ELSE            THIS LAST CASE MEANS 2 .LE. LPIECE .LE. LWRAP+1
C                       RESET LPIECE = LPIECE-1.  NOTE THAT THIS
C                       PROPERLY HANDLES THE END CASE WHERE LPIECE .EQ.
C                       LWRAP+1.  THAT IS, THE SENTINEL FALLS EXACTLY
C                       AT THE END OF A LINE.
C
      NEXTC = 1
   50 LPIECE = INDEX(MESSG(NEXTC:LENMSG), NEWLIN)
      IF (LPIECE .EQ. 0) THEN
C
C       THERE WAS NO NEW LINE SENTINEL FOUND.
C
         IDELTA = 0
         LPIECE = MIN(LWRAP, LENMSG+1-NEXTC)
         IF (LPIECE .LT. LENMSG+1-NEXTC) THEN
            DO 52 I=LPIECE+1,2,-1
               IF (MESSG(NEXTC+I-1:NEXTC+I-1) .EQ. ' ') THEN
                  LPIECE = I-1
                  IDELTA = 1
                  GOTO 54
               ENDIF
   52       CONTINUE
         ENDIF
   54    CBUFF(LPREF+1:LPREF+LPIECE) = MESSG(NEXTC:NEXTC+LPIECE-1)
         NEXTC = NEXTC + LPIECE + IDELTA
      ELSEIF (LPIECE .EQ. 1) THEN
C
C       WE HAVE A NEW LINE SENTINEL AT MESSG(NEXTC:NEXTC+1).
C       DON'T PRINT A BLANK LINE.
C
         NEXTC = NEXTC + 2
         GO TO 50
      ELSEIF (LPIECE .GT. LWRAP+1) THEN
C
C       LPIECE SHOULD BE SET DOWN TO LWRAP.
C
         IDELTA = 0
         LPIECE = LWRAP
         DO 56 I=LPIECE+1,2,-1
            IF (MESSG(NEXTC+I-1:NEXTC+I-1) .EQ. ' ') THEN
               LPIECE = I-1
               IDELTA = 1
               GOTO 58
            ENDIF
   56    CONTINUE
   58    CBUFF(LPREF+1:LPREF+LPIECE) = MESSG(NEXTC:NEXTC+LPIECE-1)
         NEXTC = NEXTC + LPIECE + IDELTA
      ELSE
C
C       IF WE ARRIVE HERE, IT MEANS 2 .LE. LPIECE .LE. LWRAP+1.
C       WE SHOULD DECREMENT LPIECE BY ONE.
C
         LPIECE = LPIECE - 1
         CBUFF(LPREF+1:LPREF+LPIECE) = MESSG(NEXTC:NEXTC+LPIECE-1)
         NEXTC  = NEXTC + LPIECE + 2
      ENDIF
C
C       PRINT
C
      DO 60 I=1,NUNIT
         WRITE(IU(I), '(A)') CBUFF(1:LPREF+LPIECE)
   60 CONTINUE
C
      IF (NEXTC .LE. LENMSG) GO TO 50
      RETURN
      END
*DECK XERSVE
      SUBROUTINE XERSVE (LIBRAR, SUBROU, MESSG, KFLAG, NERR, LEVEL,
     +   ICOUNT)
C***BEGIN PROLOGUE  XERSVE
C***SUBSIDIARY
C***PURPOSE  Record that an error has occurred.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3
C***TYPE      ALL (XERSVE-A)
C***KEYWORDS  ERROR, XERROR
C***AUTHOR  Jones, R. E., (SNLA)
C***DESCRIPTION
C
C *Usage:
C
C        INTEGER  KFLAG, NERR, LEVEL, ICOUNT
C        CHARACTER * (len) LIBRAR, SUBROU, MESSG
C
C        CALL XERSVE (LIBRAR, SUBROU, MESSG, KFLAG, NERR, LEVEL, ICOUNT)
C
C *Arguments:
C
C        LIBRAR :IN    is the library that the message is from.
C        SUBROU :IN    is the subroutine that the message is from.
C        MESSG  :IN    is the message to be saved.
C        KFLAG  :IN    indicates the action to be performed.
C                      when KFLAG > 0, the message in MESSG is saved.
C                      when KFLAG=0 the tables will be dumped and
C                      cleared.
C                      when KFLAG < 0, the tables will be dumped and
C                      not cleared.
C        NERR   :IN    is the error number.
C        LEVEL  :IN    is the error severity.
C        ICOUNT :OUT   the number of times this message has been seen,
C                      or zero if the table has overflowed and does not
C                      contain this message specifically.  When KFLAG=0,
C                      ICOUNT will not be altered.
C
C *Description:
C
C   Record that this error occurred and possibly dump and clear the
C   tables.
C
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  I1MACH, XGETUA
C***REVISION HISTORY  (YYMMDD)
C   800319  DATE WRITTEN
C   861211  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900413  Routine modified to remove reference to KFLAG.  (WRB)
C   900510  Changed to add LIBRARY NAME and SUBROUTINE to calling
C           sequence, use IF-THEN-ELSE, make number of saved entries
C           easily changeable, changed routine name from XERSAV to
C           XERSVE.  (RWC)
C   910626  Added LIBTAB and SUBTAB to SAVE statement.  (BKS)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  XERSVE
      PARAMETER (LENTAB=10)
      INTEGER LUN(5)
      CHARACTER*(*) LIBRAR, SUBROU, MESSG
      CHARACTER*8  LIBTAB(LENTAB), SUBTAB(LENTAB), LIB, SUB
      CHARACTER*20 MESTAB(LENTAB), MES
      DIMENSION NERTAB(LENTAB), LEVTAB(LENTAB), KOUNT(LENTAB)
      SAVE LIBTAB, SUBTAB, MESTAB, NERTAB, LEVTAB, KOUNT, KOUNTX, NMSG
      DATA KOUNTX/0/, NMSG/0/
C***FIRST EXECUTABLE STATEMENT  XERSVE
C
      IF (KFLAG.LE.0) THEN
C
C        Dump the table.
C
         IF (NMSG.EQ.0) RETURN
C
C        Print to each unit.
C
         CALL XGETUA (LUN, NUNIT)
         DO 20 KUNIT = 1,NUNIT
            IUNIT = LUN(KUNIT)
            IF (IUNIT.EQ.0) IUNIT = I1MACH(4)
C
C           Print the table header.
C
            WRITE (IUNIT,9000)
C
C           Print body of table.
C
            DO 10 I = 1,NMSG
               WRITE (IUNIT,9010) LIBTAB(I), SUBTAB(I), MESTAB(I),
     *            NERTAB(I),LEVTAB(I),KOUNT(I)
   10       CONTINUE
C
C           Print number of other errors.
C
            IF (KOUNTX.NE.0) WRITE (IUNIT,9020) KOUNTX
            WRITE (IUNIT,9030)
   20    CONTINUE
C
C        Clear the error tables.
C
         IF (KFLAG.EQ.0) THEN
            NMSG = 0
            KOUNTX = 0
         ENDIF
      ELSE
C
C        PROCESS A MESSAGE...
C        SEARCH FOR THIS MESSG, OR ELSE AN EMPTY SLOT FOR THIS MESSG,
C        OR ELSE DETERMINE THAT THE ERROR TABLE IS FULL.
C
         LIB = LIBRAR
         SUB = SUBROU
         MES = MESSG
         DO 30 I = 1,NMSG
            IF (LIB.EQ.LIBTAB(I) .AND. SUB.EQ.SUBTAB(I) .AND.
     *         MES.EQ.MESTAB(I) .AND. NERR.EQ.NERTAB(I) .AND.
     *         LEVEL.EQ.LEVTAB(I)) THEN
                  KOUNT(I) = KOUNT(I) + 1
                  ICOUNT = KOUNT(I)
                  RETURN
            ENDIF
   30    CONTINUE
C
         IF (NMSG.LT.LENTAB) THEN
C
C           Empty slot found for new message.
C
            NMSG = NMSG + 1
            LIBTAB(I) = LIB
            SUBTAB(I) = SUB
            MESTAB(I) = MES
            NERTAB(I) = NERR
            LEVTAB(I) = LEVEL
            KOUNT (I) = 1
            ICOUNT    = 1
         ELSE
C
C           Table is full.
C
            KOUNTX = KOUNTX+1
            ICOUNT = 0
         ENDIF
      ENDIF
      RETURN
C
C     Formats.
C
 9000 FORMAT ('0          ERROR MESSAGE SUMMARY' /
     +   ' LIBRARY    SUBROUTINE MESSAGE START             NERR',
     +   '     LEVEL     COUNT')
 9010 FORMAT (1X,A,3X,A,3X,A,3I10)
 9020 FORMAT ('0OTHER ERRORS NOT INDIVIDUALLY TABULATED = ', I10)
 9030 FORMAT (1X)
      END
*DECK XGETUA
      SUBROUTINE XGETUA (IUNITA, N)
C***BEGIN PROLOGUE  XGETUA
C***PURPOSE  Return unit number(s) to which error messages are being
C            sent.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XGETUA-A)
C***KEYWORDS  ERROR, XERROR
C***AUTHOR  Jones, R. E., (SNLA)
C***DESCRIPTION
C
C     Abstract
C        XGETUA may be called to determine the unit number or numbers
C        to which error messages are being sent.
C        These unit numbers may have been set by a call to XSETUN,
C        or a call to XSETUA, or may be a default value.
C
C     Description of Parameters
C      --Output--
C        IUNIT - an array of one to five unit numbers, depending
C                on the value of N.  A value of zero refers to the
C                default unit, as defined by the I1MACH machine
C                constant routine.  Only IUNIT(1),...,IUNIT(N) are
C                defined by XGETUA.  The values of IUNIT(N+1),...,
C                IUNIT(5) are not defined (for N .LT. 5) or altered
C                in any way by XGETUA.
C        N     - the number of units to which copies of the
C                error messages are being sent.  N will be in the
C                range from 1 to 5.
C
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  J4SAVE
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  XGETUA
      DIMENSION IUNITA(5)
C***FIRST EXECUTABLE STATEMENT  XGETUA
      N = J4SAVE(5,0,.FALSE.)
      DO 30 I=1,N
         INDEX = I+4
         IF (I.EQ.1) INDEX = 3
         IUNITA(I) = J4SAVE(INDEX,0,.FALSE.)
   30 CONTINUE
      RETURN
      END
*DECK XSETF
      SUBROUTINE XSETF (KONTRL)
C***BEGIN PROLOGUE  XSETF
C***PURPOSE  Set the error control flag.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3A
C***TYPE      ALL (XSETF-A)
C***KEYWORDS  ERROR, XERROR
C***AUTHOR  Jones, R. E., (SNLA)
C***DESCRIPTION
C
C     Abstract
C        XSETF sets the error control flag value to KONTRL.
C        (KONTRL is an input parameter only.)
C        The following table shows how each message is treated,
C        depending on the values of KONTRL and LEVEL.  (See XERMSG
C        for description of LEVEL.)
C
C        If KONTRL is zero or negative, no information other than the
C        message itself (including numeric values, if any) will be
C        printed.  If KONTRL is positive, introductory messages,
C        trace-backs, etc., will be printed in addition to the message.
C
C              ABS(KONTRL)
C        LEVEL        0              1              2
C        value
C          2        fatal          fatal          fatal
C
C          1     not printed      printed         fatal
C
C          0     not printed      printed        printed
C
C         -1     not printed      printed        printed
C                                  only           only
C                                  once           once
C
C***REFERENCES  R. E. Jones and D. K. Kahaner, XERROR, the SLATEC
C                 Error-handling Package, SAND82-0800, Sandia
C                 Laboratories, 1982.
C***ROUTINES CALLED  J4SAVE, XERMSG
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   890531  Changed all specific intrinsics to generic.  (WRB)
C   890531  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900510  Change call to XERRWV to XERMSG.  (RWC)
C   920501  Reformatted the REFERENCES section.  (WRB)
C***END PROLOGUE  XSETF
      CHARACTER *8 XERN1
C***FIRST EXECUTABLE STATEMENT  XSETF
      IF (ABS(KONTRL) .GT. 2) THEN
         WRITE (XERN1, '(I8)') KONTRL
         CALL XERMSG ('SLATEC', 'XSETF',
     *      'INVALID ARGUMENT = ' // XERN1, 1, 2)
         RETURN
      ENDIF
C
      JUNK = J4SAVE(2,KONTRL,.TRUE.)
      RETURN
      END
c----------------------------------------------------------------------
      subroutine PDFVARS(ldb,io,mdisp,icode,sigw,wstar,ustar,
     &                   bidsq,fb,zi,hs,u)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 971107                PDFVARS
c                D. Strimaitis,   Earth Tech
c
c --- PURPOSE:  Computes variables associated with the PDF formulation
c               for the convective boundary layer (CBL).  Currently
c               based on Weil (JAM, 1996 -- draft)
c
c --- INPUTS:
c
c               LDB - logical - Debug output generated when .TRUE.
c                IO - integer - Unit number for output
c             MDISP - integer - Dispersion code (see /PUFF/)
c             ICODE - integer - Puff code  (see /PUFF/)
c              SIGW - real    - Sigma-w (m/s)
c             WSTAR - real    - Convective velocity scale w* (m/s)
c             USTAR - real    - Shear velocity scale u* (m/s)
c             BIDSQ - real    - Sigma**2 due to BID (m2)
c                FB - real    - Plume buoyancy flux (m4/s3)
c                ZI - real    - Mixed layer ht (m)
c                HS - real    - Source ht (m)
c                 U - real    - Effective advection speed (m/s)
c
c
c --- OUTPUTS:
c
c     Common block /PDF/ variables:
c              LPDF - logical - PDF computation active when .TRUE.
c             SWUPF - real    - Updraft (sigma-w / full sigma-w)**2
c             SWDNF - real    - Downdraft (sigma-w / full sigma-w)**2
c             SZUPB - real    - Updraft BID**2 term (m2)
c             SZDNB - real    - Downdraft BID**2 term (m2)
c               WUP - real    - Updraft w (indirect path)(m/s)
c               WDN - real    - Downdraft w (direct path)(m/s)
c              WTUP - real    - Updraft path weight (indirect path)
c              WTDN - real    - Downdraft path weight (direct path)
c              RISQ - real    - Initial plume radius (squared) at CBL
c                               top (m^2)
c               RYZ - real    - Growth rate of elliptical plume
c                               crossection (m**2/s**2)
c             DHFAC - real    - Effective rise factor, where effective
c                               rise given by t*dhfac/SQRT(risq+ryz*t^2)
c
c --- PDFVARS called by:  COMP
c --- PDFVARS calls:      none
c----------------------------------------------------------------------
      include 'pdf.puf'

      logical ldb

      data zero/0.0/,half/0.5/,one/1.0/,two/2.0/,three/3.0/,four/4.0/

c --- Set sigmaw/w ratio to 2.0
      data r/2.0/

c --- Set parameters for lofting rise [rconst=(0.1*(2.3)^1.5)/4]
      data alpha/1.4/, rconst/0.087203/, beta2/0.4/

c --- Initialize /PDF/ variables only when turb option is used, and
c --- w* is positive, and puff is Gaussian and in Mixed Layer
      lpdf=.FALSE.
      if(mdisp.EQ.1 .OR. mdisp.EQ.2 .OR. mdisp.EQ.5) then
         if(wstar.GT.zero .AND. MOD(icode,10).EQ.1) lpdf=.TRUE.
      endif
      if(.not.LPDF) return

c --- Skewness designed to go to zero as w* goes to zero --- Use bulk
c --- turbulence properties of the CBL rather than profiled or measured
c --- sigma-w:  sigma-w = SQRT( 1.2 ustar^2 + 0.31 wstar^2)
c --- This assures skewness lies between 0.0 and 0.6
      swskew=SQRT(1.2*ustar**2 + 0.31*wstar**2)
      skew=0.105*(wstar/swskew)**3

c --- Compute constants
      gam2=one+r**2
      gam1=gam2/(one+three*(gam2-one))
      g1skew=gam1*skew
      rdcl=SQRT(g1skew**2+four/gam2)

c --- Compute updraft and downdraft velocity (scale with local sigma-w)
      wup=half*sigw*(g1skew+rdcl)
      wdn=half*sigw*(g1skew-rdcl)

c --- Compute updraft and downdraft sigma-w scaling factors (squared)
      swupf=(r*wup/sigw)**2
      swdnf=(-r*wdn/sigw)**2

c --- Compute updraft and downdraft BID**2 adjustment to sigma-z
      szupb=bidsq*(one-swupf)
      szdnb=bidsq*(one-swdnf)

c --- Compute updraft and downdraft path weight
      wtup=wdn/(wdn-wup)
      wtdn=one-wtup

c --- Establish parameters for computing the apparent rise ht that
c --- "delays" the reflection of the indirect path from the lid to
c --- simulate tendency of buoyant plumes to "stick" at top of layer

c --- Initial plume radius (squared) at CBL top
      risq=(beta2*(zi-hs))**2

c --- Growth rate of elliptical plume crossection (multiply by t**2)
      ryz=rconst*wstar**2

c --- Effective rise factor
      dhfac=SQRT(two*fb*zi/(alpha*u))

      if(LDB) then
         write(io,*) 'PDFVARS ------------------'
         write(io,*) 'Inputs:'
         write(io,*) ' sw,w*,BIDsq = ',sigw,wstar,bidsq
         write(io,*) ' Fb,Hs,Zi,U  = ',fb,hs,zi,u
         write(io,*) 'Outputs:'
         write(io,*) ' risq,ryz,dhfac= ',risq,ryz,dhfac
         write(io,*) ' skew,w+,w-    = ',skew,wup,wdn
         write(io,*) ' swf+,swf-     = ',swupf,swdnf
         write(io,*) ' szb+,szb-     = ',szupb,szdnb
         write(io,*) ' wt+,wt-       = ',wtup,wtdn
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine PDFPATH(zp,zi,t)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050128                PDFPATH
c                D. Strimaitis,   Earth Tech
c
c --- PURPOSE:  Computes the vertical distribution factor for the
c               combined direct and indirect path of the PDF formulation
c
c --- UPDATES
c --- V5.0-V5.725   050128  (DGS): Add test for a zero lofting rise
c                                  adjustment to avoid a potential
c                                  attempt to divide by zero.
c
c --- INPUTS:
c
c                ZP - real    - Receptor-specific puff ht (m)
c                ZI - real    - Mixed layer ht (m)
c                 T - real    - Time since release (s)
c
c     Common block /PDF/ variables:
c               WUP - real    - Updraft w (indirect path)(m/s)
c               WDN - real    - Downdraft w (direct path)(m/s)
c              RISQ - real    - Initial plume radius (squared) at CBL
c                               top (m^2)
c               RYZ - real    - Growth rate of elliptical plume
c                               crossection (m**2/s**2)
c             DHFAC - real    - Effective rise factor, where effective
c                               rise given by t*dhfac/SQRT(risq+ryz*t^2)
c
c --- OUTPUTS:
c
c     Common block /PDF/ variables:
c               ZUP - real    - Updraft puff ht (m)
c               ZDN - real    - Downdraft puff ht (m)
c
c --- PDFPATH called by:  CALCPF, CALCSL, AREAINT
c --- PDFPATH calls:      none
c----------------------------------------------------------------------
      include 'pdf.puf'

      logical losci
      data losci/.FALSE./

      data two/2.0/
      data zero/0.0/, half/0.5/, one/1.0/
      data pi/3.1415927/, piby2/1.5707963/

      twozi=two*zi
      ziby2=half*zi


c --- Downdraft path
c -------------------------------------------

c --- Set ht ignoring reflection from surface (wdn<0)
      z1=AMIN1(zi,(zp+t*wdn))

c --- Bouncing-ball mapping
      zdn=AMOD(ABS(z1),twozi)
      if(zdn.GT.zi) zdn=twozi-zdn

      if(losci) then
c ---    Oscillator mapping (Future Developments)
         if(z1.LT.zero) then
            zdn=ziby2*(one+SIN(-piby2-pi*z1/zi))
         else
            zdn=z1
         endif
      endif


c --- Updraft path
c -------------------------------------------

c --- Set ht ignoring possible lofting (wup>0)
      z1=zp+t*wup

c --- Set lofting rise adjustment here
c --- delh=t*dhfac/SQRT(risq+ryz*t**2)
      xdum1=t*dhfac
      xdum2=risq+ryz*t**2
      if(xdum1.LE.0.0) then
         delh=0.0
      elseif(xdum2.LE.0.0) then
         write(*,*)'PDFPATH ERROR:  Illegal Calculation'
         write(*,*)'risq,ryz,t = ',risq,ryz,t
         write(*,*)'risq+ryz*t**2 = ',xdum2
         stop
      else
         delh=xdum1/SQRT(xdum2)
      endif

c --- Add lofting adjustment only if z1 exceeds zi
      if(z1.GT.zi) z1=AMAX1(zi,(z1-delh))

c --- Bouncing-ball mapping
      zup=AMOD(z1,twozi)
      if(zup.GT.zi) zup=twozi-zup

      if(losci) then
c ---    Oscillator mapping (Future Developments)
         if(z1.GT.zi) then
            zup=ziby2*(one+COS(pi*(z1-zi)/zi))
         else
            zup=z1
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine restartq
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520               RESTARTQ
c ---            D. Strimaitis
c
c --- PURPOSE:  Read and check (QA) header records of the RESTART file
c
c --- UPDATES
c --- V6.22-V6.261  080520  (DGS): Replace source-ordered tabulations
c                                  with puff-ordered tabulations used
c                                  for the /SRCTAB/ arrays
c                                  (Dataset 3.1 format)
c                                  (HALT if older Dataset is read)
c --- V6.1-V6.22    070921  (DGS): Introduce dataset name and version
c                                  record
c                                  Add source tabulations stored for
c                                  previous met periods, resolved to
c                                  seconds
c                                  (Dataset 2.1 format)
c --- V6.1-V6.21    070801  (DGS): Relax mismatch in code version/level
c                                  to a warning (add WARNING pathway)
c --- V5.7-V6.1     050915  (DGS): resolve times to the second and
c                                  use explicit begin-time/end-time
c --- V5.5-V5.7     030402  (DGS): Add list file unit to JULDAY, INCR
c --- V5.3-V5.4     000602  (DGS): NVL2 replaces NX4,NY4
c ---               000602  (DGS): add message to "stop"
c
c --- INPUTS:
c
c    Common block /DATASET/ variables:
c         VERREST
c    Common Block /GEN/ variables:
c         IBDATHR, IBSEC, NSPEC
c
c    --- For QA
c    Common Block /QA/ variables:
c         VER, LEVEL
c    Common block /AR1/ variables:
c         NAR1
c    Common block /AR2/ variables:
c         NAR2
c    Common block /LN1/ variables:
c         NLINES
c    Common block /LN2/ variables:
c         NLN2
c    Common block /PT1/ variables:
c         NPT1
c    Common block /PT2/ variables:
c         NPT2
c    Common block /VOL1/ variables:
c         NVL1
c    Common block /VOL2/ variables:
c         NVL2
c
c    Parameters:
c         MXPUFF, IO3, IO6
c
c --- OUTPUT:
c
c    Common block /PUFF/ variables:
c         npuffs
c    Common block /RESTART/ variables:
c         rstrtnam,rstrtver,rstrtmod,
c
c --- RESTARTQ called by:  COMP
c --- RESTARTQ calls:      none
c----------------------------------------------------------------------
      include 'params.puf'

      include 'dataset.puf'
      include 'gen.puf'
      include 'puff.puf'
      include 'restarthd.puf'

      include 'ar1.puf'
      include 'ar2.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'qa.puf'
      include 'vol1.puf'
      include 'vol2.puf'

      character*12 ver0,level0
      logical problem, warning

      problem=.FALSE.
      warning=.FALSE.

      if(verrest.EQ.'3.1             ') then
c ---    Dataset 3.1 with source tables for each puff
c ---    Header 1 (dataset record)
         read(io3) rstrtnam,rstrtver,rstrtmod
c ---    Header 2 (run info record)
         read(io3) ver0,level0,npuffs0,nspec0,ndathr0,nsec0,
     &             nar10,nar20,nln10,nln20,npt10,npt20,nvl10,nvl20
      elseif(verrest.EQ.'2.1             ') then
c ---    Dataset 2.1 with source tables from previous met periods
c ---    Header 1 (dataset record)
         read(io3) rstrtnam,rstrtver,rstrtmod
c ---    Header 2 (run info record)
         read(io3) ver0,level0,npuffs0,nspec0,ndathr0,nsec0,
     &             nar10,nar20,nln10,nln20,npt10,npt20,nvl10,nvl20
c ---    Header 3 (source table info record)
         read(io3) ntabpt1,nmetpt1,nsrcpt1,
     &             ntabpt2,nmetpt2,nqempt2,nsrcpt2,
     &             ntabar1,nmetar1,nsrcar1,
     &             ntabar2,nmetar2,nqemar2,nsrcar2,
     &             ntabln1,nmetln1,nsrcln1,
     &             ntabln2,nmetln2,nqemln2,nsrcln2,
     &             ntabvl1,nmetvl1,nsrcvl1,
     &             ntabvl2,nmetvl2,nqemvl2,nsrcvl2
         problem=.TRUE.
      elseif(verrest.EQ.'1.0             ' .OR.
     &       verrest.EQ.'1.6             ') then
c ---    Header 1 (run info record)
         read(io3) ver0,level0,npuffs0,nspec0,ndathr0,nsec0,
     &             nar10,nar20,nln10,nln20,npt10,npt20,nvl10,nvl20
c         if(nln10.GT.0 .OR. nln20.GT.0) then
c            write(io6,*)
c            write(io6,*)'FATAL ERROR in RESTARTQ -- obsolete version'
c            write(io6,*)'Source tables for previous met periods are'
c            write(io6,*)'needed for buoyant line sources'
c            write(io6,*)'Expected VERREST = 2.0'
c            write(io6,*)'Found    VERREST = ',verrest
c            write(*,*)
c            stop 'Halted in RESTARTQ -- see list file.'
c         endif
         problem=.TRUE.
      else
         write(io6,*)
         write(io6,*)'FATAL ERROR in RESTARTQ -- bad version marker'
         write(io6,*)'Expected VERREST = 1.0, 1.6, 2.1 or 3.1'
         write(io6,*)'Found    VERREST = ',verrest
         write(*,*)
         stop 'Halted in RESTARTQ -- see list file.'
      endif

c --- Stop now if the dataset is not current
      if(problem) then
         write(io6,*)
         write(io6,*)'FATAL ERROR in RESTARTQ -- obsolete version'
         write(io6,*)'Source tables are needed for each puff'
         write(io6,*)'Expected VERREST = 3.1'
         write(io6,*)'Found    VERREST = ',verrest
         write(*,*)
         stop 'Halted in RESTARTQ -- see list file.'
      endif

c --- Check against variables for current run
      if(ver.NE.ver0 .OR. level.NE.level0) warning=.TRUE.
      if(mxpuff.LE.npuffs0 .OR. nspec.NE.nspec0) problem=.TRUE.
      if(nar1.NE.nar10 .OR. nar2.NE.nar20) problem=.TRUE.
      if(nlines.NE.nln10 .OR. nln2.NE.nln20) problem=.TRUE.
      if(npt1.NE.npt10 .OR. npt2.NE.npt20) problem=.TRUE.
      if(nvl1.NE.nvl10 .OR. nvl2.NE.nvl20) problem=.TRUE.

c --- Compare ending date-time stamp with beginning date-time of run
      if(ibdathr.NE.ndathr0) problem=.TRUE.
      if(ibsec.NE.nsec0) problem=.TRUE.

      if(warning) then
c ---    Report data and continue
         write(io6,*)
         write(io6,*)'WARNING: Header difference in Restart File!'
         write(io6,*)' ---    Run Data   /  Restart Data'
         write(io6,*)'Version: ',ver,ver0
         write(io6,*)'Level  : ',level,level0
         write(io6,*)
         write(*,*)
         write(*,*) 'WARNING reported in RESTARTQ -- see list file.'
      endif

      if(problem) then
c ---    Report data and quit
         write(io6,*)
         write(io6,*)'FATAL Problem in Restart File!'
         write(io6,*)' ---              Run Data    /    Restart Data'
         write(io6,*)'Version: ',ver,ver0
         write(io6,*)'Level  : ',level,level0
         write(io6,*)'Species: ',nspec,nspec0
         write(io6,*)'Npuff  : ',mxpuff,npuffs0
         write(io6,*)'DateHr : ',ibdathr,ndathr0
         write(io6,*)'Seconds: ',ibsec,nsec0
         write(io6,*)'Areas1 : ',nar1,nar10
         write(io6,*)'Areas2 : ',nar2,nar20
         write(io6,*)'Lines1 : ',nlines,nln10
         write(io6,*)'Lines2 : ',nln2,nln20
         write(io6,*)'Points1: ',npt1,npt10
         write(io6,*)'Points2: ',npt2,npt20
         write(io6,*)'Volume1: ',nvl1,nvl10
         write(io6,*)'Volume2: ',nvl2,nvl20
         write(io6,*)
         write(*,*)
         stop 'Halted in RESTARTQ -- see list file.'
      else
         npuffs=npuffs0
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine restarto
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520               RESTARTO
c ---            D. Strimaitis
c
c --- PURPOSE:  Output all data needed to restart CALPUFF with
c               current puffs in the domain
c
c --- UPDATES
c --- V6.22-V6.261  080520  (DGS): Replace source-ordered tabulations
c                                  with puff-ordered tabulations used
c                                  for the /SRCTAB/ arrays
c                                  (Dataset 3.1 format)
c --- V6.1-V6.22    070921  (DGS): Introduce dataset name and version
c                                  record
c                                  Add source tabulations stored for
c                                  previous met periods
c                                  (Dataset 2.1 format)
c --- V5.722-V6.1   050915  (DGS): Resolve times to the second and use
c                                  explicit begin-time/end-time format
c                           (DGS): Add IEMSTEP array to /PUFF/
c --- V5.72-V5.722  040610  (DGS): Fix editing error introduced in 
c                                  V5.72 (IPUFID truncated to PUFID).
c                                  Use the /puff/ and /slug/ include
c                                  files.
c --- V5.71-V5.72   031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.5-V5.71    030528  (DGS): Add RESTART notice to list file each
c                                  time a restart file is rewritten
c --- V5.4-V5.5     010730  (DGS): SYSRC0, SZSRC0 arrays added
c --- V5.2-V5.4     000602  (DGS): NVL2 replaces NX4,NY4
c ---               000602  (DGS): add message to "stop"
c --- V5.1-V5.2     991104  (JSS): Error messages written to list
c                                  file as well as to screen
c --- V5.0-V5.0     980807  (DGS): no data records written if NPUFFS=0
c                   980615  (DGS): IPUFID, IPUFCD written as integers
c                                  (order changes also)
c                   980515  (DGS): ZITIBL array added
c
c --- INPUTS:
c
c    Common Block /DATEHR/ variables:
c         nsecb,ndathrb,nsece,ndathre
c    Common Block /FILNAME/ variables:
c         RSTARTE
c    Common Block /GEN/ variables:
c         NSPEC
c    Common block /PUFF/ variables:
c         all variables
c    Common block /SLUG/ variables:
c         all variables
c
c    Common Block /QA/ variables:
c         VER, LEVEL
c    Common block /AR1/ variables:
c         NAR1
c    Common block /AR2/ variables:
c         NAR2
c    Common block /LN1/ variables:
c         NLINES
c    Common block /LN2/ variables:
c         NLN2
c    Common block /PT1/ variables:
c         NPT1
c    Common block /PT2/ variables:
c         NPT2
c    Common block /VOL1/ variables:
c         NVL1
c    Common block /VOL2/ variables:
c         NVL2
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c    Parameters:
c         MXPUFF, MXSPEC, MXRISE, IO4
c
c --- OUTPUT:
c              none
c
c --- RESTARTO called by:  COMP
c --- RESTARTO calls:      ROLLDN, WRTI1D, WRTR1D, WRTR2D, WRTR3D,
c                          SRCTABIN
c----------------------------------------------------------------------
      include 'params.puf'

      include 'datehr.puf'
      include 'filnam.puf'
      include 'gen.puf'

c --- Use include file for /puff/ rather than explicit list here
c *** Make sure this sub is updated WHENEVER /puff/ is altered ***
      include 'puff.puf'

c --- Use include file for /slug/ rather than explicit list here
c *** Make sure this sub is updated WHENEVER /slug/ is altered ***
      include 'slug.puf'

      include 'qa.puf'
      include 'ar1.puf'
      include 'ar2.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'vol1.puf'
      include 'vol2.puf'
      include 'srctab.puf'

      real xbuf(mxspec,mxpuff), xbuf3(3,2,mxpuff)

      character*16 rstrtnam,rstrtver
      character*64 rstrtmod
      character*8 clabel,blank8

      data rstrtnam/'RESTART.DAT     '/
      data rstrtver/'3.1             '/
      data blank8/'        '/

      rstrtmod(1:40)='Puff arrays and Source tables for each  '
      rstrtmod(41:64)='puff                    '

c --- Save on disk space by removing puffs that are off the
c --- grid and "roll down" arrays: np0 is total number of puffs
c --- (new + npuffs = npuffs);  npuffs is updated in ROLLDN
c --- (this also applies to the DA file of tabulated arrays)
      np0=npuffs
      call ROLLDN(np0)

c --- Open restart output file (latest information overwrites)
      open(io4,file=rstarte,status='unknown',form='unformatted')

c --- Identify dataset and version (new for version 6.22)
      write(io4) rstrtnam,rstrtver,rstrtmod
c --- Write run specification record
      write(io4) ver,level,npuffs,nspec,ndathre,nsece,nar1,nar2,
     &           nlines,nln2,npt1,npt2,nvl1,nvl2

c --- Close file and return if puff arrays are empty
      if(npuffs.EQ.0) then
         close(io4)
         return
      elseif(npuffs.LT.0) then
c ---    Fatal error
         write(io6,*)'RESTARTO:  FATAL ERROR FOUND'
         write(io6,*)'   Number of puffs after roll-down = ',npuffs
         write(*,*)
         stop 'Halted in RESTARTO -- see list file.'
      endif

c --- Write /PUFF/ data, one variable for all puffs on one record
c ---------------------------------------------------------------

c --- 1D integer arrays
c ---------------------

      clabel=blank8
      clabel='irlsnum'
      call wrti1d(io4,irlsnum,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='isrcnum'
      call wrti1d(io4,isrcnum,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='isrctyp'
      call wrti1d(io4,isrctyp,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='ipufcd'
      call wrti1d(io4,ipufcd,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='isplit'
      call wrti1d(io4,isplit,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='iemstep'
      call wrti1d(io4,iemstep,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='idw0'
      call wrti1d(io4,idw0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='istab0'
      call wrti1d(io4,istab0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='iru0'
      call wrti1d(io4,iru0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

c --- 3D real arrays
c ------------------

      clabel=blank8
      clabel='tcon'
      call wrtr3d(io4,tcon,xbuf3,3,2,mxpuff,3,2,npuffs,
     &            clabel,ndathrb,nsecb,ndathre,nsece)

c --- 2D real arrays
c ------------------

      clabel=blank8
      clabel='qu'
      call wrtr2d(io4,qu,xbuf,mxspec,mxpuff,nspec,npuffs,
     &            clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='qm'
      call wrtr2d(io4,qm,xbuf,mxspec,mxpuff,nspec,npuffs,
     &            clabel,ndathrb,nsecb,ndathre,nsece)

c --- 1D real arrays
c ------------------

      clabel=blank8
      clabel='xpb'
      call wrtr1d(io4,xpb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='ypb'
      call wrtr1d(io4,ypb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zpb'
      call wrtr1d(io4,zpb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zimax'
      call wrtr1d(io4,zimax,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='ziold'
      call wrtr1d(io4,ziold,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zitibl'
      call wrtr1d(io4,zitibl,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sigyb'
      call wrtr1d(io4,sigyb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sigzb'
      call wrtr1d(io4,sigzb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='xtotb'
      call wrtr1d(io4,xtotb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='tmtotb'
      call wrtr1d(io4,tmtotb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zfinal'
      call wrtr1d(io4,zfinal,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='xfinal'
      call wrtr1d(io4,xfinal,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='bidfnl'
      call wrtr1d(io4,bidfnl,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='fb'
      call wrtr1d(io4,fb,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='fm'
      call wrtr1d(io4,fm,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='xbfin'
      call wrtr1d(io4,xbfin,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='xmfin'
      call wrtr1d(io4,xmfin,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zbfin'
      call wrtr1d(io4,zbfin,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zmfin'
      call wrtr1d(io4,zmfin,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='stipdw'
      call wrtr1d(io4,stipdw,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='elbase'
      call wrtr1d(io4,elbase,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='ht0'
      call wrtr1d(io4,ht0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='exitw0'
      call wrtr1d(io4,exitw0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='diam0'
      call wrtr1d(io4,diam0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='ws0'
      call wrtr1d(io4,ws0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sqrts0'
      call wrtr1d(io4,sqrts0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='srat0'
      call wrtr1d(io4,srat0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='temit0'
      call wrtr1d(io4,temit0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='hb0'
      call wrtr1d(io4,hb0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='hw0'
      call wrtr1d(io4,hw0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='heff20'
      call wrtr1d(io4,heff20,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sigv0'
      call wrtr1d(io4,sigv0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sigw0'
      call wrtr1d(io4,sigw0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='el0'
      call wrtr1d(io4,el0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='plexp0'
      call wrtr1d(io4,plexp0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zly0'
      call wrtr1d(io4,zly0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='r0'
      call wrtr1d(io4,r0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sysrc0'
      call wrtr1d(io4,sysrc0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='szsrc0'
      call wrtr1d(io4,szsrc0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='xshift0'
      call wrtr1d(io4,xshift0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sy0'
      call wrtr1d(io4,sy0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sz0'
      call wrtr1d(io4,sz0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)


c --- Write /SLUG/ data

c --- 1D real arrays
c ------------------

      clabel=blank8
      clabel='xpe'
      call wrtr1d(io4,xpe,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='ype'
      call wrtr1d(io4,ype,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='zpe'
      call wrtr1d(io4,zpe,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sigye'
      call wrtr1d(io4,sigye,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='sigze'
      call wrtr1d(io4,sigze,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='xtote'
      call wrtr1d(io4,xtote,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='tmtote'
      call wrtr1d(io4,tmtote,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)

      clabel=blank8
      clabel='speed0'
      call wrtr1d(io4,speed0,npuffs,clabel,ndathrb,nsecb,ndathre,nsece)


c --- Write records for puffs from sources with rise tables
c --- One data header record is written for each puff, but arrays are
c --- written only if they are not empty
c -------------------------------------------------------------------
      nullt=0
      nullw=0
      nullc=0
c --- Loop on all puffs regardless of whether tables exist, and
c --- use null record for source types without tables
      do ii=1,npuffs
         if(isrctyp(ii).EQ.3 .OR. isrctyp(ii).GT.6) then
c ---       No tables for control file Areas, all Volumes, and BCs
            write(io4) isrctyp(ii),isrcnum(ii),irlsnum(ii),
     &                 nullt,nullw,nullc
         else
c ---       Points, Buoyant Areas, Buoyant Lines
c ---       Place source tabulations for this puff into /SRCTAB/
            call SRCTABIN(ii,isrctyp(ii),isrcnum(ii),irlsnum(ii))
c ---       Write valid data to restart file
            write(io4) isrctyp(ii),isrcnum(ii),irlsnum(ii),
     &                 ntr,nwk,ncv
            if(ntr.GT.0) then
               clabel=blank8
               clabel='xtr'
               call wrtr1d(io4,xtr,ntr,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
               clabel=blank8
               clabel='ztr'
               call wrtr1d(io4,ztr,ntr,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
               if(isrctyp(ii).LE.4) then
c ---             Points and Areas
                  clabel=blank8
                  clabel='rtr'
                  call wrtr1d(io4,rtr,ntr,clabel,
     &                        ndathrb,nsecb,ndathre,nsece)
               endif
               if(isrctyp(ii).LE.2) then
c ---             Points
                  clabel=blank8
                  clabel='htr'
                  call wrtr1d(io4,htr,ntr,clabel,
     &                        ndathrb,nsecb,ndathre,nsece)
               endif
            endif
            if(nwk.GT.0) then
               clabel=blank8
               clabel='xwk'
               call wrtr1d(io4,xwk,nwk,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
               clabel=blank8
               clabel='sywk'
               call wrtr1d(io4,sywk,nwk,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
               clabel=blank8
               clabel='szwk'
               call wrtr1d(io4,szwk,nwk,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
               clabel=blank8
               clabel='drwk'
               call wrtr1d(io4,drwk,nwk,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
            endif
            if(ncv.GT.0) then
               clabel=blank8
               clabel='xcv'
               call wrtr1d(io4,xcv,ncv,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
               clabel=blank8
               clabel='sycv'
               call wrtr1d(io4,sycv,ncv,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
               clabel=blank8
               clabel='szcv'
               call wrtr1d(io4,szcv,ncv,clabel,
     &                     ndathrb,nsecb,ndathre,nsece)
            endif
         endif
      enddo

c --- Close file
      close(io4)

c --- Write message to list file
      write(io6,*)'--- Restart file written from: ',ndathrb,nsecb
      write(io6,*)'---                        to: ',ndathre,nsece

      return
      end
c----------------------------------------------------------------------
      subroutine restarti
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520               RESTARTI
c ---            D. Strimaitis
c
c --- PURPOSE:  Input all data needed to restart CALPUFF with
c               current puffs in the domain
c
c --- UPDATE
c --- V6.22-V6.261  080520  (DGS): Replace source-ordered tabulations
c                                  with puff-ordered tabulations used
c                                  for the /SRCTAB/ arrays
c                                  (Dataset 3.1 format)
c --- V6.114-V6.22  070921  (DGS): Introduce dataset name and version
c                                  record
c                                  Add source tabulations stored for
c                                  previous met periods
c                                  (Dataset 2.1 format)
c --- V6.1-V6.114   060725  (DGS): Fix editing typo that dropped first
c                                  character of array names iru0,stipdw
c                                  and ws0
c                                  Switch mtver from 0 to 1 (new format)
c --- V5.722-V6.1   050915  (DGS): Resolve times to the second and use
c                                  explicit begin-time/end-time format
c                           (DGS): Add IEMSTEP array to /PUFF/
c --- V5.72-V5.722  040610  (DGS): Fix editing error introduced in 
c                                  V5.72 (IPUFID truncated to PUFID).
c                                  Use the /puff/ and /slug/ include
c                                  files.
c --- V5.7-V5.72    031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.5-V5.7     030402  (DGS): Add list file unit to INCR
c --- V5.4-V5.5     010730  (DGS): SYSRC0, SZSRC0 arrays added
c --- V5.0-V5.0     990228a (DGS): add IEOF to RDR2D arguments
c --- V5.0-V5.0     981025  (DGS): Pad sy0,sz0 arguments to c*8
c --- V5.0-V5.0     980615  (DGS): IPUFID, IPUFCD read as integers
c                                  (order changes also)
c --- V5.0-V5.0     980515  (DGS): ZITIBL array added
c
c --- INPUTS:
c
c    Common Block /DATEHR/ variables:
c         NDATHRB, NSECB
c    Common Block /GEN/ variables:
c         NSPEC
c
c    Parameters:
c         MXPUFF, MXSPEC, MXRISE, IO3, IO6
c
c --- OUTPUT:
c
c    Common block /PUFF/ variables:
c         all variables
c    Common block /SLUG/ variables:
c         all variables
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c --- RESTARTI called by:  COMP
c --- RESTARTI calls:      RDI1D, RDR1D, RDR2D, RDR3D, RDQA, SRCTABOUT
c----------------------------------------------------------------------
      include 'params.puf'

      include 'datehr.puf'
      include 'gen.puf'
      include 'srctab.puf'

c --- Use include file for /puff/ rather than explicit list here
c *** Make sure this sub is updated WHENEVER /puff/ is altered ***
      include 'puff.puf'

c --- Use include file for /slug/ rather than explicit list here
c *** Make sure this sub is updated WHENEVER /slug/ is altered ***
      include 'slug.puf'

      real xbuf(mxspec,mxpuff), xbuf3(3,2,mxpuff)
      character*8 clabel

c --- Define time format flag for use in argument list
      data mtver/1/

c --- Read /PUFF/ data, one variable for all puffs on one record
c ---------------------------------------------------------------

c --- 1D integer arrays
c ---------------------

      call rdi1d(io3,mtver,irlsnum,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'irlsnum ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,isrcnum,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'isrcnum ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,isrctyp,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'isrctyp ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,ipufcd,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'ipufcd  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,isplit,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'isplit  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,iemstep,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'iemstep ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,idw0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'idw0    ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,istab0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'istab0   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdi1d(io3,mtver,iru0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'iru0     ',ndathrb,nsecb,clabel,idathre,isece)

c --- 3D real arrays
c ------------------

      call rdr3d(io3,tcon,xbuf3,3,2,mxpuff,3,2,npuffs,
     &            clabel,idathrb,isecb,idathre,isece)
      call rdqa(io6,'tcon    ',ndathrb,nsecb,clabel,idathre,isece)

c --- 2D real arrays
c ------------------

      call rdr2d(io3,mtver,qu,xbuf,mxspec,mxpuff,nspec,npuffs,
     &            clabel,idathrb,isecb,idathre,isece,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'RESTARTI: Unexpected EOF in restart file'
      endif
      call rdqa(io6,'qu      ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr2d(io3,mtver,qm,xbuf,mxspec,mxpuff,nspec,npuffs,
     &            clabel,idathrb,isecb,idathre,isece,ieof)
      if(ieof.EQ.1) then
         write(*,*)
         stop 'RESTARTI: Unexpected EOF in restart file'
      endif
      call rdqa(io6,'qm      ',ndathrb,nsecb,clabel,idathre,isece)

c --- 1D real arrays
c ------------------

      call rdr1d(io3,mtver,xpb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xpb     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,ypb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'ypb     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zpb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zpb     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zimax,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zimax   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,ziold,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'ziold   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zitibl,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zitibl  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sigyb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sigyb   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sigzb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sigzb   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,xtotb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xtotb   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,tmtotb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'tmtotb  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zfinal,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zfinal  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,xfinal,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xfinal  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,bidfnl,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'bidfnl  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,fb,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'fb      ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,fm,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'fm      ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,xbfin,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xbfin   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,xmfin,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xmfin   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zbfin,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zbfin   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zmfin,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zmfin   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,stipdw,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'stipdw  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,elbase,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'elbase  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,ht0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'ht0     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,exitw0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'exitw0  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,diam0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'diam0   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,ws0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'ws0     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sqrts0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sqrts0  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,srat0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'srat0   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,temit0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'temit0  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,hb0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'hb0     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,hw0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'hw0     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,heff20,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'heff20  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sigv0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sigv0   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sigw0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sigw0   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,el0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'el0     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,plexp0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'plexp0  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zly0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zly0    ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,r0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'r0      ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sysrc0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sysrc0  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,szsrc0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'szsrc0  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,xshift0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xshift0 ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sy0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sy0     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sz0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sz0     ',ndathrb,nsecb,clabel,idathre,isece)


c --- Read /SLUG/ data

c --- 1D real arrays
c ------------------

      call rdr1d(io3,mtver,xpe,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xpe     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,ype,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'ype     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,zpe,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'zpe     ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sigye,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sigye   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,sigze,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'sigze   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,xtote,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'xtote   ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,tmtote,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'tmtote  ',ndathrb,nsecb,clabel,idathre,isece)

      call rdr1d(io3,mtver,speed0,npuffs,clabel,
     &               idathrb,isecb,idathre,isece)
      call rdqa(io6,'speed0  ',ndathrb,nsecb,clabel,idathre,isece)


c --- Read source table data for each puff
c ----------------------------------------
c --- Loop on all puffs regardless of whether tables exist
      do ii=1,npuffs
         call ZEROTAB
         read(io3) ityp,isrc,irls,ntr,nwk,ncv
         if(ntr.GT.0) then
            call rdr1d(io3,mtver,xtr,ntr,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'xtr     ',ndathrb,nsecb,clabel,
     &                idathre,isece)
            call rdr1d(io3,mtver,ztr,ntr,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'ztr     ',ndathrb,nsecb,clabel,
     &                idathre,isece)
            if(ityp.LE.4) then
c ---          Points and Areas
               call rdr1d(io3,mtver,rtr,ntr,clabel,
     &                    idathrb,isecb,idathre,isece)
               call rdqa(io6,'rtr     ',ndathrb,nsecb,clabel,
     &                   idathre,isece)
            endif
            if(isrctyp(ii).LE.2) then
c ---          Points
               call rdr1d(io3,mtver,htr,ntr,clabel,
     &                    idathrb,isecb,idathre,isece)
               call rdqa(io6,'htr     ',ndathrb,nsecb,clabel,
     &                   idathre,isece)
            endif
         endif
         if(nwk.GT.0) then
            call rdr1d(io3,mtver,xwk,nwk,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'xwk     ',ndathrb,nsecb,clabel,
     &                idathre,isece)
            call rdr1d(io3,mtver,sywk,nwk,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'sywk    ',ndathrb,nsecb,clabel,
     &                idathre,isece)
            call rdr1d(io3,mtver,szwk,nwk,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'szwk    ',ndathrb,nsecb,clabel,
     &                idathre,isece)
            call rdr1d(io3,mtver,drwk,nwk,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'drwk    ',ndathrb,nsecb,clabel,
     &                idathre,isece)
         endif
         if(ncv.GT.0) then
            call rdr1d(io3,mtver,xcv,ncv,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'xcv     ',ndathrb,nsecb,clabel,
     &                idathre,isece)
            call rdr1d(io3,mtver,sycv,ncv,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'sycv    ',ndathrb,nsecb,clabel,
     &                idathre,isece)
            call rdr1d(io3,mtver,szcv,ncv,clabel,
     &                 idathrb,isecb,idathre,isece)
            call rdqa(io6,'szcv    ',ndathrb,nsecb,clabel,
     &                idathre,isece)
         endif
         call SRCTABOUT(ii,ityp,isrc,irls)

      enddo

c --- Close file
      close(io3)

      return
      end
c----------------------------------------------------------------------
      subroutine rdqa(io,alabel,ndathr,nsec,clabel,idathr,isec)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                   RDQA
c ---            D. Strimaitis  SRC
c
c --- PURPOSE:  Checks label and date-time of a RESTART record
c
c --- UPDATE
c --- V5.4-V6.1     050915  (DGS): resolve times to the second
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c            IO - integer       - Fortran unit number of output file
c        ALABEL - character     - Expected record label
c        NDATHR - integer       - Expected record date-time (ending)
c          NSEC - integer       - Expected record seconds (ending)
c        CLABEL - character     - Record label
c        IDATHR - integer       - Record date-time (ending)
c          ISEC - integer       - Record seconds (ending)
c
c
c --- OUTPUT:
c              none
c
c --- RDQA called by:  RESTARTI
c --- RDQA calls:      none
c----------------------------------------------------------------------
      character*8 alabel,clabel
      logical problem

      problem=.FALSE.

      if(alabel.NE.clabel) problem=.TRUE.
      if(ndathr.NE.idathr) problem=.TRUE.
      if(nsec.NE.isec) problem=.TRUE.

      if(problem) then
         write(io,*)
         write(io,*)
         write(io,*)
         write(io,*)'FATAL Problem with RESTART File'
         write(io,*)' --- record out of order or missing'
         write(io,*)'     Expected ',alabel,ndathr,nsec
         write(io,*)'     Found    ',clabel,idathr,isec
         write(*,*)
         stop 'Halted in RDQA -- see list file.'
      endif

      return
      end

c----------------------------------------------------------------------
      subroutine wrti1d(iomet,idat,nwords,clabel,ndathrb,nsecb,
     &                  ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF  Version: 6.262     Level: 050915                  WRTI1D
c ---          J. Scire, SRC
c
c --- PURPOSE:  Write "NWORDS" of a one-dimensional integer array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second and use
c                                  explicit begin-time/end-time format
c
c --- INPUTS:
c         IOMET - integer       - Fortran unit number of output file
c  IDAT(nwords) - integer array - Array to output
c        NWORDS - integer       - Number of words to write
c        CLABEL - character*8   - Variable name
c   NDATHR[B,E] - integer       - Date and time of data (YYYYJJJHH)
c     NSEC[B,E] - integer       - Seconds for data (SSSS)
c                 [B: beginning of period]
c                 [E: end of period]
c
c --- OUTPUT:  none
c
c --- WRTI1D called by:  RESTARTO
c --- WRTI1D calls:      none
c----------------------------------------------------------------------
      integer idat(nwords)
      character*8 clabel
c
      write(iomet)clabel,ndathrb,nsecb,ndathre,nsece,idat
      return
      end
c----------------------------------------------------------------------
      subroutine wrtr1d(iomet,x,nwords,clabel,ndathrb,nsecb,
     &                  ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF  Version: 6.262     Level: 050915                  WRTR1D
c ---          J. Scire, SRC
c
c --- PURPOSE:  Write "NWORDS" of a one-dimensional real array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second and use
c                                  explicit begin-time/end-time format
c
c --- INPUTS:
c         IOMET - integer     - Fortran unit number of output file
c     X(nwords) - real array  - Array to output
c        NWORDS - integer     - Number of words to write
c        CLABEL - character*8 - Variable name
c   NDATHR[B,E] - integer     - Date and time of data (YYYYJJJHH)
c     NSEC[B,E] - integer     - Seconds for data (SSSS)
c                 [B: beginning of period]
c                 [E: end of period]
c
c --- OUTPUT:  none
c
c --- WRTR1D called by:  RSTARTO
c --- WRTR1D calls:      none
c----------------------------------------------------------------------
      real x(nwords)
      character*8 clabel
c
      write(iomet)clabel,ndathrb,nsecb,ndathre,nsece,x
      return
      end
c----------------------------------------------------------------------
      subroutine wrtr2d(iomet,x,xbuf,mxnx,mxny,nx,ny,clabel,
     &                  ndathrb,nsecb,ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF  Version: 6.262     Level: 050915                  WRTR2D
c ---          J. Scire, SRC
c
c --- PURPOSE:  Write NX * NY words of a 2-D real array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second and use
c                                  explicit begin-time/end-time format
c
c --- INPUTS:
c            IOMET - integer     - Fortran unit number of output file
c     X(mxnx,mxny) - real array  - Array to output
c      XBUF(nx,ny) - real array  - Buffer to hold data for output
c        MXNX,MXNY - integers    - Dimensions of data array
c            NX,NY - integers    - Actual size of grid to output
c           CLABEL - character*8 - Variable name
c      NDATHR[B,E] - integer     - Date and time of data (YYYYJJJHH)
c        NSEC[B,E] - integer     - Seconds for data (SSSS)
c                    [B: beginning of period]
c                    [E: end of period]
c
c --- OUTPUT:  none
c
c --- WRTR2D called by:  RESTARTO
c --- WRTR2D calls:      none
c----------------------------------------------------------------------
      real x(mxnx,mxny),xbuf(nx,ny)
      character*8 clabel
c
      if(nx.eq.mxnx.and.ny.eq.mxny)then
c
c ---    entire array is being used -- write full grid
         write(iomet)clabel,ndathrb,nsecb,ndathre,nsece,x
      else
c
c ---    only a portion of grid being used -- transfer to buffer
c ---    and write
         do 10 i=1,nx
         do 10 j=1,ny
         xbuf(i,j)=x(i,j)
10       continue
c
         write(iomet)clabel,ndathrb,nsecb,ndathre,nsece,xbuf
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine wrtr3d(iomet,x,xbuf,mxnx,mxny,mxnz,nx,ny,nz,
     &                  clabel,ndathrb,nsecb,ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF  Version: 6.262     Level: 050915                  WRTR3D
c ---          J. Scire, SRC
c
c --- PURPOSE:  Write NX * NY * NZ words of a 3-D real array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second and use
c                                  explicit begin-time/end-time format
c
c --- INPUTS:
c            IOMET - integer     - Fortran unit number of output file
cX(mxnx,mxny,mxnz) - real array  - Array to output
c   XBUF(nx,ny,nz) - real array  - Buffer to hold data for output
c   MXNX,MXNY,MXNZ - integers    - Dimensions of data array
c         NX,NY,NZ - integers    - Actual size of grid to output
c           CLABEL - character*8 - Variable name
c      NDATHR[B,E] - integer     - Date and time of data (YYYYJJJHH)
c        NSEC[B,E] - integer     - Seconds for data (SSSS)
c                    [B: beginning of period]
c                    [E: end of period]
c
c --- OUTPUT:  none
c
c --- WRTR3D called by:  RESTARTO
c --- WRTR3D calls:      none
c----------------------------------------------------------------------
      real x(mxnx,mxny,mxnz),xbuf(nx,ny,nz)
      character*8 clabel
c
      if(nx.eq.mxnx.and.ny.eq.mxny.and.nz.eq.mxnz)then
c
c ---    entire array is being used -- write full grid
         write(iomet)clabel,ndathrb,nsecb,ndathre,nsece,x
      else
c
c ---    only a portion of grid being used -- transfer to buffer
c ---    and write
         do 10 i=1,nx
         do 10 j=1,ny
         do 10 k=1,nz
         xbuf(i,j,k)=x(i,j,k)
10       continue
c
         write(iomet)clabel,ndathrb,nsecb,ndathre,nsece,xbuf
      endif
c
      return
      end

c----------------------------------------------------------------------
      subroutine rdr3d(iomet,x,xbuf,mxnx,mxny,mxnz,nx,ny,nz,
     &                 clabel,ndathrb,nsecb,ndathre,nsece)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  RDR3D
c                J. Scire, SRC
c
c --- PURPOSE:  Read NX * NY * NZ words of a 3-D real array
c
c --- UPDATE
c --- V5.0-V6.1     050915  (DGS): resolve times to the second and use
c                                  explicit begin-time/end-time format
c
c --- INPUTS:
c            IOMET - integer     - Fortran unit number of input file
c   XBUF(nx,ny,nz) - real array  - Buffer to hold input data
c   MXNX,MXNY,MXNZ - integers    - Dimensions of data array
c         NX,NY,NZ - integers    - Actual size of grid to read
c           CLABEL - character*8 - Variable name
c      NDATHR[B,E] - integer     - Date and time of data (YYYYJJJHH)
c        NSEC[B,E] - integer     - Seconds for data (SSSS)
c                    [B: beginning of period]
c                    [E: end of period]
c
c --- OUTPUT:
cX(mxnx,mxny,mxnz) - real array  - Input data array (padded if nec.)
c
c --- RDR3D called by:  RESTARTI
c --- RDR3D calls:      none
c----------------------------------------------------------------------
      real x(mxnx,mxny,mxnz),xbuf(nx,ny,nz)
      character*8 clabel
c
      if(nx.eq.mxnx.and.ny.eq.mxny.and.nz.eq.mxnz)then
c
c ---    entire array is being used -- read full grid
         read(iomet)clabel,ndathrb,nsecb,ndathre,nsece,x
      else
c
c ---    only a portion of grid being used -- read and
c ---    transfer from buffer
         read(iomet)clabel,ndathrb,nsecb,ndathre,nsece,xbuf
c
         do 10 i=1,nx
         do 10 j=1,ny
         do 10 k=1,nz
         x(i,j,k)=xbuf(i,j,k)
10       continue
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine tiblset(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080227                TIBLSET
c                D. Strimaitis
c
c --- PURPOSE:  Setup functions for the sub-grid TIBL module
c                 -- Transfer distance parameters from control file
c                 -- Read user-supplied coast line(s) (COASTLN.DAT)
c                 -- Convert points to MET GRID Units
c                 -- Identify MET GRID cells with coast segments
c                 -- Identify nearest land and water MET GRID cells
c                    for each point stored for each coast line
c                 -- Compute slope/intercept for coastline segments
c
c --- UPDATES
c --- V5.7-V6.25   080227  (DGS): Replace NLOOK with NLUTIBL from the
c                                 control file
c --- V5.4-V5.7    030402  (DGS): add /MAP/
c --- V5.2-V5.4    000602  (DGS): add message to "stop"
c --- V5.1-V5.2    991104  (JSS): Error messages written to list
c                                 file as well as to screen
c --- V5.0-V5.0    990228e (DGS): process distance parameters TIBLDIST
c     (from 980515)990228e (DGS): expand search radius for nearest land
c                                 and water cells from 1 to NLOOK
c
c --- INPUTS:
c              LDB - logical  - Flag controlling printing of internal
c                               data (F=suppress, T=print)
c
c     Common block /COMPARM/ variables
c        TIBLDIST(3), NLUTIBL
c     Common block /GRID/ variables
c        DGRIDI, XORIG, YORIG
c     Common block /MAP/ variables
c        IUTMZN
c     Common Block /METHD/ variables:
c        ILANDU(mxnx,mxny), IWAT1, IWAT2
c
c     Parameters:
c         MXCOAST, IO25, IO6
c
c --- OUTPUT:
c     Common block /COASTLN/ variables
c     Common block /TIBL/ variables
c        X2ZI1, X2ZI2, XUPGRD
c
c --- TIBLSET called by: SETUP
c --- TIBLSET calls:     
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'coastln.puf'
      include 'comparm.puf'
      include 'grid.puf'
      include 'map.puf'
      include 'methd.puf'
      include 'tibl.puf'
c
      logical ldb,problem,lwr,ltest
      character*12 datatype,vrscst,labcst
      character*40 avar(2)


c --- Set local variable for a difference (MET Grid Units) small
c --- enough to be treated as ZERO
      data dsmall/0.000001/

      problem=.FALSE.

c --- Transfer TIBL parameters from control file
      x2zi1=tibldist(1)*1000.
      x2zi2=tibldist(2)*1000.
      xupgrd=tibldist(3)*1000.*dgridi

c --- Read user-specified coastline data (COASTLN.DAT)
c ----------------------------------------------------
c --- Header record
      read(io25,*,end=997) datatype,ncoast,iutmcst,vrscst,labcst

c --- Perform QA checks
      if(datatype.NE.'COASTLN' .AND. datatype.NE.'coastln')then
         write(io6,*)'ERROR in subr. TIBLSET -- Data Type label',
     1   ' in COASTLN.DAT file does not match expected value ',
     2   '-- Found ',datatype,' Expected COASTLN or coastln'
         problem=.TRUE.
      endif

      if(iutmcst.NE.iutmzn)then
         write(io6,*)'ERROR in subr. TIBLSET -- Value of UTM zone',
     1   ' in COASTLN.DAT file does not match control file value ',
     2   '-- IUTMCST = ',iutmcst,' IUTMZN = ',iutmzn
         problem=.TRUE.
      endif

      if(ncoast.GT.mxcoast)then
         write(io6,*)'ERROR in subr. TIBLSET -- Number of coast ',
     1   ' lines in COASTLN.DAT file exceeds maximum parameter ',
     2   '-- NCOAST = ',ncoast,' MXCOAST = ',mxcoast
         problem=.TRUE.
      endif

      if(PROBLEM) goto 998

c --- Data records:  Loop over coastline(s) provided
      problem=.FALSE.
      nsegcst=0
      icoast=0
10    read(io25,*,end=990) avar
      if(avar(1)(1:1).EQ.'W' .OR. avar(1)(1:1).EQ.'w') then
c ---    New coastline
c --------------------
         if(icoast.GT.0) then
c ---       Terminate previous coastline
            if(nsegcst.GT.npcoast(1,icoast)) then
c ---          Previous coastline OK, set pointer to end of last segment
               npcoast(2,icoast)=nsegcst
               if(.not.LWR) then
c ---             Points defined with water to the Left along coastal
c ---             path, so these points were placed at the END of array
c ---             in reverse order to comply with internal convention.
c ---             Move the NEND points up.
                  do k=1,nend
                     ipos=npcoast(2,icoast)-nend+k
                     iend=mxptcst-nend+k
                     do i=1,2
                        coastgrd(i,ipos)=coastgrd(i,iend)
                     enddo
                  enddo
                  nend=0
               endif
            else
c ---          Previous coastline has less than 2 points -- remove it!
               nsegcst=MAX(0,npcoast(1,icoast)-1)
               icoast=MAX(0,icoast-1)
               problem=.TRUE.
            endif
         endif
c ---    Initiate new coastline
         icoast=icoast+1
         npcoast(1,icoast)=nsegcst+1
         if(avar(1).EQ.'WR') then
            LWR=.TRUE.
         else
            LWR=.FALSE.
            nend=0
         endif
      else
c ---    Current Coastline
c ------------------------
c ---    Get position from arrays
         read(avar(1),'(f10.3)') xkm
         read(avar(2),'(f10.3)') ykm
c ---    Convert coordinates from UTM (km) to MET GRID Units
         xcstmg=(1000.*xkm-xorig)*dgridi
         ycstmg=(1000.*ykm-yorig)*dgridi
         if(nsegcst.LT.npcoast(1,icoast)) then
c ---       First point along coast line:  store it
            nsegcst=nsegcst+1
            if(nsegcst.GT.mxptcst) goto 996
            if(LWR) then
               coastgrd(1,nsegcst)=xcstmg
               coastgrd(2,nsegcst)=ycstmg
            else
               nend=nend+1
               iend=mxptcst+1-nend
               coastgrd(1,iend)=xcstmg
               coastgrd(2,iend)=ycstmg
            endif
         else
c ---       Compute number of points to store (separation < grid cell)
            k=iend
            if(LWR) k=nsegcst
            dxstep=xcstmg-coastgrd(1,k)
            dystep=ycstmg-coastgrd(2,k)
            step=AMAX1(ABS(dxstep),ABS(dystep))
            if(step.GT.0.5) then
               nstep=2*step
               dxstep=dxstep/FLOAT(nstep)
               dystep=dystep/FLOAT(nstep)
            else
               nstep=1
            endif
c ---       Loop over points
            do istep=1,nstep
               nsegcst=nsegcst+1
               if(nsegcst.GT.mxptcst) goto 996
               if(LWR) then
                  coastgrd(1,nsegcst)=coastgrd(1,nsegcst-1)+dxstep
                  coastgrd(2,nsegcst)=coastgrd(2,nsegcst-1)+dystep
               else
                  nend=nend+1
                  iend=mxptcst+1-nend
                  coastgrd(1,iend)=xcstmg
                  coastgrd(2,iend)=ycstmg
                  coastgrd(1,iend)=coastgrd(1,iend+1)+dxstep
                  coastgrd(2,iend)=coastgrd(2,iend+1)+dystep
               endif
            enddo
         endif
      endif

c --- Next record
      goto 10

c --- End of data reached in file   
990   if(icoast.GT.0) then
c ---    Terminate previous coastline
         if(nsegcst.GT.npcoast(1,icoast)) then
c ---       Coastline OK, set pointer to end of last segment
            npcoast(2,icoast)=nsegcst
            if(.not.LWR) then
c ---          Points defined with water to the Left along coastal
c ---          path, so these points were placed at the END of array
c ---          in reverse order to comply with internal convention.
c ---          Move the NEND points up.
               do k=1,nend
                  ipos=npcoast(2,icoast)-nend+k
                  iend=mxptcst-nend+k
                  do i=1,2
                     coastgrd(i,ipos)=coastgrd(i,iend)
                  enddo
               enddo
               nend=0
            endif
         else
c ---       Coastline has less than 2 points -- remove it!
            nsegcst=MAX(0,npcoast(1,icoast)-1)
            icoast=MAX(0,icoast-1)
            problem=.TRUE.
         endif
      endif

      if(icoast.LE.0) goto 997

c --- Compute slope 'em' and intercept 'be' for each segment
c ----------------------------------------------------------
c --- Loop over coasts
      do ic=1,icoast
c ---    Loop over segments in coast
         do is=npcoast(1,ic),npcoast(2,ic)-1
            dx=coastgrd(1,is+1)-coastgrd(1,is)
            dy=coastgrd(2,is+1)-coastgrd(2,is)
            if(ABS(dx).LE.dsmall) then
c ---          Segment is assumed to be vertical (N/S)
               em=9.91e10
               be=9.91e10
            else
               em=dy/dx
               be=coastgrd(2,is)-em*coastgrd(1,is)
            endif
            ymxpb(1,is)=em
            ymxpb(2,is)=be
         enddo
c ---    Place data for last segment into end-point location also
         ymxpb(1,npcoast(2,ic))=em
         ymxpb(2,npcoast(2,ic))=be
      enddo


c --- Identify met grid cells touched by at least 1 coastline
c -----------------------------------------------------------
c --- Initialize LCOAST array
      do j=1,ny
         do i=1,nx
            lcoast(i,j)=.FALSE.
         enddo
      enddo
c --- Loop over coasts
      do ic=1,icoast
c ---    Loop over segments in coast
         do is=npcoast(1,ic),npcoast(2,ic)-1
            ix=1+coastgrd(1,is)
            iy=1+coastgrd(2,is)
            if(ix.GE.1 .AND. ix.LE.nx) then
               if(iy.GE.1 .AND. iy.LE.ny) then
                  lcoast(ix,iy)=.TRUE.
               endif
            endif
         enddo
      enddo

c --- Identify nearest land and water cell to each point
c ------------------------------------------------------
c --- Loop over coasts
      ltest=.FALSE.
      do ic=1,icoast
c ---    Loop over points in coast
         do ip=npcoast(1,ic),npcoast(2,ic)
            lwcell(1,ip)=0
            lwcell(2,ip)=0
            dlandsq=2.*nlutibl**2
            dwatersq= dlandsq
            ixp=1+coastgrd(1,ip)
            iyp=1+coastgrd(2,ip)
c ---       Set search range within grid limits
            ixlo=MAX(1,ixp-nlutibl)
            ixhi=MIN(nx,ixp+nlutibl)
            iylo=MAX(1,iyp-nlutibl)
            iyhi=MIN(ny,iyp+nlutibl)
cc ---       Adjust search range near grid boundary
c            if(ixlo.EQ.1) then
c               ixhi=MAX(ixhi,2)
c            elseif(ixhi.EQ.nx) then
c               ixlo=MIN(ixlo,nx-1)
c            endif
c            if(iylo.EQ.1) then
c               iyhi=MAX(iyhi,2)
c            elseif(iyhi.EQ.ny) then
c               iylo=MIN(iylo,ny-1)
c            endif
            do i=ixlo,ixhi
               do j=iylo,iyhi
                  index=nx*(j-1)+i
                  distsq=(i-.5-coastgrd(1,ip))**2+
     &                   (j-.5-coastgrd(2,ip))**2
                  if(ilandu(i,j).GE.iwat1 .AND.
     &               ilandu(i,j).LE.iwat2) then
c ---                Water cell
                     if(distsq.LT.dwatersq) then
                        dwatersq=distsq
                        lwcell(2,ip)=index
                     endif
                  else
c ---                Land cell
                     if(distsq.LT.dlandsq) then
                        dlandsq=distsq
                        lwcell(1,ip)=index
                     endif
                  endif
               enddo
            enddo
c ---       Update test for finding both land and water cells
            if(lwcell(1,ip)*lwcell(2,ip).EQ.0) ltest=.TRUE.
         enddo
      enddo
      if(ltest) problem=.TRUE.

c --- Documentation for LIST file
      write(io6,*)
      write(io6,*)'TIBLSET ---------------'
      write(io6,*)'Coastline derived from data provided in ',
     &            'COASTLN.DAT file'
      write(io6,*)'Number of coastlines     = ',icoast
      write(io6,*)'Total number of segments = ',nsegcst
      write(io6,*)
      write(io6,*)'Met Grid cells containing coastline segments:'
      write(io6,*)'   (Grid North)'
      do j=ny,1,-1
         write(io6,'(1000L2)') (lcoast(i,j),i=1,nx)
      enddo
      write(io6,*)'Transition from TIBL Hts to CALMET Mixing Hts'
      write(io6,*)'starts at (m):  ',x2zi1
      write(io6,*)' stops at (m):  ',x2zi2
      write(io6,*)'Maximum distance upwind of source in search for'
      write(io6,*)'   coast (km):  ',tibldist(3)
      write(io6,*)'   (Met Grid):  ',xupgrd

c --- Additional DEBUG Output Section
c -----------------------------------
      if(LDB.OR.PROBLEM) then
         do icst=1,icoast
            write(io6,*)
            write(io6,*)'  Coastline ',icst
            write(io6,*)'  Located in array elements ',npcoast(1,icst),
     &                  ' to ',npcoast(2,icst)
            write(io6,*)'  (x,y){MET Grid Units} and pointer to ',
     &                  'nearest LAND and WATER cell (>0)'
            do i=npcoast(1,icst),npcoast(2,icst)
               write(io6,*) (coastgrd(k,i),k=1,2),(lwcell(k,i),k=1,2)
            enddo
            write(io6,*)
            write(io6,*)'  (slope,intercept) {MET Grid Units}'
            do i=npcoast(1,icst),npcoast(2,icst)
               write(io6,*) (ymxpb(k,i),k=1,2)
            enddo
         enddo
      endif

c --- Perform QA check on number of coasts processed
      if(icoast.NE.ncoast) then
         write(io6,*)'ERROR in subr. TIBLSET -- Number of coasts',
     1   ' in COASTLN.DAT file does not match expected value ',
     2   '-- Found ',icoast,' Expected ',ncoast
         goto 998
      endif

      if(ltest) goto 999

      return

996   write(io6,*)'ERROR in subr. TIBLSET -- No. of coast segments',
     &   ' exceeds maximum parameter MXPTCST = ',mxptcst
      write(*,*)
      stop 'Halted in TIBLSET -- see list file.'
997   write(io6,*)'FATAL Error: COASTLN.DAT file empty or incomplete'
      write(*,*)
      stop 'Halted in TIBLSET -- see list file.'
998   write(io6,*)'FATAL Error in COASTLN.DAT Header'
      write(*,*)
      stop 'Halted in TIBLSET -- see list file.'
999   write(io6,*)'FATAL Error in COASTLN.DAT Data'
      write(io6,*)'Met Grid Land Use not consistent with coast'
      write(*,*)
      stop 'Halted in TIBLSET -- see list file.'
c
      end
c----------------------------------------------------------------------
      subroutine tiblon(ldb0,ifree,xs,ys,xe,ye,ixs,iys,ixe,iye,zpht,
     &                  ltibl)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050805                 TIBLON
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Screen coastline segments to determine if puff
c               trajectory can encounter a TIBL, and compute
c               initial TIBL properties if it does
c
c --- UPDATE
c
c --- V5.7-V5.751  050805  (DGS): Augment test for onshore trajectory
c                                 to exclude parallel lines
c                  050805  (DGS): Place water cell mixing ht (not ht0)
c                                 into TIBL array locations upwind of
c                                 the coast
c                  050805  (DGS): Use land cell pointer in call
c                                 to TIBLGRO so that shore properties
c                                 are consistent with coastline as puff
c                                 crosses coast
c --- V5.0-V5.7    030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.0-V5.0    990228e (DGS): recast loops over ixs,ixe and iys,iye
c                                 to assure a positive range
c                  990228e (DGS): fix fstep logic
c                  990228e (DGS): obtain heat flux from ustar and L
c                  990228e (DGS): include upwind fetch in search for
c                                 coast for fresh emissions
c
c --- INPUTS:
c             LDB0 - logical  - Flag controlling printing of internal
c                               data (F=suppress, T=print)
c            IFREE - integer  - Flag indicating if puff/slug is free
c                               of the source (1=free)
c            XS,YS - real     - Puff position at start of sampling step

c                               in MET GRID Units
c            XE,YE - real     - Puff position at end of sampling step
c                               in MET GRID Units
c          IXS,IYS - integer  - Cell for puff position (XS,YS)
c          IXE,IYE - integer  - Cell for puff position (XE,YE)
c             ZPHT - real     - Puff height (m)
c
c     Common block /COASTLN/ variables
c         NCOAST, NPCOAST(2,mxcoast), COASTGRD(2,mxptcst),
c         LCOAST(mxnx,mxny), YMXPB(2,mxptcst)
c     Common block /GRID/ variables
c         NX, NY, DGRIDI
c     Common block /METHD/ variables
c         I2DMET, NEARS(mxnx,mxny)
c     Common block /METHR/ variables
c         WSTAR(mxnx,mxny), HTMIX(mxnx,mxny), TEMPSS(mxss),
c         UMET(mxnx,mxny), VMET(mxnx,mxny),
c         USTAR(mxnx,mxny), XMONIN(mxnx,mxny),
c         temp2d(mxnx,mxny)
c     Common block /TIBL/ variables
c         XUPGRD
c
c     Parameters:
c         MXNXY, MXNX, MXNY, MXSS, MXCOAST, MXPTCST,  IO6
c
c --- OUPUT:
c            LTIBL - logical  - Flag indicating if TIBL is treated this
c                               step
c
c     Common block /TIBL/ variables
c          MXTIBL,
c          NTIBL,IXTIBL(mxtibl),IYTIBL(mxtibl),
c          HTIBL(mxtibl),TSTIBL(mxtibl)
c
c --- TIBLON called by: COMP
c --- TIBLON calls:     PTLAPS, TIBLGRO
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'coastln.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'tibl.puf'
c
      logical ldb0,ldb,ltibl

c --- Set minimum overwater potential temperature gradient
      data ptgrad0/0.0001/

c --- Set initial TIBL ht at coast
      data ht0/20./

c --- Set (1+2*beta), where beta is -ratio of heat flux at the TIBL
c --- height to that at the surface inland (assumed 0.2 here)
      data r1p2b/1.4/

c --- Set local variable for a difference (MET Grid Units) small
c --- enough to be treated as ZERO
      data dsmall/0.000001/

c --- Introduce ldb to allow override of ldb0
      ldb=ldb0
c --- ldb=.TRUE.

c --- Initialize intercept results to NULL values
      is0=0
      frac=10.*mxnxy
      tiblk=0.

c --- Find nearest coastline segment that puff trajectory could cross
c -------------------------------------------------------------------
c --- Set sampling step vector components and length
      dxp=xe-xs
      dyp=ye-ys
      dsp=SQRT(dxp**2+dyp**2)
      dspm=dsp*dgrid
c --- No TIBL is calculated if step length is not positive
      if(dsp.LE.0.) goto 900
c --- Set range of cells to check
      if(ifree.EQ.0) then
c ---    Fresh emission
         xup=xs-dxp*xupgrd/dsp
         ixb=xup+1
         if(ixb.LT.1) then
            ixb=1
         elseif(ixb.GT.nx) then
            ixb=nx
         endif
         yup=ys-dyp*xupgrd/dsp
         iyb=yup+1
         if(iyb.LT.1) then
            iyb=1
         elseif(iyb.GT.ny) then
            iyb=ny
         endif
      else
         ixb=ixs
         iyb=iys
      endif
      ixlo=MIN(ixb,ixe)
      ixhi=MAX(ixb,ixe)
      iylo=MIN(iyb,iye)
      iyhi=MAX(iyb,iye)
c --- Check for a coast segment in any one of these cells
      ltibl=.FALSE.
      do iy=iylo,iyhi
         do ix=ixlo,ixhi
            if(lcoast(ix,iy)) ltibl=.TRUE.
         enddo
      enddo
      if(.NOT.ltibl) goto 900
c --- Set slope, intercept of trajectory
      if(ABS(dxp).LE.dsmall) then
c ---    Trajectory is assumed to be vertical (N/S)
         slope=9.91e10
         bintr=9.91e10
      else
         slope=dyp/dxp
         bintr=ys-slope*xs
      endif
c --- Loop over coasts
      do ic=1,ncoast
c ---    Loop over segments in coast
         do is=npcoast(1,ic),npcoast(2,ic)-1
            ixc1=1+coastgrd(1,is)
            iyc1=1+coastgrd(2,is)
            ixc2=1+coastgrd(1,is+1)
            iyc2=1+coastgrd(2,is+1)
c
c ---       Loop over cells in sampling step
            do iy=iylo,iyhi
            do ix=ixlo,ixhi
c
               if((ixc1.EQ.ix .AND. iyc1.EQ.iy) .OR.
     &            (ixc2.EQ.ix .AND. iyc2.EQ.iy)) then
c ---             Test this segment
                  dxc=coastgrd(1,is+1)-coastgrd(1,is)
                  dyc=coastgrd(2,is+1)-coastgrd(2,is)
c ---             Coast Vector [CROSS] Puff Vector:
                  cxp=dxc*dyp-dxp*dyc

c ---             Screen out equal slopes (cxp=0
c ---             if slopes are equal, but precision may
c ---             let this slip through)

                  if(cxp.GT.0.0 .AND. slope.NE.ymxpb(1,is)) then
c ---                Trajectory is onshore, find intercept
                     if(slope.GT.9.9e10) then
                        xint=xs
                        yint=ymxpb(1,is)*xint+ymxpb(2,is)
                     elseif(ymxpb(1,is).GT.9.9e10) then
                        xint=coastgrd(1,is)
                        yint=slope*xint+bintr
                     else
                        xint=(bintr-ymxpb(2,is))/(ymxpb(1,is)-slope)
                        yint=slope*xint+bintr
                     endif
c ---                Intercept must be within the coast segment
                     if(ymxpb(1,is).GT.9.9e10) then
                        frac1=(yint-coastgrd(2,is))/dyc
                     else
                        frac1=(xint-coastgrd(1,is))/dxc
                     endif
                     if(frac1.GE.0.0 .AND. frac1.LE.1.0) then
c ---                   Save this segment if it is nearest start
                        if(slope.GT.9.9e10) then
                           frac2=(yint-ys)/dyp
                        else
                           frac2=(xint-xs)/dxp
                        endif
                        if(ABS(frac2).LT.ABS(frac)) then
                           frac=frac2
                           fraccst=frac1
                           is0=is
                        endif
                     endif
                  endif
               endif
c
            enddo
            enddo
c
         enddo
      enddo

c --- DEBUG Output Section
c ------------------------
      if(LDB) then
         write(io6,*)
         write(io6,*)'TIBLON ---------------'
         write(io6,*)'Coastline segments screened for intersection in'
         write(io6,*)'ixb,iyb,ixe,iye: ',ixb,iyb,ixe,iye
         write(io6,*)'Nearest coastline segment selected     = ',is0
         write(io6,*)'Coast crossed @ sampling step fraction = ',frac
         write(io6,*)
      endif

c ---------------------
c --- Interpret results
c ---------------------

900   if(is0.EQ.0 .OR. frac.GE.1.0) then
c ---    Valid intercept not found:  No TIBL this step
c ----------------------------------------------------
         ltibl=.FALSE.
         return
      endif

c --- Compute initial TIBL properties
c -----------------------------------
c --- Pick the cell data nearest the intercept
      ipt=is0
      if(NINT(fraccst).GE.1) ipt=is0+1

c --- Nearest LAND cell:
      ipland=lwcell(1,ipt)
      ixl=MOD(ipland,nx)
      if(ixl.EQ.0)ixl=nx
      iyl=1+(ipland-ixl)/nx

c --- Nearest WATER cell:
      ipwater=lwcell(2,ipt)
      ixw=MOD(ipwater,nx)
      if(ixw.EQ.0)ixw=nx
      iyw=1+(ipwater-ixw)/nx

c --- Set over-land met data
      wstr=wstar(ixl,iyl)
      xmol=xmonin(ixl,iyl)
c !!!c --- Abort if wstar not positive (no TIBL)
c !!!      if(wstr.LE.0.0) then
c --- Abort if Monin-Obukhov length is positive (no TIBL)
      if(xmol.GE.0.0) then
         ltibl=.FALSE.
         return
      endif
      ziland=htmix(ixl,iyl)
      ustr=ustar(ixl,iyl)
c 
c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
         tss=temp2d(ixl,iyl)
      elseif(i2dmet.EQ.0) then
         tss=tempss(nears(ixl,iyl))
      else
         write(*,*)'Subr. TIBLON:  Invalid I2DMET = ',i2dmet
         stop
      endif
c     tss=tempss(nears(ixl,iyl))
      hbyrcp=-ustr**3*tss/(9.8*0.4*xmol)
c --- Abort if sensible heat flux < 5 W/m**2 (no TIBL)
      if(hbyrcp.LE.0.004) then
         ltibl=.FALSE.
         return
      endif
c --- Mean speed for TIBL growth taken equal to layer 1 speed
      u0=SQRT(umet(ixl,iyl,1)**2+vmet(ixl,iyl,1)**2)

c --- Set over-water met data
      ziwater=htmix(ixw,iyw)
c --- Use pot. temperature (K) gradient of overwater layer from HT0
c --- to HT0+mixed layer depth. Minimum gradient is PTGRAD0,
c --- and minimum layer thickness is 100m.
      delz=AMAX1(ziwater,100.)
      call PTLAPS(ixw,iyw,ht0,ptgrad0,delz,ptgrad,t0)

c --- Compute K-factor for initial rate of TIBL growth
      tiblk=(r1p2b*hbyrcp)/(ptgrad*u0)

c --- Additional DEBUG Output Section
c -----------------------------------
      if(LDB) then
         write(io6,*)'ixw,iyw,ixl,iyl      : ',ixw,iyw,ixl,iyl
         write(io6,*)'wstr,tss             : ',wstr,tss
         write(io6,*)'zpht,ustr,xmol       : ',zpht,ustr,xmol
         write(io6,*)'u0,ptgrad,hbyrcp     : ',u0,ptgrad,hbyrcp 
         write(io6,*)'ziland,ziwater,tiblk : ',ziland,ziwater,tiblk
         write(io6,*)'step length (m)      : ',dspm
      endif

c --- Fill the TIBL arrays
c -------------------------
c --- Case 1: Coast is upwind of start of step
      if(frac.LT.0.0) then
c ---    Grow TIBL to the start of the current step
         xdist=-frac*dspm
c ---    Initial growth rate is used for first X2ZI1 (m) from coast
         x1=AMIN1(xdist,x2zi1)
         ht1sq=2.*tiblk*x1+ht0**2
         if(xdist.GT.x1) then
c ---       Augment growth rate for transition to inland mixing ht
            zik=htmix(ixs,iys)**2/(2.*x2zi2)
            tiblk=AMAX1(tiblk,zik)
c ---       Compute growth for additional distance to start of step
            ht1sq=2.*tiblk*(xdist-x1)+ht1sq
         endif
         ht1=AMIN1(SQRT(ht1sq),htmix(ixs,iys))
c ---    Compute TIBL ht during step
         tiblku=tiblk*u0
         call TIBLGRO(ldb,xs,ys,xe,ye,ixl,iyl,ht1,
     &                -.001,tiblku)

c --- Case 2:  Coast is within the step
      else
c ---    First entry is interval to coast
         ntibl=1
         tstibl(ntibl)=AMIN1(frac,1.0)
         htibl(ntibl)=ziwater
         ixtibl(ntibl)=ixw
         iytibl(ntibl)=iyw
c ---    Remaining entries filled if needed (use land cell here)
         if(frac.LT.1.0) then
            tiblku=tiblk*u0
            call TIBLGRO(ldb,xs,ys,xe,ye,ixl,iyl,ht0,
     &                   frac,tiblku)
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine tiblgro(ldb0,xs,ys,xe,ye,ixr,iyr,ht0,
     &                   frac0,tiblku0)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 060309                TIBLGRO
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Grow an existing TIBL along the path of a puff, using
c               current land use
c
c --- UPDATES
c --- V5.751-V6.11  060309 (DGS): Test for small/negative heat flux
c                                 during step
c --- V5.711-V5.751 050805 (DGS): Change puff start/end cell indices
c                                 to a cell override index ixr,iyr
c                                 (-1,-1 if no override)
c --- V5.7-V5.711  030625  (DGS): Fix ix,iy assignment logic to avoid
c                                 undefined outcome
c --- V5.4-V5.7    030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.3-V5.4    000602  (DGS): add message to "stop"
c --- V5.2-V5.3    991222  (DGS): Use MIN,MAX in place of MIN1,MAX1
c --- V5.1-V5.2    991104  (JSS): Error messages written to list
c                                 file as well as to screen
c --- V5.0-V5.0    990228e (DGS): add adaptive step size
c    (from 980515) 990228e (DGS): obtain heat flux from ustar and L
c                  998228e (DGS): add transition to inland mixing hts.
c                  998228e (DGS): allow for a fractional step
c
c --- INPUTS:
c             LDB0 - logical  - Flag controlling printing of internal
c                               data (F=suppress, T=print)
c            XS,YS - real     - Puff position at start of sampling step
c                               in MET GRID Units
c            XE,YE - real     - Puff position at end of sampling step
c                               in MET GRID Units
c          IXR,IYR - integer  - Replacement Cell for grid properties
c                               overrides computed cell if not (-1,-1)
c              HT0 - real     - TIBL height (m) at the start of the step
c            FRAC0 - real     - Fraction of step already assigned in TIBL
c                               arrays (if greater than zero)
c          TIBLKU0 - real     - TIBL rate K times U at the coast
c
c     Common block /GRID/ variables
c         DGRID
c     Common block /METHD/ variables
c         NEARS(mxnx,mxny), ZO(mxnx,mxny), ILANDU(mxnx,mxny),
c         IWAT1, IWAT2 , I2DMET
c     Common block /METHR/ variables
c         WSTAR(mxnx,mxny), HTMIX(mxnx,mxny), XMONIN(mxnx,mxny),
c         IPGT(mxnx,mxny), TEMPSS(mxss), USTAR(mxnx,mxny), TEMP2D(mxnx,mxny)
c
c     Parameters:
c         MXNX, MXNY, MXSS, IO6
c
c --- OUPUT:
c
c     Common block /TIBL/ variables
c          MXTIBL
c          NTIBL,IXTIBL(mxtibl),IYTIBL(mxtibl),
c          HTIBL(mxtibl),TSTIBL(mxtibl)
c
c
c --- TIBLGRO called by: COMP, TIBLON
c --- TIBLGRO calls:     PTLAPS, ADVECT
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'tibl.puf'
c
      logical ldb0,ldb
      data zero/0.0/, delz/100./

c --- Set minimum overwater potential temperature gradient
      data ptgrad0/0.0001/

c --- Set (1+2*beta), where beta is -ratio of heat flux at the TIBL
c --- height to that at the surface inland (assumed 0.2 here)
      data r1p2b/1.4/

c --- Set minimum sub-step size (m)
      data ssmin/20./

c --- Introduce ldb to allow override of ldb0
      ldb=ldb0
c --- ldb=.TRUE.

c --- Set sampling step vector components and length
      dxp=xe-xs
      dyp=ye-ys
      dspm=SQRT(dxp**2+dyp**2)*dgrid

c --- Set fraction of step that remains
      if(frac0.LE.0.0) then      
         frac=1.0
         n1=1
      elseif(frac0.LT.1.0) then
         frac=1.0-frac0
         n1=2
      else
         write(io6,*)'FATAL ERROR:  TIBLGRO'
         write(io6,*)'Fraction of step already used cannot exceed 1'
         write(io6,*)'     frac0 = ',frac0
         write(*,*)
         stop 'Halted in TIBLGRO -- see list file.'
      endif

c --- Compute number of sampling substeps (NTIBL) to use
      sdel=AMAX1(ht0,ssmin)
      ntibl=(frac*dspm/sdel)+n1
      ntibl=MIN(ntibl,mxtibl)
      ntibl=MAX(ntibl,n1)

c --- Divide the sampling step into NTIBL pieces to resolve TIBL
      fstep=frac/FLOAT(ntibl+1-n1)
      dstepm=fstep*dspm
      delx=fstep*dxp
      dely=fstep*dyp
      xnew=xs+frac0*dxp
      ynew=ys+frac0*dyp
      hnew=ht0

c --- Loop over sub-steps
      do it=n1,ntibl
         tstibl(it)=fstep
c ---    Define sub-step
         xold=xnew
         yold=ynew
         hold=hnew
         xnew=xold+delx
         ynew=yold+dely
c ---    Set cell for surface properties (choose overland cell if
c ---    choice is needed)
         if(ixr.GT.0 .AND. iyr.GT.0) then
            ix=ixr
            iy=iyr
         else
            ixo=xold+1
            ixo=MAX(1,ixo)
            ixo=MIN(nx,ixo)
            iyo=yold+1
            iyo=MAX(1,iyo)
            iyo=MIN(ny,iyo)
            ixn=xnew+1
            ixn=MAX(1,ixn)
            ixn=MIN(nx,ixn)
            iyn=ynew+1
            iyn=MAX(1,iyn)
            iyn=MIN(ny,iyn)
            ix=ixo
            iy=iyo
            if(ixo.NE.ixn .OR. iyo.NE.iyn) then
               if(ilandu(ixo,iyo).LT.iwat1 .OR.
     &            ilandu(ixo,iyo).GT.iwat2) then
                  ix=ixo
                  iy=iyo
               elseif(ilandu(ixn,iyn).LT.iwat1 .OR.
     &            ilandu(ixn,iyn).GT.iwat2) then
                  ix=ixn
                  iy=iyn
               endif
            endif
         endif
c ---    Obtain cell properties
c !!!         wstr=AMAX1(0.0,wstar(ix,iy))
c !!!         hbyrcp=wstr**3*tempss(nears(ix,iy))/(9.8*zi)
         zi=htmix(ix,iy)
         ustr=AMAX1(0.0,ustar(ix,iy))
         xmol=xmonin(ix,iy)
c frr (09/01) new calmet format (2D temp)
         if(i2dmet.EQ.1) then
            tss=temp2d(ix,iy)
         elseif(i2dmet.EQ.0) then
            tss=tempss(nears(ix,iy))
         else
            write(*,*)'Subr. TIBLGRO:  Invalid I2DMET = ',i2dmet
            stop
         endif
         hbyrcp=-ustr**3*tss/(9.8*0.4*xmol)
c ---    Use pot. temperature (K) gradient above ZI (min is PTGRAD0)
         call PTLAPS(ix,iy,zi,ptgrad0,delz,ptgrad,t0)
c ---    Mean speed for TIBL growth is average from 0 to last TIBL ht
         call ADVECT(ldb0,ix,iy,z0(ix,iy),xmonin(ix,iy),zi,ipgt(ix,iy),
     &               hold,zero,hold,uadv,vadv)
         utibl=SQRT(uadv**2+vadv**2)
c ---    Compute K-factor for rate of TIBL growth
         tiblk0=(r1p2b*hbyrcp)/(ptgrad*utibl)

c ---    Compute the effective distance from coast to reach current ht
c ---    using this K-factor
c ---    Note:  Heat flux may be zero or negative here (set s0 large)
c ---           Use sensible heat flux < 5 W/m**2 as cut-off
         if(hbyrcp.GT.0.004) then
            s0=0.5*hold**2/tiblk0
         else
            s0=x2zi1
         endif

c ---    Adjust for transition to inland mixing ht
         if(s0.GE.x2zi1) then
            zik=zi**2/(2.*x2zi2)
            tiblk=AMAX1(tiblk0,zik)
         else
            tiblk=tiblk0
         endif

c ---    Replace this rate if that found at the coast is larger
         tiblk=AMAX1(tiblk,tiblku0/utibl)

c ---    Compute TIBL height at end of this sub-step
         hnew=SQRT(2.*tiblk*dstepm+hold**2)
         htibl(it)=hnew
         ixtibl(it)=ix
         iytibl(it)=iy
      enddo    

c --- DEBUG Output Section
c ------------------------
      if(LDB) then
         write(io6,*)
         write(io6,*)'TIBLGRO --------------'
         write(io6,*)'Replacement cell for Met properties ---'
         write(io6,*)'ixr,iyr              : ',ixr,iyr
         write(io6,*)'Initial TIBL height (m) is : ',ht0
         write(io6,*)'at step fraction     : ',frac0
         write(io6,*)'full step length (m) : ',dspm
         write(io6,*)'Properties of cell at end of step ---'
         write(io6,*)'wstr,tss             : ',wstar(ix,iy),tss
         write(io6,*)'ustr,xmol            : ',ustr,xmol
         write(io6,*)'utibl,ptgrad,hbyrcp  : ',utibl,ptgrad,hbyrcp 
         write(io6,*)'ziland,ziK           : ',zi,zik
         write(io6,*)'tiblku0,tiblk0,tiblk : ',tiblku0,tiblk0,tiblk
         do it=1,ntibl
           write(io6,*)'it,htibl,tstibl      : ',it,htibl(it),tstibl(it)
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine chemriv(delt,qin,coz,ctnh3,ch2o2,maqchem,temp,rhum,
     1                   rhoair,pivol,zpuf,cloud,zcoef,nspec,ldb1,io6,
     2                   rate)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_3              CHEMRIV
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  This routine sets up call to RIVAD chemical
c               transformation subroutines, and passes results to
c               calling program
c
c --- UPDATE
c --- V5.4-V5.4     000602_3(DGS): add aqueous chemistry module
c
c --- INPUTS:
c         DELT - real    - integration time interval (hours)
c  QIN(mxspec) - real    - Pollutant mass (g) in the puff
c                            QIN(1) = SO2
c                            QIN(2) = SO4
c                            QIN(3) = NO
c                            QIN(4) = NO2
c                            QIN(5) = TNO3 (HNO3 + NO3)
c                            QIN(6) = NH4NO3
c                            QIN(+) = Not Used Here
c
c          COZ - real    - background ozone concentration (ppb)
c        CTNH3 - real    - background ammonia concentration (ppb)
c        CH2O2 - real    - background H2O2 concentration (ppb)
c      MAQCHEM - integer - Aqueous phase transformation flag
c                            0 = aqueous phase transformation
c                                not modeled
c                            1 = transformation rates adjusted
c                                for aqueous phase reactions
c         TEMP - real    - temperature (deg. K)
c         RHUM - real    - relative humidity (percent)
c       RHOAIR - real    - surface air density (kg/m**3)
c        PIVOL - real    - Reciprocal of puff volume (1/m**3)
c         ZPUF - real    - Puff/Slug elevation (m MSL)
c        CLOUD - real    - Cloud cover (tenths)
c        ZCOEF - real    - Cosine of solar zenith angle
c        NSPEC - real    - number of species
c         LDB1 - logical - Control variable for printing of debug
c                          information
c          IO6 - integer - Fortran unit number of printed output
c
c
c --- OUTPUT:
c  QIN(mxspec) - real    - Pollutant mass (g) in the puff
c                            QIN(1) = SO2
c                            QIN(2) = SO4
c                            QIN(3) = NO
c                            QIN(4) = NO2
c                            QIN(5) = TNO3 (HNO3 + NO3)
c                            QIN(6) = NH4NO3
c                            QIN(+) = Not Used Here
c      RATE(4) - real    - Transformation rates (percent/hour)
c                            R(1) -- SO2 loss rate
c                            R(2) -- NOX loss rate
c                            R(3) -- TNO3 formation rate
c                            R(4) -- NO  loss rate
c
c --- CHEMRIV called by: CHEM
c --- CHEMRIV calls:     PHOT, CHMRIV, CHEMEQ
c----------------------------------------------------------------------
c

      real qin(nspec)
      real ppb(6),ppbi(6),q(6),rate(4)
      real rmwt(6)

c --- Concentration array (g/m^3) for AQTEST
      real con(5)

      logical ldb1

c --- Note: TNO3 is weighted as NO3
      data rmwt/64.,96.,30.,46.,62.,62./

c --- Define default fraction of mass available for aqueous phase chem
c --- as a fraction/hour
      data faqmass0/0.02/

c --- Combine %-conversion with time-step
      dt=0.01*delt

c --- Transfer mass data to local array
      iss=MIN0(nspec,6)
      do is=1,iss
         q(is)=qin(is)
      enddo
      do is=(iss+1),6
         q(is)=0.0
      enddo

c --- Initialize parameters for aqueous phase chem
c --- Store initial SO2 and SO4 mass
      qso2i=q(1)
      qso4i=q(2)

c --- Compute initial concentrations as PPB
c --- kg-Molar volume (m^3) at ambient T,P computed from air density
      vkgmol=28.97/rhoair
c --- Conversion factor to ppm in RIVAD
      confct=(1.0e-3)*vkgmol*pivol
      do is=1,6
         ppbi(is)=(1.0e09)*confct*q(is)/rmwt(is)
      enddo

c --- Get NO2 photolysis rate
      call PHOT(zpuf,cloud,zcoef,rk1,zcoefb)

c --- Do conversions needed for RIVAD input arguments
c --- RIVAD weights TNO3 as HNO3: scale mass by 63/62=1.016129
      q(5)=q(5)*1.016129
c --- Background ozone in PPM rather than PPB
      o3ppm=1.0e-03*coz
c --- Implied pressure (mb) -- use T0=273. P0=1013. as in RIVAD
      presur=1013.*(22.4/vkgmol)*(temp/273.)

      if(ldb1) then
         write(io6,*)
         write(io6,*)'CHEMRIV:  rk1, O3ppm = ',rk1,o3ppm
         write(io6,*)'         presur,temp = ',presur,temp
         write(io6,*)'    zpuf,cloud,zcoef = ',zpuf,cloud,zcoef
         write(io6,*)' vkgmol,confct,pivol = ',vkgmol,confct,pivol
         write(io6,*)
         write(io6,101)
101      format('ppb =  SO2',7x,'SO4',7x,'NO',7x,'NO2',7x,'TNO3',
     &              6x,'NO3')
         write(io6,*)'Starting Concs -----'
         write(io6,'(3x,6e10.2)') (ppbi(j),j=1,6)
      endif

c --- Call RIVAD module
      call CHMRIV(q,temp,presur,rhum,o3ppm,rk1,zcoef,delt,confct)

c --- Re-weight TNO3 as NO3
      q(5)=q(5)*0.984127

      if(maqchem.EQ.1) then
c ---    Revise SO2 loss rate if using aqueous phase module
c ---    Convert concentrations from ppb to g/m**3 using AQTEST method
c ---    Note: constant 28.97e6 is based on rho in kg/m**3, not g/m**3
         f=28.97e6/rhoair
         con(1)=ppbi(1)*rmwt(1)/f
         con(2)=ppbi(2)*rmwt(2)/f
c ---    Zero other species for now (only SOX addressed)
         do ii=3,5
            con(ii)=0.0
         enddo
         call AQTEST(delt,con,coz,ctnh3,ch2o2,temp,
     1               rhoair,ldb1,io6,raq)
c ---    Factor for SO2 loss rate from Aqueous Chem Module
         faqloss=(1.-exp(-raq*dt))
         faqmass=faqmass0*delt

c ---    Perform transformation/integration to get SOX mass
c ---    Factor for SO2 loss rate from Chem Module
         floss=1.-q(1)/qso2i
c
         dc1=qso2i*((1.-faqmass)*floss+faqmass*faqloss)
         q(1)=qso2i-dc1
         q(2)=qso4i+rmwt(2)*dc1/rmwt(1)
      endif

c --- Condition mass results
      do i=1,6
         q(i)=AMAX1(q(i),0.0)
      enddo

c --- Compute ending concentrations as PPB
      do is=1,6
         ppb(is)=(1.0e09)*confct*q(is)/rmwt(is)
      enddo

c --- Compute conversion rates (%/hr) for QA review
      do i=1,4
         rate(i)=0.0
      enddo

c --- Compute these logs only if debug output is ON
      if(ldb1) then
         dt=.01*delt
c ---    SOX:
         if(ppbi(1).GT.0.0 .AND. ppb(1).GT.0.0) rate(1)=-ALOG(ppb(1)/
     &                                                 ppbi(1))/dt
c ---    NOX:
         ppbix=ppbi(4)+ppbi(3)
         ppbx=ppb(4)+ppb(3)
         if(ppbix.GT.0.0 .AND. ppbx.GT.0.0) rate(2)=-ALOG(ppbx/ppbix)/dt
c ---    TNO3:  Conversion of NO2 after NO:NO2 process
         ppbi4=ppbi(4)+ppbi(3)-ppb(3)
         if(ppbi4.GT.0.0 .AND. ppb(4).GT.0.0) rate(3)=-ALOG(ppb(4)/
     &                                                 ppbi4)/dt
c ---    NO:
         delno=ppb(3)-ppbi(3)
         if(delno.LT.0.0) then
            if(ppbi(3).GT.0.0 .AND. ppb(3).GT.0.0) rate(4)=ALOG(ppb(3)/
     &                                                 ppbi(3))/dt
         elseif(delno.GT.0.0) then
            if(ppbi4.GT.0.0 .AND. ppb(4).GT.0.0) rate(4)=-ALOG(ppbi4/
     &                                                 ppbi(4))/dt
         endif
      endif

      if(q(5).gt.0.0)then
c
c ---    Adjust total ammonia for that absorbed by SO4 in the puff
         canh3=ctnh3-2.*ppb(2)
         if(canh3.gt.0.0)then
c
c ---       Compute NH4NO3 concentration from chemical equilibrium
            call CHEMEQ(canh3,ppb(5),rhum,temp,ppb(6),ehno3,ehn3,io6)
c
c --------- HNO3, NH4NO3 --------------
            pfrac=0.0
            if(ppb(5).gt.0.0)pfrac=ppb(6)/ppb(5)
c ---       Prevent round-off problem; PFRAC must be 0.0-1.0
            pfrac=amax1(pfrac,0.0)
            pfrac=amin1(pfrac,1.0)
            q(6)=q(5)*pfrac
         endif
      endif
c*****
      if(ldb1) then
         write(io6,*)'Ending Concs -----'
         write(io6,'(3x,6e10.2)') (ppb(j),j=1,6)
c         write(io6,102)pfrac,ppb(5),ehno3,ppb(6),ehn3,
c     1                 rhum,temp
c102      format(2x,'PFRAC=',f4.2,1x,'TNO3(ppb)=',f6.2,1x,
c     1    'HNO3(ppb)=',f6.2,1x,'NO3(ppb)=',f6.2,1x,'NH3(ppb)=',
c     2    f6.2,1x,'RHUM=',f4.0,1x,'TEMP=',f5.1)
      endif
c*****

c --- Transfer revised mass data to original array
      do is=1,iss
         qin(is)=q(is)
      enddo


      return
      end

c----------------------------------------------------------------------
      subroutine chmriv(PM,TEMPER,PRESUR,RH,O3AMB,RK1,ZCOEF,
     &                  TSTP,CONFCT)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980304                 CHMRIV
c                D. Strimaitis, Earth Tech
c
c --- ADOPTED FROM ARM3 (see banner below) 
c                Sulfate & nitrate conversion uses exponential fcn
c                Unused variables are deactivated
c
c----------------------------------------------------------------------
      SAVE
C
CDECK.CHMRIV
C
C  DATE: NOVEMBER 1987
C  VERSION: ARM3-1.0
C
C     CALCULATE TRANSFORMATION OF SO2 TO SO4 AND NO2 TO HNO3-NO3
C     FOR ONE TIME STEP, TSTP
C     BASED ON RIVAD CHEMICAL MECHANISM
C     ADPATED FROM THE RIVAD MODEL
C
C
C  INPUT ARGUMENTS:
C                   PM     R  MASS OF SPECIES (I) IN PUFF (G)
C                             SO2, SO4, NO, NO2, HNO3-NO3, TSP
C                   TEMPER R  TEMPERATURE AT PLUME HEIGHT (K)
C                   PRESUR R  PRESSURE AT PLUME HEIGHT (MB)
C                   RH     R  RELATIVE HUMIDITY AT PLUME (%)
C                   O3AMB  R  BACKGROUND OZONE CONCENTRATION (PPM)
C                   RK1    R  NO2 PHOTOLYSIS RATE CONSTANT (PPM/MIN)
C                   ZCOEF  R  COSONE OF SOLAR ZENITH ANGLE
C                   TSTP   R  TIME STEP (HOURS)
C                   CONFCT R  CONVERSION FACTOR FOR UG/M3 TO PPM-MWT
C
C  OUTPUT ARGUMENTS:
C                   PM     R  NEW MASS OF PUFF DUE TO CHANGES BASED ON
C
C
C  SUBROUTINES CALLED:
C
C  CALLED BY:
C
      DIMENSION PM(6),PPM(5),SMWT(5)
      LOGICAL LFIRST
      DATA LFIRST/.TRUE./
      DATA SMWT/64.0,96.0,30.0,46.0,63.0/
C
C     FIRST TIME THROUGH SET UP SOME GLOBAL RATE CONSTANTS
C
      IF (.NOT.LFIRST) GO TO 1
C
c dgs      RAD=1./572957.75913E-4
c dgs      CLDFAC=0.0
C
C
      TFACT=1./273.
c dgs      ONE3=1./3.
c dgs      RSO4=1./2.547E-4
      R26=1./26.4
c dgs      R33=1./3.33
c dgs      R38=1./3.821E-4
c dgs      R53=1./5.315E-4
c dgs      R44=1./4.43
      ROHM=4.87E-7/1.32E-3
c dgs      RSSUM=0.
c dgs      NSSUM=0
c dgs      IFRST=1
    1 CONTINUE
      LFIRST=.FALSE.
C
      DO 5 L=1,5
         PPM(L)=1.E6*CONFCT*PM(L)/SMWT(L)
    5 CONTINUE
C
      CNO=PPM(3)
      CNO2=PPM(4)
      CNOX=CNO+CNO2
C
      TAMB=TEMPER
      PAMB=PRESUR/1013.0
C
      IF (RK1.LE.0.0) THEN
         QJ=0.0
         PHIKK=0.0
      ELSE
         PHIKK=RK1*R26
         QJ=(1.338E-3)*ZCOEF**2.74
      ENDIF
   20 IF (TAMB.GE.273.)
     1RCONST=18.02*(597.3-.566*(TAMB-273.))/1.9869
      IF (TAMB.LT.273.) RCONST=6133.17
      RH1=RH
      IF (RH.GT.95.) RH1=95.
      IF (RH.LT.0.) RH1=0.
      H2O=(6030.*.01*RH1/PAMB)*EXP(RCONST*(TFACT-1./TAMB))
C
C  DO SIMPLE CHEMISTRY
C
      XNOX=CNOX
      XOX=O3AMB+CNO2
      SUM = XOX + XNOX + PHIKK
      XNO2 = 0.5*(SUM-SQRT(ABS(SUM*SUM-4.*XNOX*XOX)))
      IF (XNO2.GT.XNOX) XNO2=XNOX
      IF (XNO2.LT.0.) XNO2=0.
c dgs      XNO=XNOX-XNO2
c dgs      IF (XNO.LT.0.0) XNO=0.0
      RNO2X=0.
      IF (XNOX.GT.0.) RNO2X=XNO2/XNOX

c dgs Use NO2/NOX ratio to test for zero NO (single precision)
      xno=xnox-xno2
      if(rno2x.GE.0.999999) XNO=0.0

      XO3=XOX-XNO2
      IF (XO3.LT.0.) XO3=0.
      IF (ZCOEF.LT.0.06975) GO TO 55
C
C  DO DAYTIME CHEMISTRY
C
      XOHMAX=ROHM*QJ
      XOH=XOHMAX
      IF (PPM(1).NE.0..OR.XNO2.NE.0.)
     1XOH=2.*QJ*3.4E5*H2O*XO3/((4.45E10+3.4E5*H2O)*
     1  (2000.*PPM(1) + 14000.*XNO2))
      IF (XOH.GT.XOHMAX) XOH=XOHMAX

c dgs Use explicit exponential loss calculation here to obtain
c     fractional gain in sulfate and nitrate
c --- RSULF=1.2E5*XOH*TSTP*.3
c --- RNITR=8.4E5*XOH*TSTP*.3
      rsulf=1.-EXP(-1.2e5*xoh*tstp)
      rnitr=1.-EXP(-8.4e5*xoh*tstp)
c dgs

      GO TO 56
C
C  NIGHTTIME CHEMISTRY
C
   55 CONTINUE
      RSULF=0.
C     RNITR=.1*TSTP
C     DNO3=XNO2*RNITR
C     IF (DNO3.GT.XO3) DNO3=XO3
C     RNITR=0.
C     IF (XNO2.GT.0.) RNITR=DNO3/XNO2
C
C  IMPLEMENT NEW NIGHTTIME CHEMISTRY - 1/86
C
      RNITR=0.0
      IF (XO3.LT.0.) XO3=0.
      IF (XO3.LE.0.) GO TO 56
      RKX=1780./(1.9E-6*H2O + 3.12)
      RNO3=0.086
      A0=0.59 + 1780. -3.12*RKX
      A = 2.*RKX*RNO3-A0
      B = RNO3 + 0.0474*XO3 +XNO2*A0
      C = -0.0474*XNO2*XO3
C
      XNO3=-2.*C/(B+SQRT(B*B-4.*A*C))
      XN2O5 = XNO3*XNO2*RKX
      RNITRN = 2.*1.9E-6*H2O*XN2O5*60.*TSTP
c dgs      RRNITR=0.0
c dgs      IF (XNO2.GT.0.0) RRNITR=RNITRN*100./(XNO2*TSTP)
      IF (RNITRN.GT.XNO2) RNITRN=XNO2
      PPM(5) = PPM(5) + RNITRN
      XNO2 = XNO2 - RNITRN
      GO TO 66
   56 CONTINUE
C
C     DAYTIME CHEMISTRY
C
      RNITRD=RNITR*XNO2
      IF (RNITRD.GT.XNOX) RNITRD=XNOX
      PPM(5)=PPM(5)+RNITRD
      XNOX=XNOX-RNITRD
      IF (XNOX.LT.0.) XNOX=0.
      XNO=XNOX*(1.-RNO2X)
      XNO2=XNOX*RNO2X
   66 WSO4=0.002*PPM(1)*TSTP
      SULFN=PPM(1)*RSULF+WSO4
      IF (SULFN.GT.PPM(1)) SULFN=PPM(1)
      PPM(2)=PPM(2)+SULFN
      PPM(1)=PPM(1)-SULFN
C
C     UPDATE NEW STEADY-STATE NO AND NO2 VALUES
C
      PPM(3)=XNO
      PPM(4)=XNO2
C
C     CONVERT BACK TO GRAMS OF SPECIES IN PUFF
C
      DO 100 L=1,5
         PM(L)=1.E-6*PPM(L)*SMWT(L)/CONFCT
100   CONTINUE
      RETURN
      END

c----------------------------------------------------------------------
      subroutine phot(z,cloud,zcoef,factor,zcoefb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980304                   PHOT
c                D. Strimaitis, Earth Tech
c
c --- ADOPTED FROM ARM3 (see banner below):
c                Subroutine SOLAR has been moved outside of this
c                routine for use in CALPUFF
c
c----------------------------------------------------------------------
c     SUBROUTINE PHOT(rlat,rlong,tz,TIME,NYR,NMTH,NDAY,Z,
c    1                CLOUD,FACTOR,ZCOEF,ZCOEFB)
      SAVE
C
CDECK.PHOT
C
C  DATE:  NOVEMBER 1987
C  VERSION: ARM3-1.0
C
C     DETERMINE THE NO2 PHOTOLYSIS RATE CONSTANT FACTOR (1/PM-MIN)
C     AT A HEIGHT Z METERS ABOVE MSL FOR CBM-II MECHANISM
C     NOTE:  USE LONG/LAT FOR CENTER OF MASTER GRID
C            MODELING DOMAIN (108.0,41.0)
C            PHOTOLYSIS RATES FOR CBM-IV ARE HIGHER
C
C     REFERENCE:  THEORETICAL ESTIMATES OF ACTINIC (SPHERICALLY INTEGRATED
C            FLUX AND PHOTOLYTIC RATE CONSTANTS OF ATMOSPHERIC SPECIES
C            IN THE LOWER TROPOSPHERE
C            K. L. DEMERJIAN, K. L. SCHERE (EPA ESRL)
C            J. T. PETERSON (NOAA ARL)
C            ADVANCES IN ENVIROMENTAL SCIENCE AND TECHNOLOGY VOLUME 10
C
C
C
C  INPUT ARGUMENTS:
c --- not needed here---
C                   TIME  R  TIME OF DAY (MILTARY TIME 1 PM = 1300)
C                   NYR   I  YEAR (EG 1981)
C                   NMTH  I  MONTH (1-12)
C                   NDAY  I  DAY OF MONTHY (1-31)
c --- not needed here---
C                   Z     R  HEIGHT OF PLUME ABOVE MSL
C                   CLOUD R  FRACTION CLOUD COVER (0-10.0)
C
C  OUTPUT ARGUMENTS:
C                   FACTOR R  NO2 PHOTOLYSIS RATE (1/PPM-MIN)
c --- input arg now ZCOEF   R  COSINE OF SOLAR ZENITH ANGLE
C                   ZCOEFB  R  COSINE OF SOLAR ZENITH ANGLE ADJUSTED
C                              FOR CLOUD COVER
C
C  SUBROUTINES CALLED:
c --- not needed here---
C                   SOLAR
c --- not needed here---
C
C  CALLED BY:
C                   CHEMRIV
C
C
      DIMENSION RK1Z(16),ZEN(16)
      DIMENSION ZHT(11),FCTHT(16,11)
      DIMENSION FCTH1(16,6),FCTH2(16,5)
      DIMENSION CLDADJ(11)
      EQUIVALENCE (FCTHT(1,1),FCTH1),(FCTHT(1,7),FCTH2)
C***
C***  THESE K1 VALUES ARE AT MEAN SEA LEVEL (Z=0) HEIGHT ADJUSTMENTS
C***  ARE MADE THROUGH ARRAY FCTHT
C***
      DATA RK1Z/0.5129,0.5087,0.4963,0.4741,0.4568,0.4395
     1         ,0.4138,0.3881,0.3525,0.3168,0.2613,0.2058
     2         ,0.1406,0.0440,0.0218,0.0/
C
C     COSINE OF ZENITH ANGLES FOR K1 INTERPOLATION
C     (0,10,20,30,35,40,45,50,55,60,65,70,75,80,85,90)
C
      DATA ZEN/1.0000,0.9848,0.9397,0.8660,0.8192,0.7660,0.7071,0.6428
     1        ,0.5736,0.5000,0.4226,0.3420,0.2588,0.1736,0.0872,0.0000/
C
C     ARRAY ZHT IS HEIGHTS FOR INTERPOLATION
C
      DATA ZHT/0.0,150.0,360.0,640.0,980.0,1380.0,1840.0
     1        ,2350.0,2910.0,3530.0,4210.0/
C
C     ARRAY FCTHT IS ARRAY OF FACTORS FOR ADJUSTING SURFACE
C     K1 VALUES FOR GIVEN ZENITH ANGLES
C
      DATA FCTH1/1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000
     1          ,1.000,1.000,1.000,1.000,1.000,1.000,1.000,1.000
     2          ,1.061,1.061,1.065,1.069,1.074,1.078,1.085,1.091
     2          ,1.094,1.097,1.119,1.140,1.156,1.151,1.113,1.105
     3          ,1.115,1.116,1.122,1.132,1.140,1.147,1.159,1.171
     3          ,1.183,1.195,1.233,1.275,1.318,1.317,1.250,1.237
     4          ,1.167,1.169,1.178,1.191,1.202,1.213,1.230,1.247
     4          ,1.268,1.288,1.346,1.404,1.480,1.487,1.388,1.368
     5          ,1.216,1.219,1.229,1.246,1.261,1.275,1.296,1.317
     5          ,1.346,1.374,1.450,1.525,1.636,1.652,1.525,1.500
     6          ,1.260,1.263,1.276,1.296,1.312,1.330,1.356,1.381
     6          ,1.416,1.451,1.542,1.632,1.780,1.810,1.662,1.632/
      DATA FCTH2/1.298,1.303,1.317,1.340,1.359,1.377,1.407,1.436
     7          ,1.477,1.518,1.624,1.730,1.909,1.947,1.772,1.737
     8          ,1.333,1.338,1.354,1.379,1.401,1.422,1.455,1.487
     8          ,1.535,1.582,1.703,1.823,2.037,2.098,1.929,1.895
     9          ,1.365,1.370,1.388,1.417,1.440,1.463,1.500,1.537
     9          ,1.591,1.644,1.780,1.916,2.169,2.247,2.063,2.026
     O          ,1.395,1.401,1.420,1.451,1.477,1.503,1.544,1.585
     O          ,1.646,1.706,1.860,2.014,2.323,2.435,2.248,2.211
     1          ,1.422,1.429,1.449,1.484,1.512,1.540,1.586,1.631
     1          ,1.700,1.768,1.942,2.115,2.464,2.611,2.453,2.421/
C
C     CLDADJ(11) ARRAY OF K1 ADJUSTMENTS FOR CLOUD COVER
C     (0-10 CLEAR TO OVERCAST)
C     SOURCE: MAUL,1980
C
      DATA CLDADJ/1.0,0.91,0.84,0.79,0.75,0.72,0.68,0.62
     1               ,0.53,0.41,0.23/
C
C     CALCULATE COSINE OF SOLAR ZENITH ANGLE, ZCOEF
C     AND INTERPOLATE K1 FACTOR
C
C&      DO 33 JJ=1,6
C&      DO 22 II=1,16
C&      FCTHT(II,JJ)=FCTH1(II,JJ)
C&22    CONTINUE
C&33    CONTINUE
C&      DO 44 JJ=1,5
C&      DO 55 II=1,16
C&      FCTHT(II,JJ+6)=FCTH2(II,JJ)
C&55    CONTINUE
C&44    CONTINUE
C
C     DETERMINE HEIGHT ADJUSTMENT FACTORS
C
      IF (Z.GT.0.0) GO TO 2
      IZ1=1
      IZ2=1
      RATZ1=1.0
      RATZ2=0.0
      GO TO 8
2     CONTINUE
      DO 4 IZ=2,11
         IF (Z.LE.ZHT(IZ)) GO TO 6
4     CONTINUE
      IZ1=11
      IZ2=11
      RATZ1=1.0
      RATZ2=0.0
      GO TO 8
6     CONTINUE
      IZ1=IZ-1
      IZ2=IZ
      RATZ1=(ZHT(IZ2)-Z)/(ZHT(IZ2)-ZHT(IZ1))
      RATZ2=1.0-RATZ1
8     CONTINUE

c --- Remove call to SOLAR as result is passed as argument
C
C     NOTE SOLAR ACTUALLY WANTS NEGATIVE OF W. LONGITUDE
C                               (I.E. EAST LONGITUDE)
C
c --- CALL SOLAR(RLAT,RLONG,TZ,NYR,NMTH,NDAY,TIME,ZCOEF)
      FACTOR=0.0
      FACTZ=1.0
      IF (ZCOEF.LE.ZEN(16)) GO TO 100
      IF (ZCOEF.GE.ZEN(1)) GO TO 30
      DO 10 K=2,16
      IF (ZCOEF.GE.ZEN(K)) GO TO 20
10    CONTINUE
      WRITE(*,3000) ZCOEF,ZEN
3000  FORMAT(' $$ ERROR IN PHOT, ZCOEF= ',E12.4
     1,/,' ZEN= ',16E12.4)
      STOP1
20    CONTINUE
      Z1=(ZEN(K-1)-ZCOEF)/(ZEN(K-1)-ZEN(K))
      Z2=1.0-Z1
      FACTOR=(Z1*RK1Z(K)+Z2*RK1Z(K-1))
      FACTZ=(Z1*(RATZ1*FCTHT(K,IZ1)+RATZ2*FCTHT(K,IZ2)) +
     1       Z2*(RATZ1*FCTHT(K-1,IZ1)+RATZ2*FCTHT(K-1,IZ2)))
      GO TO 100
30    CONTINUE
      FACTOR=RK1Z(1)
      FACTZ=RATZ1*FCTHT(1,IZ1)+RATZ2*FCTHT(1,IZ2)
100   CONTINUE
C
C     ADJUST FOR HEIGHT
C
      FACTOR=FACTOR*FACTZ
C
C     ADJUST FOR CLOUD COVER
C
      ICLD=INT(CLOUD+1.01)
      IF (ICLD.GT.11) ICLD=11
      IF (ICLD.LT.1) ICLD=1
      FACTOR=CLDADJ(ICLD)*FACTOR
      ZCOEFB=ZCOEF*CLDADJ(ICLD)
C
C     CHECK FOR NIGHTTIME (K1 < .0015)
C
      IF (FACTOR.GE.0.0015) RETURN
C
C     NIGHTTIME SET FLAG TO TRUE AND ZERO OUT FACTOR
C
      FACTOR=0.0
      ZCOEF=0.0
      ZCOEFB=0.0
C
      RETURN
      END

c----------------------------------------------------------------------
      subroutine sundata(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                SUNDATA
c                D. Strimaitis, Earth Tech
c                Modified by F.Robe, Earth Tech
c
c --- PURPOSE:  This routine computes cloud cover and cosine of
c               solar zenith angle at each surface met station
c               or at each grid points if noobs CALMET mode
c
c --- UPDATES
c --- V5.7-V6.1    050915  (DGS): midpoint time used in /DATEHR/
c                                 with time resolved to seconds
c --- V5.4-V5.7    030402  (FRR): CALMET NOOBS update
c --- V5.4-V5.4    000602_4(DGS): add XBTZ from /DATEHR/, and remove
c                                 XTZ from /GRID/
c
c --- INPUTS:
c          LDB - logical - control for DEBUG output
c
c     Common block /DATEHR/ variables:
c           NYRM,NJULM,NHRM,NSECM,XBTZ
c     Common block /METHD/ variables:
c           I2DMET, XLATSS, XLONSS, NSSTA
c     Common block /GRID/ variables:
c           XLATM, XLONM
c     Common block /METHR/ variables:
c           QSWSS,QSW2D
c
c --- OUTPUT:
c     Common block /METHR/ variables:
c           CCSS, CZENSS, CC2D, CZEN2D
c
c --- SUNDATA called by: COMP
c --- SUNDATA calls:     SOLAR
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'datehr.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'grid.puf'

      logical ldb
c
c  Define necessary constants to calculate short-wave radiation
c
      data ha1/990./,ha2/-30./,hb1/-0.75/,hb2/3.4/

c --- Set decimal hour for SOLAR
      xhr=nhrm+FLOAT(nsecm)/3600.

c --- Set solar angle, and estimate clouds (10ths) from the solar
c --- radiation value obtained from the met file (qsw in W/m^2)

c frr(09/01)
c --- At all CALMET Grid points for 2D format met data

      if(i2dmet.EQ.1) then

         do 1 i=1,nxm
         do 1 j=1,nym

            call SOLAR(xlatm(i,j),xlonm(i,j),xbtz,njulm,xhr,zcoef)
c
c ---       Estimate cloud cover (tenths) using relation:
c ---       qsw=(ha1*zcoef+ha2)*(1.+hb1*ccfrac**hb2)
            cloud=0.0
            qsw=qsw2d(i,j)
            if(qsw.GT.0.0 .AND. zcoef.GT.0.0) then
c ---          Clear sky radiation
               qsw0=(ha1*zcoef+ha2)
               if(qsw.LT.qsw0) then
                  hb1i=1./hb1
                  hb2i=1./hb2
                  ccfrac=(hb1i*(qsw/qsw0-1.))**hb2i
                  cloud=10.*AMIN1(1.0,ccfrac)
               endif
            endif
c
            cc2d(i,j)=cloud
            czen2d(i,j)=zcoef

1        continue

      elseif(i2dmet.EQ.0) then

c ---    At surface stations only prior to CALMET V5.3 Level 010901
c ---    Loop over surface stations
         do i=1,nssta
            call SOLAR(xlatss(i),xlonss(i),xbtz,njulm,xhr,zcoef)
c
c ---       Estimate cloud cover (tenths) using relation:
c ---       qsw=(ha1*zcoef+ha2)*(1.+hb1*ccfrac**hb2)
            cloud=0.0
            qsw=qswss(i)
            if(qsw.GT.0.0 .AND. zcoef.GT.0.0) then
c ---          Clear sky radiation
               qsw0=(ha1*zcoef+ha2)
               if(qsw.LT.qsw0) then
                  hb1i=1./hb1
                  hb2i=1./hb2
                  ccfrac=(hb1i*(qsw/qsw0-1.))**hb2i
                  cloud=10.*AMIN1(1.0,ccfrac)
               endif
            endif
c
            ccss(i)=cloud
            czenss(i)=zcoef
         enddo

c ---    Conditional output
         if(ldb) then
            write(io6,*)'SUNDATA:'
            write(io6,*)'Yr, Day, Hour  : ',nyrm,njulm,xhr
            write(io6,*)'CCSS (tenths)    =',(ccss(i),i=1,nssta)
            write(io6,*)'CZENSS           =',(czenss(i),i=1,nssta)
         endif

      else
         write(*,*)'Subr. SUNDATA:  Invalid I2DMET = ',i2dmet
         stop
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine SOLAR(xlatss,xlonss,xbtz,njul,xhr,sinalp)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                  SOLAR
c
c --- From:
c --- CALMET   Version: 6.262     Level: 950531                   SOLAR
c ---          J. Scire, SRC
c ---          Modified by M. Fernau, 9/94, & J. Scire (5/95)
c
c --- CALPUFF Application:  all data placed in calling args, and a
c ---                       single location is processed
c
c --- PURPOSE:  Calculate sin(solar elevation angle) at surface
c               stations (in "base time zone" time)
c
c --- UPDATES
c --- V5.4-V6.1    050915  (DGS): XHR replaces NHR so that the actual
c                                 time (like 13.5) is used without
c                                 assuming that the time needs to be
c                                 shifted to the half-hour (or middle
c                                 of a time step)
c --- V5.4-V5.4    000602_4(DGS): XBTZ replaces IBTZ
c
c --- INPUTS:
c        XLATSS, XLONSS - real       - N. latitude, W. longitude
c                  XBTZ - real       - Base time zone (5.=EST, 6.=CST,
c                                      7.=MST, 8.=PST)
c                  NJUL - integer    - Julian day number
c                   XHR - real       - Time in hours from midnight that
c                                      corresponds to the middle of a
c                                      timestep
c
c --- OUTPUT:
c                SINALP - real       - Sine of the solar elevation
c                                      angle at location
c                                      (equals Cosine of Zenith angle)
c
c ---  SOLAR called by:  SUNDATA
c ---  SOLAR calls: none
c----------------------------------------------------------------------
c
c
c --- constant 0.9856479 = 360./365.242
c
      d = (float(njul) -1.) * 0.9856479
      radd = 0.0174533 * d
      xsind = sin(radd)
      xcosd = cos(radd)
      rad2d = 2. * radd
      sin2d = sin(rad2d)
      cos2d = cos(rad2d)
      em = 12. + 0.12357 * xsind - 0.004289 * xcosd + 0.153809
     &     * sin2d + 0.060783 * cos2d
      sigma = 279.9348 + d + 1.914827 * xsind - 0.079525 * xcosd
     &        + 0.019938 * sin2d - 0.00162 * cos2d
      sincd = 0.39784989 * sin(0.0174533 * sigma)
      capd = asin(sincd)
      coscd = cos(capd)
c
c --- calculate sine of solar elevation angle for surface station
c
        radlat = 0.0174533 * xlatss
        sinlat = sin(radlat)
        coslat = cos(radlat)
c
c --- constant 3.8197187 = 57.29578/15.
c
c ***   Needed only if sunrise/sunset times computed
c ***   caph = acos(-sinlat * sincd / (coslat * coscd)) * 3.8197187
c ***   dtemp = xslon(ista) / 15. + em - xbtz
c
c --- sunrise/sunset not currently needed
c
c ***   tsr = dtemp - caph
c ***   tss = dtemp + caph
c ***   write(io6,*) ' sunrise: ',tsr,' sunset: ',tss
c
c --- in GMT calculation:
c --- Variable 'xhr' is clock time (decimal hr) at which solar
c --- elevation is computed
c --- Zero negative values; these occur before sunrise or after sunset
c
          gmt = xhr + xbtz
          solha = 15. * (gmt - em) - xlonss
          sinalp = sinlat * sincd + coslat * coscd
     &             * cos(0.0174533 * solha)
          if (sinalp .lt. 0.) sinalp = 0.
      return
      end
c----------------------------------------------------------------------
      subroutine SSLATLON(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402               SSLATLON
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Compute N. Latitude and W. Longitude for the surface
c               met stations (from CALMET file)
c
c --- UPDATES
c --- V5.4(000602) to V5.7(030402)  (DGS): Replace coordinate routines
c --- V5.3-V5.4    000602  (DGS): add message to "stop"
c                  000602  (DGS): add Y2K to CALMET level check
c
c
c --- INPUTS:
c         LDB - logical  - Write results to list file when .TRUE.
c
c     Common block /METHD/ variables:
c           NSSTA, XSSTA(mxss),YSSTA(mxss)
c     Common block /GRID/ variables:
c           nx,ny,dgrid,xorig,yorig
c     Common block /MAP/ variables:
c           lutm,llcc,lps,lem,llaza,lttm,
c           iutmzn,feast,fnorth,
c           pmap,utmhem,datum,daten
c     Parameters:
c           MXSS, IO6
c
c --- OUTPUT:
c     Common block /METHD/ variables:
c           XLATSS(mxss), XLONSS(mxss)
c
c --- SSLATLON called by:  CHEMI
c --- SSLATLON calls:      GLOBE1, GLOBE
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'

      include 'methd.puf'
      include 'grid.puf'
      include 'map.puf'

      logical ldb

c --- For coordinate transformations
      character*8 cmapi,cmapo
      character*12 caction
      character*4 c4hem
      real*8 vecti(9),vecto(9)

c --- Scale factor for Tangential TM projection
      tmsone=1.00000

c --- Set translation vectors going from projection(x,y)km
c --- to N.lat/E.lon
      iutmi=iutmzn
      if(utmhem.EQ.'S   ' .AND. iutmzn.LT.900) iutmi=-iutmi
      cmapi=pmap
      if(cmapi.EQ.'TTM     ') cmapi='TM      '
      cmapo='LL      '
      idum=0
      rdum=0.0
      call GLOBE1(cmapi,iutmi,tmsone,xlat1,xlat2,rnlat0,relon0,
     &            feast,fnorth,
     &            cmapo,idum,rdum,rdum,rdum,rdum,rdum,
     &            rdum,rdum,
     &            caction,vecti,vecto)

c --- SW corner of grid in km
      xmap0=xorig*.001
      ymap0=yorig*.001

c --- Compute latitude/longitude of each surface station
      do i=1,nssta
c ---    Compute coordinates of the station (km)
         xkm=xmap0+xssta(i)*.001
         ykm=ymap0+yssta(i)*.001

c ---    Tranform to lat/lon
         call GLOBE(io6,caction,datum,vecti,datum,vecto,
     &              xkm,ykm,xelon0,xnlat0,izone,c4hem)
         xlatss(i)=xnlat0
         xlonss(i)=-xelon0
      enddo

      if(ldb) then
c ---    Debug Output
         write(io6,*)
         write(io6,*)'SSLATLON -- CALMET surface stations'
         write(io6,*)'         XMAP0,YMAP0 = ',xmap0,ymap0
         do i=1,nssta
            write(io6,*)'ista,xrelm,yrelm  = ',i,xssta(i),yssta(i)
            write(io6,*)'      nlat, wlon  = ',xlatss(i),xlonss(i)
         enddo
      endif

      return
      end

c----------------------------------------------------------------------
      subroutine METLATLON
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402              METLATLON
c                F.Robe, Earth Tech
c
c --- PURPOSE:  Compute N. Latitude and W. Longitude for all MET
c               gridpoints
c
c --- UPDATES
c --- V5.5(010901) to V5.7(030402)  (DGS): Replace coordinate routines
c                                          and put lat/lon into /GRID/
c
c --- INPUTS:
c         
c     Common block /GRID/ variables:
c           nx,ny,dgrid,xorig,yorig
c     Common block /MAP/ variables:
c           lutm,llcc,lps,lem,llaza,lttm,
c           iutmzn,feast,fnorth,
c           pmap,utmhem,datum,daten
c     Parameters:
c           IO6
c
c --- OUTPUT:
c
c     Common block /GRID/ variables:
c           XLATM(mxnx,mxny) - real - N.Latitude of MET gridpoints 
c           XLONM(mxnx,mxny) - real - W.Longitude of MET gridpoints 
c
c --- METLATLON called by:  SETUP
c --- METLATLON calls:      GLOBE1, GLOBE
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'

      include 'grid.puf'
      include 'map.puf'


c --- For coordinate transformations
      character*8 cmapi,cmapo
      character*12 caction
      character*4 c4hem
      real*8 vecti(9),vecto(9)

c --- Scale factor for Tangential TM projection
      tmsone=1.00000

c --- Set translation vectors going from projection(x,y)km
c --- to N.lat/E.lon
      iutmi=iutmzn
      if(utmhem.EQ.'S   ' .AND. iutmzn.LT.900) iutmi=-iutmi
      cmapi=pmap
      if(cmapi.EQ.'TTM     ') cmapi='TM      '
      cmapo='LL      '
      idum=0
      rdum=0.0
      call GLOBE1(cmapi,iutmi,tmsone,xlat1,xlat2,rnlat0,relon0,
     &            feast,fnorth,
     &            cmapo,idum,rdum,rdum,rdum,rdum,rdum,
     &            rdum,rdum,
     &            caction,vecti,vecto)

c --- SW corner of grid in km
      xmap0=xorig*.001
      ymap0=yorig*.001

c --- Cell step in km
      dgridkm=dgrid*.001

c --- Compute latitude/longitude of all MET gridpoints

      do i=1,nx
         do j=1,ny

c ---       Compute coordinates of the gridpoints(km)
            xkm=xmap0+(float(i)-0.5)*dgridkm
            ykm=ymap0+(float(j)-0.5)*dgridkm

c ---       Tranform to lat/lon
            call GLOBE(io6,caction,datum,vecti,datum,vecto,
     &           xkm,ykm,xelon0,xnlat0,izone,c4hem)
            xlatm(i,j)=xnlat0
            xlonm(i,j)=-xelon0
         enddo
      enddo

      return
      end

c----------------------------------------------------------------------
      subroutine risewind(ldbhr,lpuff,ncount,dzb,ii,ixs,iys,z0m,el,
     &                    dpbl,istab,dt,uadv,vadv,ws)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080204               RISEWIND
c                D. Strimaitis
c
c --- PURPOSE:  This routine computes the mean wind components for 
c               the transitional rise range
c
c --- UPDATES
c --- V5.0 to V6.23(080204)  (DGS): Trap case of falling puff because
c                                   it may lead to ZBOT>ZTOP in ADVECT
c
c --- INPUTS:
c        LDBHR - logical  - ouput debug information if .T.
c        LPUFF - logical  - puff if .T., slug if .F.
c       NCOUNT - integer  - number of iterations used to align mean
c                           wind speed and sampling step length for a
c                           fixed time interval
c          DZB - real     - distance from puff center to "top" (m)
c                           at beginning of step
c           II - integer  - puff index
c        IX,IY - integer  - Cell index of puff in MET grid
c          Z0M - real     - Surface roughness (m)
c           EL - real     - Monin-Obukhov length (m)
c         DPBL - real     - Depth of boundary layer (m)
c        ISTAB - integer  - PG stability class
c           DT - real     - duration of step (s)
c         UADV - real     - u-component of mean wind (m/s) @ final rise
c         VADV - real     - v-component of mean wind (m/s) @ final rise
c           WS - real     - wind speed (m/s) @ final rise
c
c
c --- OUTPUT:
c         UADV - real     - u-component of mean wind (m/s)
c         VADV - real     - v-component of mean wind (m/s)
c           WS - real     - mean wind speed (m/s)
c
c --- RISEWIND called by: COMP
c --- RISEWIND calls:     GRISE, ADVECT
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'puff.puf'
      include 'slug.puf'

      logical ldbhr,lpuff

      data zero/0.0/, half/0.5/, one/1.0/

c --- Set minimum value of transport wind speed
      data ucalm/0.001/

c --- Set counter
      icount=0

c --- Store wind at final rise
      ufnl=uadv
      vfnl=vadv

c --- Puff top/bottom at start of step (gradual rise)
      if(LPUFF) then
         xbeg=xtotb(ii)
      else
         xbeg=half*(xtotb(ii)+xtote(ii))
      endif
      if(xbeg.LT.xfinal(ii)) then
         call GRISE(xbeg,rbeg,facdum)
      else
         rbeg=zfinal(ii)
      endif
      rtop=rbeg+dzb
      rbot=rbeg-dzb
      rbot=AMAX1(rbot,zero)              

c --- Wind at beginning of step during rise
      call ADVECT(ldbhr,ixs,iys,z0m,el,dpbl,istab,ht0(ii),
     &            rbot,rtop,ub,vb)
      wsb=SQRT(ub**2+vb**2)
      ws=AMAX1(wsb,ucalm)

c --- Top of iteration section
10    icount=icount+1

c --- Step length for current wind speed
      dxb=ws*dt

c --- Puff range from beginning to end of step (just rise; no growth)
      xend=xbeg+dxb
      if(xend.LT.xfinal(ii)) then
         call GRISE(xend,rend,facdum)
      else
         rend=zfinal(ii)
      endif
      if(rend.GE.rbeg) then
c ---    Rising
         rbot=rbeg-dzb
         rtop=rend+dzb
      else
c ---    Falling
         rbot=rend-dzb
         rtop=rbeg+dzb
      endif
      rbot=AMAX1(rbot,zero)              

c --- Average wind in rise layer
      call ADVECT(ldbhr,ixs,iys,z0m,el,dpbl,istab,ht0(ii),
     &            rbot,rtop,ugr,vgr)

c --- Average wind during step
      if(xend.GT.xfinal(ii)) then
         ffinal=one-xfinal(ii)/xend
         uadv=(one-ffinal)*ugr+ffinal*ufnl
         vadv=(one-ffinal)*vgr+ffinal*vfnl
      else
         uadv=ugr
         vadv=vgr
      endif
      ws=SQRT(uadv**2+vadv**2)

      if(LDBHR) then
         write(io6,*)
         write(io6,*)'RISEWIND:  pass ',icount
         write(io6,*)'xbeg, xend, xfnl = ',xbeg, xend, xfinal(ii)
         write(io6,*)'rbot, rtop       = ',rbot, rtop
         write(io6,*)'u,v final rise   = ',ufnl,vfnl
         write(io6,*)'u,v gradual rise = ',ugr,vgr
         write(io6,*)'u,v transport    = ',uadv,vadv
         write(io6,*)
      endif

c --- Refine estimate of average wind (limited by NCOUNT)
      if(icount.LT.ncount) goto 10

      return
      end
c----------------------------------------------------------------------
      function asdf(ldb,rrec,syrec)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 981025                   ASDF
c                D. Strimaitis,    Earth Tech
c
c --- PURPOSE:  Compute the Area Source Distribution Factor as the
c               ratio of concentration due to a puff from a finite
c               line source to the concentration due to a puff with
c               an equivalent initial sigma-y
c
c --- UPDATE
c --- V5.0-V5.0     981025  (DGS): Treat limiting case with sya=0
c
c --- INPUTS:
c               LDB - logical - Write debug information when TRUE
c              RREC - real    - Puff-Receptor distance at nearest point
c                               during sampling step (m)
c             SYREC - real    - Sigma-y at receptor (m), including any
c                               initial size used to represent the area
c                               source distribution
c
c     Common Block /CURRENT/ variables:
c        SY0SQ, ISTYPE
c     Parameters:
c        IO6
c
c --- OUTPUTS:
c             ASDF  - real    - Area source distribution factor
c
c
c --- ASDF called by:  CALCPF, SLUGSNP, SLUGINT
c --- ASDF calls:      ERF, ERFDIF
c----------------------------------------------------------------------
c
c --- Include parameter block
      include 'params.puf'

c --- Include common blocks
      include 'current.puf'

      logical ldb, lsigok
      data half/0.5/, rthalf/.7071068/, rt2pi/2.5066283/

      asdf=1.0
      if(istype.LT.3 .OR. istype.GT.4) return

c --- Length scale used for initial lateral scale of area source
      sy0=SQRT(sy0sq)
      elby2=half*sy0*rt2pi

c --- Sigma-y without initial source contribution (sya)
      syasq=syrec**2-sy0sq
      if(syasq.GT.0.0) then
         lsigok=.TRUE.
         syainv=1./SQRT(syasq)
      else
c ---    Ambient sigma not important: distribution has sharp edge
c ---    so that ERFDIF result is 2.0 if receptor is within the
c ---    distribution, or it is 0.0 if outside the distribution
         lsigok=.FALSE.
         ediff=0.0
         if((elby2-ABS(rrec)).GE.0.0) ediff=2.0
      endif

c --- Set arguments for function calls
      fac=half*syrec/sy0
      if(LSIGOK) then
         arg2=rthalf*(rrec+elby2)*syainv
         arg3=rthalf*(rrec-elby2)*syainv
      endif
      arg4=(rthalf*rrec/syrec)**2

c --- Compute factor
      if(LSIGOK) then
         asdf=fac*ERFDIF(arg2,arg3)/EXP(-arg4)
      else
         asdf=fac*ediff/EXP(-arg4)
      endif

c --- Debug output
      if(LDB) then
         write(io6,*)
         write(io6,*)'ASDF:  correction factor for area source puff'
         write(io6,*)'---------------------------------------------'
         write(io6,*)'  rec dist, sigy (m) = ',rrec,syrec
         write(io6,*)'     source sigy (m) = ',sy0
         write(io6,*)'L/2(area source) (m) = ',elby2
         write(io6,*)'                ASDF = ',asdf
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine nextfil(nx,ny,ifound)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                NEXTFIL
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Prepare the next CALMET.DAT file data records if
c               multiple files are used
c
c --- UPDATE
c --- V5.2-V6.1     050915  (DGS): Add FILVERS call for dataset version
c --- V5.0-V5.2     991104  (DGS): Trap cases where imetdat.GE.nmetdat,
c                                  not just imetdat.EQ.nmetdat
c
c --- INPUTS:
c              NX,NY - integer - Met grid cell number
c
c     Common block /FILNAM/ variables:
c           METDATL, NMETDAT, IMETDAT
c
c --- OUTPUT:
c             IFOUND - integer - Flag indicating if more data records
c                                are available (1=yes)
c     Common block /DATASET/ variables:
c           vermet
c
c --- Parameters used:
c        IO7,MXMETDAT
c
c --- NEXTFIL called by: RDMET
c --- NEXTFIL calls:     FILVERS, MET1
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'dataset.puf'
      include 'filnam.puf'
      include 'wrkspc.puf'

      logical lprt

c --- Close the current CALMET.DAT file
      close(io7)

c --- Screen out obvious cases
      if(imetdat.GE.nmetdat) then
         ifound=0
         return
      endif

c --- Open the next data file in the list
      imetdat=imetdat+1
      k=imetdat
      call FILVERS(io7,'BIN',metdatl(k),'CALMET          ',vercmet)
      open(io7,file=metdatl(k),status='old',form='unformatted')

c --- Read and check the header records
      lprt=.false.
      call MET1(nx,ny,lprt,tmp1,nw1)

c --- Set flag to 'yes'
      ifound=1

      return
      end

c----------------------------------------------------------------------
      subroutine mflxset(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                MFLXSET
c                D. Strimaitis, Earth Tech
c
c --- UPDATES:
c --- V5.4-V5.7    030402  (DGS): add /MAP/
c --- V5.2-V5.4    000602  (DGS): add message to "stop"
c --- V5.1-V5.2    991104  (JSS): Error messages written to list
c                                 file as well as to screen
c
c --- PURPOSE:  Setup functions for the Mass Flux module
c                 -- Read user-supplied boundary line(s) (FLUXBDY.DAT)
c                 -- Convert points to MET GRID Units
c                 -- Identify MET GRID cells with boundary segments
c                 -- Compute slope/intercept for boundary segments
c
c --- INPUTS:
c              LDB - logical  - Flag controlling printing of internal
c                               data (F=suppress, T=print)
c
c     Common block /MAP/ variables
c              IUTMZN
c
c     Parameters:
c         MXBNDRY, IO35, IO6
c
c --- OUTPUT:
c     Common block /MFLUX/ variables
c
c --- MFLXSET called by: SETUP
c --- MFLXSET calls:     none
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'mflux.puf'
      include 'grid.puf'
      include 'map.puf'
c
      logical ldb,problem,linr

      character*12 datatype,vrsbdy,labbdy
      character*40 avar(2)

      problem=.FALSE.

c --- Set local variable for a difference (MET Grid Units) small
c --- enough to be treated as ZERO
      dsmall=0.000001

c --- Read user-specified boundary data (FLUXBDY.DAT)
c ----------------------------------------------------
c --- Header record
      read(io35,*,end=997) datatype,nbndry,iutmbdy,vrsbdy,labbdy

c --- Perform QA checks
      if(datatype.NE.'FLUXBDY' .AND. datatype.NE.'fluxbdy')then
         write(io6,*)'ERROR in subr. MFLXSET -- Data Type label',
     1   ' in FLUXBDY.DAT file does not match expected value ',
     2   '-- Found ',datatype,' Expected FLUXBDY or fluxbdy'
         problem=.TRUE.
      endif

      if(iutmbdy.NE.iutmzn)then
         write(io6,*)'ERROR in subr. MFLXSET -- Value of UTM zone',
     1   ' in FLUXBDY.DAT file does not match control file value ',
     2   '-- IUTMBDY = ',iutmbdy,' IUTMZN = ',iutmzn
         problem=.TRUE.
      endif

      if(nbndry.GT.mxbndry)then
         write(io6,*)'ERROR in subr. MFLXSET -- Number of boundaries',
     1   ' in FLUXBDY.DAT file exceeds maximum parameter ',
     2   '-- NBNDRY = ',nbndry,' MXBNDRY = ',mxbndry
         write(io6,*)'NOTE:  Keep mxbndry.LE.20 to avoid line length'
         write(io6,*)'       problems in the mass flux output file'
         problem=.TRUE.
      endif

      if(PROBLEM) goto 998

c --- Data records:  Loop over boundary line(s) provided
      problem=.FALSE.
      nsegbdy=0
      ibndry=0
10    read(io35,*,end=990) avar
      if(avar(1)(1:1).EQ.'I' .OR. avar(1)(1:1).EQ.'i') then
c ---    New boundary
c --------------------
         if(ibndry.GT.0) then
c ---       Terminate previous line
            if(nsegbdy.GT.npbndry(1,ibndry)) then
c ---          Previous line OK, set pointer to end of last segment
               npbndry(2,ibndry)=nsegbdy
               if(.not.LINR) then
c ---             Points defined with INSIDE to the Left along
c ---             boundary path, so these points were placed
c ---             at the END of array in reverse order to comply with
c ---             the internal convention.
c ---             Move the NEND points up.
                  do k=1,nend
                     ipos=npbndry(2,ibndry)-nend+k
                     iend=mxptbdy-nend+k
                     do i=1,2
                        bndrygrd(i,ipos)=bndrygrd(i,iend)
                     enddo
                  enddo
                  nend=0
               endif
            else
c ---          Previous line has less than 2 points -- remove it!
               nsegbdy=MAX(0,npbndry(1,ibndry)-1)
               ibndry=MAX(0,ibndry-1)
               problem=.TRUE.
            endif
         endif
c ---    Initiate new line
         ibndry=ibndry+1
         npbndry(1,ibndry)=nsegbdy+1
         if(avar(1).EQ.'IR') then
            LINR=.TRUE.
         else
            LINR=.FALSE.
            nend=0
         endif
c ---    Place boundary name into storage array
         cnambdy(ibndry)=avar(2)(1:16)
      else
c ---    Current Line
c ------------------------
c ---    Get position from arrays
         read(avar(1),'(f10.3)') xkm
         read(avar(2),'(f10.3)') ykm
c ---    Convert coordinates from (km) to MET GRID Units
         xbdymg=(1000.*xkm-xorig)*dgridi
         ybdymg=(1000.*ykm-yorig)*dgridi
         if(nsegbdy.LT.npbndry(1,ibndry)) then
c ---       First point along line:  store it
            nsegbdy=nsegbdy+1
            if(nsegbdy.GT.mxptbdy) goto 996
            if(LINR) then
               bndrygrd(1,nsegbdy)=xbdymg
               bndrygrd(2,nsegbdy)=ybdymg
            else
               nend=nend+1
               iend=mxptbdy+1-nend
               bndrygrd(1,iend)=xbdymg
               bndrygrd(2,iend)=ybdymg
            endif
         else
c ---       Compute number of points to store (separation < grid cell)
            k=iend
            if(LINR) k=nsegbdy
            dxstep=xbdymg-bndrygrd(1,k)
            dystep=ybdymg-bndrygrd(2,k)
            step=AMAX1(ABS(dxstep),ABS(dystep))
            if(step.GT.0.5) then
               nstep=2*step
               dxstep=dxstep/FLOAT(nstep)
               dystep=dystep/FLOAT(nstep)
            else
               nstep=1
            endif
c ---       Loop over points
            do istep=1,nstep
               nsegbdy=nsegbdy+1
               if(nsegbdy.GT.mxptbdy) goto 996
               if(LINR) then
                  bndrygrd(1,nsegbdy)=bndrygrd(1,nsegbdy-1)+dxstep
                  bndrygrd(2,nsegbdy)=bndrygrd(2,nsegbdy-1)+dystep
               else
                  nend=nend+1
                  iend=mxptbdy+1-nend
                  bndrygrd(1,iend)=xbdymg
                  bndrygrd(2,iend)=ybdymg
                  bndrygrd(1,iend)=bndrygrd(1,iend+1)+dxstep
                  bndrygrd(2,iend)=bndrygrd(2,iend+1)+dystep
               endif
            enddo
         endif
      endif

c --- Next record
      goto 10

c --- End of data reached in file   
990   if(ibndry.GT.0) then
c ---    Terminate previous line
         if(nsegbdy.GT.npbndry(1,ibndry)) then
c ---       Line OK, set pointer to end of last segment
            npbndry(2,ibndry)=nsegbdy
            if(.not.LINR) then
c ---          Points defined with INSIDE to the Left along boundary
c ---          path, so these points were placed at the END of array
c ---          in reverse order to comply with internal convention.
c ---          Move the NEND points up.
               do k=1,nend
                  ipos=npbndry(2,ibndry)-nend+k
                  iend=mxptbdy-nend+k
                  do i=1,2
                     bndrygrd(i,ipos)=bndrygrd(i,iend)
                  enddo
               enddo
               nend=0
            endif
         else
c ---       Line has less than 2 points -- remove it!
            nsegbdy=MAX(0,npbndry(1,ibndry)-1)
            ibndry=MAX(0,ibndry-1)
            problem=.TRUE.
         endif
      endif

      if(ibndry.LE.0) goto 997

c --- Compute slope 'em' and intercept 'be' for each segment
c ----------------------------------------------------------
c --- Loop over boundary lines
      do ic=1,ibndry
c ---    Loop over segments in line
         do is=npbndry(1,ic),npbndry(2,ic)-1
            dx=bndrygrd(1,is+1)-bndrygrd(1,is)
            dy=bndrygrd(2,is+1)-bndrygrd(2,is)
            if(ABS(dx).LE.dsmall) then
c ---          Segment is assumed to be vertical (N/S)
               em=9.91e10
               be=9.91e10
            else
               em=dy/dx
               be=bndrygrd(2,is)-em*bndrygrd(1,is)
            endif
            ymxpbm(1,is)=em
            ymxpbm(2,is)=be
         enddo
c ---    Place data for last segment into end-point location also
         ymxpbm(1,npbndry(2,ic))=em
         ymxpbm(2,npbndry(2,ic))=be
      enddo


c --- Identify met grid cells touched by at least 1 boundary
c -----------------------------------------------------------
c --- Initialize LBNDRY array
      do j=1,ny
         do i=1,nx
            lbndry(i,j)=.FALSE.
         enddo
      enddo
c --- Loop over boundary lines
      do ic=1,ibndry
c ---    Loop over segments in line
         do is=npbndry(1,ic),npbndry(2,ic)
            ix=1+bndrygrd(1,is)
            iy=1+bndrygrd(2,is)
            if(ix.GE.1 .AND. ix.LE.nx) then
               if(iy.GE.1 .AND. iy.LE.ny) then
                  lbndry(ix,iy)=.TRUE.
               endif
            endif
         enddo
      enddo

c --- Documentation for LIST file
      write(io6,*)
      write(io6,*)'MFLXSET ---------------'
      write(io6,*)'Boundaries derived from data provided in ',
     &            'FLUXBDY.DAT file'
      write(io6,*)'Number of boundaries     = ',ibndry
      write(io6,*)'Boundary Names:'
         write(io6,'(10x,a)') (cnambdy(ib),ib=1,ibndry)
      write(io6,*)'Total number of segments = ',nsegbdy
      write(io6,*)
      write(io6,*)'Met Grid cells containing boundary segments:'
      write(io6,*)'   (Grid North)'
      do j=ny,1,-1
         write(io6,'(1000L2)') (lbndry(i,j),i=1,nx)
      enddo

c --- Additional DEBUG Output Section
c -----------------------------------
      if(LDB.OR.PROBLEM) then
         do ibdy=1,ibndry
            write(io6,*)
            write(io6,*)'  Boundary ',ibdy
            write(io6,*)'  Located in array elements ',npbndry(1,ibdy),
     &                  ' to ',npbndry(2,ibdy)
            write(io6,*)'  (x,y){MET Grid Units} '
            do i=npbndry(1,ibdy),npbndry(2,ibdy)
               write(io6,*) (bndrygrd(k,i),k=1,2)
            enddo
            write(io6,*)
            write(io6,*)'  (slope,intercept) {MET Grid Units}'
            do i=npbndry(1,ibdy),npbndry(2,ibdy)
               write(io6,*) (ymxpbm(k,i),k=1,2)
            enddo
         enddo
      endif

c --- Perform QA check on number of boundaries processed
      if(ibndry.NE.nbndry) then
         write(io6,*)'ERROR in subr. MFLXSET -- Number of boundaries',
     1   ' in FLUXBDY.DAT file does not match expected value ',
     2   '-- Found ',ibndry,' Expected ',nbndry
         goto 998
      endif

      return

996   write(io6,*)'ERROR in subr. MFLXSET -- No. of line segments',
     &   ' exceeds maximum parameter MXPTBDY = ',mxptbdy
      write(*,*)
      stop 'Halted in MFLXSET -- see list file.'
997   write(io6,*)'FATAL Error: FLUXBDY.DAT file empty or incomplete'
      write(io6,*)'FLUXBDY.DAT file empty or incomplete'
      write(*,*)
      stop 'Halted in MFLXSET -- see list file.'
998   write(*,*)
      stop 'Halted in MFLXSET -- see list file.'
c
      end
c----------------------------------------------------------------------
      subroutine mflxhdr(title)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                MFLXHDR
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Writes header records to the Mass Flux file
c
c --- UPDATE
c --- V5.2-V6.1     050915  (DGS): end time used with seconds
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c
c --- INPUTS:
c         TITLE(3) - Char.*80 - Run title (3 lines of 80 char. each)
c
c     Common block /MFLUX/ variables
c         CNAMBDY(mxbndry)
c     Common block /GEN/ variables
c         NGRUP
c     Common block /OUTPT/ variables
c         IOUTOP(7,mxspec)
c
c     Parameters:
c         MXGRUP, MXBNDRY, IO36, IO6
c
c --- OUTPUT:
c             none
c
c --- MFLXHDR called by: SETUP
c --- MFLXHDR calls:     none
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'mflux.puf'
      include 'gen.puf'
      include 'outpt.puf'
c
      character*80 title(3)
      character*16 datehr
      character*12 specnm
      character*24 cinout

      data cinout/'     In        Out      '/
      data datehr/'Year Day Hr Sec '/
      data specnm/'  Species   '/

c --- Identify species-groups with reported mass flux
      numgrp=0
      do i=1,ngrup
         if(ioutop(7,i).EQ.1) then
            numgrp=numgrp+1
         endif
      enddo
      if(numgrp.EQ.0) then
         write(*,*)'MFLXHDR:  Error Found in Control File Group 5'
         write(*,*)'No species selected for Mass Flux Output'
         write(io6,*)'MFLXHDR:  Error Found in Control File Group 5'
         write(io6,*)'No species selected for Mass Flux Output'
      endif

      write(io36,'(a)') title
      write(io36,*)
      write(io36,'(t30,a)')'---------------'
      write(io36,'(t30,a)')'   Mass Flux'
      write(io36,'(t30,a)')'     (g/s)'
      write(io36,'(t30,a)')'---------------'
      write(io36,*)
      write(io36,'(21x,20(8x,a16))') (cnambdy(i),i=1,nbndry)
      write(io36,'(a16,a12,20a24)') datehr,specnm,(cinout,i=1,nbndry)
      write(io36,*)

      return
c
      end
c----------------------------------------------------------------------
      subroutine mflxini
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 990228d               MFLXINI
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Initializes data arrays for mass flux output
c
c --- UPDATE
c --- V5.0-V5.0     990228d (DGS): initialize ZERO/0.0/
c
c --- INPUTS:
c
c     Common block /GEN/ variables
c         NSPEC
c     Common block /MFLUX/ variables
c         NBNDRY, FLXIN(mxspec,mxbndry), FLXOUT(mxspec,mxbndry)
c
c     Parameters:
c         MXSPEC, MXBNDRY
c
c --- OUTPUT:
c             none
c
c --- MFLXINI called by: COMP
c --- MFLXINI calls:     INITR2D
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'gen.puf'
      include 'mflux.puf'
c
      data zero/0.0/

      call INITR2D(zero,mxspec,mxbndry,nspec,nbndry,flxin)
      call INITR2D(zero,mxspec,mxbndry,nspec,nbndry,flxout)

      return
c
      end
c----------------------------------------------------------------------
      subroutine mflxgrp(ig,is)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 990228c               MFLXGRP
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Sum results for individual species into output groups
c
c --- INPUTS:
c             IG - integer - Species index used to sum current group
c             IS - integer - Species index to add to current group
c
c     Common block /MFLUX/ variables
c         NBNDRY, FLXIN(mxspec,mxbndry), FLXOUT(mxspec,mxbndry)
c
c     Parameters:
c         MXSPEC, MXBNDRY
c
c --- OUTPUT:
c     Common block /MFLUX/ variables
c         FLXIN(mxspec,mxbndry), FLXOUT(mxspec,mxbndry)
c
c --- MFLXGRP called by: OUTPUT
c --- MFLXGRP calls:     none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'mflux.puf'

c --- Loop over boundaries and sum mass fluxes of species 'is' to
c --- group total in species 'ig'
      do ib=1,nbndry
         flxin(ig,ib)=flxin(ig,ib)+flxin(is,ib)
         flxout(ig,ib)=flxout(ig,ib)+flxout(is,ib)
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine mflxout(istore)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                MFLXOUT
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Write selected mass fluxes for hour to output file
c
c --- UPDATE
c --- V5.2-V6.1     050915  (DGS): end time used with seconds
c                           (DGS): end of day time reset to 2400
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c
c --- INPUTS:
c
c   ISTORE(mxgrup) - integer - Species index of mass flux arrays used
c                              to store summed results for group
c
c     Common block /DATEHR/ variables
c         NYRE, NJULE, NHRE, NSECE
c     Common block /GEN/ variables
c         NGRUP, CGRUP(mxgrup)
c     Common block /MFLUX/ variables
c         NBNDRY, FLXIN(mxspec,mxbndry), FLXOUT(mxspec,mxbndry)
c     Common block /OUTPT/ variables
c         IOUTOP(7,mxspec)
c
c     Parameters:
c         MXGRUP, MXSPEC, MXBNDRY, IO36
c
c --- OUTPUT:
c             none
c
c --- MFLXOUT called by: OUTPUT
c --- MFLXOUT calls:     MIDNITE
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'datehr.puf'
      include 'gen.puf'
      include 'mflux.puf'
      include 'outpt.puf'

      integer istore(mxgrup)

c --- Change hour in time label from 00 to 24 if period ends at 2400
      imo=0
      iday=0
      if(nhre.EQ.0 .AND. nsece.EQ.0) then
         call MIDNITE(io6,'TO 24h',nyre,imo,iday,njule,
     &                nyr,kmo,kday,njul)
         nhr=24
      else
         nyr=nyre
         njul=njule
         nhr=nhre
      endif

c --- Loop over groups and write those requested by user
      do i=1,ngrup
         if(ioutop(7,i).EQ.1) then
            j=istore(i)
            write(io36,99) nyr,njul,nhr,nsece,cgrup(i),
     &              (flxin(j,ib),flxout(j,ib),ib=1,nbndry)
         endif
      enddo

99    format(i4,i4,i3,i5,2x,a12,50e12.5)
      return
      end
c----------------------------------------------------------------------
      subroutine mflxcmp(ldb0,lslug,nspec,qtot)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 990228d               MFLXCMP
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Update mass flux totals for current puff, for current
c               (sub)step
c
c --- UPDATE
c --- V5.0-V5.0     990228d (DGS): remove real argument from MAX/MIN
c
c --- INPUTS:
c
c             LDB0 - logical  - Flag controlling printing of internal
c                               data (F=suppress, T=print)
c            LSLUG - logical  - Slug flag (F=puff, T=slug)
c            NSPEC - integer  - Number of species
c     QTOT(mxspec) - real     - Total average puff mass over step (g)
c
c     Common block /CURRENT/ variables
c         XB1,YB1,XE1,YE1
c         XB2,YB2,XE2,YE2
c     Common block /GRID/ variables
c         NX, NY, DGRIDI, DGRID
c     Common block /MFLUX/ variables
c         NBNDRY, LBNDRY(mxnx,mxny), YMXPBM(2,mxptbdy),
c         NPBNDRY(2,mxbndry), BNDRYGRD(2,mxptbdy),
c         FLXIN(mxspec,mxbndry), FLXOUT(mxspec,mxbndry)
c
c     Parameters:
c         MXNX, MXNY, MXNXY,
c         MXSPEC, MXBNDRY, MXPTBDY, IO6
c
c --- OUTPUT:
c     Common block /MFLUX/ variables
c         FLXIN(mxspec,mxbndry), FLXOUT(mxspec,mxbndry)
c
c --- MFLXCMP called by: COMP
c --- MFLXCMP calls:     none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'current.puf'
      include 'grid.puf'
      include 'mflux.puf'
c
      real qtot(mxspec)
      logical ldb0,lslug,ldb,lold,lnew

c --- Set local variable for a difference (MET Grid Units) small
c --- enough to be treated as ZERO
      data dsmall/0.000001/

c --- Set the factor to convert the mass accumulated over an hour
c --- to a mass/s = (1/3600)
      data persec/2.777778e-4/

c --- Introduce ldb to allow override of ldb0
      ldb=ldb0
c --- ldb=.FALSE.

c ------------------------------------------------------------
c --- Convert trajectory locations to met grid units and met
c --- cell index, and test for presence of boundary near step
c ------------------------------------------------------------

c --- Puff or Old-Slug-End
      xb1met=xb1*dgridi
      yb1met=yb1*dgridi
      xe1met=xe1*dgridi
      ye1met=ye1*dgridi
      ixb1=1+xb1met
      iyb1=1+yb1met
      ixe1=1+xe1met
      iye1=1+ye1met
      ixb1=MIN(nx,ixb1)
      iyb1=MIN(ny,iyb1)
      ixe1=MIN(nx,ixe1)
      iye1=MIN(ny,iye1)
      ixb1=MAX(1,ixb1)
      iyb1=MAX(1,iyb1)
      ixe1=MAX(1,ixe1)
      iye1=MAX(1,iye1)
c --- Check cells in step range to see if any contain a boundary
      lold=.FALSE.
      idy=1
      if(iyb1.GT.iye1) idy=-1
      idx=1
      if(ixb1.GT.ixe1) idx=-1
      do iy=iyb1,iye1,idy
         do ix=ixb1,ixe1,idx
            if(LBNDRY(ix,iy)) lold=.TRUE.
         enddo
      enddo

c --- Process new-slug-end locations if SLUG
      lnew=.FALSE.
      if(LSLUG) then
         xb2met=xb2*dgridi
         yb2met=yb2*dgridi
         xe2met=xe2*dgridi
         ye2met=ye2*dgridi
         ixb2=1+xb2met
         iyb2=1+yb2met
         ixe2=1+xe2met
         iye2=1+ye2met
         ixb2=MIN(nx,ixb2)
         iyb2=MIN(ny,iyb2)
         ixe2=MIN(nx,ixe2)
         iye2=MIN(ny,iye2)
         ixb2=MAX(1,ixb2)
         iyb2=MAX(1,iyb2)
         ixe2=MAX(1,ixe2)
         iye2=MAX(1,iye2)
         idy=1
         if(iyb2.GT.iye2) idy=-1
         idx=1
         if(ixb2.GT.ixe2) idx=-1
         do iy=iyb2,iye2,idy
            do ix=ixb2,ixe2,idx
               if(LBNDRY(ix,iy)) lnew=.TRUE.
            enddo
         enddo
      endif

c --- Assume mass of slug is divided evenly between both ends
      factor=persec
      if(LSLUG) factor=0.5*factor
      do n=1,nspec
         qtot(n)=factor*qtot(n)
      enddo

10    continue
      if(LOLD) then
c ---    Set up for a puff, or the old end of a slug
         xs=xb1met
         ys=yb1met
         xe=xe1met
         ye=ye1met
         ixs=ixb1
         iys=iyb1
         ixe=ixe1
         iye=iye1
         lold=.FALSE.
      elseif(LNEW) then
c ---    Set up for the new end of a slug
         xs=xb2met
         ys=yb2met
         xe=xe2met
         ye=ye2met
         ixs=ixb2
         iys=iyb2
         ixe=ixe2
         iye=iye2
         lnew=.FALSE.
      else
         goto 999
      endif

c ---    DEBUG Output Section
c ---------------------------
      if(LDB) then
         write(io6,*)
         write(io6,*)'MFLXCMP ---------------'
         write(io6,*)'Type of puff/slug (LOLD,LNEW): ',lold,lnew
         write(io6,*)'Mass/s contributed by this puff/slug-end:'
         write(io6,*)(qtot(n),n=1,nspec)
         write(io6,*)'Boundary segments screened for intersection in'
         write(io6,*)'(ixs,iys) to (ixe,iye): ',ixs,iys,ixe,iye
      endif

c -------------------------------------------------------------
c --- Process boundary segment(s) that puff trajectory crosses
c -------------------------------------------------------------
c --- Set sampling step vector components and length
      dxp=xe-xs
      dyp=ye-ys
      dp0=ABS(dxp)+ABS(dyp)
      if(dp0.LE.dsmall) then
c ---    This puff is not moving across any boundaries
         goto 999
      elseif(ABS(dxp).LE.dsmall) then
c ---    Trajectory is assumed to be vertical (N/S)
         slope=9.91e10
         bintr=9.91e10
      else
         slope=dyp/dxp
         bintr=ys-slope*xs
      endif
c --- Set stepping index for sampling step
      idy=1
      if(iys.GT.iye) idy=-1
      idx=1
      if(ixs.GT.ixe) idx=-1

c --- Loop over boundaries
      do ib=1,nbndry

c ---    Initialize intercept results to NULL values
         numseg=0

c ---    Loop over segments in boundary
         do is=npbndry(1,ib),npbndry(2,ib)-1
            ixc1=1+bndrygrd(1,is)
            iyc1=1+bndrygrd(2,is)
            ixc2=1+bndrygrd(1,is+1)
            iyc2=1+bndrygrd(2,is+1)
c ---       Set stepping index for boundary segments
            idyc=1
            if(iyc1.GT.iyc2) idyc=-1
            idxc=1
            if(ixc1.GT.ixc2) idxc=-1

c ---       Check for overlap of segment cells and sampling step cells
            isame=0
            do iy=iys,iye,idy
            do ix=ixs,ixe,idx
              do jy=iyc1,iyc2,idyc
              do jx=ixc1,ixc2,idxc
                if(ix.EQ.jx .AND. iy.EQ.jy) isame=isame+1
              enddo
              enddo
            enddo
            enddo
            if(isame.GT.0) then
c ---          Test this segment for an intercept
               dxc=bndrygrd(1,is+1)-bndrygrd(1,is)
               dyc=bndrygrd(2,is+1)-bndrygrd(2,is)
c ---          Boundary Vector [CROSS] Puff Vector is positive
c ---          when trajectory is from IN to OUT
               cxp=dxc*dyp-dxp*dyc
c ---          Find intercept
               if(slope.GT.9.9e10) then
                  xint=xs
                  yint=ymxpbm(1,is)*xint+ymxpbm(2,is)
               elseif(ymxpbm(1,is).GT.9.9e10) then
                  xint=bndrygrd(1,is)
                  yint=slope*xint+bintr
               else
                  xint=(bintr-ymxpbm(2,is))/(ymxpbm(1,is)-slope)
                  yint=slope*xint+bintr
               endif
c ---          Intercept must be within the line segment
               if(ymxpbm(1,is).GT.9.9e10) then
                  frac1=(yint-bndrygrd(2,is))/dyc
               else
                  frac1=(xint-bndrygrd(1,is))/dxc
               endif
c ---          Intercept must be within the sampling step
               if(slope.GT.9.9e10) then
                  frac2=(yint-ys)/dyp
               else
                  frac2=(xint-xs)/dxp
               endif

c ---    DEBUG Output Section
c ---------------------------
         if(LDB) then
         write(io6,*)'Segment,FRAC1,FRAC2:',is,frac1,frac2
         endif

               if((frac1.GE.0.0 .AND. frac1.LE.1.0) .AND.
     &            (frac2.GE.0.0 .AND. frac2.LE.1.0)) then
c ---             Path has crossed boundary at this segment
                  numseg=numseg+1
                  if(cxp.GT.0.) then
                     do n=1,nspec
                        flxout(n,ib)=flxout(n,ib)+qtot(n)
                     enddo
                  elseif(cxp.LT.0.) then
                     do n=1,nspec
                        flxin(n,ib)=flxin(n,ib)+qtot(n)
                     enddo
                  endif
               endif
            endif
         enddo

c ---    DEBUG Output Section
c ---------------------------
         if(LDB) then
         write(io6,*)'Boundary:',ib,'  Segments crossed: ',numseg
         endif

      enddo

      goto 10

999   return
      end
c----------------------------------------------------------------------
      subroutine mbalhdr(title,mbcon)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                MBALHDR
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Writes header records to the Mass Balance file
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): end time used with seconds;
c                                  YYYY format used for year;
c                                  Hour changed to Timestep
c --- V5.3-V5.7     030402  (DGS): remove extra ')' from formats
c --- V5.2-V5.3     991222  (DGS): add section for boundary condition
c                                  mass
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c
c --- INPUTS:
c         TITLE(3) - Char.*80 - Run title (3 lines of 80 char. each)
c            MBCON - integer  - BCON flag (BC puffs modeled if >0)
c
c     Parameters:
c         IO37, IO6
c
c --- OUTPUT:
c
c     Common block /MSBAL/ variables
c         LBC
c
c --- MBALHDR called by: SETUP
c --- MBALHDR calls:     none
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'msbal.puf'
c
      character*80 title(3)
      character*16 datehr
      character*12 specnm
      character*13 cline1(8),cline2(8),clinebc(8)

      data cline1/'             ','   Advected  ','             ',
     &            '     Wet     ','     Dry     ','    Domain   ',
     &            '    Domain   ','    Domain   '/
      data clinebc/'     BC      ',' BC Advected ','      BC     ',
     &            '   BC Wet    ','   BC Dry    ','  BC Domain  ',
     &            '  BC Domain  ','  BC Domain  '/
      data cline2/'   Emitted   ','     Out     ',' Transformed ',
     &            '  Depletion  ','  Depletion  ','     Total   ',
     &            '    Surface  ','     Aloft   '/
      data datehr/'Year Day Hr Sec '/
      data specnm/'  Species   '/


      write(io37,'(1x,a)') title
      write(io37,*)
      write(io37,'(t30,a)')'-----------------------'
      write(io37,'(t30,a)')'Mass Balance (Timestep)'
      write(io37,'(t30,a)')'         (g)'
      write(io37,'(t30,a)')'-----------------------'
      write(io37,*)
      if(mbcon.GT.0) then
         lbc=.TRUE.
         write(io37,'(24x,16a13)') cline1,clinebc
         write(io37,'(a16,a12,16a13)') datehr,specnm,cline2,cline2
      else
         lbc=.FALSE.
         write(io37,'(24x,8a13)') cline1
         write(io37,'(a16,a12,8a13)') datehr,specnm,cline2
      endif
      write(io37,*)

      return
c
      end
c----------------------------------------------------------------------
      subroutine mbalini
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991222                MBALINI
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Initializes data arrays for mass balance output
c
c --- UPDATE
c --- V5.2-V5.3     991222  (DGS): add treatment for boundary condition
c                                  mass
c
c --- INPUTS:
c
c     Common block /GEN/ variables
c         NSPEC
c     Parameters:
c         MXSPEC
c
c --- OUTPUT:
c
c     Common block /MSBAL/ variables
c         BALINP(mxspec),BALOUT(mxspec),BALTRN(mxspec),BALWET(mxspec),
c         BALDRY(mxspec),BALTOT(mxspec,2)
c         BALINPBC(mxspec),BALOUTBC(mxspec),BALTRNBC(mxspec),
c         BALWETBC(mxspec),BALDRYBC(mxspec),BALTOTBC(mxspec,2)
c
c --- MBALINI called by: COMP
c --- MBALINI calls:     none
c----------------------------------------------------------------------
c
      include 'params.puf'

      include 'gen.puf'
      include 'msbal.puf'

c --- Loop over species
      do i=1,nspec
         balinp(i)=0.0
         balout(i)=0.0
         baltrn(i)=0.0
         balwet(i)=0.0
         baldry(i)=0.0
         baltot(i,1)=0.0
         baltot(i,2)=0.0
         balinpbc(i)=0.0
         baloutbc(i)=0.0
         baltrnbc(i)=0.0
         balwetbc(i)=0.0
         baldrybc(i)=0.0
         baltotbc(i,1)=0.0
         baltotbc(i,2)=0.0
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine mbalout
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                MBALOUT
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Write mass balance for hour to output file
c
c --- UPDATE
c --- V5.3-V6.1     050915  (DGS): end time used with seconds 
c                           (DGS): end of day time reset to 2400
c --- V5.2-V5.3     991222  (DGS): add section for boundary condition
c                                  mass
c --- V5.0-V5.2     991104  (DGS): YYYY format for year
c
c --- INPUTS:
c
c
c     Common block /DATEHR/ variables
c         NYRE, NJULE, NHRE, NSECE
c     Common block /GEN/ variables
c         NSPEC, CSPEC(mxspec)
c     Common block /MSBAL/ variables
c         BALINP(mxspec),BALOUT(mxspec),BALTRN(mxspec),BALWET(mxspec),
c         BALDRY(mxspec),BALTOT(mxspec,2)
c         BALINPBC(mxspec),BALOUTBC(mxspec),BALTRNBC(mxspec),
c         BALWETBC(mxspec),BALDRYBC(mxspec),BALTOTBC(mxspec,2), LBC
c
c     Parameters:
c         MXSPEC, IO37
c
c --- OUTPUT:
c             none
c
c --- MBALOUT called by: OUTPUT
c --- MBALOUT calls:     MIDNITE
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'datehr.puf'
      include 'gen.puf'
      include 'msbal.puf'

c --- Change hour in time label from 00 to 24 if period ends at 2400
      imo=0
      iday=0
      if(nhre.EQ.0 .AND. nsece.EQ.0) then
         call MIDNITE(io6,'TO 24h',nyre,imo,iday,njule,
     &                nyr,kmo,kday,njul)
         nhr=24
      else
         nyr=nyre
         njul=njule
         nhr=nhre
      endif

c --- Loop over species
      do i=1,nspec
         total=baltot(i,1)+baltot(i,2)
         if(LBC) then
            totalbc=baltotbc(i,1)+baltotbc(i,2)
            write(io37,98) nyr,njul,nhr,nsece,
     &                     cspec(i),balinp(i),balout(i),
     &                     baltrn(i),balwet(i),baldry(i),total,
     &                     baltot(i,1),baltot(i,2),
     &                     balinpbc(i),baloutbc(i),
     &                     baltrnbc(i),balwetbc(i),baldrybc(i),totalbc,
     &                     baltotbc(i,1),baltotbc(i,2)
         else
            write(io37,99) nyr,njul,nhr,nsece,
     &                     cspec(i),balinp(i),balout(i),
     &                     baltrn(i),balwet(i),baldry(i),total,
     &                     baltot(i,1),baltot(i,2)
         endif
      enddo

98    format(i4,i4,i3,i5,2x,a12,16(1pe13.5))
99    format(i4,i4,i3,i5,2x,a12,8(1pe13.5))
      return
      end
c----------------------------------------------------------------------
      subroutine mbalsum(atype,qbsfc,qbupr,qesfc,qeupr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991222                MBALSUM
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Update mass balance totals for current puff, for current
c               (sub)step
c
c --- UPDATE
c --- V5.2-V5.3     991222  (DGS): add treatment for boundary condition
c                                  mass
c
c --- INPUTS:
c
c            ATYPE - char*3   - Mass balance component name:
c                                 INP, OUT, TRN, WET, DRY, TOT
c                                 IBC, OBC, TBC, WBC, DBC, SBC
c    QBSFC(mxspec) - real     - Puff mass (g) in surface layer
c                               before gain/loss
c    QBUPR(mxspec) - real     - Puff mass (g) above surface layer
c                               before gain/loss
c    QESFC(mxspec) - real     - Puff mass (g) in surface layer
c                               after gain/loss
c    QEUPR(mxspec) - real     - Puff mass (g) above surface layer
c                               after gain/loss
c
c     Common block /GEN/ variables
c         NSPEC
c     Common block /MSBAL/ variables
c         BALINP(mxspec),BALOUT(mxspec),BALTRN(mxspec),BALWET(mxspec),
c         BALDRY(mxspec),BALTOT(mxspec,2)
c         BALINPBC(mxspec),BALOUTBC(mxspec),BALTRNBC(mxspec),
c         BALWETBC(mxspec),BALDRYBC(mxspec),BALTOTBC(mxspec,2)
c
c     Parameters:
c         MXSPEC, IO6
c
c --- OUTPUT:
c     Common block /MSBAL/ variables
c         BALINP(mxspec),BALOUT(mxspec),BALTRN(mxspec),BALWET(mxspec),
c         BALDRY(mxspec),BALTOT(mxspec,2)
c         BALINPBC(mxspec),BALOUTBC(mxspec),BALTRNBC(mxspec),
c         BALWETBC(mxspec),BALDRYBC(mxspec),BALTOTBC(mxspec,2)
c
c --- MBALSUM called by: COMP, SPLIT
c --- MBALSUM calls:     none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'gen.puf'
      include 'msbal.puf'
c
      real qbsfc(mxspec),qesfc(mxspec),qbupr(mxspec),qeupr(mxspec)
      real qdiff(mxspec)
      character*3 atype

      data zero/0.0/

c --- Loop over species to obtain change in mass
      do i=1,nspec
         qdiffs=qesfc(i)-qbsfc(i)
         qdiffu=qeupr(i)-qbupr(i)
         qdiff(i)=qdiffs+qdiffu
      enddo

c --- Loop over mass balance components

      if(atype.EQ.'INP') then
c ---    Sum emissions this period
         do i=1,nspec
            balinp(i)=balinp(i)+qesfc(i)+qeupr(i)
         enddo

      elseif(atype.EQ.'OUT') then
c ---    Sum puff mass lost from domain this period
         do i=1,nspec
            balout(i)=balout(i)+qesfc(i)+qeupr(i)
         enddo

      elseif(atype.EQ.'TRN') then
c ---    Sum mass change due to chem transformation this period
         do i=1,nspec
            if(qdiff(i).NE.zero) baltrn(i)=baltrn(i)+qdiff(i)
         enddo

      elseif(atype.EQ.'WET') then
c ---    Sum wet depletion this period (as a positive loss)
         do i=1,nspec
            if(qdiff(i).NE.zero) balwet(i)=balwet(i)-qdiff(i)
         enddo

      elseif(atype.EQ.'DRY') then
c ---    Sum dry depletion this period (as a positive loss)
         do i=1,nspec
            if(qdiff(i).NE.zero) baldry(i)=baldry(i)-qdiff(i)
         enddo

      elseif(atype.EQ.'TOT') then
c ---    Sum total puff mass in domain at end of this period
         do i=1,nspec
            baltot(i,1)=baltot(i,1)+qesfc(i)
            baltot(i,2)=baltot(i,2)+qeupr(i)
         enddo
      elseif(atype.EQ.'IBC') then
c ---    Sum emissions this period
         do i=1,nspec
            balinpbc(i)=balinpbc(i)+qesfc(i)+qeupr(i)
         enddo

      elseif(atype.EQ.'OBC') then
c ---    Sum puff mass lost from domain this period
         do i=1,nspec
            baloutbc(i)=baloutbc(i)+qesfc(i)+qeupr(i)
         enddo

      elseif(atype.EQ.'TBC') then
c ---    Sum mass change due to chem transformation this period
         do i=1,nspec
            if(qdiff(i).NE.zero) baltrnbc(i)=baltrnbc(i)+qdiff(i)
         enddo

      elseif(atype.EQ.'WBC') then
c ---    Sum wet depletion this period (as a positive loss)
         do i=1,nspec
            if(qdiff(i).NE.zero) balwetbc(i)=balwetbc(i)-qdiff(i)
         enddo

      elseif(atype.EQ.'DBC') then
c ---    Sum dry depletion this period (as a positive loss)
         do i=1,nspec
            if(qdiff(i).NE.zero) baldrybc(i)=baldrybc(i)-qdiff(i)
         enddo

      elseif(atype.EQ.'SBC') then
c ---    Sum total puff mass in domain at end of this period
         do i=1,nspec
            baltotbc(i,1)=baltotbc(i,1)+qesfc(i)
            baltotbc(i,2)=baltotbc(i,2)+qeupr(i)
         enddo

      else
c ---    PROBLEM
         write(io6,*) 'Fatal Error in MBALSUM ---'
         write(io6,*) 'Mass balance component not recognized: ',atype
         write(*,*)
         stop 'Fatal Error in MBALSUM --- see list file.'
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine wrivl(ichan,amodel,vers,lev)
c----------------------------------------------------------------------
c
c --- CALPUFF   Version: 6.262          Level: 990228d            WRIVL
c ---           D. Strimaitis, SRC
c
c --- PURPOSE:  Write identification label that specifies model,
c               version number, and level
c
c --- INPUTS:
c
c           ICHAN - integer   - channel number for output file
c          AMODEL - char*12   - model name
c            VERS - char*12   - version number
c             LEV - char*12   - level (modification date yymmdd)             [c]
c
c --- OUTPUT:
c            none
c
c
c --- WRIVL called by: READCF, SETUP
c --- WRIVL calls:     none
c-----------------------------------------------------------------------
      character*12 amodel,vers,lev

      write(ichan,110)amodel,vers,lev
110   format(40x,a12,3x,'Version: ',a12,3x,'Level: ',a12/
     1 1x,13('**********')/)

      return
      end
c----------------------------------------------------------------------
      subroutine rdhdbc
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050218                 RDHDBC
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Read header portion of the free-formatted Boundary
c               Condition file (IO15) and process information
c
c --- UPDATE
c --- V5.71-V5.726  050218  (DGS): Replace restriction that Boundary
c                                  Condition (BC) segments must match
c                                  the grid cell size with a warning
c --- V5.7-V5.71    030528  (DGS): Fix xmesh,ymesh definition for
c                                  computing segment grid coordinates
c                   030528  (DGS): Add more QA output
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4 call
c                   030402  (DGS): MXVAR relocated to PARAMS.CAL
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c     Common block /COMPARM/:
c           VQFAC(12,mxq12), IQNUM(5), IQNEXT
c     Common block /GEN/:
c           NSPEC,NSE,ISPLST(4,mxspec),CSPEC(mxspec),XMOL(mxspec)
c     Common block /GRID/:
c           DGRID, IBCOMP, JBCOMP, IECOMP, JECOMP
c     Parameters:
c           MXNX, MXSG, MXVAR, MXSPEC, IO15, IO6,
c           MXP2, MXBC
c
c --- OUTPUT:
c
c     Common block /BCS/:
c           XLENBC, YLENBC, IBCU, FUNITSBC(4), CUNITSBC(4),
c           NBC,XBCGRD(mxbc),YBCGRD(mxbc),ITYPEBC(mxbc),
c           IBC(mxbc),NEWBC(mxbc),
c           NTYPEBC1,HTBC(mxbc),CONBC(mxspec,mxbc),
c           ivbc(mxspec,mxbc),iq12bc(mxspec,mxbc),CNAMTYP(mxbc),
c           FNAMEBC, NTYPEBC2, NSPECBC, IBYDBC, IBHBC,
c           IEYDBC, IEHBC, VRSBC, LBLBC, CSPECBC(mxspec),
c           XMWTBC(mxspec), IBEGBC, IENDBC
c
c --- RDHDBC called by:  SETUP
c --- RDHDBC calls:      READIN, YR4, QCHECK
c----------------------------------------------------------------------
c
      parameter(mxsg0=7,mxsg3=1)
c
c --- Include parameter statements
      include 'params.puf'
      include 'params.cal'

c --- Include common blocks
      include 'bcs.puf'
      include 'chiflx.puf'
      include 'comparm.puf'
      include 'flags.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'qa.puf'
c
      real bc1data(mxp2)
      real vqtemp(96,mxspec)
      integer inorth(mxnx),isouth(mxnx),iw_e(2)
      character*4 ctemp(12)

c --- Name for air-mass types
      character*12 cnambc
c --- Name for boundary edge (N,S,E,W)
      character*1 nsew(4)

      logical lecho,problem,lmatch,lwarn
      logical lgridbc,lemit

      character*12 cvdic(mxvar,mxsg0),cvdic3(mxvar,mxsg3)
      integer ivleng(mxvar,mxsg0),ivleng3(mxvar,mxsg3)
      integer ivtype(mxvar,mxsg0),ivtype3(mxvar,mxsg3)
c
      data lecho/.false./,lgridbc/.false./,lemit/.false./

      data nsew/'N','S','E','W'/

c --- Identify input groups with letters as continuation character;
c --- and input subgroups with numbers as continuation character.

      data cvdic/
     a  'LBLBC','VRSBC','NBCX','NBCY','IBCU','NTYPEBC1','NTYPEBC2',
     a  'NSPECBC','NSBC',  51*' ',
     b  60*' ',
     c  'AIRMASS','X',58*' ',
     2  'AIRMASS','IVARY',58*' ',
c ---  (Note: the 58*' ' above includes mxspec entries)
     d  'NORTH','WEST_EAST','SOUTH', 57*' ',
     e  'AIRMASS','X',58*' ',
     f  'IBDAT','IBHH','IEDAT','IEHH',56*' '/

      data cvdic3/
     b  'CSPEC', 59*' '/

      data ivleng/
     a             12,8*1, 51*0,
     b             60*0,
     c             12,mxp2, 58*0,
     2             12,1, 58*0,
c ---             (Note: the 58*0 above includes mxspec entries)
     d             mxnx,2,mxnx, 57*0,
     e             12,1, 58*0,
     f             4*1, 56*0/
      data ivleng3/
     b             12, 59*0/

c --- Variable types (ivtype) are coded as:
c          0 = null
c          1 = real
c          2 = integer
c          3 = logical
c          4 = character
      data ivtype/
     a             4,1,7*2, 51*0,
     b             60*0,
     c             4,1, 58*0,
     2             4,2, 58*0,
c ---             (Note:  the 58*0 includes mxspec entries of type 1)
     d             3*2, 57*0,
     e             4,2, 58*0,
     f             4*2, 56*0/
      data ivtype3/
     b             4, 59*0/
c
c --- Initialize air-mass/species with variation factors to zero
      data nsbc/0/
c
c --- Set valid version number to 5
      data iver/5/
c
c --- Set "problem" and "warning" markers to FALSE
      data problem/.FALSE./, lwarn/.FALSE./

c --- Set fractional offset from edge of domain for BC source location
c --- to 0.1% of grid cell
      data fuzz/.001/

c --- Initialize dataset version to 0.0
      vrsbc=0.0
c --- Set dataset type
      fnamebc='BCON        '

c --- Set coordinates for corners (met grid units)
      xbcw=ibcomp-1
      ybcs=jbcomp-1
      xbce=iecomp
      ybcn=jecomp
c
c
c --------------------------------------------
c --- General run control parameters -- IG # 1
c --------------------------------------------
c
c --- Clear temporary array for reading dataset label
      do j=1,12
         ctemp(j)(1:1)=' '
      enddo
      call readin(cvdic(1,1),ivleng(1,1),ivtype(1,1),io15,io6,lecho,
     1 CTEMP,VRSBC,NBCX,NBCY,IBCU,NTYPEBC1,NTYPEBC2,NSPECBC,NSBC,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum)
c
c --- Transfer CHAR*4 names into CHAR*12 dataset label
      lblbc='            '
      do j=1,12
         lblbc(j:j)=ctemp(j)(1:1)
      enddo

c --- Compute segment lengths
      nxgrid=iecomp-ibcomp+1
      nygrid=jecomp-jbcomp+1
      xmesh=FLOAT(nxgrid)/FLOAT(nbcx)
      ymesh=FLOAT(nygrid)/FLOAT(nbcy)
      xlenbc=dgrid*xmesh
      ylenbc=dgrid*ymesh
      nbc=2*(nbcx+nbcy)
      
c --- QA checks
c -------------

c --- Check version (must be version 5.0 or greater)
      ivrsbc=vrsbc
      if(ivrsbc.lt.iver)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,13)vrsbc,iver
13       format(/1x,'ERROR in SUBR. RDHDBC -- version of ',
     1   ' BCON file is not acceptable to CALPUFF'/1x,
     2   '        Version of BCON file: ',f5.2/1x,
     3   '   Expected at least Version: ',i5)
         problem=.TRUE.
      endif

c --- Compare segments with computational grid
      if(LGRIDBC) then
c ---    Segments must align with grid cells on computational grid
         if(nbcx.NE.nxgrid .OR. nbcy.NE.nygrid) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. RDHDBC -- boundary segments',
     &                  ' must align with computational grid: '
            write(io6,*)'Segment NBCX,NBCY = ',nbcx,nbcy
            write(io6,*)'Comp Grid NX,NY   = ',nxgrid,nygrid
            problem=.TRUE.
         endif
      else
c ---    Warn if segments do not align with grid cells
         if(nbcx.NE.nxgrid .OR. nbcy.NE.nygrid) then
            write(io6,*)
            write(io6,*)'********  WARNING  **********'
            write(io6,*)'RDHDBC -- boundary segments do not align',
     &                  ' with computational grid (may be OK): '
            write(io6,*)'Segment NBCX,NBCY = ',nbcx,nbcy
            write(io6,*)'Comp Grid NX,NY   = ',nxgrid,nygrid
            lwarn=.TRUE.
         endif
c ---    Apply weaker constraints
c ---    (a) number of boundary segments >= number of grid cells
         if(nbcx.GT.nxgrid .OR. nbcy.GT.nygrid) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. RDHDBC -- too many boundary ',
     &                  'segments -- '
            write(io6,*)'Segment NBCX,NBCY = ',nbcx,nbcy
            write(io6,*)'Comp Grid NX,NY   = ',nxgrid,nygrid
            problem=.TRUE.
         endif
c ---    (b) segment lengths along X,Y must be within 10%
          ratio=xlenbc/ylenbc
          if(ratio.GT.1.1 .OR. ratio.LT.0.9) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. RDHDBC -- length of boundary ',
     &                  'segments differ more than 10% -- '
            write(io6,*)'Segment length X,Y = ',xlenbc,ylenbc
            problem=.TRUE.
          endif
       endif

c --- Check units selection (only 4 types)
      if(ibcu.LT.1 .OR. ibcu.GT.4) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- units choice must be ',
     &   '1-4  -- ','IBCU = ',ibcu
         problem=.TRUE.
      endif

c --- Check number of air-mass types
      ntypebc=ntypebc1+ntypebc2
      if(ntypebc.gt.mxbc)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- too many air-mass ',
     &   'types -- ','NTYPEBC = ',ntypebc,' MXBC = ',mxbc
         problem=.TRUE.
      endif

c --- Check number of species
      if(nspecbc.gt.nspec)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- number of species ',
     &   'exceeds number modeled -- '
         write(io6,*)'NSPECBC = ',nspecbc,' NSPEC = ',nspec
         problem=.TRUE.
      endif

c --- Check number of species/air-mass types
      ntest=nspecbc*ntypebc
      if(nsbc.gt.ntest)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- number of species/ ',
     &   'air-mass combinations exceeds number possible -- '
         write(io6,*)'NSBC = ',nsbc,' NSPECBC*NTYPEBC = ',ntest
         problem=.TRUE.
      endif

c
c --------------------------
c --- Species list -- IG # 2
c --------------------------
c
      do i=1,nspecbc
         do j=1,12
            ctemp(j)(1:1)=' '
         enddo

         call readin(cvdic3(1,1),ivleng3(1,1),ivtype3(1,1),io15,io6,
     1   lecho,
     1   CTEMP,
     2   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 species name into CHAR*12 variable
         cspecbc(i)='            '
         do j=1,12
            cspecbc(i)(j:j)=ctemp(j)(1:1)
         enddo
      enddo
c
c --- Transfer species names from master species list into variable
c --- dictionary for use in subsequent input groups
      do i=1,mxspec
c ---    Group 2
         cvdic(i,2)=cspecbc(i)
         ivleng(i,2)=4
         ivtype(i,2)=2
c
c ---    Group 3b
c ---    NOTE: ip2 variable needs to be adjusted if any changes in
c ---    the variables list of Input Group 3b occurs (before vqtemp)
         ip2=i+2
         cvdic(ip2,4)=cspecbc(i)
         ivleng(ip2,4)=96
         ivtype(ip2,4)=1
      enddo
c
c --- Read molecular weights (for ppm, ppb units)
c ------------------------------------------------
      if(ibcu.EQ.3 .OR. ibcu.EQ.4) then

c --- The following call is set for MXSPEC=35
c *** call readin(cvdic(1,2),ivleng(1,2),ivtype(1,2),io15,io6,lecho,
c ***1 XMWTBC(1),XMWTBC(2),XMWTBC(3),XMWTBC(4),XMWTBC(5),
c ***2 XMWTBC(6),XMWTBC(7),XMWTBC(8),XMWTBC(9),XMWTBC(10),
c ***3 XMWTBC(11),XMWTBC(12),XMWTBC(13),XMWTBC(14),XMWTBC(15),
c ***4 XMWTBC(16),XMWTBC(17),XMWTBC(18),XMWTBC(19),XMWTBC(20),
c ***5 XMWTBC(21),XMWTBC(22),XMWTBC(23),XMWTBC(24),XMWTBC(25),
c ***6 XMWTBC(26),XMWTBC(27),XMWTBC(28),XMWTBC(29),XMWTBC(30),
c ***7 XMWTBC(31),XMWTBC(32),XMWTBC(33),XMWTBC(34),XMWTBC(35),
c ***8 idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***9 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***a idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=20
      call readin(cvdic(1,2),ivleng(1,2),ivtype(1,2),io15,io6,lecho,
     1 XMWTBC(1),XMWTBC(2),XMWTBC(3),XMWTBC(4),XMWTBC(5),
     2 XMWTBC(6),XMWTBC(7),XMWTBC(8),XMWTBC(9),XMWTBC(10),
     3 XMWTBC(11),XMWTBC(12),XMWTBC(13),XMWTBC(14),XMWTBC(15),
     4 XMWTBC(16),XMWTBC(17),XMWTBC(18),XMWTBC(19),XMWTBC(20),
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8 idum,idum,idum,idum)
c
c --- The following call is set for MXSPEC=5
c *** call readin(cvdic(1,2),ivleng(1,2),ivtype(1,2),io15,io6,lecho,
c ***1 XMWTBC(1),XMWTBC(2),XMWTBC(3),XMWTBC(4),XMWTBC(5),
c ***2 idum,idum,idum,idum,idum,
c ***3 idum,idum,idum,idum,idum,
c ***4 idum,idum,idum,idum,idum,
c ***5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***8 idum,idum,idum,idum)

      endif
      
c --- QA checks
c -------------
      call QCHECK(mxspec,io6,nspec,nse,isplst,cspec,xmol,lemit,
     1 fnambc,nspecbc,cspecbc,xmwtbc,ierr,ixrembc)
      if(ierr.EQ.1) problem=.TRUE.

c --- Halt processing now if errors were found
      write(io6,*)
      if(PROBLEM) goto 998

c
c -------------------------------------------------------------------
c --- Air-mass information (Constant or Factored Variation) -- IG # 3
c -------------------------------------------------------------------
c
c --- Subgroup (3a) -- Set data for each air-mass type provided
c -----------------
c
      do 150 i=1,ntypebc1
c --- Clear temporary array for type name
      do j=1,12
         ctemp(j)(1:1)=' '
      enddo
c
      call readin(cvdic(1,3),ivleng(1,3),ivtype(1,3),io15,io6,lecho,
     1 CTEMP,BC1DATA,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c --- Extract air-mass index
      iam=NINT(bc1data(1))
      if(iam.GT.ntypebc) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- air-mass type index ',
     &   'exceeds number of types -- ',i,'  index = ',iam
         problem=.TRUE.
      endif
c
c --- Transfer CHAR*4 name array into CHAR*12 variable for type
      do j=1,12
         cnamtyp(iam)(j:j)=ctemp(j)(1:1)
      enddo
c --- Current name must be new
         do j=1,ntypebc
            if(cnamtyp(j).EQ.cnamtyp(iam) .AND. j.NE.iam) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. RDHDBC -- name duplicated ',
     1         'for types -- ',j,iam,'  name = ',cnamtyp(iam)
               problem=.TRUE.
            endif
         enddo
c
c --- Transfer the air-mass data to the common block arrays
      htbc(iam)=bc1data(2)
c --- Apply units conversion factor to obtain concentrations in g/m**3
      if(ibcu.EQ.1 .OR. ibcu.EQ.2) then
         do j=1,nspecbc
            conbc(j,iam)=bc1data(2+j)*funitsbc(ibcu)
         enddo
      else
         do j=1,nspecbc
            conbc(j,iam)=bc1data(2+j)*funitsbc(ibcu)*xmwtbc(j)
         enddo
      endif
c
150   continue

c
c --- Subgroup (3b) -- Variable concentration scaling factors
c -----------------
c
      do i=1,nsbc
c ---    Clear temporary arrays
         do j=1,12
            ctemp(j)(1:1)=' '
         enddo
         do is=1,mxspec
            do iv=1,96
               vqtemp(iv,is)=0.0
            enddo
         enddo
c
c --- The following call is set for MXSPEC=35
c ***    call readin(cvdic(1,4),ivleng(1,4),ivtype(1,4),io15,io6,
c ***1      lecho,
c ***1   CTEMP,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
c ***4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
c ***5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
c ***6   VQTEMP(1,19),VQTEMP(1,20),VQTEMP(1,21),VQTEMP(1,22),
c ***7   VQTEMP(1,23),VQTEMP(1,24),VQTEMP(1,25),VQTEMP(1,26),
c ***8   VQTEMP(1,27),VQTEMP(1,28),VQTEMP(1,29),VQTEMP(1,30),
c ***9   VQTEMP(1,31),VQTEMP(1,32),VQTEMP(1,33),VQTEMP(1,34),
c ***a   VQTEMP(1,35),                                              
c ***b   idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***c   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***d   idum,idum)
c
c --- The following call is set for MXSPEC=20
         call readin(cvdic(1,4),ivleng(1,4),ivtype(1,4),io15,io6,
     1      lecho,
     1   CTEMP,IVARY,
     2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
     3   VQTEMP(1,6),VQTEMP(1,7),VQTEMP(1,8),VQTEMP(1,9),VQTEMP(1,10),
     4   VQTEMP(1,11),VQTEMP(1,12),VQTEMP(1,13),VQTEMP(1,14),
     5   VQTEMP(1,15),VQTEMP(1,16),VQTEMP(1,17),VQTEMP(1,18),
     6   VQTEMP(1,19),VQTEMP(1,20),
     7   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     8   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     9   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     1   idum,idum)

c --- The following call is set for MXSPEC=5
c ***    call readin(cvdic(1,4),ivleng(1,4),ivtype(1,4),io15,io6,
c ***1      lecho,
c ***1   CTEMP,IVARY,
c ***2   VQTEMP(1,1),VQTEMP(1,2),VQTEMP(1,3),VQTEMP(1,4),VQTEMP(1,5),
c ***3   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***4   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***5   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***6   idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
c ***7   idum,idum,idum,idum,idum)
c
c ---    Transfer CHAR*4 source name into CHAR*12 variable for type
         cnambc='            '
         do j=1,12
            cnambc(j:j)=ctemp(j)(1:1)
         enddo
c ---    Match type name to index
         lmatch=.FALSE.
         do ip=1,ntypebc
            if(cnambc.EQ.cnamtyp(ip)) then
               ityp=ip
               lmatch=.TRUE.
            endif
         enddo
         if(lmatch) then
c ---       Check IVARY
            if(ivary.LE.0 .OR. ivary.GT.5) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. RDHDBC -- type of variable',
     1         ' concentration factor invalid:',' type = ',ivary
               write(io6,*)'                         Valid type is 1-5'
               problem=.TRUE.
            else
c ---          Find species (a value of VQTEMP will be >0.0)
               do iv=1,96
                  do isp=1,mxspec
                     if(vqtemp(iv,isp).GT.0.0) goto 1001
                  enddo
               enddo
1001           continue
c ---          Place data into arrays
               ivbc(isp,ityp)=ivary
               iq12bc(isp,ityp)=iqnext
               iqnext=iqnext+iqnum(ivary)
               if((iqnext-1).LE.mxq12) then
                  do iq=iq12bc(isp,ityp),iqnext-1
                     do n12=1,12
                        itemp=12*(iq-iq12bc(isp,ityp))+n12
                        vqfac(n12,iq)=vqtemp(itemp,isp)
                     enddo
                  enddo
               else
                  write(io6,*)
                  write(io6,*)'*********  FATAL  ***********'
                  write(io6,*)'ERROR in subr. RDHDBC -- array dim. ',
     1                        'MXQ12 too small for conc. factors'
                  write(io6,*)'MXQ12 = ',mxq12,'    Need  ',iqnext
                  write(io6,*)'Increase parameter and recompile '
                  problem=.TRUE.
                  goto 999
               endif
            endif
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. RDHDBC -- type name for ',
     1      'Air-Mass factor invalid :',' name = ',cnambc
            write(io6,*)'Valid air-mass type names are: '
            do ip=1,ntypebc
               write(io6,*) cnamtyp(ip)
            enddo
            problem=.TRUE.
         endif
      enddo
c --- End Subgroup (3b) input

c --- QA checks
c -------------
c --- Check for duplication of air-mass/species combinations
      number=0
      do j=1,ntypebc
         do i=1,nspecbc
            if(ivbc(i,j).GT.0) number=number+1
         enddo
      enddo
      if(number.NE.nsbc) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- fewer than NSBC ',
     1   'air-mass/species combinations found for variation factors'
         write(io6,*)'Valid air-mass/species expected: ',nsbc
         write(io6,*)'Valid air-mass/species found   : ',number
         do j=1,ntypebc
            do i=1,nspecbc
            if(ivbc(i,j).GT.0) write(io6,*) cnamtyp(j),' / ',cspecbc(i)
            enddo
         enddo
         problem=.TRUE.
      endif

c --- Halt processing now if errors were found
      write(io6,*)
      if(PROBLEM) goto 998

c
c --------------------------
c --- Air-mass map -- IG # 4
c --------------------------

c --- NBCY + 2 valid 'subgroups' are expected in this group
c --- First must be NORTH, and last must be SOUTH
      j=0
      ilast=nbcy+2
      do i=1,ilast
c ---    Set initial value in each array to 0
         inorth(1)=0
         isouth(1)=0
         iw_e(1)=0

      call readin(cvdic(1,5),ivleng(1,5),ivtype(1,5),io15,io6,lecho,
     1 INORTH,IW_E,ISOUTH,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum)

c ---   Process 'subgroup'
        if(i.EQ.1) then
           if(iw_e(1).GT.0 .OR. isouth(1).GT.0) then
              write(io6,*)
              write(io6,*)'*********  FATAL  ***********'
              write(io6,*)'ERROR in subr. RDHDBC -- first map record ',
     &        'must be the North boundary '
              problem=.TRUE.
              goto 998
           else
              ygrd=ybcn-fuzz
              do ix=1,nbcx
                 j=j+1
                 ibc(j)=1
                 itypebc(j)=inorth(ix)
                 xbcgrd(j)=xbcw+xmesh*(FLOAT(ix)-.5)
                 ybcgrd(j)=ygrd
              enddo
           endif
        elseif(i.EQ.ilast) then
           if(iw_e(1).GT.0 .OR. inorth(1).GT.0) then
              write(io6,*)
              write(io6,*)'*********  FATAL  ***********'
              write(io6,*)'ERROR in subr. RDHDBC -- last map record ',
     &        'must be the South boundary '
              problem=.TRUE.
              goto 998
           else
              ygrd=ybcs+fuzz
              do ix=1,nbcx
                 j=j+1
                 ibc(j)=2
                 itypebc(j)=isouth(ix)
                 xbcgrd(j)=xbcw+xmesh*(FLOAT(ix)-.5)
                 ybcgrd(j)=ygrd
              enddo
           endif
        else
           if(inorth(1).GT.0 .OR. isouth(1).GT.0) then
              write(io6,*)
              write(io6,*)'*********  FATAL  ***********'
              write(io6,*)'ERROR in subr. RDHDBC -- middle map records',
     &        ' must be for the West and East boundaries'
              problem=.TRUE.
              goto 998
           else
              ygrd=ybcn-ymesh*(FLOAT(i-1)-.5)
              j1=j+1
              j2=j+2
              ibc(j1)=4
              ibc(j2)=3
              itypebc(j1)=iw_e(1)
              itypebc(j2)=iw_e(2)
              xbcgrd(j1)=xbcw+fuzz
              xbcgrd(j2)=xbce-fuzz
              ybcgrd(j1)=ygrd
              ybcgrd(j2)=ygrd
              j=j2
           endif
        endif
      enddo
      
c --- QA check
c ------------
c --- No air-mass type should be outside the range 1 to ntypebc
      do i=1,nbc
         if(itypebc(i).LT.1 .OR. itypebc(i).GT.ntypebc) problem=.TRUE.
      enddo
      if(PROBLEM) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- air-mass map incomplete',
     &   ' No air-mass type should be outside the range 1 to NTYPEBC'
         write(io6,*)' NTYPEBC = ',ntypebc
         goto 998
      endif


c
c --------------------------------------------------------------
c --- Air-mass information (Arbitrary Time Variation) -- IG # 5
c --------------------------------------------------------------
c
c --- Subgroup (5a) -- Set data for each air-mass type provided
c -----------------
c
      do i=1,ntypebc2
c ---   Clear temporary array for type name
         do j=1,12
            ctemp(j)(1:1)=' '
         enddo
c
      call readin(cvdic(1,6),ivleng(1,6),ivtype(1,6),io15,io6,lecho,
     1 CTEMP,IAM,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum)
c
c ---    QA air-mass index
         if(iam.GT.ntypebc) then
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. RDHDBC -- air-mass type index ',
     &      'exceeds number of types -- ',i,'  index = ',iam
            problem=.TRUE.
         endif
c
c ---    Transfer CHAR*4 name array into CHAR*12 variable for type
         do j=1,12
            cnamtyp(iam)(j:j)=ctemp(j)(1:1)
         enddo
c ---    Current name must be new
         do j=1,ntypebc
            if(cnamtyp(j).EQ.cnamtyp(iam) .AND. j.NE.iam) then
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR in subr. RDHDBC -- name duplicated ',
     1         'for types -- ',j,iam,'  name = ',cnamtyp(iam)
               problem=.TRUE.
            endif
         enddo
      enddo

c
c --- Subgroup (5b) -- Define time-period provided
c -----------------
c
      if(ntypebc2.GT.0) then

      call readin(cvdic(1,7),ivleng(1,7),ivtype(1,7),io15,io6,lecho,
     1 IBYDBC,IBHBC,IEYDBC,IEHBC,
     2 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     3 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     4 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     5 idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,idum,
     6 idum,idum,idum,idum,idum,idum,idum,idum)

c ---    Enforce YYYY format for year
         jbyr=ibydbc/1000
         jbdy=ibydbc-jbyr*1000
         jeyr=ieydbc/1000
         jedy=ieydbc-jeyr*1000
         call YR4(io6,jbyr,ierrb)
         call YR4(io6,jeyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) then
            problem=.TRUE.
            goto 998
         endif
         ibydbc=jbyr*1000+jbdy
         ieydbc=jeyr*1000+jedy

c ---    Initialize "current" beginning/ending date-time to zero
         ibegbc=0
         iendbc=0

      endif

c --------------------------
c --- End of file header ---
c --------------------------

c --  Report configuration to the list file
c ------------------------------------------
998   write(io6,*)
      write(io6,*)
      write(io6,*)'   ****   BOUNDARY CONDITION DATA  ****'
      write(io6,*)
      write(io6,*)'dataset type                     = ',fnamebc
      write(io6,*)'dataset version                  = ',vrsbc
      write(io6,*)'dataset label                    = ',lblbc
      write(io6,*)'segments on N&S borders          = ',nbcx
      write(io6,*)'         segment length (m)      = ',xlenbc
      write(io6,*)'segments on E&W borders          = ',nbcy
      write(io6,*)'         segment length (m)      = ',ylenbc
      write(io6,*)
      write(io6,*)'concentration units              = ',cunitsbc(ibcu)
      write(io6,*)'species and units conversion factor to g/m^3:'
      do j=1,nspecbc
         factor=funitsbc(ibcu)
         if(ibcu.GT.2) factor=factor*xmwtbc(j)
         write(io6,'(20x,a12,1pe11.4)') cspecbc(j),factor
      enddo
      write(io6,*)
      write(io6,*)'Species cross-reference vector:'
      do j=1,nspecbc
         write(io6,'(20x,a12,i5)') cspecbc(j),ixrembc(j)
      enddo
      write(io6,*)
      write(io6,*)'time-variable air-mass types     = ',ntypebc2
      if(ntypebc2.GT.0) then
         write(io6,*)'    beginning date (YYYYJJJ)     = ',ibydbc
         write(io6,*)'    beginning hour (00-23 LST)   = ',ibhbc
         write(io6,*)'    ending date (YYYYJJJ)        = ',ieydbc
         write(io6,*)'    ending hour (00-23 LST)      = ',iehbc
      endif
      write(io6,*)'constant/factored air-mass types = ',ntypebc1
      write(io6,*)
      write(io6,*)'Type Air-mass  Layer(m) Concentrations (g/m^3)'
      write(io6,*)'---- --------  -------- ----------------------'
      do i=1,ntypebc
         do j=1,nspecbc
            conc=conbc(j,i)*funitsbc(ibcu)
            if(ibcu.GT.2) conc=conc*xmwtbc(j)
            if(j.EQ.1) then
              write(io6,'(i4,1x,a12,f6.0,1pe11.4,4x,a12)')i,cnamtyp(i),
     &                                   htbc(i),conbc(j,i),cspecbc(j)
            else
              write(io6,'(23x,1pe11.4,4x,a12)')  conbc(j,i),cspecbc(j)
            endif
            if(ivbc(j,i).NE.0) then
               write(io6,*)'   factors for variation type: ',ivbc(j,i)
               do iq=1,iqnum(ivbc(j,i))
                  k=iq12bc(j,i)+iq-1
                  write(io6,'(20x,6f8.3,/,20x,6f8.3)') (vqfac(n12,k),
     &                                                  n12=1,12)
               enddo
            endif
         enddo
      enddo
      write(io6,*)
      write(io6,*)'Air-mass type along the North boundary:'
      write(io6,'(40i3)') (itypebc(i),i=1,nbcx)
      write(io6,*)
      write(io6,*)'Air-mass type along the West & East boundaries:'
      do i=1,nbcy
         j=nbcx+2*(i-1)
         write(io6,'(i3,21x,i3)') (itypebc(j+k),k=1,2)
      enddo
      write(io6,*)
      write(io6,*)'Air-mass type along the South boundary:'
      j=nbcx+2*nbcy
      write(io6,'(40i3)') (itypebc(j+k),k=1,nbcx)
      write(io6,*)
      write(io6,*)'Characteristics of each Air-mass segment:'
      write(io6,*)'   Bndy Ht   Type  xgrd    ygrd'
      write(io6,*)
      do i=1,nbc
         write(io6,'(i4,1x,a1,f7.1,i4,2f8.2)') i,nsew(ibc(i)),
     &         htbc(itypebc(i)),itypebc(i),xbcgrd(i),ybcgrd(i)
      enddo
      write(io6,*)
      write(io6,*)


c --- Terminate run if QA detected a fatal flaw in control file
999   if(PROBLEM) then
         write(*,*)
         stop 'Halted in RDHDBC -- see list file.'
      elseif(LWARN) then
         write(*,*)
         write(*,*) 'Warning issued by RDHDBC -- see list file.'
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine RDEMBC(ldb,ndathr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                 RDEMBC
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read the time-varying records of the BCON boundary
c               conditions file (unit IO15) and update data in the
c               air-mass arrays for these air-mass types
c
c --- UPDATE
c --- V5.5-V5.7     030402  (DGS): Add list file unit to YR4 call
c
c --- INPUTS:
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c           NDATHR - integer    - Current modeling date/time
c                                 (YYYYJJJHH)
c
c     Common block /BCS/:
c           HTBC(mxbc),CONBC(mxspec,mxbc),IBCU,FUNITSBC(4),
c           NTYPEBC2, NSPECBC, CSPECBC(mxspec), XMWTBC(mxspec)
c
c     Parameters:
c           MXBC, MXSPEC, IO15, IO6
c
c --- OUTPUT:
c             IBEG - integer    - Starting time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH)
c             IEND - integer    - Ending time for which emissions
c                                 data in current set of
c                                 records is valid (YYYYJJJHH)
c
c     Common block /BCS/:
c           HTBC(mxbc),CONBC(mxspec,mxbc),
c           IBEGBC, IENDBC
c
c --- RDEMBC called by: INITPUF
c --- RDEMBC calls:     YR4, ALLCAP
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'bcs.puf'

c --- Local variables for reading air-mass data
      real conc(mxspec)
      character*12 cid
      character*1 cstore1(12)

      logical ldb,lmatch

c --- Read starting, ending date and time
101   read(io15,*)ibdat,ibtim,iedat,ietim
c --- Enforce YYYY format for year
      ibyr=ibdat/1000
      ibdy=ibdat-ibyr*1000
      ieyr=iedat/1000
      iedy=iedat-ieyr*1000
      call YR4(io6,ibyr,ierrb)
      call YR4(io6,ieyr,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) then
         write(*,*)
         stop 'Halted in RDEMBC'
      endif
      ibdat=ibyr*1000+ibdy
      iedat=ieyr*1000+iedy

      ibegbc=ibdat*100+ibtim
      iendbc=iedat*100+ietim

c --- Test for valid time period
      if(ndathr.GT.iendbc) then
c ---    Read records for air-mass types and try next set of records
         do i=1,ntypebc2
            read(io15,*)cid,ht,(conc(k),k=1,nspecbc)
         enddo
         goto 101
      elseif(ndathr.LT.ibegbc)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR -- BCON date/time exceeds current'
         write(io6,*)'      -- current date/time :',ndathr
         write(io6,*)'      -- BCON date/time    :',ibegbc
         write(*,*)
         stop 'ERROR -- BCON date/time exceeds current --'
      endif

c --- Report valid time period
      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-varying BCON data'
         write(io6,*)'IBEG = ',ibegbc,' IEND = ',iendbc
         write(io6,*)'Updated BCON data'
         write(io6,*)'Air-mass  Layer(m) Concentrations (g/m^3)'
         write(io6,*)'--------  -------- ----------------------'
      endif

c --- Loop over air-mass types and update stored data
      do i=1,ntypebc2
         read(io15,*)cid,ht,(conc(k),k=1,nspecbc)
c ---    Convert characters to upper case
         do j=1,12
            cstore1(j)=cid(j:j)
         enddo
         call ALLCAP(cstore1,12)
         do j=1,12
            cid(j:j)=cstore1(j)
         enddo

c ---    Match type name to index
         lmatch=.FALSE.
         do ip=1,(ntypebc1+ntypebc2)
            if(cid.EQ.cnamtyp(ip)) then
               ityp=ip
               lmatch=.TRUE.
            endif
         enddo
         if(LMATCH) then
c ---       Update stored data
            htbc(ityp)=ht
            do is=1,nspecbc
               conbc(is,ityp)=conc(is)*funitsbc(ibcu)
               if(ibcu.GT.2) conbc(is,ityp)=conbc(is,ityp)*xmwtbc(is)
c ---          Report new data values
               if(ldb)then
                  if(is.EQ.1) then
                    write(io6,'(a12,f6.0,1pe11.4,4x,a12)')
     &              cnamtyp(ityp),htbc(ityp),conbc(is,ityp),cspecbc(is)
                  else
                    write(io6,'(18x,1pe11.4,4x,a12)')
     &              conbc(is,ityp),cspecbc(is)
                  endif
               endif
            enddo
         else
            write(io6,*)
            write(io6,*)'*********  FATAL  ***********'
            write(io6,*)'ERROR in subr. RDEMBC -- type name for ',
     &      'Air-Mass data invalid :',' name = ',cid
            write(io6,*)'Valid air-mass type names are: '
            do ip=1,(ntypebc1+ntypebc2)
               write(io6,*) cnamtyp(ip)
            enddo
            write(*,*)
            stop 'ERROR -- BCON air-mass name is invalid --'
         endif
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine bcs1(i,nspec,dthr,ldbhr,np,newpuf,problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                   BCS1
c                D. Strimaitis
c
c --- PURPOSE:  Initialize newly released puff variables to represent
c               inflow of background air consistent with boundary
c               conditions (emissions provided in BCON file)
c
c --- UPDATE
c --- V5.72-V6.261  080520  (DGS): Place rise tables in DA file
c --- V5.71-V5.72   031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                  IPUFID
c --- V5.7-V5.71    030528  (DGS): Use min/max ZI when defining current
c                                  mixing ht
c                   030528  (DGS): Place mass into species BCON so that
c                                  BC puffs are always fully active
c                                  even when influx concs are zero
c --- V5.4-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c             I - integer - Boundary segment index
c         NSPEC - real    - Number of species modeled
c          DTHR - real    - Length (seconds) of a basic time step
c         LDBHR - logical - Control variable for debug write statements
c                           (T = write, F = do not write)
c            NP - integer - Index of last puff/slug initialized
c        NEWPUF - integer - Number of new puffs/slugs released
c                           during the current time step
c
c     Common block /COMPARM/ variables:
c           MXNEW, WSCALM, XMINZI, XMAXZI
c     Common block /GRID/ variables:
c           IBCOMP, IECOMP, JBCOMP, JECOMP
c     Common block /FLAGS/ variables:
c           MBCON
c     Common block /METHD/ variables:
c           Z0(mxnx,mxny), I2DMET
c     Common block /METHR/ variables:
c           HTMIX(mxnx,mxny), TEMPSS(mxss),TEMP2D
c     Common block /PUFF/ variables:
c           NPUFFS
c     Common block /BCS/ variables:
c           NBC,XBCGRD(mxbc),YBCGRD(mxbc),ITYPEBC(mxbc),
c           IBC(mxbc),
c           NTYPEBC1,HTBC(mxbc),CONBC(mxspec,mxbc),
c           ivbc(mxspec,mxbc),iq12bc(mxspec,mxbc),
c           XLENBC, YLENBC, 
c           NSPECBC,CSPECBC(mxspec),XMWTBC(mxspec),IXRBC(mxspec)
c     Parameters:
c           MXNX, MXNY, MXNZ, MXNZP1, MXSS, MXBC, MXSPEC, IO6
c
c --- OUTPUT:
c            NP - integer - UPDATED index of last puff/slug initialized
c        NEWPUF - integer - UPDATED number of new puffs/slugs released
c                           during the current time step
c       PROBLEM - logical - Set true if fatal problem encountered
c
c     Common block /BCS/ variables:
c           NEWBC(mxbc)
c     Common block /PUFF/ variables:
c           all variables in common block
c
c --- BCS1 called by:  INITPUF
c --- BCS1 calls:      RLSMET, ROLLDN, SWAP, VEMFAC, ZEROTAB, SRCTABOUT
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      include 'bcs.puf'
      include 'comparm.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'puff.puf'

      real q(mxspec)
      real finu(4),finv(4)
      logical ldbhr,problem,lfalse

      data rtpi/1.7724539/
      data lfalse/.false./

c --- Set conversion factor for obtaining sigma from a length scale as
c --- done in CHEM module
      data x2sig/3.467/

c --- Set minimum allowed wind speed normal to boundary for inflow puff
      data wsin0/0.1/
c --- Set local value of mfact (always a PUFF for BC)
      data mfact/0/

c --- Set array to establish inflow direction for boundary on N,S,E,W
c ---   finu= 0 if segment is on north or south boundary
c ---       = 1 if segment is on west boundary
c ---       =-1 if segment is on east boundary
c ---   finv= 0 if segment is on east or west boundary
c ---       = 1 if segment is on south boundary
c ---       =-1 if segment is on north boundary
      data finu/0.,0.,-1.,1./, finv/-1.,1.,0.,0./

c --- Initialize all species mass to zero (not all species may be
c --- characterized on the boundary)
      data q/mxspec*0.0/
c
c --- Determine the met. grid point closest to the segment
      ixs=1.0+xbcgrd(i)
      iys=1.0+ybcgrd(i)
c
c --- Source off the computational grid -- write a FATAL message
      if(ixs.lt.ibcomp.or.ixs.gt.iecomp.or.iys.lt.jbcomp.or.iys.gt.
     1   jecomp)then
         write(io6,20)i,ixs,iys
20       format(/1x,'FATAL -- a BC segment with constant emissions ',
     1   'is off the computational grid'/1x,'segment no. (i) = ',i6,2x,
     2   'nearest grid point (ixs,iys) = (',i5,',',i5,')')
         problem=.TRUE.
         return
      endif

c --- Initialize source tabulation specifications to NULL
      call ZEROTAB

c --- Identify the boundary condition type for this segment
      it=itypebc(i)

c --- Set top of puff and mean height
      zicell=AMAX1(htmix(ixs,iys),xminzi)
      zicell=AMIN1(zicell,xmaxzi)
      ztop=AMAX1(htbc(it),zicell)
      zbot=0.0
      heff=0.5*ztop
c
c --- Extract met. variables; and set CALM configuration if triggered
      call RLSMET(lfalse,ixs,iys,heff,mfact,
     &            mfact0,ilayer,ws,flow,ivec,istab,dpbl,el,
     &            ustr,wstr,tsigv,tsigw,iru,issta,sqrts,idopty,idoptz)

c frr (09/01) new calmet format (2D temp)
      if(i2dmet.EQ.1) then
          temp=temp2d(ixs,iys)
      elseif(i2dmet.EQ.0) then
         temp=tempss(issta)
      else
         write(*,*)'Subr. BCS1:  Invalid I2DMET = ',i2dmet
         stop
      endif

c --- Obtain average advection wind components
      call ADVECT(lfalse,ixs,iys,z0(ixs,iys),el,dpbl,istab,heff,
     &            zbot,ztop,uadv,vadv)

c --- Obtain the wind component normal to the segment
      wsin=uadv*finu(ibc(i))+vadv*finv(ibc(i))

c --- Return without generating new puffs if wsin < wsin0
      if(wsin.LT.wsin0) return

c --- Select length for this segment
      if(ibc(i).LE.2) then
         seglen=xlenbc
      else
         seglen=ylenbc
      endif

c --- Compute emission rate (g/s) for segment 'i' as 1D array and scale
      vflx=ztop*seglen*wsin
c --- Loop over species list as provided in BCON.DAT file
      do k=1,nspecbc
c ---    Select master species index from cross-reference array
         is=ixrembc(k)
         q(is)=vflx*conbc(k,it)*
     &         VEMFAC(ldbhr,ivbc(k,it),iq12bc(k,it),
     &                temp,ws,istab)
cfrr &                tempss(issta),ws,istab)
         if(is.EQ.nspec) then
            write(*,*)'Subr. BCS1:  Invalid array of concentrations'
            write(*,*)'Expected NO influx of BCON species #',nspec
            write(*,*)'Found: ',conbc(k,it)
            write(*,*)'for Air-Mass type: ',it
            stop
         endif
      enddo
c --- Now provide emission rate of marker species BCON
      q(nspec)=vflx*conbc0

c ***
c --- Report active segments in debug mode
      if(ldbhr) then
         write(io6,*)
         write(io6,*) 'BCS1:  Segment Number    ',i
      endif
c ***

c ---------------------------------------------------------
c --- Compute the number of puffs released this hour
c --- from this source and the radius
c ---------------------------------------------------------

c --- Inflow distance normal to segment
      xinflo=dthr*wsin
c --- Effective radius of puff with area equal to inflow
      reff=SQRT(xinflo*seglen)/rtpi
c --- Target radius
      rc=0.5*seglen

c --- Number of puffs 
      npnew=1+reff/rc
      npnew=min0(npnew,mxnew)

c --- Set new effective radius (preserve total area)
      reff=reff/SQRT(FLOAT(npnew))

c --- Compute initial sigma-y and sigma-z (for CHEM and reporting)
      sysrc=reff/x2sig*rtpi
      szsrc=ztop/x2sig

c --- Update puff counts
      newbc(i)=npnew
      newpuf=newpuf+npnew
c --- If puff arrays are full, remove puffs that are off the grid
c --- and "roll down" arrays to make room for new puffs
c --- (this also applies to the DA file of tabulated arrays)
      if(npuffs+newpuf.gt.mxpuff) call ROLLDN(np)
c --- Check to see if roll-down was adequate
      if(npuffs+newpuf.gt.mxpuff)then
         write(io6,*) ' ERROR in subr. BCS1'
         write(io6,*)'Too many puff on grid for array dimensions -- ',
     1   'NPUFFS (old puffs) = ',npuffs,' NEWPUF = ',newpuf,
     2   ' MXPUFF = ',mxpuff
         write(*,*)
         stop 'Halted in BCS1 -- see list file.'
      endif
c
c --- DT is the time (sec) over which each puff is emitted
      dt=dthr/float(npnew)
c
cc*****
      if(ldbhr)then
         write(io6,204)i,ilayer,ixs,iys,ws,istab,dpbl,issta,npnew,
     1    newpuf,dt
204      format(5x,'IS: ',i5,2x,'ILAYER: ',i3,2x,'IXS: ',i4,2x,
     1    'IYS: ',i4,2x,'WS: ',f5.1,2x,'ISTAB: ',i1,2x,'DPBL: ',
     2    f7.1,2x,'ISSTA: ',i4,2x,'NPNEW: ',i4,2x,'NEWPUF: ',i5/
     3    5x,'DT: ',f7.2)
c
         write(io6,208)np,rc,reff,ztop,uadv,vadv,wsin
208      format(5x,'NP: ',i5,2x,'RC: ',f8.2,2x,
     1    'REFF: ',f8.2,2x,'ZTOP: ',f8.2,/2x,'UADV: ',f8.2,2x,
     2    'VADV: ',f8.2,2x,'WSIN: ',f7.2)
      endif
c*****
c ----------------------------------------------------------
c ---    Initialize current hour's new puffs for this source
c ----------------------------------------------------------
         do 50 j=1,npnew
         np=np+1
c
c ---    Use SWAP to start with all puff/slug variables equal to zero
         call swap(np,0)
c
c ---    Fill non-zero values
         xpb(np)=xbcgrd(i)
         ypb(np)=ybcgrd(i)
         zitibl(np)=-1.0
         elbase(np)=elev(ixs,iys)
         sigyb(np)=sysrc
         sigzb(np)=szsrc
c ---    Final plume rise results
         zfinal(np)=heff
         zpb(np)=heff
         isplit(np)=1
c ---    Time-of-release data
         ht0(np)=heff
         diam0(np)=2.*reff
         temit0(np)=dt
         ws0(np)=wsin
         istab0(np)=istab
         sqrts0(np)=sqrts
         iru0(np)=iru
         el0(np)=el
c ---    Set vector/scalar ws ratio to 1.0
         srat0(np)=1.0

c ---    Set puff identity where IRLSNUM is the puff number released
c ---    from a source this time step, ISRCNUM is the source number
c ---    of type ISRCTYP from which the puff was released.
c ---    (Type =9 for control file boundary sources)
         irlsnum(np)=j
         isrcnum(np)=i
         isrctyp(np)=9
c
c ------------------------------------------------------------------
c ---    Inject emissions into proper layer (above/below mixing ht.)
c ------------------------------------------------------------------
         zimax(np)=ztop
         ziold(np)=dpbl
         fmix=dpbl/ztop
         do ispec=1,nspec
            qtotal=q(ispec)*dt
            qm(ispec,np)=qtotal*fmix
            qu(ispec,np)=qtotal-qm(ispec,np)
         enddo
         if(ztop.GT.dpbl) then
            ipufcd(np)=6+mfact0
         else
            ipufcd(np)=2+mfact0
         endif

c ------------------------------------------------------------------
c ---    Transfer NULL tabulated arrays record to DA file (no
c ---    arrays are written, just the number of entries -- zero)
c ------------------------------------------------------------------
         call SRCTABOUT(np,isrctyp(np),isrcnum(np),irlsnum(np))

50       continue

      return
      end
c----------------------------------------------------------------------
      subroutine setbcpuf(ii,tsamp,distm,ws,xnew,ynew,ldbhr,uavg)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991222               SETBCPUF
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Set distances/times for boundary condition puff, and
c               update stored puff data.
c
c --- INPUTS:
c          II - integer   - Puff number
c       TSAMP - real      - Sampling time step (sec)
c       DISTM - real      - Advection distance (m) for time-step
c          WS - real      - Current wind speed (m/s)
c        XNEW - real      - New puff x-position (Met Grid Units)
c        YNEW - real      - New puff y-position (Met Grid Units)
c       LDBHR - logical   - Debug write logical
c
c       Common block /CURRENT/ variables:
c             IDOPTY, IDOPTZ, ICODE,
c             IPNUM, ISNUM, ISTYPE
c       Common block /GRID/ variables:
c             DGRID
c       Common block /PUFF/ variables:
c             SIGYB(mxpuff), SIGZB(mxpuff), ZPB(mxpuff),
c             TMTOTB(mxpuff), XTOTB(mxpuff), BIDFNL(mxpuff),
c             IPUFCD(mxpuff), STIPDW(mxpuff)
c       Parameters:
c             IO6
c
c --- OUTPUT:
c        UAVG - real      - Mean transport speed (m/s)
c       Common block /CURRENT/ variables:
c             xb1,yb1,zb1,syb1,szb1,
c             xe1,ye1,ze1,sye1,sze1,
c             xttb1,xtte1,xshift,
c             sym1,szm1,zm1,fracz1,lup1
c             ipnum,iage,speedi,srat,temis
c       Common block /PUFF/ variables:
c             XPB(mxpuff), YPB(mxpuff), SIGYB(mxpuff), SIGZB(mxpuff),
c             TMTOTB(mxpuff), XTOTB(mxpuff), ZPB(mxpuff)
c
c --- SETBCPUF called by:  COMP
c --- SETBCPUF calls:      none
c
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'current.puf'
      include 'grid.puf'
      include 'puff.puf'

      logical ldbhr
      data zero/0.0/, dm2km/0.001/

c --- Initialize variables associated with terrain option MCTADJ=2
      fracz1=zero
      lup1=.FALSE.

c --- Distance travelled by puff to midpoint (km)
      dmidkm=0.5*distm*dm2km

c --- Time travelled by puff to midpoint (sec)
      tmid=0.5*tsamp

c --- Set mean transport speed for step
      uavg=ws

c --- Assign puff number
      ipnum=ii

c -----------------------------------------
c --- Pass constant sigmas and puff height
c -----------------------------------------
      syb1=sigyb(ii)
      sym1=sigyb(ii)
      sye1=sigyb(ii)
      szb1=sigzb(ii)
      szm1=sigzb(ii)
      sze1=sigzb(ii)
      zb1=zpb(ii)
      zm1=zpb(ii)
      ze1=zpb(ii)

c ----------------------------------------
c --- Store remaining /CURRENT/ variables
c ----------------------------------------
c
c --- Puff coordinates in /CURRENT/ are relative to the origin of the
c --- meteorological grid (0.0, 0.0) = LL corner of cell (1,1) --
c --- units: meters
      xb1=xpb(ii)*dgrid
      yb1=ypb(ii)*dgrid
      xe1=xnew*dgrid
      ye1=ynew*dgrid
c
c --- Set sigma**2 at final rise due to buoyancy enhancement
      bidsq=bidfnl(ii)
c
c --- Set distance to final rise, and final rise height (delta)
      xfrise=xfinal(ii)
      zfrise=zfinal(ii)-(ht0(ii)-stipdw(ii))
c
c --- Set distance from upwind edge of line sources
      xshift=xshift0(ii)
c
c --- Wind speed variables at time of release of emissions
      speedi=ws0(ii)
      srat=srat0(ii)
c
c --- Duration (sec) of the original emissions release
      temis=temit0(ii)
c
c --- Total travel distance (m) at beginning and end of step
      xttb1=xtotb(ii)
      xtte1=xttb1+distm
c
c --- Treat all puffs as OLD
      iage=1

c ------------------------------
c --- Update /PUFF/ variables
c ------------------------------
c
c --- Update total distance (m) and time (s) to end of current step
      xtotb(ii)=xtotb(ii)+distm
      tmtotb(ii)=tmtotb(ii)+tsamp
c
c --- Update position of puff at end of step
      xpb(ii)=xnew
      ypb(ii)=ynew
      zpb(ii)=ze1

      if(ldbhr)then
         write(io6,*) 'SETBCPUF --'
         write(io6,252)dmidkm,tmid,xtotb(ii),
     &                 tmtotb(ii)
252      format(10x,' DMID(km)=',f10.3,' TMID=',f10.1,
     1    ' XTOTB(m)=',f10.1,' TMTOTB=',f10.1)
         write(io6,256)icode,sigyb(ii),sigzb(ii)
256      format(10x,'ICODE=',i2,' SIGYB=',f10.1,' SIGZB=',f10.1)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine calcbc(xold,yold,xnew,ynew,qold,qnew,icode,hlid,puffd,
     1                  vdpvd,nspec,q01wet,q01dry,vd,fracwet,tsampi,
     2                  rbc0,ldbhr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030528                 CALCBC
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  For a given puff from a boundary-condition source,
c               perform the loop over all receptors.  Update the
c               concentration and wet and dry deposition fluxes at a
c               receptor if this puff comes the closest of any BC
c               puffs sampled so far this hour.
c               Time-averaged results represent the full timestep
c               (1 hour).
c
c --- UPDATE
c --- V5.4-V5.71    030528  (DGS): impose user-defined search radius
c                                  for screening BC puff impacts, 
c                                  passed as argument
c                   030528  (DGS): apply MDEPBC flag for using vdpvd
c                                  adjustment for surface depletion
c --- V5.3-V5.4     000602  (DGS): add message to "stop"
c
c --- INPUTS:
c
c         XOLD,YOLD - real    - Starting position (m)
c         XNEW,YNEW - real    - Ending position (m)
c       QOLD(nspec) - real    - Puff mass (g) at beginning of time step
c       QNEW(nspec) - real    - Puff mass (g) at end of time step
c             ICODE - integer - Code for vertical layering of puff
c              HLID - real    - Height of reflection lid (m)
c             PUFFD - real    - Diameter of this puff (m)
c      VDPVD(nspec) - real    - Conc. correction factor (vd'/vd) used
c                               to estimate effect of dry deposition and
c                               vertical mixing on near-surface concs.
c             NSPEC - real    - Number of species
c  Q01WET(mxspec,2) - real    - Puff mass before/after wet removal (g)
c  Q01DRY(mxspec,2) - real    - Puff mass before/after dry removal (g)
c         VD(nspec) - real    - Dry deposition velocity (m/s) for each
c                               species
c    FRACWET(nspec) - real    - Fraction of mass left in puff after wet
c                               removal
c            TSAMPI - real    - 1.0/(TSAMP)
c              RBC0 - real    - Search radius for BC puffs in grid units
c             LDBHR - logical - Debug output (T,F)
c
c     Common block /CTSGDAT/ variables:
c        NCTREC,XRCT(mxrect),YRCT(mxrect)
c     Common block /FLAGS/ variables:
c        MWET,MDRY,MBCON,MDEPBC
c     Common block /GRID/ variables:
c        NXSAM,NYSAM,LSAMP,IBSAMP,JBSAMP,MESHDN,SAM2GRID
c     Common block /NONGRID/ variables:
c        NREC,XNG(mxrec),YNG(mxrec)
c
c     Parameters:
c        MXNX, MXNY, NSPEC, MXNXG, MXNYG, MXREC, IO6
c
c --- OUTPUTS:
c
c     Common block /CHIFLX/ variables:
c        CBCSAM(mxnxg,mxnyg,mxspec),DBCSAM(mxnxg,mxnyg,mxspec),
c        WBCSAM(mxnxg,mxnyg,mxspec),
c        CBCREC(mxrec,mxspec),DBCREC(mxrec,mxspec),WBCREC(mxrec,mxspec),
c        CBCCT(mxrect,mxspec),
c        RBCSAM(mxnxg,mxnyg),RBCREC(mxrec),RBCCT(mxrect)
c
c --- CALCBC called by:  COMP
c --- CALCBC calls:      PFSCRN
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'chiflx.puf'
      include 'ctsgdat.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'nongrd.puf'
c
      real qold(nspec),qnew(nspec),vdpvd(nspec)
      real q01wet(mxspec,2),q01dry(mxspec,2),vd(nspec),fracwet(nspec)
      real conc(mxspec),dflx(mxspec),wflx(mxspec)
      logical ldbhr,limpact

      data pi/3.1415927/

c --- This follows the CALCPF methods with the following exceptions
c     1)  A concentration or a flux is computed at a receptor only if
c         the current BC puff passes closer to the receptor than any
c         BC puff in any previous sampling step this averaging period;
c         previous results are replaced
c     2)  A mean mass is used for the sampling step
c     3)  The horizontal coupling coefficient is the area of the BC puff
c     4)  Weighting by the fraction of the averaging period that is
c         represented in this sampling step is removed -- the impact
c         for this step is assumed to be active for the entire averaging
c         period (TFRACT is not used here)

c --- Uniform vertical distribution factor in surface layer
      if(icode.EQ.2 .OR. icode.EQ.6) then
c ---    ICODE=2,6:  within past/present mixed layer and uniform
         f1=1./hlid
      else
c ---    Problem here
         write(io6,*)'CALCBC: Puffs for boundary conditions should be'
         write(io6,*)'        well mixed (code 2 or 6)'
         write(io6,*)'        Found ICODE = ',icode
         write(*,*)
         stop 'Halted in CALCBC -- see list file.'
      endif

c --- Reciprocal of puff area for horizontal sampling factor
      f2=4.0/(pi*puffd**2)

c --- Concentration and fluxes for this puff
      depcorr=1.0
      do i=1,nspec
         if(mdepbc.EQ.1) depcorr=vdpvd(i)
         conc(i)=depcorr*f1*f2*0.5*(qold(i)+qnew(i))
         if(mdry.EQ.1) dflx(i)=vd(i)*depcorr*f1*f2*
     &                         0.5*(q01dry(i,1)+q01dry(i,2))
         if(mwet.EQ.1) wflx(i)=(1.0-fracwet(i))*tsampi*q01wet(i,1)*f2
      enddo
c ***
      if(LDBHR) then
         write(io6,*) 'CALCBC: conc = ',conc
         if(mdry.EQ.1) write(io6,*) '        dflx = ',dflx
         if(mwet.EQ.1) write(io6,*) '        wflx = ',wflx
      endif
c ***
c
c -------------------------------------------------------------
c --- SAMPLING GRID RECEPTOR POINTS  (uses SAMPLING grid units)
c -------------------------------------------------------------
c
      if(.NOT.lsamp) goto 101
c --- Compute the start of the sampling grid in MET grid units
      xbsamp=float(ibsamp)-0.5
      ybsamp=float(jbsamp)-0.5
c --- Calculate puff center coordinates in SAMPLING grid units
      samxo=(xold-xbsamp)*meshdn+1.0
      samyo=(yold-ybsamp)*meshdn+1.0
      samxn=(xnew-xbsamp)*meshdn+1.0
      samyn=(ynew-ybsamp)*meshdn+1.0

c --- Convert search radius to SAMPLING grid units
      samr=rbc0*meshdn
      samrp1=samr+1.0
c
c --- Determine section of grid within this distance of puff
      il=amin1(samxo-samrp1,samxn-samrp1,float(nxsam))+0.001
      il=max0(1,il)
      ir=amax1(samxo+samrp1,samxn+samrp1,1.0)+0.001
      ir=min0(nxsam,ir)
      jb=amin1(samyo-samrp1,samyn-samrp1,float(nysam))+0.001
      jb=max0(1,jb)
      jt=amax1(samyo+samrp1,samyn+samrp1,1.0)+0.001
      jt=min0(nysam,jt)
c
c --- Loop over receptors in this section
      do 100 isamp=il,ir
         xr=float(isamp)
         do 100 jsamp=jb,jt
            yr=float(jsamp)
c ---       Square current minimum distance in SAMPLING grid units
            rec2=(rbcsam(isamp,jsamp)*meshdn)**2
c ---       Impose a minimum on rec2
            rec2m=AMAX1(rec2,1.0)
c
c ---       Compute nearest approach of puff to receptor and screen out
c ---       combinations that are too far away
            call PFSCRN(samxo,samyo,samxn,samyn,xr,yr,rec2m,
     &                  samd2,limpact)
c
            if(.NOT.limpact) goto 100
c
c ---       Update impact of BC at this receptor
            if(samd2.LT.rec2) then
               rbcsam(isamp,jsamp)=SQRT(samd2)*sam2grid
               do ipol=1,nspec
                  cbcsam(isamp,jsamp,ipol)=conc(ipol)
                  if(mdry.EQ.1) dbcsam(isamp,jsamp,ipol)=dflx(ipol)
                  if(mwet.EQ.1) wbcsam(isamp,jsamp,ipol)=wflx(ipol)
               enddo
            endif
100   continue
101   continue
c
c ----------------------------------------------------
c --- DISCRETE RECEPTOR POINTS  (using MET grid units)
c ----------------------------------------------------
c
      if(nrec.LE.0) goto 201
c
c --- Loop over receptors
      do i=1,nrec

c ---    Compute nearest approach of puff to receptor and screen out
c ---    combinations that are too far away

c ---    Square current minimum distance for this receptor (grid units)
         rec2=rbcrec(i)**2
c ---    Impose a minimum on rec2
         rec2m=AMAX1(rec2,1.0)
         call pfscrn(xold,yold,xnew,ynew,xng(i),yng(i),rec2m,
     &               d2,limpact)
c
         if(.NOT.limpact) goto 200
c
c ---    Update impact of BC at this receptor
         if(d2.LT.rec2) then
            rbcrec(i)=SQRT(d2)
            do ipol=1,nspec
               cbcrec(i,ipol)=conc(ipol)
               if(mdry.EQ.1) dbcrec(i,ipol)=dflx(ipol)
               if(mwet.EQ.1) wbcrec(i,ipol)=wflx(ipol)
            enddo
         endif
200      continue
c
c --- End loop over discrete receptors
      enddo
c
201   continue
c
c ----------------------------------------------------
c --- CTSG RECEPTOR POINTS  (using MET grid units)
c ----------------------------------------------------
c
      if(nctrec.LE.0) return
c
c --- Loop over receptors
      do i=1,nctrec
c
c ---    Compute nearest approach of puff to receptor and screen out
c ---    receptors that are too far away

c ---    Square current minimum distance for this receptor (grid units)
         rec2=rbcct(i)**2
c ---    Impose a minimum on rec2
         rec2m=AMAX1(rec2,1.0)
         call pfscrn(xold,yold,xnew,ynew,xrct(i),yrct(i),rec2m,
     &               d2,limpact)
c
         if(.NOT.limpact) goto 300
c
c ---    Update impact of BC at this receptor
         if(d2.LT.rec2) then
            rbcct(i)=SQRT(d2)
            do ipol=1,nspec
               cbcct(i,ipol)=conc(ipol)
            enddo
         endif
c
c ---    End computation of impact at receptor
300      continue
c
c --- End loop over CTSG receptors
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine sumbc
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 991222                  SUMBC
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Sum the contribution of boundary-condition sources
c               this time-step to the total concentration/flux
c
c --- INPUTS:
c
c     Common block /CHIFLX/ variables:
c        CHISAM(mxnxg,mxnyg,mxspec),DFSAM(mxnxg,mxnyg,mxspec),
c        WFSAM(mxnxg,mxnyg,mxspec),CHIREC(mxrec,mxspec),
c        DFREC(mxrec,mxspec),WFREC(mxrec,mxspec),
c        CHICT(mxrect,mxspec)
c        CBCSAM(mxnxg,mxnyg,mxspec),DBCSAM(mxnxg,mxnyg,mxspec),
c        WBCSAM(mxnxg,mxnyg,mxspec),
c        CBCREC(mxrec,mxspec),DBCREC(mxrec,mxspec),WBCREC(mxrec,mxspec),
c        CBCCT(mxrect,mxspec)
c     Common block /CTSGDAT/ variables:
c        NCTREC
c     Common block /FLAGS/ variables:
c        MWET,MDRY
c     Common block /GEN/ variables:
c        NSPEC
c     Common block /GRID/ variables:
c        NXSAM,NYSAM,LSAMP
c     Common block /NONGRID/ variables:
c        NREC
c
c     Parameters:
c        MXNX, MXNY, MXSPEC, MXNXG, MXNYG, MXREC, IO6
c
c --- OUTPUTS:
c
c     Common block /CHIFLX/ variables:
c        CHISAM(mxnxg,mxnyg,mxspec),DFSAM(mxnxg,mxnyg,mxspec),
c        WFSAM(mxnxg,mxnyg,mxspec),CHIREC(mxrec,mxspec),
c        DFREC(mxrec,mxspec),WFREC(mxrec,mxspec),
c        CHICT(mxrect,mxspec)
c
c --- SUMBC called by:  COMP
c --- SUMBC calls:      none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'chiflx.puf'
      include 'ctsgdat.puf'
      include 'flags.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'nongrd.puf'

c
c ----------------------------------
c --- SAMPLING GRID RECEPTOR POINTS
c ----------------------------------
c
      if(LSAMP) then
         do is=1,nspec
            do j=1,nysam
            do i=1,nxsam
               chisam(i,j,is)=chisam(i,j,is)+cbcsam(i,j,is)
               if(mdry.EQ.1) dfsam(i,j,is)=dfsam(i,j,is)+dbcsam(i,j,is)
               if(mwet.EQ.1) wfsam(i,j,is)=wfsam(i,j,is)+wbcsam(i,j,is)
            enddo
            enddo
         enddo
      endif
c
c -----------------------------
c --- DISCRETE RECEPTOR POINTS
c -----------------------------
c
      if(nrec.GT.0) then
         do is=1,nspec
            do i=1,nrec
               chirec(i,is)=chirec(i,is)+cbcrec(i,is)
               if(mdry.EQ.1) dfrec(i,is)=dfrec(i,is)+dbcrec(i,is)
               if(mwet.EQ.1) wfrec(i,is)=wfrec(i,is)+wbcrec(i,is)
            enddo
         enddo
      endif
c
c -------------------------
c --- CTSG RECEPTOR POINTS
c -------------------------
c
      if(nctrec.GT.0) then
         do is=1,nspec
            do i=1,nctrec
               chict(i,is)=chict(i,is)+cbcct(i,is)
            enddo
         enddo
      endif

      return
      end
c---------------------------------------------------------------------
      subroutine chemsoa(ldb,io,delt,q,ipgt,qsw,tempk,ppbo3,vloss)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 981124                CHEMSOA
c                G. Moore, Earth Tech
c ---            modified YIELD 981119 for nighttime alpha-pinene
c
c --- PURPOSE:  Compute the average rate of VOC destruction (%/hr)
c               and the average rate of secondary organic aerosol (SOA)
c               formation from VOC suitable for application in a
c               first order chemistry model, and update VOC, SOA mass
c --- UPDATE
c --- V5.3-V5.3    981124  (GEM): Add radiation to Yield call
c
c --- INPUTS:
c
c          LDB - logical - Debug T/F
c           IO - integer - Unit number for output
c         DELT - real    - Integration time interval (hours)
c         Q(5) - real    - Pollutant mass (g) in the puff before step
c         IPGT - integer - PGT stability class (1-6)
c          QSW - real    - Short-wave solar radiation (W/m**2)
c        TEMPK - real    - Air temperature (deg. K)
c        PPBO3 - real    - Ozone concentration (ppb) to use in
c                               chemistry calculations
c     Common Block /SOA/ variables:
c        LBIOG, LAROM, VC2NX, AMO
c
c --- OUTPUT:
c         Q(5) - real    - Pollutant mass (g) in the puff after step
c     VLOSS(4) - real    - VOC transformation rates (%/hour)
c                           VLOSS(1) -- TOLUENE loss rate
c                           VLOSS(2) -- XYLENE loss rate
c                           VLOSS(3) -- B-PINENE loss rate
c                           VLOSS(4) -- A-PINENE loss rate
c
c --- CHEMSOA called by:  CHEM
c --- CHEMSOA calls:      MAKEOHN, YIELD, AROMA, BIOG
c----------------------------------------------------------------------
      parameter (ms=4, nc=2)
c --- MS is the number of VOC species, NC is the number of classes
c --- 4 VOC species are used, and are taken in the following order:
c        (1) toluene - low yield aromatics
c        (2) xylene - high yield aromatics
c        (3) beta-pinene monoterpene biogenics
c        (4) alpha-pinene monoterpene biogenics
c --- The first 2 represent 2 classes of aromatics, while the second
c --- 2 represent 2 classes of biogenics.

c --- Include common blocks
      include 'soa.puf'

      real q(5)
      logical ldb

      dimension qvoc(ms),ylds(ms),vloss(ms)
      dimension arate(nc),brate(nc)

c --- Assign species mass (3 combinations of VOC species are possible)
      qsoa=0.0
      do is=1,4
         qvoc(is)=0.0
      enddo
      if(LAROM .AND. LBIOG) then
         do is=1,4
            qvoc(is)=q(is)
         enddo
         qsoa=q(5)
      elseif(LAROM) then
         do is=1,2
            qvoc(is)=q(is)
         enddo
         qsoa=q(3)
      elseif(LBIOG) then
         do is=1,2
            qvoc(is+2)=q(is)
         enddo
         qsoa=q(3)
      endif     

c --- Debug output
      if(LDB) then
         write(io,*)
         write(io,*)'CHEMSOA: Inputs -------'
         write(io,'(1x,a30,i2,4f8.2)')'  ipgt,delt,qsw,tempk,ppbo3 = ',
     &                                   ipgt,delt,qsw,tempk,ppbo3
         write(io,*)'   BIOG,AROM,vc2nx,amo = ',LBIOG,LAROM,vc2nx,amo
         write(io,'(1x,a10,5e12.4)')'   Q(5) = ',q
         write(io,'(1x,a10,4e12.4)')'QVOC(4) = ',qvoc
         write(io,'(1x,a10,e12.4)') '   QSOA = ',qsoa
      endif

c --- Convert ozone conc from PPB to PPM
      ppmo3=0.001*ppbo3

c --- Estimate oh and no3
      call MAKEOHN(ipgt,qsw,tempk,vc2nx,ppmo3,ppmoh,ppmno3)

c --- Estimate the yields, and identify aromatic and biogenic parts
      call YIELD(qsw,amo,tempk,vc2nx,ylds)

c --- Estimate the destruction rate of VOCs
      do i=1,2
         arate(i)=0.0
         brate(i)=0.0
      enddo
      if(LAROM) call AROMA(ppmo3,ppmoh,ppmno3,tempk,arate)
      if(LBIOG) call BIOG(ppmo3,ppmoh,pmno3,tempk,brate)
c --- Transfer to VLOSS(mc) rate array
      do i = 1,2
         vloss(i)=arate(i)
         vloss(i+2)=brate(i)
      enddo

c --- Perform transformation/integration
c --- Include factor in timestep to remove % from rate
      dt=0.01*delt
      dsoa=0.0
      do i=1,4
c ---    VOC mass loss
         dc=qvoc(i)*(1.-EXP(-vloss(i)*dt))
c ---    SOA mass gain
         dsoa=dsoa+dc*ylds(i)
c ---    New VOC mass
         qvoc(i)=qvoc(i)-dc
      enddo
c --- New SOA mass
      qsoa=qsoa+dsoa

c --- Re-assign species mass for output
      if(LAROM .AND. LBIOG) then
         do is=1,4
            q(is)=qvoc(is)
         enddo
         q(5)=qsoa
      elseif(LAROM) then
         do is=1,2
            q(is)=qvoc(is)
         enddo
         q(3)=qsoa
      elseif(LBIOG) then
         do is=1,2
            q(is)=qvoc(is+2)
         enddo
         q(3)=qsoa
      endif     

c --- Debug output
      if(LDB) then
         write(io,*)
         write(io,*)'CHEMSOA: Results ------'
         write(io,*)'   ppmoh,ppmno3 = ',ppmoh,ppmno3
         write(io,*)'   arom rate(2) = ',arate
         write(io,*)'   biog rate(2) = ',brate
         write(io,'(1x,a10,4e12.4)')'yield(4)= ',ylds
         write(io,'(1x,a10,5e12.4)')'   Q(5) = ',q
         write(io,'(1x,a10,4e12.4)')'QVOC(4) = ',qvoc
         write(io,'(1x,a10,e12.4)') '   QSOA = ',qsoa
      endif

      return
      end
c---------------------------------------------------------------------
      subroutine makeohn(ipgt,rad,temp,vc2nx,ppmo3,ppmoh,ppmno3)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980918                MAKEOHN
c                G. Moore, Earth Tech
c
c --- PURPOSE:  Computes the hydroxyl and the nitrate concentrations
c               using a method consistent with the MESOPUFF II
c               transformation algorithm (the RIVAD approach
c               may be implemented in the future, but is currently
c               disabled).
c
c --- INPUTS:
c
c              IPGT - integer - PGT stability class
c               RAD - real    - Short-wave solar radiation (W/m**2)
c              TEMP - real    - Air temperature (deg. K)
c             VC2NX - real    - Hydrocarbon/NOX ratio
c            RHOAIR - real    - Air density (kg/m**3)
c             PPMO3 - real    - Ozone concentration (ppm) to use in
c                               chemistry calculations
c
c --- OUTPUT:
c             PPMOH - real    - Hydroxyl concentration (ppm)
c            PPMNO3 - real    - Nitrate radical concentration (ppm)
c
c --- MAKEOHN called by:  CHEMSOA
c --- MAKEOHN calls:      none
c----------------------------------------------------------------------
c --- 1 ppm = xnd molecules/cm3 at 1 atm-289K
      data xnd/2.55e13/

c --- Set OH conc for night (used as minimum)
      data ppmnite/1.0e-11/

c --- Force use of MESOPUFF II type of calculation
      data ichem/1/
c --- Declare dummy input variables for RIVAD
      data coszn/0.0/,ppmh2o/0.0/,ppmso2/1./,ppmnox/1./

c --- Convert solar radiation from W/m**2 to kW/m**2
      srad = 0.001*rad

c --- Set PG class index to range 2-6
      xpgt = ipgt
      if(xpgt.lt.2.)xpgt = 2.0
      if(xpgt.gt.6.0)xpgt = 6.0

      xconv = xnd*60.0
c --- 3-body reaction rate at 300K at 1 atm
c     roh = xconv*3.0e-12        
c --- Use value from CB4 (reference ...)
      roh = 2.0e+03
c
c --- Estimate hydroxyl radical concentration (ppm)
c -------------------------------------------------
c --- MESOPUFF chemistry approach (ichem = 1)
      if(ichem.eq.1)then
         if(rad.gt.0.0)then
c ---       Daytime
            c1 = ppmo3**0.71
            c2 = 1.0/(xpgt**1.29)
            c3 = srad**0.55
            ppmoh = 0.36*c1*c2*c3/(60.*roh)
            ppmoh = AMAX1(ppmoh,ppmnite)
         else
c ---       Nighttime
            ppmoh = ppmnite
         endif
c
c --- RIVAD chemistry approach NOT AVAIALBLE (ichem = 2)
      elseif(ichem.eq.2)then
         x34 = 1.3e-03*coszn**2.74
         x35 = 4.45e+10
         x36 = 3.4e+05
         x37 = 2.0e+03
         x38 = 1.4e+04
         if(rad.gt.0.0)then
c ---       Daytime
            o1d = x34*ppmo3/(x35 + x36*ppmh2o)
            ppmoh = 2.0*x36*o1d*ppmh2o/(x37*ppmso2 + x38*ppmnox)
            ppmoh = AMAX1(ppmoh,ppmnite)
         else
c ---       Nighttime
            ppmoh = ppmnite
         endif
      endif
c
c --- Estimate nitrate radical concentration (ppm)
c ------------------------------------------------
      if(rad.gt.0.0)then
c ---    Photolysis severely attenuates NO3 during the day
         ppmno3 = 1.0E-10
      else
c ---    Slow buildup at night (assume N2O5 equlibrium)
c ---    Production [NO2]+[O3] - steady state with [NO3][VOC]
c ---    destruction
         c1 = 1.0e-15*xconv
         c2 = 1.760e+02*exp(-2450./temp)
         if(vc2nx.gt.0.0)then
            ppmno3 = (c2/c1)*ppmo3/vc2nx
         else
            ppmno3 = (c2/c1)*ppmo3/10.0
         endif
      endif

      return
      end
c---------------------------------------------------------------------
      subroutine yield(rad,amo,temp,vc2nx,yrates)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 981124                  YIELD
c                G. Moore, Earth Tech
c
c --- PURPOSE:  Estimate the yield coefficients for a specific set
c               of chemical classes using the ambient conditions such
c               as the organic aerosol mass, the temperature, and the
c               prevailing VOC/NOx ratio.  The present form of
c               of the yield model assumes that a CB4/SAPRC90 mechanism
c               is followed with 4 classes - two aromatic and two
c               monoterpene
c
c --- UPDATE
c --- V5.3-V5.3    981124  (GEM): Add nighttime module for alpha-pinene
c
c --- INPUTS:
c
c               RAD - real    - Short-wave solar radiation (W/m**2)
c               AMO - real    - Aerosol mass load (ug/m3)
c              TEMP - real    - Air temperature (deg. K)
c             VC2NX - real    - Hydrocarbon/NOX ratio (after reaction)
c
c --- OUTPUT:
c          YRATES - real array - 1-D array of yields for 4 VOC classes:
c                                (1) toluene - low yield aromatics
c                                (2) xylene - high yield aromatics
c                                (3) beta-pinene monoterpene biogenics
c                                (4) alpha-pinene monoterpene biogenics
c
c --- YIELD called by:  CHEMSOA
c --- YIELD calls:      none
c----------------------------------------------------------------------
      parameter (nc=4)
c
      dimension yrates(nc)
      dimension scoef(2,nc),pc(2,nc)
      dimension tref(nc),vcnxr(nc)
c
      data scoef /0.071,0.138,0.038,0.167,0.35,0.0,0.038,0.326/
      data pc /0.053,0.0019,0.042,0.0014,0.11,0.0,0.171,0.004/
      data tref/308.,312.,312.,315./
      data vcnxr/nc*10.0/
c
c --- Reset nighttime parameters for alpha-pinene
      if(rad.le.0.0)then
         scoef(1,4) = 0.120
         scoef(2,4) = 0.19
         pc(1,4) = 0.20
         pc(2,4) = 0.005
      else
         scoef(1,4) = 0.038
         scoef(2,4) = 0.326
         pc(1,4) = 0.171
         pc(2,4) = 0.004
      endif
c
c --- Loop over nc classes estimating the yields
      do i = 1,nc
         yrates(i) = 0.0

c ---    Assume a two-product yield relation
         do k = 1,2
c ---       Adjustment of the ambient conditions for temp and vapor
c ---       pressure
            p1 = 1.0
            partc = pc(k,i)*(temp/tref(i))**p1
            c1 = 0.1*(vc2nx - vcnxr(i))/vcnxr(i)
            scoeff = scoef(k,i)*(1.0 + c1)

c ---       Two-product absorption isotherm yield relation
            yrates(i) = yrates(i) + amo*scoeff*partc/(1.0+partc*amo)
         enddo
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine biog(ppmo3,ppmoh,ppmno3,temp,brate)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980918                   BIOG
c                G. Moore, Earth Tech
c
c --- PURPOSE:  Estimate the destruction rate of biogenic VOC's by OH,
c               O3, and NO3.
c               This version has been designed for a 2 specie biogenic
c               profile approximating beta and alpha monoterpenes.
c
c --- INPUTS:
c
c             PPMO3 - real       - Ozone concentration (ppm)
c             PPMOH - real       - OH radical concentration (ppm)
c            PPMNO3 - real       - NO3 radical concentration (ppm)
c              TEMP - real       - Air temperature (deg. K)
c
c --- OUTPUT:
c          BRATE(2) - real       - Loss rate (%/hr)
c
c --- BIOG called by:  CHEMSOA
c --- BIOG calls:      none
c----------------------------------------------------------------------
c --- NOTES ---
c----------------------------------------------------------------------
c --- Biogenic compound estmates from BEIS and BEIS2 are put into 3
c --- broad categories - isoprene, monoterpenes, and other VOC's which
c --- include mainly low carbon olefins such as ethene, propene, etc.
c --- As a result- only monoterpenes are assumed to have the potential
c --- to form SOA. The monoterpene emissions are dominated by the emissions
c --- of pinenes, limonene, and myrcene (all are C10H16 in various stages
c --- of unsaturation) - myrcene is the most unsaturated being a triply
c --- unsaturated aliphatic hydorcabon.
c
c --- In this program we assume that monoterpenes are almost totally
c --- dominated by pinenes emissions which are split equally between alpha
c --- and beta pinene. Both species are treated seperately at the present
c --- due to slightly different lifetimes.
c
c --- If the CB4 speciation is utilized the following analogues are made
c --- (1) PAR - 8/9 monoterpene carbon mole fraction
c --- (2) OLE = 1/9 monoterpene carbon mole fraction
c----------------------------------------------------------------------
      parameter(ns=2)

      dimension brate(ns)
      dimension roh(ns),ro3(ns),rno3(ns)

c --- Convert cm3/(molec-sec) to ppm-1-min-1 (ref conditions only)
c      pwm = 154.0     pinene molecular weight g/mol
c      xn = 6.023e24   Avagadros # molecule/mole
c      1 ppm = xnd molecules/cm3 at 1 atm-289K
      xnd = 2.55e13
      xconv = xnd*60.0

c --- Inverse half life beta-pinene (min-1) - Warneck (1988) table A-4
c --- Thorsten et. al. 1997
      roh(1) = ppmoh*2.4e-11*xconv*exp(446.0/temp)
      ro3(1) = ppmo3*15.0e-18*xconv
      rno3(1) = ppmno3*2.5e-12*xconv

c --- Inverse half life alpha-pinene (min-1) - Warneck (1988) table A-4
c --- Thorsten et. al. 1997
      roh(2) = ppmoh*1.4e-11*xconv*exp(358.0/temp)
      ro3(2) = ppmo3*9.4e-16*xconv*exp(-731.0/temp)
      rno3(2) = ppmno3*6.2e-12*xconv

c --- Cnew = Cold*exp(-(roh+ro3+rno3)*dt)
c --- Express rate as %/hr rather than min-1 by factor 60.*100.
      do k = 1,ns
         brate(k)=6000.*(roh(k)+ro3(k)+rno3(k))
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine aroma(ppmo3,ppmoh,ppmno3,temp,arate)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 980918                  AROMA
c                G. Moore, Earth Tech
c
c --- PURPOSE:  Estimate the destruction rate of aromatic VOC's by OH,
c               O3, and NO3.
c               This version has been designed for a 2 specie aromatic
c               profile approximating xylenes and toluenes.
c
c --- INPUTS:
c
c             PPMO3 - real       - Ozone concentration (ppm)
c             PPMOH - real       - OH radical concentration (ppm)
c            PPMNO3 - real       - NO3 radical concentration (ppm)
c              TEMP - real       - Air temperature (deg. K)
c
c --- OUTPUT:
c          ARATE(2) - real       - Loss rate (%/hr)
c
c --- AROMA called by:  CHEMSOA
c --- AROMA calls:      none
c----------------------------------------------------------------------
c --- NOTES ---
c----------------------------------------------------------------------
c --- The aromatic species are assumed to exist in terms of high 
c --- formation rate, low formation rate species. For CB4 this 
c --- translates into XYL and TOL species, and for SAPRC90 this
c --- tranlates into ARO1 and ARO2 for the COND2243 mechanism.
c----------------------------------------------------------------------
      parameter(ns=2)

      dimension arate(ns)
      dimension roh(ns),ro3(ns),rno3(ns)

c --- Convert cm3/(molec-sec) to ppm-1-min-1 (ref conditions only)
c      xn = 6.023e24   Avagadros # molecule/mole
c      1 ppm = xnd molecules/cm3 at 1 atm-289K
      xnd = 2.55e13
      xconv = xnd*60.0

c --- Inverse half life of toluene - Warneck 1988/cb4
c      roh(1) = ppmoh*6.4e-12*xconv
      roh(1) = ppmoh*3100.*exp(322./temp)
      ro3(1) = ppmo3*1.5e-22*xconv
      rno3(1) = ppmno3*1.8e-17*xconv

c --- Inverse half life of xylene - Warneck 1988/cb4
c      roh(2) = ppmoh*1.8e-11*xconv
      roh(2) = ppmoh*24530.*exp(116./temp)
      ro3(2) = ppmo3*5.0e-22*xconv
      rno3(2) = ppmno3*6.2e-17*xconv
c
c --- Cnew = Cold*exp(-(roh+ro3+rno3)*dt) 
c --- Express rate as %/hr rather than min-1 by factor 60.*100.
      do k = 1,ns
         arate(k)=6000.*(roh(k)+ro3(k)+rno3(k))
      enddo

      return
      end
c---------------------------------------------------------------------
      subroutine setsoa(ndathr)
c---------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                SETSOA
c                G. Moore, Earth Tech
c
c --- PURPOSE:  Select aerosol mass concentration and VOC/NOX ratio
c               for current hour
c
c --- UPDATE
c --- V5.5-V5.7     030402  (DGS): Add list file unit to GRDAY
c
c --- INPUTS:
c            NDATHR - integer    - YYJJJHH date-time for hour
c
c     Common Block /CHEMDAT/ variables:
c        BCKPMF(12),OFRAC(12),VCNX(12)
c
c --- OUTPUT:
c
c     Common Block /SOA/ variables:
c        VC2NX, AMO
c
c --- SETSOA called by:  COMP
c --- SETSOA calls:      GRDAY
c----------------------------------------------------------------------
      include 'params.puf'
      include 'chemdat.puf'
      include 'soa.puf'

c --- Extract month from date-time
      iyr=ndathr/100000
      ijul=ndathr/100 - 1000*iyr
      call GRDAY(io6,iyr,ijul,imo,iday)

c --- Set background data for this month
      vc2nx=vcnx(imo)
      amo=bckpmf(imo)*ofrac(imo)

      return
      end
c----------------------------------------------------------------------
      subroutine qafog(problem)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_2                QAFOG
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Check FOG-related input data provided in control file
c
c --- UPDATE
c --- V5.4-V5.4   000602_2 (DGS): Add MXREC >= (NPT1+NPT2)*MXRFOG for
c                                 MFOG=1 (PLUME mode)
c                 000602_2 (DGS): Add check for terrain treatment for
c                                 MFOG=1 (PLUME mode)
c                 000602_2 (DGS): Require METFM=2 (ISCMET) for MFOG=1
c                                 (PLUME mode)
c                 000602_2 (DGS): Remove 1-source limit in PLUME mode
c                 000602_2 (DGS): Remove receptor limit of 999
c
c --- INPUTS:
c        PROBLEM - logical    - Flag indicating if FATAL flaw is found
c                ( common blocks filled in READCF )
c
c     Common Block /FLAGS/ variables:
c        MSLUG, MFOG, MCTADJ
c     Common Block /GEN/ variables:
c        METFM, NSPEC, CSPEC
c     Common Block /GRID/ variables:
c        LSAMP
c     Common Block /NONGRD/ variables:
c        NREC
c     Common Block /PT1/ variables:
c        NPT1
c     Common Block /PT2/ variables:
c        NPT2
c     Common Block /AR1/ variables:
c        NAR1
c     Common Block /AR2/ variables:
c        NAR2
c     Common Block /LN1/ variables:
c        NLINES
c     Common Block /LN2/ variables:
c        NLN2
c     Common Block /VOL1/ variables:
c        NVL1
c     Common Block /VOL2/ variables:
c        NVL2
c
c --- OUTPUT:
c        PROBLEM - logical    - Flag indicating if FATAL flaw is found
c
c --- QAFOG called by:  READCF
c --- QAFOG calls:      none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common blocks
      include 'flags.puf'
      include 'outpt.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'nongrd.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'ar1.puf'
      include 'ar2.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'vol1.puf'
      include 'vol2.puf'
c
      logical problem
c
c --- Check for valid non-zero MFOG selection
      if(mfog.GT.2) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--    FOG output is selected when       --'
         write(io6,*)'--            MFOG=1,2                  --'
         write(io6,*)'--  Other non-zero values are INVALID   --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Compressed output is NOT allowed in PLUME Mode
      if(MFOG.EQ.1 .AND. LCOMPRS) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--     FOG output in PLUME Mode         --'
         write(io6,*)'--        is NOT compressed             --'
         write(io6,*)'--   LCOMPRS has been reset to FALSE    --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         lcomprs=.FALSE.
      endif
c
c --- Restrict sampling method to PUFF
      if(mslug.NE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  FOG output requires PUFF sampling   --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- PDF not allowed with FOG processing
      if(mpdf.NE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  PDF treatment not available with    --'
         write(io6,*)'--  FOG output selected                 --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Chemical transformation not allowed with FOG processing
      if(mchem.NE.0 .OR. mwet.NE.0 .OR. mdry.NE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'-- Transformation (MWET,MDRY,MCHEM) not --'
         write(io6,*)'--  available when FOG output selected  --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Only ISCMET is allowed with FOG processing
      if(metfm.NE.2) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  Use ISCMET met data format when     --'
         write(io6,*)'--  FOG output is selected                 --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Remove any source-types that are not allowed
      nsrc=nar1+nar2+nlines+nln2+nvl1+nvl2
      if(nsrc.NE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  FOG processing applies to POINT     --'
         write(io6,*)'--  sources (control file & PTEMARB).   --'
         write(io6,*)'--  Other sources in control file are   --'
         write(io6,*)'--       RESET to zero.                  --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         nar1=0
         nar2=0
         nlines=0
         nln2=0
         nvl1=0
         nvl2=0
      endif
c
c --- Discrete receptors are essential in receptor mode
      if(nrec.LE.0 .AND. mfog.EQ.2) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  FOG output requires DISCRETE recs   --'
         write(io6,*)'--  when run in receptor mode           --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Ignore gridded receptors
      if(LSAMP) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  FOG processing applies to DISCRETE  --'
         write(io6,*)'--  receptors ONLY.  Gridded receptors  --'
         write(io6,*)'--  are ignored (LSAMP reset to FALSE). --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         lsamp=.FALSE.
      endif
c
c --- Species are fixed: 1=H2O, 2=TXS
      if(nspec.NE.2 .OR. cspec(1).NE.'H2O' .OR. cspec(2).NE.'TXS') then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--    MFOG option requires NSPEC=2      --'
         write(io6,*)'-- Species 1= H2O  (emitted water)      --'
         write(io6,*)'-- Species 2= TXS  (temperature excess) --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- Discrete receptor array must accept (npt1+npt2)*MXRFOG points
      nsize=(npt1+npt2)*mxrfog
      if(nsize.GT.MXREC) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'          FATAL SELECTION  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--  MFOG=1 option (PLUME mode) requires --'
         write(io6,*)'--  MXREC >= (NPT1+NPT2)* MXRFOG        --'
         write(io6,*)'--  MXREC               = ',mxrec
         write(io6,*)'--  (NPT1+NPT2)* MXRFOG = ',nsize
         write(io6,*)'--  Use fewer sources, or               --'
         write(io6,*)'--  Resize MXREC, MXRFOG and recompile  --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         problem=.TRUE.
      endif
c
c --- No terrain treatment in PLUME Mode
      if(MFOG.EQ.1 .AND. MCTADJ.NE.0) then
         write(io6,*)
         write(io6,*)
         write(io6,*)
         write(io6,*)'------------------------------------------'
         write(io6,*)'           QA ALERT  !! '
         write(io6,*)'------------------------------------------'
         write(io6,*)'--     FOG output in PLUME Mode         --'
         write(io6,*)'--  does NOT use terrain adjustments    --'
         write(io6,*)'--    MCTADJ has been reset to 0        --'
         write(io6,*)'------------------------------------------'
         write(io6,*)
         mctadj=0
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine setfog(atitle)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_2               SETFOG
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Set FOG data in commons (fixed data are assigned in
c               block data)
c
c --- UPDATE
c --- V5.4-V5.4   000602_2 (DGS): Remove the receptor index of 1000 
c                                 used in the original FOG.DAT format
c                                 to indicate compression
c                 000602_2 (DGS): Set receptor distances for PLUME mode
c
c --- INPUTS:
c        ATITLE - character    - First line of CALPUFF.INP file
c
c     Common Block /FLAGS/ variables:
c        MFOG
c     Common Block /GEN/ variables:
c        IBYR
c     Common Block /GRID/ variables:
c        NX, NY
c     Common Block /OUTPT/ variables:
c        LDEBUG, LCOMPRS
c     Common Block /NONGRD/ variables:
c        NREC
c     Common block /METHD/ variables:
c        NEARS(mxnx,mxny), NSSTA
c     Common Block /PT1/ variables:
c        XPT1GRD(mxpt1),YPT1GRD(mxpt1)   ...(Met grid)
c        ELSTAK(mxpt1)
c     Common Block /PT2/ variables:
c        TIEM2(7,mxpt2)                  ...(Met grid)
c
c --- OUTPUT:
c
c     Common Block /FOG/ variables:
c        FTITLE,NFREC,IFYR,XRFOG,ZELEVFOG,ISSTA,IXSRC,IYSRC,
c        XRFOG,LPMODE,LADTFOG,TXSMXFOG
c
c --- SETFOG called by:  SETUP
c --- SETFOG calls:      none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common blocks
      include 'flags.puf'
      include 'fog.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'outpt.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'nongrd.puf'
      include 'methd.puf'

      character*80 atitle

c     Common Block /FOG/ variables:
c -----------------------------------
c --- Pass first title line to identify run
      ftitle(1)=atitle(1:20)
      ftitle(2)=atitle(21:40)
      ftitle(3)=atitle(41:60)
      ftitle(4)=atitle(61:80)

c --- Set FOG logicals based on MFOG value
c --- PLUME Mode versus RECEPTOR Mode output
      lpmode=.FALSE.
      if(mfog.EQ.1) lpmode=.TRUE.

c --- Add the temperature excesses at receptor subject to constraint
c --- that total temperature excess does not exceed DTEMP at release
      ladtfog=.TRUE.

c --- Initialize the maximum temperature excess to a LARGE value;
c --- it will be reset to this value at the end of each timestep
      txsmxfog=9999.

      if(LPMODE) then
c ---    Setup for plume mode
c ---------------------------
c ---    Set the downwind source-receptor distances (m)
c ---    Distribute using a quadratic profile x=a*(i**2) + b
         xmin=50.
         xmax=10000.
         alpha=(xmax-xmin)/(FLOAT(mxrfog**2)-1.)
         beta=xmin-alpha
         do i=1,mxrfog
            xrfog(i)=alpha*FLOAT(i**2)+beta
         enddo
         nfrec=mxrfog
      else
c ---    Setup for receptor mode
c ------------------------------
         nfrec=nrec
      endif

c --- Number of sources (points only)
      nfpts=npt1+npt2

c --- Set the year for the run equal to the starting year
      ifyr=ibyr

c --- Retain the initial zeroed days array to signal use of ALL
c --- days (and hours) in CALPUFF run (POSTPM and POSTRM modified)

c --- Set index of surface met station nearest the sources
      xsum=0.
      ysum=0.
      nsum=0
      do i=1,npt1
         xsum=xsum+xpt1grd(i)
         ysum=ysum+ypt1grd(i)
         nsum=nsum+1
      enddo
      do i=1,npt2
         xsum=xsum+tiem2(1,i)
         ysum=ysum+tiem2(2,i)
         nsum=nsum+1
      enddo
      if(nsum.LE.0) stop 'SETFOG:  No point sources are found!'
      xbar=xsum/nsum
      ybar=ysum/nsum
      ixsrc=1.0+xbar
      iysrc=1.0+ybar
      if(ixsrc.LT.1) then
         ixsrc=1
      elseif(ixsrc.GT.nx) then
         ixsrc=nx
      endif
      if(iysrc.LT.1) then
         iysrc=1
      elseif(iysrc.GT.ny) then
         iysrc=ny
      endif
      issta=nears(ixsrc,iysrc)
      if(issta.gt.nssta)then
         write(io6,*) ' ERROR in subr. SETFOG'
         write(io6,*)'ISSTA > NSSTA -- ISSTA = ',issta,' NSSTA = ',
     1                nssta
         stop
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine fogrec(ldb)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                FOGREC
c                D. Strimaitis
c
c --- PURPOSE:  Compute array of discrete receptor locations (x,y)
c               based on set 'distances' fixed in BLOCK DATA.
c               These locations are set for each wind direction
c               sector.
c
c --- UPDATE
c --- V5.4-V6.22   070921 (DGS): Add check for ATAN2(0.0,0.0) as
c                                function will halt execution if
c                                both arguments are zero
c
c --- INPUTS:
c               LDB - logical - Debug output (T,F)
c
c     Common Block /COMPARM/ variables:
c        XMINZI, XMAXZI
c     Common Block /FOG/ variables:
c        XRFOG(mxrfog),ZRFOG(mxrfog,mxpt) ...(meters)
c        IXSRC, IYSRC
c     Common Block /GRID/ variables:
c        DGRIDI                          ...(1/meters)
c     Common Block /METHD/ variables:
c        Z0
c     Common Block /METHR/ variables:
c        IPGT, HTMIX, XMONIN, Z0
c     Common Block /PUFF/ variables:
c        XPB(mxpuff), YPB(mxpuff),       ...(met grid)
c        ZPB(mxpuff), ELBASE(mxpuff)
c
c --- OUTPUT:
c
c     Common Block /NONGRD/ variables:
c        NREC, XNG(mxrec), YNG(mxrec)    ...(met grid)
c        ZNG(mxrec), ELEVNG(mxrec)
c
c --- FOGREC called by:  COMP
c --- FOGREC calls:      ADVECT
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
c --- Include common blocks
      include 'comparm.puf'
      include 'fog.puf'
      include 'grid.puf'
      include 'methd.puf'
      include 'methr.puf'
      include 'nongrd.puf'
      include 'puff.puf'

      logical ldb

      data d2rad/0.0174533/

c --- Process puff heights to identify the mean position
      zsum=0.
      nsum=0
      do i=1,nipfog
         zsum=zsum+zpb(ipfog(i))
         nsum=nsum+1
      enddo
      if(nsum.LE.0) stop 'FOGREC:  No point sources are found!'
      zbar=zsum/nsum

c --- Find the flow direction at this height, at the mean location
      istab=ipgt(ixsrc,iysrc)
      istab=MIN0(istab,6)
      dpbl=AMAX1(htmix(ixsrc,iysrc),xminzi)
      dpbl=AMIN1(dpbl,xmaxzi)
      el=xmonin(ixsrc,iysrc)
      z0m=z0(ixsrc,iysrc)
      zbot=0.95*zbar
      ztop=1.05*zbar
      call ADVECT(ldbhr,ixsrc,iysrc,z0m,el,dpbl,istab,zbar,
     &            zbot,ztop,uadv,vadv)
c --- Convert vector components to a flow direction
      if(vadv.EQ.0.0 .AND. vadv.EQ.0.0) then
c ---    Point calms to the north
         flow0=0.0
      else
         flow0=90.-(ATAN2(vadv,uadv))/d2rad
         flow0=AMOD(flow0,360.)
      endif
c --- Shift to nearest 10-degrees
      iflow=NINT(flow0/10.)
      florad=10.*d2rad*FLOAT(iflow)
      sinf=SIN(florad)
      cosf=COS(florad)
      
c --- Initialize number of discrete receptors to zero
      nrec=0

c --- Loop over sources, and establish discrete receptors for each
      do i=1,nipfog
         do irec=1,mxrfog
            nrec=nrec+1
            xng(nrec)=xpb(ipfog(i))+xrfog(irec)*sinf*dgridi
            yng(nrec)=ypb(ipfog(i))+xrfog(irec)*cosf*dgridi
            zng(nrec)=zrfog(irec,i)
            elevng(nrec)=elbase(ipfog(i))
         enddo
      enddo

c --- Report results
      if(LDB) then
         write(io6,*)
         write(io6,*)'FOGREC:  Flow direction (deg): ',flow0
         ir=0
         do i=1,nipfog
            write(io6,*)
            write(io6,*)'Discrete receptors for source ',i
            write(io6,*)'    xng','            yng',
     &                  '            zng','           elev'
            do irec=1,mxrfog
               ir=ir+1
               write(io6,*) xng(ir),yng(ir),zng(ir),elevng(ir)
            enddo
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine ztrace(ldb,ip,ndist,xa,za)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                 ZTRACE
c                D. Strimaitis
c
c --- PURPOSE:  Computes puff trajectory height (m AGL) at array of
c               distances from a source, for the conditions at the
c               time of release;  terrain effects are not included
c               -- For POINT sources only --
c
c --- UPDATE
c --- V6.23-V6.261 080520 (DGS): Replace call to PRSS with GRISE
c --- V5.72-V6.23 080204  (DGS): Remove stack-tip downwash adjustment
c                                to gradual rise because adjustment
c                                is done within GRISE.
c --- V5.4-V5.72  031017  (DGS): IRLSNUM,ISRCNUM,ISRCTYP replace
c                                IPUFID
c --- V5.4-V5.4   000602_4 (DGS): Assign ZFRISE the rise rather than
c                                 the effective plume ht at final rise
c
c --- INPUTS:
c               LDB - logical - Flag for debug output
c                IP - integer - Puff index
c             NDIST - integer - Number of distances in trace
c                xa - real    - Array of distances in trace (m)
c
c     Common block /CURRENT/ variables:
c        IPNUM, ISNUM, ISTYPE, ZFRISE, XSHIFT
c     Common Block /FLAGS/ variables:
c        MTRANS, MTIP
c     Common Block /PUFF/ variables:
c        zfinal,xfinal,fb,fm,xbfin,xmfin,elbase,
c        idw0,ht0,exitw0,diam0,ws0,istab0,sqrts0,srat0,
c        hb0,hw0,heff20,iru0,sigv0,sigw0,el0,
c        plexp0,zly0,r0
c
c     Parameters:
c        IO6, MXPUFF
c
c --- OUTPUTS:
c                za - real    - Array of heights in trace (m AGL)
c
c
c --- ZTRACE called by:  COMP
c --- ZTRACE calls:      GRISE
c----------------------------------------------------------------------
c
c --- Include parameter block
      include 'params.puf'

c --- Include common blocks
      include 'current.puf'
      include 'flags.puf'
      include 'puff.puf'

      real xa(ndist),za(ndist)
      logical ldb

c --- Set variables in /CURRENT/ that may be used in GRISE call
      ipnum=ip
      zfrise=zfinal(ip)-(ht0(ip)-stipdw(ip))
      xfrise=xfinal(ip)
      xshift=xshift0(ip)
c --- Fix as source 1 from PTEMARB file (update if this subroutine is
c --- applied to other types)
      istype=2
      isnum=1

c --- Loop over distances
      do ix=1,ndist
         x=xa(ix)

c -------------------------------------------------------------------
c ---    Building downwash ---
c -------------------------------------------------------------------
c        Point sources:
c        Consider the details of effects of the Huber-Snyder downwash
c        formulation or the Schulman-Scire downwash formulation
c        within 10 HL of the source.
c -------------------------------------------------------------------
         if(idw0(ip).GT.0) then
c ---       Check for receptors in downwash zone
            hl=amin1(hb0(ip),hw0(ip))
            if(x.LT.(10.*hl)) then
               hgr=zfinal(ip)
c ---          Assess gradual rise in downwash zone
               if(x.LT.xfinal(ip)) then
c ---             Compute gradual rise
                  if(idw0(ip).EQ.2) then
c ---                Schulman-Scire building downwash
                     call grise(x,hgr,risefac)
                  elseif(idw0(ip).EQ.1) then
c ---                Huber-Snyder building downwash
                     call grise(x,hgr,risefac)
                  endif
               endif
c
c ---          Done
               goto 500
            endif
         endif

c ---    Continue on for receptors outside downwash zone

c --------------------------------------------------------------------
c ---    Compute the gradual rise if appropriate ...............
c ---      Use ISC convention that gradual rise is used to compute
c ---      buoyancy enhancement to sigmas; and is used as the "plume"
c ---      height only if MTRANS=1
c --------------------------------------------------------------------
c
         if(x.LT.xfinal(ip) .AND. x.GT.0.0) then
c ---       Compute gradual rise
            if(idw0(ip).EQ.2) then
c ---          Schulman-Scire building downwash
               call grise(x,hgr,risefac)
            elseif(idw0(ip).EQ.1) then
c ---          Huber-Snyder building downwash
               call grise(x,hgr,risefac)
            else
c ---          No building downwash
cc ---          Adjustment for stack-tip downwash (NOT for bldg downwash)
c               if(mtip.EQ.1) then
c                  call stktip(ht0(ip),diam0(ip),fm(ip),
c     &                        exitw0(ip),ws0(ip),tipdw)
c               else
c                  tipdw=0.0
c               endif
               call grise(x,hgr,risefac)
c               hgr=amax1(0.0,hgr-tipdw)
            endif
         elseif(x.LE.0.0 .AND. xfinal(ip).GT.0.0) then
c ---       Receptor upwind of source, and final rise does NOT occur at
c ---       source (wind for plume rise is not "calm")
            hgr=ht0(ip)
         else
c ---       Final rise
            hgr=zfinal(ip)
         endif

500      za(ix)=hgr

      enddo

      if(LDB) then
         write(io6,*)
         write(io6,*)'ZTRACE:  Puff IRLSNUM, ISRCNUM, ISRCTYP: '
         write(io6,*)'       ',irlsnum(ip),isrcnum(ip),isrctyp(ip)
         do i=1,ndist
            write(io6,*)'                 i,x,z = ',i,xa(i),za(i)
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine fogwind(io,ldb,ws,u,v)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_2              FOGWIND
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Change advection direction to align it with the
c               nearest 10-degree sector used for PLUME mode receptors
c
c --- INPUTS:
c             IO - integer - File unit for output
c            LDB - logical - Debug output (T,F)
c             WS - real    - Wind speed (m/s)
c            U,V - real    - Vector flow components (m/s)
c
c
c --- OUTPUT:
c            U,V - real    - Vector flow components (m/s)
c
c --- FOGWIND called by:  COMP
c --- FOGWIND calls:      none
c----------------------------------------------------------------------
c
      logical ldb

      data rad2deg/57.295778/

c --- Save initial flow components
      usave=u
      vsave=v

c --- Convert vector components to a flow direction
      flow0=90.-rad2deg*ATAN2(v,u)
      flow0=AMOD(flow0,360.)

c --- Shift to nearest 10-degrees
      iflow=NINT(flow0/10.)
      flow=10.*FLOAT(iflow)

c --- Compute revised flow components
      ang=(90.-flow)/rad2deg
      u=ws*COS(ang)
      v=ws*SIN(ang)

      if(LDB) then
         write(io,*)
         write(io,*)'FOGWIND:     input u,v = ',usave,vsave
         write(io,*)' flow dir input/output = ',flow0,flow
         write(io,*)'            output u,v = ',u,v
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine plmfog(xold,yold,jstab,
     1                  iru,sigv,sigw,el,bvf,ws,wd,dpbl,nspec,
     2                  qlo,qup,icode,hlid,temiti,ldbhr,lcalm)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050225                 PLMFOG
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute fog-related plume data for current source
c
c --- UPDATE
c --- V5.7-V5.75    050225  (DGS): Add DPBL arg to pass on to PUFRECS,
c                                  for SETCSIG and TAULY
c --- V5.5-V5.7     030402  (FRR): Add 2D met arrays (i2dmet)
c                   030402  (DGS): Drop impact at receptors in/near
c                                  cavity zone for PRIME downwash
c
c --- INPUTS:
c         XOLD,YOLD - real    - Starting position (Met grid units)
c             JSTAB - integer - PGT stability class at puff ht
c               IRU - integer - Rural(0) or urban(1) flag
c              SIGV - real    - Sigma-v velocity (m/s)
c              SIGW - real    - Sigma-w velocity (m/s)
c                EL - real    - Monin-Obukhov length (m)
c               BVF - real    - Brunt-Vaisala frequency (1/s)
c                WS - real    - Mean wind speed (m/s)
c                WD - real    - Mean  wind direction
c             NSPEC - real    - Number of species
c        QLO(nspec) - real    - Puff mass (g) in surface layer
c        QUP(nspec) - real    - Puff mass (g) above surface layer
c             ICODE - integer - Code for vertical layering of puff
c              HLID - real    - Height of reflection lid (m)
c            TEMITI - real    - 1/Emission duration for puff mass (s-1)
c             LDBHR - logical - Debug output (T,F)
c             LCALM - logical - .TRUE. if this puff is in a calm
c
c     Common block /CHIFLX/ variables:
c           CHIREC(mxrec,mxspec)
c     Common block /FOG/ variables:
c           TXSMXFOG, ISSTA
c     Common block /GRID/ variables:
c           DGRID
c     Common block /METHR/ variables:
c     Common block /METHD/ variables:
c            I2DMET
c     Common Block /NONGRD/ variables:
c           NREC, XNG(mxrec), YNG(mxrec)
c
c     Parameters:
c        MXSPEC, MXREC, IO6, IO12
c
c --- OUTPUTS:
c     Common block /CHIFLX/ variables:
c           CHIREC(mxrec,mxspec)
c
c --- PLMFOG called by:  COMP
c --- PLMFOG calls:      INCR, VSAT, PUFRECS, VCOUP
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'chiflx.puf'
      include 'methr.puf'
      include 'fog.puf'
      include 'flags.puf'
      include 'grid.puf'
      include 'nongrd.puf'

      real qlo(nspec),qup(nspec)
      logical ldbhr,lcalm,lclip

      data rt2pi/2.5066283/, d2rad/0.0174533/

c --- No clipping for receptor-specific sigmas here
      data lclip/.FALSE./

c --- Set number of sigmas to reach "edge" of plume
      data edge/3./

c --- Calculate vertical distribution factor (uniform ONLY)
      if(icode.EQ.2 .OR. icode.EQ.6) then
c ---    ICODE=2,6:  within past/present mixed layer and uniform
         f1=1./hlid
      elseif(icode .EQ. 4) then
c ---    ICODE=4:  above mixed layer and uniform (no ground-level concs)
         f1=0.
      else
c ---    ICODE ODD: Gaussian,  set f1 to 1.0 for now
         f1=1.0
      endif

c --- Skip this puff if vertical factor is zero
      if(f1.EQ.0.) return

c
c ----------------------------------------------------
c --- DISCRETE RECEPTOR POINTS  (using MET grid units)
c --- Process plume data at receptor locations
c ----------------------------------------------------
c
      if(nrec.LE.0) then
         write(*,*)
         stop 'PLMFOG:  No FOG Receptors!'
      endif

c --- Establish coordinate rotation to place y-axis along the flow
      flow=wd+180
      flow=AMOD(flow,360.)
      florad=d2rad*flow
      sinf=SIN(florad)
      cosf=COS(florad)

c --- Loop over receptors
      do i=1,nrec
         xrec = xng(i)*dgrid
         yrec = yng(i)*dgrid
         zrec = zng(i)
         elrec = elevng(i)

c ---    Obtain receptor-specific sigmas and puff height (gradual
c ---    rise) including any terrain adjustment to height
         call PUFRECS(lclip,xrec,yrec,zrec,jstab,iru,sigv,sigw,el,bvf,
     &                ws,dpbl,elrec,ppc,lcalm,
     &                trec,frec,syrec,szrec,zgrise,zpr,zrpole,
     &                rfacsq,idrop)
c ---    PRIME downwash:  skip 'dropped' receptors in cavity zone
         if(idrop.EQ.1) goto 100

c ---    Lateral coupling
         x=xng(i)-xold
         y=yng(i)-yold
         cross=ABS(dgrid*(x*cosf-y*sinf))/syrec
         if(cross.LE.edge) then
            f2=EXP(-0.5*(cross)**2)/(rt2pi*syrec)
         else
            f2=0.0
         endif
c
         if(mod(icode,2).EQ.1) then
c ---       Sample vertical distribution (GAUSSIAN)
            f1=VCOUP(icode,zrpole,zpr,szrec,hlid)
         endif
c
c ***
      if(LDBHR) then
      write(io6,*) 'PLMFOG: Disc rec x,y,z= ',xrec,yrec,zrec
      write(io6,*) '        Trans. Rise   = ',zgrise
      write(io6,*) '        Adj. Puff Ht. = ',zpr
      write(io6,*) '    Adj. Rec Pole Ht. = ',zrpole
      write(io6,*) '       Sigma-y @ rec. = ',syrec
      write(io6,*) '       Sigma-z @ rec. = ',szrec
      write(io6,*) '  Reflecting Lid Ht.  = ',hlid
      write(io6,*) '     Time to receptor = ',trec
      write(io6,*) ' G.Rise Adj to BID**2 = ',rfacsq
      write(io6,*) '               vcoup  = ',f1
      write(io6,*) '               hcoup  = ',f2
      endif
c ***
c
         f12=f1*f2
         if(f12.GT.0.) then
            if(LCALM) then
c ---          Compute concentration as if a single puff
               chibyq=f12/(rt2pi*syrec)
            else
c ---          Compute concentration as if a plume
               chibyq=(temiti/ws)*f12
            endif
         else
            chibyq=0.0
         endif
         do ipol=1,2
            chirec(i,ipol)=chirec(i,ipol)+(qlo(ipol)+qup(ipol))*chibyq
            if(ipol.EQ.2 .AND. LADTFOG) then
c ---          FOG: SUM the T excess (ipol=2) at receptor but
c ---          do not allow sum to exceed excess at release
               chirec(i,ipol)=AMIN1(txsmxfog,chirec(i,ipol))
            endif
         enddo

c ---    
         if(LDBHR) then
            write(io6,*)'i,chi: ',i,(chirec(i,j),j=1,2)
         endif

100      continue

c --- End loop over discrete receptors
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine fogout
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915               FOGOUT
c                D. Strimaitis, SRC
c
c --- PURPOSE:  Compute fog-related data at discrete receptors and
c               output for processing with "POSTRM" or "POSTPM"
c
c --- UPDATE
c --- V5.7-V6.1   050915   (DGS): Update date-time variables, but
c                                 retain hourly output
c --- V5.5-V5.7   030402   (DGS): Add list file unit to INCR
c --- V5.4-V5.4   000602_2 (DGS): Add LPMODE=T processing for revised
c                                 PLUME Mode
c                 000602_2 (DGS): Write compression logical instead of
c                                 adding 1000 to receptor number
c
c --- INPUTS:
c
c     Common block /CHIFLX/ variables:
c          CHIREC(mxrec,mxspec)
c     Common block /DATEHR/ variables
c          NYRE, NJULE, NHRE
c     Common block /FOG/ variables:
c          ISSTA, IXSRC, IYSRC, LPMODE
c     Common block /GRID/ variables:
c          NZ
c     Common block /METHR/ variables:
c          IRHSS(mxss), TEMPSS(mxss)
c          umet(mxnx,mxny,mxnz), vmet(mxnx,mxny,mxnz)
c          ipgt(mxnx,mxny), htmix(mxnx,mxny)
c          ptg(2)
c     Common block /NONGRD/ variables
c          NREC, ZNG
c     Common block /OUTPT/ variables
c          LCOMPRS
c     Common block /WRKSPC/ variables
c          TMP3(mxrec)
c
c     Parameters:
c        MXSPEC, MXREC, MXSS, MXNX, MXNY, MXNZ, IO6, IO12
c
c --- OUTPUTS:
c               (results to FOG.DAT file)
c
c     Common block /FOG/ variables:
c          TXSMXFOG
c
c --- FOGOUT called by:  COMP
c --- FOGOUT calls:      VSAT
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'

c --- Include common blocks
      include 'chiflx.puf'
      include 'datehr.puf'
      include 'flags.puf'
      include 'fog.puf'
      include 'grid.puf'
      include 'methr.puf'
      include 'nongrd.puf'
      include 'outpt.puf'
      include 'wrkspc.puf'
c frr(09/01)
      include 'methd.puf'
c
      real qsat(mxrec),qback(mxrec),qpeak(mxrec),tplm(mxrec)
      character*15 cname,qbname,qsname

      data rtod/57.29578/
      data cname/'H2O_peak'/, qbname/'H2O_bck'/, qsname/'H2O_sat'/

c --- Set day, hour for output record (use hr=1,24)
      iyr=nyre
      ijul=njule
      ihr=nhre
      if(ihr.EQ.0) then
c ---    Back up 1 hour
         nhrinc=-1
         call INCR(io6,iyr,ijul,ihr,nhrinc)
c ---    Go forward 1 hour
         ihr=ihr+1
      endif
      nyrjulhr=iyr*100000+ijul*100+ihr

c --- Set supporting met data from cell nearest first source
      iz=1
      if(nz.EQ.1) iz=2
      ws=SQRT(umet(ixsrc,iysrc,iz)**2+vmet(ixsrc,iysrc,iz)**2)
      if(ws.GT.0.0) then
         fv=90.-(ATAN2(vmet(ixsrc,iysrc,iz),umet(ixsrc,iysrc,iz)))*rtod
         if(fv.LT.0.) fv=fv+360.
      else
c ---    Absolute calm
         fv=0.0
      endif
      dpbl=htmix(ixsrc,iysrc)
      idpbl=NINT(dpbl)
      istab=MIN(ipgt(ixsrc,iysrc),6)
c --- Codes
      icd=NINT(ws*10.)*10000+istab*1000+999
      imet2=NINT(fv)*10000+MIN(9999,idpbl)

c --- Set temperature (K) and relative humidity (fraction) for
c --- representative surface met station
c frr (09/01) new calmet format (2D temp, RH)
      if(i2dmet.EQ.1) then
         tdegk=temp2d(ixsrc,iysrc)
         frh=0.01*FLOAT(irh2d(ixsrc,iysrc))
      elseif(i2dmet.EQ.0) then
         tdegk=tempss(issta)
         frh=0.01*FLOAT(irhss(issta))
      else
         write(*,*)'Subr. FOGOUT:  Invalid I2DMET = ',i2dmet
         stop
      endif

c --- Convert background RH to water vapor pressure (mb)
c     --- PBSAT   saturation vapor pressure (mb) at TDEGK
c     --- PBACK   background vapor pressure (mb) at TDEGK
c     --- QBSAT   saturation vapor mass conc (g/m^3)
c     --- QBACK0  background vapor mass conc (g/m^3)
      call VSAT(tdegk,pbsat,qbsat)
      pback=frh*pbsat
      qback0=qbsat*frh

c --- Compute QSAT(q/m^3) and QBACK(q/m^3) arrays from temperature
c --- excess array for receptors with non-zero concentration
c --- Loop over discrete receptors
      if(nrec.LE.0) then
         write(*,*)
         stop 'FOGOUT:  No FOG Receptors!'
      endif
      do i=1,nrec
c ---    Initialize in-plume temperature to the ambient near-surface
c ---    air temperature
         tplm(i)=tdegk
         if(chirec(i,1).LE.0.0) then
            chirec(i,1)=0.
            qback(i)=0.
            qsat(i)=0.
            qpeak(i)=0.
         else
c ---       Set in-plume temperature (temperature excess is species 2)
c ---       and compute local in-plume saturation vapor mass conc.
c           --- PSAT    saturation vapor pressure (mb)
c           --- QSAT    saturation vapor mass conc (g/m^3)
            tplm(i)=tplm(i)+chirec(i,2)
            call VSAT(tplm(i),psat,qsat(i))
            qpeak(i)=chirec(i,1)
c ---       Compute local in-plume ambient vapor mass conc., assuming
c ---       that the ambient mixing ratio is constant
c           --- QBACK   background vapor mass conc (g/m^3)
            qback(i)=qsat(i)*pback/psat
         endif

c --- End loop over discrete receptors
      enddo

c -------------------------------------------------
c --- Output for either PLUME mode or RECEPTOR mode
c -------------------------------------------------
      if(LPMODE) then
c ---    Plume Mode date/hr, met. data record
         write(io12)ijul,ihr,ws,fv,istab,tdegk,dpbl,qback0,qbsat,nrec
c ---    Plume Mode data records for hour
         nsrc=nrec/mxrfog
         if(mxrfog*nsrc.NE.nrec) then
            write(io6,*)'FOGOUT:  FATAL Error'
            write(io6,*)'Inconsistent number of receptors found'
            write(io6,*)'           Number of sources : ',nsrc
            write(io6,*)'  Number of receptors/source : ',mxrfog
            write(io6,*)'Number of discrete receptors : ',nrec
            stop 'Halted in FOGOUT -- see list file for details'
         endif
         do i=1,nrec
            write(io12) i,zng(i),qpeak(i),qsat(i),qback(i),tplm(i)
         enddo
      else
c ---    Receptor mode results records for hour        
         write(io12)nyrjulhr,icd,imet2,tdegk,frh,qbsat
         if(LCOMPRS) then
c ---       Write compressed data records
            call COMPRS(qpeak,nrec,tmp3,mxrec,cname,io12)
            call COMPRS(qback,nrec,tmp3,mxrec,qbname,io12)
            call COMPRS(qsat,nrec,tmp3,mxrec,qsname,io12)
         else
            call WRDAT(io12,cname,qpeak,nrec,1)
            call WRDAT(io12,qbname,qback,nrec,1)
            call WRDAT(io12,qsname,qsat,nrec,1)
         endif
      endif

c --- Reset maximum temperature excess for next step
      txsmxfog=9999.

      return
      end
c----------------------------------------------------------------------
      subroutine vsat(tdegk,psat,csat)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602                   VSAT
c                J. Scire, Earth Tech
c
c --- PURPOSE:  Compute saturation vapor pressure and corresponding
c               saturation mass concentration for given temperature
c
c --- INPUTS:
c          tdegk - real       - Temperature (K)
c
c --- OUTPUT:
c           psat - real       - Saturation water vapor pressure (mb)
c           csat - real       - Saturation water vapor mass
c                               concentration (g h2o/m**3 air)
c
c --- VSAT called by:   PLMFOG, FOGOUT
c --- VSAT calls:       none
c----------------------------------------------------------------------
c
      data gascon/8.31372e-2/

c --- Compute saturation vapor pressure (Goff-Gratch eqns.)
      trat=273.16/tdegk
      if(tdegk.lt.273.16)then
c ---    temperature below 0. deg. C
         psat=exp(2.303*(-9.09685*(trat-1.0)+
     1   0.87682*(1.0-tdegk/273.16))-3.56654*(5.6100577-alog(tdegk))+
     2   1.81)
      else
c ---    temperature above 0. deg. C
         psat=exp(2.303*(10.79574*(1.0-trat)+
     1   1.50475e-4*(1.0-10.**(-8.2969*(tdegk/273.16-1.0)))+
     2   4.2873e-4*(10.**(4.76955*(1.0-trat))-1.0))-
     3   5.028*(alog(tdegk)-5.6100577)+1.81)
      endif

c --- Compute saturation water vapor mass concentration (g h2o/m**3 air)
c --- (gascon is the gas constant -- 8.31372e-2 m**3*mb/(mole*deg k)
      csat=18.016*psat/(gascon*tdegk)

      return
      end
c----------------------------------------------------------------------
      subroutine rdhdaq(dtype,iunit,versaq,lprt,nsta,ibdathr,ibsec,
     & iedathr,iesec,t2btz,iutm,pmap,utmhem,datum,daten,xyunit,
     & feast,fnorth,rnlat0,relon0,rnlat1,rnlat2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                 RDHDAQ
c                J. Scire, D. Strimaitis 
c
c --- PURPOSE:  Read the header records from an air quality data file
c               (e.g. OZONE.DAT, H2O2.DAT)
c
c --- UPDATE
c --- V6.2-V6.22:  070921 (DGS):Condition GEO referencing string
c                               variables and add QA
c                               Remove calls to ALLCAP
c --- V6.114-V6.2: 070629 (DGS):Fix typo in call to YR4 for dataset
c                               version 1.5a
c --- V6.102-V6.114:060725(DGS):Expand input processing to include
c                               headers for PS,EM,LAZA,TTM maps for
c                               version 2.1 datasets
c --- V6.1-V6.102: 051130 (DGS):Drop LLORDER from header for Lat/Lon
c                               coordinates.  These files require the
c                               order to be (lat,lon), and values
c                               include N/S or E/W explicitly.
c                  051130 (DGS):Fix bug in reading the UTM zone and
c                               hemispere, and XYUNITS
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added,
c                               including full coordinate and time
c                               documentation with begin/end times with
c                               seconds.
c                               Header information is passed to scratch
c                               file.
c --- V5.5-V5.7 : 030402 (DGS): Add list file unit to YR4 call
c
c --- INPUTS:
c            DTYPE - C*12       - Data type: e.g. ('OZONE' or 'H2O2')
c                                 [Upper Case]
c            IUNIT - integer    - Fortran unit number of data file
c           VERSAQ - C*16       - Data set version
c             LPRT - logical    - Flag controlling printing of header
c                                 record data (F=suppress, T=print)
c
c     Common Block /DATEHR/ variables:
c            XBTZ
c     Common Block /QA/ variables:
c            NCOMMOUT
c        Parameters:
c            IO6, IOX, MXAQ
c
c --- OUTPUT:
c             NSTA - integer - Number of stations in the data file
c          IBDATHR - integer - Date/hour at beginning of period for
c                              the first data record in the file
c                              (YYYYJJJHH, where YYYY=year,
c                              JJJ=Julian day, HH=hour [00-23 LST])
c            IBSEC - integer - Seconds of the first data record in the
c                              file  (0000-3599)
c          IEDATHR - integer - Date/hour at end of period for
c                              the last data record in the file
c                              (YYYYJJJHH, where YYYY=year,
c                              JJJ=Julian day, HH=hour [00-23 LST])
c            IESEC - integer - Seconds of the last data record in the
c                              file  (0000-3599)
c            T2BTZ - real    - Time to ADD to dataset time to convert
c                              to the Base Time Zone
c             IUTM - integer - UTM zone in which the station
c                              coordinates are specified
c             PMAP - char    - Character code for input map projection
c                              LL  :  Latitude/longitude
c                              UTM :  Universal Transverse Mercator
c                              LCC :  Lambert Conformal Conic
c                              PS  :  Polar Stereographic
c                              EM  :  Equatorial Mercator
c                              LAZA:  Lambert Azimuthal Equal Area
c                              TTM :  Tangential Transverse Mercator
c           UTMHEM - char    - Base hemisphere for UTM projection
c                               (S=southern, N=northern)
c            DATUM - char    - Datum-Region for grid coordinates
c            DATEN - char    - NIMA date for datum parameters
c                                    (MM-DD-YYYY  )
c           XYUNIT - char    - Units for coordinates (e.g., KM)
c           FEAST  - real    - False Easting (km) at projection origin
c           FNORTH - real    - False Northing (km) at projection origin
c          RNLAT0, - real    - N. latitude & E. longitude of x=0 and y=0
c           RELON0 (deg)       of map projection (Used only if PMAP =
c                              LCC, PS, EM, TTM or LAZA) 
c                              NOTE: longitude neg in western hemisphere
c          RNLAT1, - real    - Matching N. latitude(s) for projection
c          RNLAT2 (deg)        (Used only if PMAP3= LCC, PS, or EM)
c                              LCC :  Projection cone slices through
c                                     Earth's surface at XLAT1 and XLAT2
c                              PS  :  Projection plane slices through
c                                     Earth at XLAT1
c                              EM  :  Projection cylinder slices through
c                                     Earth at [+/-] XLAT1
c     Common Block /QA/ variables:
c            NCOMMOUT
c
c --- RDHDAQ called by: CHEMI
c --- RDHDAQ calls:     YR4, INCR, XTRACTLL, TCLOCK, GEOFMT
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'datehr.puf'
      include 'qa.puf'
c
      character*12 fname,vrs,lab
      character*12 dtype
      logical lprt

      logical lgeo,lutm,llcc,lps,lem,llaza,lttm

      character*8 axtz
      character*16 dataset,dataver,versaq
      character*16 clat0,clon0,clat1,clat2
      character*33 blank33,break33
      character*64 datamod
      character*132 comment1,blank,break

      character*4 utmhem,xyunit
      character*8 datum,pmap
      character*12 daten

      data blank33/'                                 '/
      data break33/'.................................'/
      data nlim/1/
      data zero/0.0/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Set break (132 characters)
      break(1:33)=break33
      break(34:66)=break33
      break(67:99)=break33
      break(100:132)=break33

c --- Begin scratch file image
      write(iox,'(a132)') blank
      write(iox,'(a132)') break
      write(iox,'(a132)') blank
      ncommout=ncommout+3

c --- Initialize local map projection logicals
      lgeo=.FALSE.
      lutm=.FALSE.
      llcc=.FALSE.
      lps=.FALSE.
      lem=.FALSE.
      llaza=.FALSE.
      lttm=.FALSE.

c --- Initialize other variables
      daten='02-21-2003  '
      xyunit='KM  '
      ibsec=0.0
      iesec=0.0
      feast=0.0
      fnorth=0.0
      clat0='0.0N            '
      clon0='0.0W            '
      clat1='0.0N            '
      clat2='0.0N            '
      dataset='                '
      dataver='                '
      pmap='XXX     '
      iutm=1
      utmhem='N   '
      datum='XXX     '
      axtz='UTC+0000'

c --- AQ routines currently configured for OZONE, H2O2
      if(dtype.EQ.'OZONE       ')then
         dataset='OZONE.DAT    '
      elseif(dtype.EQ.'H2O2        ')then
         dataset='H2O2.DAT     '
      else
         write(*,*)'ERROR in RDHDAQ '
         write(*,*)'Bad calling argument: ',dtype
         write(*,*)'Expected OZONE or H2O2'
         stop
      endif


c     -------------------------
      if(versaq.EQ.'1.5') then
c     -------------------------

c ---    Provide help and then stop (old format not supported)

         read(iunit,*)fname,nsta,iutm,ibdat,ibhr,iedat,iehr,
     &                vrs,lab
         dataver='1.5a            '
         datamod(1:40)='Augmented 5 format with Map Projection, '
         datamod(41:64)='DATUM, Time Zone        '


         write(io6,*)
         write(io6,*)
         write(io6,*)'ERROR in data file for ',dtype
         write(io6,*)
         write(io6,*)'Old file format cannot be used because:'
         write(io6,*)'1.  Coordinate map projection is incomplete'
         write(io6,*)'2.  The DATUM for the coordinates is missing'
         write(io6,*)'3.  The time zone is missing'
         write(io6,*)
         write(io6,*)'ADD these records to the top of the file:'
         write(io6,*)
         write(io6,'(2a16,a64)') dataset,dataver,datamod
         if(iutm.NE.0) then
            write(io6,'(a8)')'UTM     '
            write(io6,'(a8)')'  xxN   '
         else
            write(io6,'(a8)')'LCC     '
            write(io6,'(4a16)')'yy.yyyN         ','xx.xxxW         ',
     &                         'yy.yyyN         ','yy.yyyN         '
            write(io6,*)zero,zero
         endif
         write(io6,'(a8)')'DATUM   '
         write(io6,'(a8)')'UTC-0500'
         write(io6,*)
         write(io6,*)'UPDATE these records to describe your file:'
         if(iutm.NE.0) then
           write(io6,*)'- Replace the xxN with your UTM zone and',
     &                 ' hemisphere (S for Southern Hemisphere)'
         else
           write(io6,*)'- Replace the xx.xxxW and yy.yyyN with your',
     &                 ' LCC projection parameters.'
           write(io6,*)'  The order is Origin Latitude, Origin',
     &                 ' Longitude, and the 2 Matching Parallels'
           write(io6,*)'  (each field is 16 characters)'
           write(io6,*)'- Replace the 0.0 0.0 with your False Easting',
     &                 ' and Northing if non-zero'   
         endif
         write(io6,*)'- Replace DATUM with your datum code (enter',
     &               ' left-justified in the 8-character field)'
         write(io6,*)'- Replace UTC-0500 with your time zone code'
         write(io6,*)'  (GMT=UTC+0000, EST=UTC-0500, CET=UTC+0100)'
         write(io6,*)
         write(*,*)
         write(*,*)'ERROR in ',dtype,' file -- see list file'
         write(*,*)
         stop

c     ------------------------------
      elseif(versaq.EQ.'1.5a') then
c     -----------------------------

c ---    Augmented headers

         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         ncommout=ncommout+1
c ---    Map projection
         read(iunit,'(a8)') pmap
         write(iox,'(a8)') pmap
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmap,iutm,utmhem,clat0,clon0,
     &               clat1,clat2,datum,daten,xyunit,axtz)

         if(pmap.EQ.'LL      ')  lgeo =.TRUE.
         if(pmap.EQ.'UTM     ')  lutm =.TRUE.
         if(pmap.EQ.'LCC     ')  llcc =.TRUE.
         if(pmap.EQ.'PS      ')  lps  =.TRUE.
         if(pmap.EQ.'EM      ')  lem  =.TRUE.
         if(pmap.EQ.'LAZA    ')  llaza=.TRUE.
         if(pmap.EQ.'TTM     ')  lttm =.TRUE.
c ---    Map projection parameters
         if(LUTM) then
            read(iunit,'(i4,a4)') iutm,utmhem
            write(iox,'(i4,a4)')  iutm,utmhem
            ncommout=ncommout+1
         elseif(LLCC) then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCC) then
            read(iunit,*) feast,fnorth
            write(iox,*)  feast,fnorth
            ncommout=ncommout+1
         endif
c ---    Map DATUM
         read(iunit,'(a8)') datum
         write(iox,'(a8)')  datum
         ncommout=ncommout+1
c ---    Time zone
         read(iunit,'(a8)') axtz
         write(iox,'(a8)')  axtz
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmap,iutm,utmhem,clat0,clon0,
     &               clat1,clat2,datum,daten,xyunit,axtz)

c ---    Process time zone
         read(axtz(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDAQ -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz
            stop 'Halted in RDHDAQ -- see list file'
         endif
         xtz=-FLOAT(ibtzhh)

c ---    Old Header Record(s)

c
c --- Header Record #1 - General data - beginning, ending dates &
c                        times, UTM zone, number of stations
c
         read(iunit,*)fname,nsta,iutmx,ibdat,ibhr,iedat,iehr,vrs,lab
         write(iox,'(a12,6i6,2a12)')fname,nsta,iutmx,ibdat,ibhr,
     &                              iedat,iehr,vrs,lab

c ---    Enforce YYYY format
         ibyr=ibdat/1000
         ibdy=ibdat-1000*ibyr
         ieyr=iedat/1000
         iedy=iedat-1000*ieyr
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) then
            write(*,*)
            stop 'Halted in RDHDAQ -- see list file.'
         endif

c     -----------------------------
      elseif(versaq.EQ.'2.1') then
c     -----------------------------

c ---    First record and comments
         read(iunit,'(2a16,a64)') dataset,dataver,datamod
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         read(iunit,*) ncom
         write(iox,*) ncom
         do k=1,ncom
            comment1=blank
            read(iunit,'(a132)') comment1
            write(iox,'(a132)') comment1
         enddo
         ncommout=ncommout+2+ncom
c ---    Map projection
         read(iunit,'(a8)') pmap
         write(iox,'(a8)') pmap
         ncommout=ncommout+1

c ---    Condition map projection (rest are dummies)
         call GEOFMT(dataset,dataver,pmap,iutm,utmhem,clat0,clon0,
     &               clat1,clat2,datum,daten,xyunit,axtz)

         if(pmap.EQ.'LL      ')  lgeo =.TRUE.
         if(pmap.EQ.'UTM     ')  lutm =.TRUE.
         if(pmap.EQ.'LCC     ')  llcc =.TRUE.
         if(pmap.EQ.'PS      ')  lps  =.TRUE.
         if(pmap.EQ.'EM      ')  lem  =.TRUE.
         if(pmap.EQ.'LAZA    ')  llaza=.TRUE.
         if(pmap.EQ.'TTM     ')  lttm =.TRUE.
c ---    Map projection parameters
         if(LUTM) then
            read(iunit,'(i4,a4)') iutm,utmhem
            write(iox,'(i4,a4)')  iutm,utmhem
            ncommout=ncommout+1
         elseif(LLCC) then
            read(iunit,'(4a16)') clat0,clon0,clat1,clat2
            write(iox,'(4a16)')  clat0,clon0,clat1,clat2
            ncommout=ncommout+1
         elseif(LPS) then
            read(iunit,'(3a16)') clat0,clon0,clat1
            write(iox,'(3a16)')  clat0,clon0,clat1
            ncommout=ncommout+1
         elseif(LEM.or.LLAZA.or.LTTM) then
            read(iunit,'(2a16)') clat0,clon0
            write(iox,'(2a16)')  clat0,clon0
            ncommout=ncommout+1
         endif
c ---    Map false Easting/Northing
         if(LLCC.or.LLAZA.or.LTTM) then
            read(iunit,*) feast,fnorth
            write(iox,*)  feast,fnorth
            ncommout=ncommout+1
         endif
c ---    Map DATUM
         read(iunit,'(a8,a12)') datum,daten
         write(iox,'(a8,a12)')  datum,daten
         ncommout=ncommout+1
c ---    Units
         read(iunit,'(a4)') xyunit
         write(iox,'(a4)')  xyunit
         ncommout=ncommout+1
c ---    Time zone
         read(iunit,'(a8)') axtz
         write(iox,'(a8)')  axtz
         ncommout=ncommout+1

c ---    Condition remaining variables
         call GEOFMT(dataset,dataver,pmap,iutm,utmhem,clat0,clon0,
     &               clat1,clat2,datum,daten,xyunit,axtz)

c ---    Process time zone
         read(axtz(4:6),'(i3)') ibtzhh
         if(ibtzhh.LT.-13 .OR. ibtzhh.GT.13) then
            write(io6,*)'FATAL Error in RDHDAQ -- Time Zone'
            write(io6,*)'Expected UTC-1300 to UTC+1300'
            write(io6,*)'Found: ',axtz
            stop 'Halted in RDHDAQ -- see list file'
         endif
         xtz=-FLOAT(ibtzhh)

c ---    Time period
         read(iunit,*)ibyr,ibdy,ibhr,ibsec,
     &                ieyr,iedy,iehr,iesec
c ---    Enforce YYYY format for year
         call YR4(io6,ibyr,ierrb)
         call YR4(io6,ieyr,ierre)
         if(ierrb.NE.0 .OR. ierre.NE.0) stop 'Halted in RDHDAQ'
         write(iox,'(9i6)')ibyr,ibdy,ibhr,ibsec,
     &                     ieyr,iedy,iehr,iesec
         ncommout=ncommout+1

c ---    Number of stations
         read(iunit,*) nsta
         write(iox,*) nsta
         ncommout=ncommout+1

c     -----
      else
c     -----

         write(*,*)'ERROR in ',dtype,' File '
         write(*,*)'Bad Dataset Version: ',versaq
         write(*,*)'Expected 1.5, 1.5a, 2.1'
         stop

c     -----
      endif
c     -----

      if(nsta.gt.mxaq)then
         write(io6,12)nsta,mxaq
12       format(/1x,'ERROR in SUBR. RDHDAQ -- No. of stations ',
     1   ' in data file is greater than current array dimension'/1x,
     2   '          No. stations in file: ',i5/1x,
     3   'Current Array dimension (MXAQ): ',i5)
         write(*,*)
         stop 'Halted in RDHDAQ -- see list file.'
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibsec)
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iesec)

c --- Apply time zone adjustment to date/times
      if(xtz.GE.-13 .AND. xtz.LE.13) then
         t2btz=xtz-xbtz
         ishift=NINT(t2btz)
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
         call INCR(io6,ieyr,iedy,iehr,ishift)
      else
         write(io6,*)
         write(io6,*)'ERROR in ',dtype,' file : Bad Time Zone'
         write(io6,*)'Expected zone between -13 and 13'
         write(io6,*)'Found zone = ',xtz
         stop 'Bad Time Zone in OZONE or H2O2 file -- see list file'
      endif

c --- Hourly Data:  Move the time for the first period from the end
c ---               to the start of the first hour
      if(versaq.NE.'2.1') then
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      endif

c --- Form date-hr variables
      ibdathr=ibyr*100000+ibdy*100+ibhr
      iedathr=ieyr*100000+iedy*100+iehr

c --- Process lat/lon character variables to extract content
      call XTRACTLL(io6,'LAT ',clat1,rnlat1)
      call XTRACTLL(io6,'LAT ',clat2,rnlat2)
      call XTRACTLL(io6,'LAT ',clat0,rnlat0)
      call XTRACTLL(io6,'LON ',clon0,relon0)

c --- WRITE CONTENTS OF HEADER RECORDS (if requested)
      if(lprt)then
         write(io6,101) dtype
101      format(///1x,13('----------')//1x,'Header record data from ',
     1   a12,' file')
         write(io6,102)dataset,axtz,nsta,
     &         ibdathr,ibsec,iedathr,iesec,pmap,
     &         datum
102      format(/1x,'DATASET: ',a16/1x,
     1   'AXTZ:   ',a8,'NSTA:   ',i8,/
     2   1x,'IBDATHR:',i9/1x,'IBSEC:  ',i4/
     3   1x,'IEDATHR:',i9/1x,'IESEC:  ',i4/
     4   1x,'MAP:    ',a8/1x,'DATUM:   ',a8)

         if(LUTM) write(io6,104) iutm,utmhem
         if(LLCC) write(io6,105) clat0,clon0,clat1,clat2,
     &                                 feast,fnorth
         if(LPS) write(io6,106) clat0,clon0,clat1
         if(LEM) write(io6,107) clat0,clon0
         if(LLAZA.or.LTTM) write(io6,108) clat0,clon0,
     &                                 feast,fnorth

104      format(/1x,'UTMZN:   ',i4/1x,'UTMHEM:  ',a4)
105      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16/1x,'Lat2:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)
106      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'Lat1:    ',a16)
107      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16)
108      format(/1x,'Lat0:    ',a16/1x,'Lon0:    ',a16/
     &           1x,'False_E: ',f15.3/1x,'False_N: ',f15.3)

      endif

c
      return
      end
c----------------------------------------------------------------------
      subroutine rdtiaq(dtype,iunit,nsta,pmap,ldb,cid,xeast,ynorth)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 051130                 RDTIAQ
c                J. Scire, D. Strimaitis  Earth Tech
c
c --- PURPOSE:  Read the time-invariant records of an air quality data
c               file (e.g. OZONE, H2O2)
c
c --- UPDATE
c --- V6.1-V6.102: 051130 (DGS):Drop LLORDER for Lat/Lon coordinates.
c                               These files require the order to be
c                               (lat,lon), and values include N/S/E/W.
c                               Add PMAP to test for LL.
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1
c                               Header information is passed to scratch
c                               file.
c
c --- INPUTS:
c            DTYPE - C*12       - Data type: e.g. ('OZONE' or 'H2O2')
c                                 [Upper Case]
c            IUNIT - integer    - Fortran unit number of data file
c             NSTA - integer    - Number of stations in the data file
c             PMAP - char*8     - Map projection
c             LPRT - logical    - Flag controlling printing of header
c                                 record data (F=suppress, T=print)
c     Common Block /QA/ variables:
c            NCOMMOUT
c        Parameters:
c            IO6, IOX
c
c --- OUTPUT:
c        CID(nsta) - C*16 array - Station identifiers (16 characters)
c      xeast(nsta) - real array - Coordinate 1 of the station
c                                 Easting (km) or ELongitude (deg)
c     ynorth(nsta) - real array - Coordinate 2 of the station
c                                 Northing (km) or NLatitude (deg)
c
c     Common Block /QA/ variables:
c            NCOMMOUT
c
c --- RDTIAQ called by: CHEMI
c --- RDTIAQ calls:     XTRACTLL
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'qa.puf'
c
      real xeast(nsta),ynorth(nsta)
      character*16 cid(nsta)
c
      character*8 pmap
      character*12 dtype
      character*16 alat,alon
      logical ldb

c --- Coordinates may be latitude/longitude strings
      if(pmap.EQ.'LL      ') then
c ---    Loop over data stations
         do i=1,nsta
            read(iunit,*)cid(i),alat,alon
            write(iox,'(3a20)')cid(i),alat,alon
            ncommout=ncommout+1
c ---       Conver to real NLAT and ELON and place in arrays
            call XTRACTLL(io6,'LON ',alon,xeast(i))
            call XTRACTLL(io6,'LAT ',alat,ynorth(i))
         enddo
      else
c ---    Loop over data stations
         do i=1,nsta
            read(iunit,*)cid(i),xeast(i),ynorth(i)
            write(iox,'(a16,2f12.3)')cid(i),xeast(i),ynorth(i)
            ncommout=ncommout+1
         enddo
      endif
c
      if(ldb)then
         write(io6,*) 'Time-invariant data from file ',dtype
         do i=1,nsta
            write(io6,*)'I = ',i,' CID(i) = ',cid(i),
     &                  ' XEast(i) = ',xeast(i),
     &                  ' YNorth(i) = ',ynorth(i)
         enddo
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine rdaq(iunit,dtype,vers,idathrm,isecm,tzhr,nsta,ldb,
     &                ibegh,ibegs,iendh,iends,aqconc,leof)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                   RDAQ
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Read the time-varying records of an air quality data
c               file (e.g OZONE, H2O2)
c
c --- UPDATE
c --- V5.7-V6.1 : 050915 (DGS): Dataset version 2.1 is added, and other
c                               versions are retained.
c                               Begin/end times include seconds.
c --- V5.5-V5.7 : 030402 (DGS): Add list file unit to YR4 call
c
c --- INPUTS:
c            IUNIT - integer    - Fortran unit number of data file
c            DTYPE - C*12       - Data type: ('OZONE' or 'H2O2')
c             VERS - char*16    - Data-set version for file
c          IDATHRM - integer    - Mid-pt date/hour of required
c                                 data (YYYYJJJHH)
c            ISECM - integer    - Mid-pt second of required data (SSSS)
c             TZHR - real       - Hours to ADD to times in file to
c                                 convert to BASE TIME ZONE
c             NSTA - integer    - Number of stations in the data file
c              LDB - logical    - Flag controlling printing of data
c        Parameters:
c            IO6
c
c --- OUTPUT:
c      IBEGH,IBEGS - integer    - Starting date-time for which data
c                                 in current set of records is valid
c                                 (YYYYJJJHH , SSSS) in BASE TIME ZONE
c      IENDH,IENDS - integer    - Ending date-time for which data
c                                 in current set of records is valid
c                                 (YYYYJJJHH , SSSS) in BASE TIME ZONE
c     AQCONC(nsta) - real       - Concentration at each station
c                                 (NOTE: 9999. used as
c                                 a missing value indicator)
c             LEOF - logical    - End-Of-File flag
c
c --- RDAQ called by: CHEM
c --- RDAQ calls:     YR4, INCR, TPERIOD, TCLOCK
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      real aqconc(nsta)
      character*12 dtype
      character*16 vers
      logical ldb,leof

1     continue

c --- Read the data record
      if(vers.EQ.'1.5a') then
         ibegs=0.0
         iends=0.0
         read(iunit,*,end=999)ieyr,iedy,iehr,aqconc
c ---    Shift start time to beginning of hour
         ibyr=ieyr
         ibdy=iedy
         ibhr=iehr
         ishift=-1
         call INCR(io6,ibyr,ibdy,ibhr,ishift)
      elseif(vers.EQ.'2.1') then
         read(iunit,*,end=999)ibyr,ibdy,ibhr,ibegs,
     &                        ieyr,iedy,iehr,iends,aqconc
      else
         write(io6,*)
         write(io6,*)'RDAQ: Invalid Dataset Version for ',dtype
         write(io6,*)'Expected 1.5a,2.1'
         write(io6,*)'Found: ',vers
         write(*,*)
         stop 'Halted in RDAQ -- see list file.'
      endif

c --- Enforce YYYY format for year
      call YR4(io6,ibyr,ierrb)
      call YR4(io6,ieyr,ierre)
      if(ierrb.NE.0 .OR. ierre.NE.0) then
         write(*,*)
         stop 'Halted in RDAQ'
      endif

c --- Condition times
      idum=-999
      call TCLOCK(io6,idum,ibyr,ibdy,ibhr,ibegs)
      call TCLOCK(io6,idum,ieyr,iedy,iehr,iends)

c --- Adjust times to BASE TIME ZONE
      ishift=NINT(tzhr)
      call INCR(io6,ibyr,ibdy,ibhr,ishift)
      call INCR(io6,ieyr,iedy,iehr,ishift)

c --- Form date-hour
      ibegh=ibyr*100000+ibdy*100+ibhr
      iendh=ieyr*100000+iedy*100+iehr

c --- Check period of AQ data with mid-point of step
      call TPERIOD(0,idathrm,isecm,ibegh,ibegs,iendh,iends,ilocate)
      if(ilocate.EQ.1) then
c ---    Obtain next time period in AQ file
         go to 1
      elseif(ilocate.EQ.-1) then
         write(io6,*)'ERROR in subr. RDAQ -- current time not found',
     1   ' in the data file ',dtype
         write(io6,*)' -- Current date/hour,sec = ',idathrm,isecm
         write(io6,*)' -- Last date/hour,sec read = ',ibegh,ibegs
         write(io6,*)'                           to ',iendh,iends
         stop 'Halted in RDAQ -- see list file.'
      endif

      if(ldb)then
         write(io6,*)
         write(io6,*)'Data File: ',dtype
         write(io6,*)'Time-varying data for period'
         write(io6,*)' -- from = ',ibegh,ibegs
         write(io6,*)' --   to = ',iendh,iends
         write(io6,*)'AQCONC = ',aqconc
      endif
c
      return

999   write(io6,*)'RDAQ: End-Of-File found in data file'
      leof=.TRUE.
      return

      end
c----------------------------------------------------------------------
      subroutine geth2o2(ixs,iys,dgrid,ldb,chih2o2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_3              GETH2O2
c                J. Scire, SRC
c
c --- PURPOSE:  Determine the appropriate value of H2O2 concentration
c               to use in the aqueous phase chemical routine
c                -- Use monthly background value if MH2O2 = 0
c                -- Read hourly values if MH2O2 = 1
c
c --- INPUTS:
c              IXS - integer - X index of the closest met. grid point
c                              to the puff/slug center
c              IYS - integer - Y index of the closest met. grid point
c                              to the puff/slug center
c            DGRID - real    - Grid spacing (m)
c              LDB - logical - Control variable determining if debug
c                              information is printed
c
c     Common block /CHEMDAT/ variables:
c           MH2O2, BCKH2O2, NH2O2STA, H2O2CONC(mxaq), XH2O2M(mxaq),
c           YH2O2M(mxaq), NEARH2O2(mxnx,mxny)
c     Parameters:
c           MXNX, MXNY, MXOZ, IO6, IO23
c
c --- OUTPUT:
c          CHIH2O2 - real    - H2O2 concentration (ppb)
c
c --- GETH2O2 called by:  CHEM
c --- GETH2O2 calls:      FINDR
c----------------------------------------------------------------------
c
      include 'params.puf'
c
      logical ldb
c
      include 'chemdat.puf'
c
c --- Missing value indicator
      data xmiss/9999./
c
      if(mh2o2.eq.0)then
         chih2o2=bckh2o2
      elseif(mh2o2.eq.1)then
c
c ---    ISTA is the H2O2 station closest to grid point (IXS,IYS)
         istah2o2=nearh2o2(ixs,iys)
c
c ---    Determine H2O2 concentration (ppb) at the closest station
         chih2o2=h2o2conc(istah2o2)
         if(chih2o2.ge.xmiss)then
c
c ---       Compute grid point coordinates (m) relative to met.
c ---       grid origin
            xgrd=(float(ixs)-0.5)*dgrid
            ygrd=(float(iys)-0.5)*dgrid
c
c ---       Find closest H2O2 station with non-missing data
            call findr(xh2o2m,yh2o2m,nh2o2sta,h2o2conc,xgrd,ygrd,
     1      istah2o2,chih2o2,ierr)
c
c ---       If all station data missing, use default background conc.
            if(ierr.eq.1)chih2o2=bckh2o2
         endif
      else
         write(io6,*)'ERROR in subr. GETH2O2 -- Invalid MH2O2 value',
     1   ' -- MH2O2 = ',mh2o2
         write(*,*)
         stop 'Halted in GETH2O2 -- see list file.'
      endif
c
c*****
      if(ldb)then
         write(io6,*)
         write(io6,*)'SUBR. GETH2O2 -- ixs = ',ixs,' iys = ',iys,
     1   ' dgrid = ',dgrid,' istah2o2 = ',istah2o2
         write(io6,*)'h2o2conc = ',(h2o2conc(n),n=1,nh2o2sta)
         write(io6,*)'chih2o2  = ',chih2o2
      endif
c*****
      return
      end
c----------------------------------------------------------------------
      subroutine aqtest(delt,con,coz,ctnh3,ch2o2,temp,rhoair,
     1 ldb,io6,r)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 000602_3               AQTEST
c                J. Scire          Earth Tech
c
c --- PURPOSE:  STUB routine in place of aqueous phase oxidation of SO2
c
c
c --- INPUTS:
c         DELT - real    - integration time interval (hours)
c       CON(5) - real    - Concentrations current time (g/m**3)
c                            CON(1) = SO2  (not used within CHEMTF)
c                            CON(2) = SO4
c          COZ - real    - background ozone concentration (ppb)
c        CTNH3 - real    - background ammonia concentration (ppb)
c        CH2O2 - real    - background hydrogen peroxide (ppb)
c         TEMP - real    - temperature (deg. K)
c       RHOAIR - real    - surface air density (kg/m**3)
c          LDB - logical - Control variable for printing of debug
c                          information
c          IO6 - integer - Fortran unit number of printed output
c
c --- OUTPUT:
c            R - real    - Transformation rates (percent/hour)
c                            R(1) -- SO2 loss rate
c
c --- AQTEST called by: CHEMTF, CHEMRIV
c --- AQTEST calls:     none
c----------------------------------------------------------------------
c
      real con(5)
      logical ldb
c
      r=0.0
c --- Use input variables (nonsense)
      sum=delt+con(1)+coz+ctnh3+ch2o2+temp+rhoair
      r=r*sum

      if(LDB) then
         write(io6,*) 'AQTEST:    R = ',r
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine rdemsrc(nardat,nvoldat,em3dat,em4dat,em5dat,em5grp)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921                RDEMSRC
c                D. Strimaitis
c
c --- PURPOSE:  Pull source location data from the first set of 
c ---           time-variable records for area, volume, and line 
c ---           sources and reposition file pointers (source locations
c ---           are written to output files)
c
c --- UPDATE
c --- V6.1-V6.22    070921  (DGS): Change LDB to LPRT in RDEM5 call
c --- 5.725-V6.1    050915  (DGS): Use begin-time/end-time (seconds)
c                                  for variable emissions files
c                                  and allow coordinate projection
c                                  transformations
c --- V5.72-V5.725  050128  (DGS): Add logical argument PROBLEM to
c                                  LN2FILL call
c
c --- INPUTS:
c
c             NARDAT - integer  - Number of area source files
c            NVOLDAT - integer  - Number of volume source files
c             EM3DAT - real arr - Array allocated for area source data
c             EM4DAT - real arr - Array allocated for volumesource data
c             EM5DAT - real arr - Array allocated for line source data
c             EM5GRP - real arr - Array allocated for line source data
c
c     Common block /DATASET/ variables:
c           veraarb(mxemdat),verlarb,vervarb(mxemdat)
c
c --- OUTPUT:
c
c     Common block /AR2/
c        XAR2GRD(mxvertp1,mxqstep,mxarea),
c        YAR2GRD(mxvertp1,mxqstep,mxarea)
c     Common block /VOL2/
c        XVL2GRD(mxqstep,mxvol),YVL2GRD(mxqstep,mxvol),
c        ELVL2(mxqstep,mxvol)
c     Common block /LN2/
c        XL2BEGGRD(mxqstep,mxlines),YL2BEGGRD(mxqstep,mxlines),
c        XL2ENDGRD(mxqstep,mxlines),YL2ENDGRD(mxqstep,mxlines),
c        XL2BAR(mxqstep,mxlngrp),YL2BAR(mxqstep,mxlngrp)
c
c --- Parameters used:       
c        IO6, IOPT2, IOAR2, IOVOL, IO19, MXLNGRP
c
c --- RDEMSRC called by: SETUP
c --- RDEMSRC calls:     RDEM3, RDEM4, RDEM5, LN2FILL,
c                        SKIPHDEM3, SKIPHDEM4, SKIPHDEM5,
c                        GLOBE, GLOBE1
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Set number of variables before emissions in 'EMARB' arrays
c --- as parameters
      parameter(nvarpt=4, nvarba=14, nvarln=6, nvarvl=6)
c
c --- Include common blocks
      include 'dataset.puf'
      include 'grid.puf'
      include 'ar2.puf'
      include 'ln2.puf'
      include 'map.puf'
      include 'qa.puf'
      include 'vol2.puf'
c
      logical lprt,lnar2,lnvl2

c --- Time-variable emission arrays (declare actual dimensions here)
      real em3dat(nse3+nvarba,nar2)
      real em4dat(nse4+nvarvl,nvl2)
      real em5dat(nse5+nvarln,nln2),em5grp(7,mxlngrp)
      integer idmap(mxlines),igrp(mxlngrp)

c --- For coordinate transformations
      character*8 cmapi,cmapo
      character*12 caction
      character*4 c4hem
      real*8 vecti(9),vecto(9)

c --- Scale factor for Tangential TM projection
      tmsone=1.00000

c --- Output of coord transform is to CALPUFF (x,y) - /MAP/
      iutmo=iutmzn
      if(utmhem.EQ.'S   ' .AND. iutmo.LT.900) iutmo=-iutmo
      cmapo=pmap
      if(cmapo.EQ.'TTM     ') cmapo='TM      '

      lprt=.true.

c --- Variable area sources
c -------------------------
      if(nar2.GT.0) then
c ---    Loop over BAEMARB files for all source locations
         do ia=1,nardat
            io=ioar2+ia-1

c ---       Set up map projection conversion to CALPUFF coordinates
c ---       Input is from BAEMARB.DAT header - /ar2/
            iutmi=iutmznar2(ia)
            if(utmhemar2(ia).EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
            cmapi=pmapar2(ia)
            if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---       Set conversion vectors
            call GLOBE1(cmapi,iutmi,tmsone,rnlat1ar2(ia),rnlat2ar2(ia),
     $                  rnlat0ar2(ia),relon0ar2(ia),
     &                  feastar2(ia),fnorthar2(ia),
     &                  cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &                  feast,fnorth,
     &                  caction,vecti,vecto)

            call RDEM3(io,nar2,nse3,cid3,ibsrc3(ia),iesrc3(ia),
     &                 veraarb(ia),t2btz3(ia),lprt,io6,ibegh,
     &                 ibegs,iendh,iends,em3dat,ieof)
c ---       Swap location data into /ar2/
            do i=ibsrc3(ia),iesrc3(ia)
c ---          Compute & store relative vertex coordinates;
c ---          accumulate sums for computing the mean location of
c ---          the area source
               sumx=0.
               sumy=0.
c ---          Explicitly allow ONLY 4-sided shapes!
               nvert2(i)=4
               do iv=1,nvert2(i)
                  xvert3=em3dat(iv,i)
                  yvert3=em3dat(iv+nvert2(i),i)
c ---             Apply coordinate transformation
                  call GLOBE(io6,caction,datumar2(ia),vecti,datum,
     &                       vecto,xvert3,yvert3,xvert,yvert,
     &                       izone,c4hem)
                  xar2grd(iv,1,i)=(1000.*xvert-xorig)*dgridi
                  yar2grd(iv,1,i)=(1000.*yvert-yorig)*dgridi
                  sumx=sumx+xar2grd(iv,1,i)
                  sumy=sumy+yar2grd(iv,1,i)
               enddo
c ---          Mean location of source
               xar2grd(nvert2(i)+1,1,i)=sumx/FLOAT(nvert2(i))
               yar2grd(nvert2(i)+1,1,i)=sumy/FLOAT(nvert2(i))
            enddo
            REWIND(io)
         enddo
c ---    Reposition pointer to start of data records
         call SKIPHDEM3(nardat)
      endif

c --- Variable volume sources
c ----------------------------
      if(nvl2.GT.0) then
c ---    Loop over VOLEMARB files for all source locations
         do iv=1,nvoldat
            io=iovol+iv-1

c ---       Set up map projection conversion to CALPUFF coordinates
c ---       Input is from VOLEMARB.DAT header - /vol2/
            iutmi=iutmznvl2(iv)
            if(utmhemvl2(iv).EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
            cmapi=pmapvl2(iv)
            if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---       Set conversion vectors
            call GLOBE1(cmapi,iutmi,tmsone,rnlat1vl2(iv),rnlat2vl2(iv),
     &                  rnlat0vl2(iv),relon0vl2(iv),
     &                  feastvl2(iv),fnorthvl2(iv),
     &                  cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &                  feast,fnorth,
     &                  caction,vecti,vecto)

            call RDEM4(io,nvl2,nse4,cid4,ibsrc4(iv),iesrc4(iv),
     &                 vervarb(iv),t2btz4(iv),lprt,io6,ibegh,
     &                 ibegs,iendh,iends,em4dat,ieof)
c ---       Swap location data (em4dat) into /vol2/ arrays
            do i=ibsrc4(iv),iesrc4(iv)
c ---          Apply coordinate transformation
               call GLOBE(io6,caction,datumvl2(iv),vecti,datum,
     &                    vecto,em4dat(1,i),em4dat(2,i),xvol,yvol,
     &                    izone,c4hem)
c ---          Compute relative grid coordinates
               xvl2grd(1,i)=(1000.*xvol-xorig)*dgridi
               yvl2grd(1,i)=(1000.*yvol-yorig)*dgridi
               elvl2(1,i)=em4dat(4,i)
            enddo
            REWIND(io)
         enddo

c ---    Reposition pointer to start of data records
         call SKIPHDEM4(nvoldat)

      endif

c --- Variable buoyant line sources
c ----------------------------------
      if(nln2.gt.0) then
         iq=1
c ---    Set up map projection conversion to CALPUFF coordinates
c ---    Input is from LNEMARB.DAT header - /LN2/
         iutmi=iutmznln2
         if(utmhemln2.EQ.'S   ' .AND. iutmi.LT.900) iutmi=-iutmi
         cmapi=pmapln2
         if(cmapi.EQ.'TTM     ') cmapi='TM      '
c ---    Set conversion vectors
         call GLOBE1(cmapi,iutmi,tmsone,rnlat1ln2,rnlat2ln2,
     &          rnlat0ln2,relon0ln2,
     &          feastln2,fnorthln2,
     &          cmapo,iutmo,tmsone,xlat1,xlat2,rnlat0,relon0,
     &          feast,fnorth,
     &          caction,vecti,vecto)

c ---    Read data from LNEMARB file for source locations
         call RDEM5(io19,mxlngrp,nln2,nse5,cid5,verlarb,t2btz5,
     &              lprt,io6,ibegh,ibegs,iendh,iends,lngrp,idmap,
     &              em5dat,em5grp,ieof)

c---     Apply projection/datum translation to positions
         iline=0
         do ig=1,lngrp
            do il=1,em5grp(1,ig)
               iline=iline+1
               x1=em5dat(1,iline)
               y1=em5dat(2,iline)
               x2=em5dat(3,iline)
               y2=em5dat(4,iline)
               call GLOBE(io6,caction,datumln2,vecti,datum,
     &              vecto,x1,y1,em5dat(1,iline),em5dat(2,iline),
     &              izone,c4hem)
               call GLOBE(io6,caction,datumln2,vecti,datum,
     &              vecto,x2,y2,em5dat(3,iline),em5dat(4,iline),
     &              izone,c4hem)
            enddo
         enddo
c ---    Swap location data (em5grp,em5dat) into /ln2/
         call LN2FILL(iq,lngrp,nln2,idmap,em5grp,em5dat,nvarln,
     &                   problem)
         REWIND(io19)

c ---    Reposition pointer to start of data records
         call SKIPHDEM5
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine SKIPHDEM3(nardat)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915              SKIPHDEM3
c                J. Scire, D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Skip over header records from the BAEMARB buoyant area
c               source file (arbitrarily-varying location & emissions)
c               to reach the start of the data records
c
c --- INPUTS:
c           NARDAT - integer    - Number of BAEMARB files
c
c --- OUTPUT:
c
c --- SKIPHDEM3 called by: RDEMSRC
c --- SKIPHDEM3 calls:     none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c --- Include common blocks
      include 'ar2.puf'
      include 'dataset.puf'

c --- Local variables
      character*1 char1
      real xmwem(mxspec)
      character*12 cslst(mxspec)

2     format(a1)

c --- Loop over all BAEMARB.DAT files

      do i=1,nardat
         io=ioar2+i-1

         if(veraarb(i).EQ.'1.5a' .OR.
     &      veraarb(i).EQ.'1.54a' .OR.
     &      veraarb(i).EQ.'1.6a') then

c ---       Augmented headers
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            if(LLCCAR2(i)) read(io,2) char1
            read(io,2) char1
            read(io,2) char1

c ---       Old Header Record(s)
            read(io,2) char1
            if(veraarb(i).EQ.'1.54a') read(io,2) char1

         elseif(veraarb(i).EQ.'2.1') then

            read(io,2) char1
            read(io,*) ncom
            do k=1,ncom
               read(io,2) char1
            enddo
            read(io,2) char1
            read(io,2) char1
            if(LLCCAR2(i).or.LLAZAAR2(i).or.
     &                       LTTMAR2(i)) read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1

         else
            write(*,*)'ERROR in BAEMARB File: ',i
            write(*,*)'Bad Dataset Version: ',veraarb(i)
            write(*,*)'Expected 1.5a, 1.54a, 1.6a, 2.1'
            stop

         endif

c ---    Species list
         read(io,*)(cslst(n),n=1,nse3)
c ---    Molecular weights of each emitted species
         read(io,*)(xmwem(n),n=1,nse3)

c ---    TIEM3 records
c ---    Loop over sources
         do k=ibsrc3(i),iesrc3(i)
            read(io,2) char1
         enddo

      enddo

c --- Use char1 (compilation warning)
      if(char1.EQ.'~') return

      return
      end
c----------------------------------------------------------------------
      subroutine SKIPHDEM4(nvoldat)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915              SKIPHDEM4
c                J. Scire, D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Skip over header records from the VOLEMARB volume
c               source file (arbitrarily-varying location & emissions)
c               to reach the start of the data records
c
c --- INPUTS:
c          NVOLDAT - integer    - Number of VOLEMARB files
c
c --- OUTPUT:
c
c --- SKIPHDEM4 called by: RDEMSRC
c --- SKIPHDEM4 calls:     none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c --- Include common blocks
      include 'vol2.puf'
      include 'dataset.puf'

c --- Local variables
      character*1 char1
      real xmwem(mxspec)
      character*12 cslst(mxspec)

2     format(a1)

c --- Loop over all VOLEMARB.DAT files

      do i=1,nvoldat
         io=iovol+i-1

         if(vervarb(i).EQ.'1.54a' .OR.
     &      vervarb(i).EQ.'1.6a') then

c ---       Augmented headers
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            if(LLCCVL2(i)) read(io,2) char1
            read(io,2) char1
            read(io,2) char1

c ---       Old Header Record(s)
            read(io,2) char1
            if(vervarb(i).EQ.'1.54a') read(io,2) char1

         elseif(vervarb(i).EQ.'2.1') then

            read(io,2) char1
            read(io,*) ncom
            do k=1,ncom
               read(io,2) char1
            enddo
            read(io,2) char1
            read(io,2) char1
            if(LLCCVL2(i).or.LLAZAVL2(i).or.
     &                       LTTMVL2(i)) read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1

         else
            write(*,*)'ERROR in VOLEMARB File: ',i
            write(*,*)'Bad Dataset Version: ',vervarb(i)
            write(*,*)'Expected 1.54a, 1.6a, 2.1'
            stop

         endif

c ---    Species list
         read(io,*)(cslst(n),n=1,nse4)
c ---    Molecular weights of each emitted species
         read(io,*)(xmwem(n),n=1,nse4)

c ---    TIEM4 records
c ---    Loop over sources
         do k=ibsrc4(i),iesrc4(i)
            read(io,2) char1
         enddo

      enddo

c --- Use char1 (compilation warning)
      if(char1.EQ.'~') return

      return
      end
c----------------------------------------------------------------------
      subroutine SKIPHDEM5
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 051020              SKIPHDEM5
c                J. Scire, D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Skip over header records from the LNEMARB buoyant line
c               source file (arbitrarily-varying location & emissions)
c               to reach the start of the data records
c
c --- UPDATE
c --- V6.1-V6.101 051020   (DGS): TIEM data for sources are on fewer
c                                 than NLN2 lines
c
c --- INPUTS:
c
c --- OUTPUT:
c
c --- SKIPHDEM5 called by: RDEMSRC
c --- SKIPHDEM5 calls:     none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c --- Include common blocks
      include 'ln2.puf'
      include 'dataset.puf'

c --- Local variables
      character*1 char1
      real xmwem(mxspec)
      character*12 cslst(mxspec)
      character*16 cid(mxlines)

2     format(a1)

         io=io19

         if(verlarb.EQ.'1.54a') then

c ---       Augmented headers
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            if(LLCCLN2) read(io,2) char1
            read(io,2) char1
            read(io,2) char1

c ---       Old Header Record(s)
            read(io,2) char1
            read(io,2) char1

         elseif(verlarb.EQ.'2.1') then

            read(io,2) char1
            read(io,*) ncom
            do k=1,ncom
               read(io,2) char1
            enddo
            read(io,2) char1
            read(io,2) char1
            if(LLCCLN2.or.LLAZALN2.or.
     &                    LTTMLN2) read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1
            read(io,2) char1

         else
            write(*,*)'ERROR in LNEMARB File: '
            write(*,*)'Bad Dataset Version: ',verlarb
            write(*,*)'Expected 1.54a, 2.1'
            stop

         endif

c ---    Species list
         read(io,*)(cslst(n),n=1,nse5)
c ---    Molecular weights of each emitted species
         read(io,*)(xmwem(n),n=1,nse5)

c ---    TIEM5 records
         read(io,2) char1
c ---    Loop over sources names
         read(io,*) (cid(k),k=1,nln2)

c --- Use char1 (compilation warning)
      if(char1.EQ.'~') return

      return
      end
c----------------------------------------------------------------------
      subroutine qaplot1
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 051130                QAPLOT1
c                D. Strimaitis,   Earth Tech
c
c --- PURPOSE:  Pass geographic setup information to files for making
c               plots to verify configuration.  Standard filenames
c               are used for each type of data, and extensions are
c               consistent with defaults used in the SURFER plotting
c               system.  All locations are in km.
c
c --- UPDATE
c --- V6.1-V6.102 051130   (DGS): Add OZONE and H2O2 stations
c --- V5.725-V6.1 050915   (DGS): Expand arg list of variable emissions
c                                 source locations to include the 
c                                 emissions timestep
c --- V5.724-V5.725 050128 (DGS): Modify wetland color and add a RED
c                                 strip at the top of the bar in the
c                                 LUSE.CLR file.
c --- V5.723-V5.724 041013 (DGS): Use SURFER 8 image format for
c                                 QALUSE.GRD file.  Add a control for
c                                 this format, but set it locally here.
c --- V5.72-V5.723 040827  (DGS): Enlarge format for QATERR.DAT hts
c --- V5.7-V5.72  031017   (DGS): Fix gridded receptor file QARECG.DAT
c                                 [used discrete rec. elevations]
c                 031017   (DGS): Add variable area sources
c --- V5.5-V5.7   030402   (DGS): Change header format to avoid SURFER7
c                                 bug (use space-delimited form for
c                                 header of POST data files)
c
c --- INPUTS:
c
c     Common block /AR1/ variables:
c        NAR1, NVERT1(mxarea),
c        XAR1GRD(mxvertp1,mxarea),YAR1GRD(mxvertp1,mxarea),
c     Common block /AR2/ variables:
c        NAR2, NVERT2(mxarea),
c        XAR2GRD(mxvertp1,mxqstep,mxarea),
c        YAR2GRD(mxvertp1,mxqstep,mxarea),
c     Common block /CHEMDAT/ variables:
c        NOZSTA, XOZM(mxoz), YOZM(mxoz),
c        NH2O2STA, XH2O2M(mxaq), YH2O2M(mxaq),
c     Common block /CTSGDAT/ variables:
c        NCTREC, XRCT(mxrect), YRCT(mxrect), ELRECT(mxrect)
c     Common block /GEN/ variables:
c        METFM
c     Common block /GRID/ variables:
c        nx,ny,dgrid,xorig,yorig,
c        ibcomp,jbcomp,nxcmp,nycmp,
c        lsamp,ibsamp,jbsamp,nxsam,nysam,delsam
c     Common block /LN1/ variables:
c        NLINES, XLBEGGRD(mxlines), YLBEGGRD(mxlines),
c        XLENDGRD(mxlines), YLENDGRD(mxlines)
c     Common block /LN2/ variables:
c        NLN2, XL2BEGGRD(mxqstep,mxlines), YL2BEGGRD(mxqstep,mxlines),
c        XL2ENDGRD(mxqstep,mxlines), YL2ENDGRD(mxqstep,mxlines)
c     Common block /METHD/ variables:
c        ELEV(mxnx,mxny),ILANDU(mxnx,mxny)
c     Common block /NONGRD/ variables:
c        NREC, XNG(mxrec), YNG(mxrec), ZNG(mxrec), ELEVNG(mxrec)
c     Common block /PT1/ variables:
c        NPT1, XPT1GRD(mxpt1), YPT1GRD(mxpt1), ELSTAK(mxpt1)
c     Common block /PT2/ variables:
c        NPT2, TIEM2(8,mxpt2)
c     Common block /VOL1/ variables:
c        NVL1, ELVL1(mxvol), XVL1GRD(mxvol), YVL1GRD(mxvol)
c     Common block /VOL2/ variables:
c        NVL2, ELVL2(mxqstep,mxvol),
c        XVL2GRD(mxqstep,mxvol), YVL2GRD(mxqstep,mxvol)
c      
c     
c     Parameters:
c           MXNX, MXNY, MXPT1, MXPT2, MXAREA, MXVERTP1, MXLINES
c           MXVOL, MXREC, MXQSTEP, MXAQ
c
c --- OUTPUT:
c
c     Files:
c        QATERR.GRD - gridded terrain elevations (mMSL) [CALMET only]
c        QALUSE.GRD - gridded land use                  [CALMET only]
c        QAGRID.BNA - borders for the METEOROLOGICAL, COMPUTATIONAL,
c                     and SAMPLING grid domains
c        QARECD.DAT - location of discrete receptors
c        QARECG.DAT - location of gridded receptors
c        QARECT.DAT - location of CTSG receptors
c        QAPNTS.DAT - location of point sources
c        QAVOLS.DAT - location of volume sources
c        QAAREA.BNA - outlines for area sources
c        QALINE.BNA - segments for buoyant line sources
c        QA_OZN.DAT - location of ozone stations
c        QAH2O2.DAT - location of H2O2 stations
c
c
c --- QAPLOT1 called by:  SETUP
c --- QAPLOT1 calls:      none
c----------------------------------------------------------------------
c --- Set the io unit number for QA files (should eventually be in
c --- the params file)
      parameter (ioqa=50)

c --- Include parameter statements
      include 'params.puf'

c --- Include common blocks
      include 'ar1.puf'
      include 'ar2.puf'
      include 'chemdat.puf'
      include 'ctsgdat.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'ln1.puf'
      include 'ln2.puf'
      include 'methd.puf'
      include 'nongrd.puf'
      include 'pt1.puf'
      include 'pt2.puf'
      include 'vol1.puf'
      include 'vol2.puf'

c --- Conversion factors
      data fm2km/0.001/

c --- Image GRD file format
c ---   image=0:  SURFER 8 format with range defined by cell-centers
c ---   image=1:  SURFER 7 format with range defined by domain edges
      data image/0/

c --- Report position of variable sources from first emissions step
      istep=1

c --- Met grid corners and corner-cell-centers (km)
      dgridkm=dgrid*fm2km
      xmetLL=xorig*fm2km
      xmetUR=xmetLL+FLOAT(nx)*dgridkm
      xmet1=xmetLL+0.5*dgridkm
      xmetnx=xmet1+FLOAT(nx-1)*dgridkm
      ymetLL=yorig*fm2km
      ymetUR=ymetLL+FLOAT(ny)*dgridkm
      ymet1=ymetLL+0.5*dgridkm
      ymetny=ymet1+FLOAT(ny-1)*dgridkm

c --- Computational grid corners (km)
      xcmpLL=xmetLL+float(ibcomp-1)*dgridkm
      xcmpUR=xcmpLL+FLOAT(nxcmp)*dgridkm
      ycmpLL=ymetLL+float(jbcomp-1)*dgridkm
      ycmpUR=ycmpLL+FLOAT(nycmp)*dgridkm

c --- Sampling grid corners (km)
      xsamLL=xmetLL+(float(ibsamp)-0.5)*dgridkm
      xsamUR=xsamLL+FLOAT(nxsam-1)*delsam*fm2km
      ysamLL=ymetLL+(float(jbsamp)-0.5)*dgridkm
      ysamUR=ysamLL+FLOAT(nysam-1)*delsam*fm2km


c --- Process boundary of grids [BNA format]
c ------------------------------------------
      open(ioqa,file='qagrid.bna',status='unknown')
c --- Met grid
      write(ioqa,'(a15)') '" Met","grid",5'
      write(ioqa,'(f12.4,a1,f12.4)') xmetLL,',',ymetLL
      write(ioqa,'(f12.4,a1,f12.4)') xmetLL,',',ymetUR
      write(ioqa,'(f12.4,a1,f12.4)') xmetUR,',',ymetUR
      write(ioqa,'(f12.4,a1,f12.4)') xmetUR,',',ymetLL
      write(ioqa,'(f12.4,a1,f12.4)') xmetLL,',',ymetLL
c --- Comp grid
      write(ioqa,'(a15)') '"Comp","grid",5'
      write(ioqa,'(f12.4,a1,f12.4)') xcmpLL,',',ycmpLL
      write(ioqa,'(f12.4,a1,f12.4)') xcmpLL,',',ycmpUR
      write(ioqa,'(f12.4,a1,f12.4)') xcmpUR,',',ycmpUR
      write(ioqa,'(f12.4,a1,f12.4)') xcmpUR,',',ycmpLL
      write(ioqa,'(f12.4,a1,f12.4)') xcmpLL,',',ycmpLL
c --- Samp grid
      if(LSAMP) then
         write(ioqa,'(a15)') '"Samp","grid",5'
         write(ioqa,'(f12.4,a1,f12.4)') xsamLL,',',ysamLL
         write(ioqa,'(f12.4,a1,f12.4)') xsamLL,',',ysamUR
         write(ioqa,'(f12.4,a1,f12.4)') xsamUR,',',ysamUR
         write(ioqa,'(f12.4,a1,f12.4)') xsamUR,',',ysamLL
         write(ioqa,'(f12.4,a1,f12.4)') xsamLL,',',ysamLL
      endif
      close(ioqa)

c --- Process terrain elevations [GRD format]
c -------------------------------------------
      open(ioqa,file='qaterr.grd',status='unknown')
      if(metfm.EQ.1) then
c ---    Obtain min/max elevations
         emin=elev(1,1)
         emax=elev(1,1)
         do j=1,ny
            do i=1,nx
               if(elev(i,j).GT.emax) emax=elev(i,j)
               if(elev(i,j).LT.emin) emin=elev(i,j)
            enddo
         enddo
         if(emax.EQ.emin) then
            close(ioqa, status='DELETE')
         else
c ---       Header records
c ---       Place data points at cell centers for contouring
            write(ioqa,'(a4)') 'DSAA'
            write(ioqa,'(2i12)') nx,ny
            write(ioqa,'(2f12.4)') xmet1,xmetnx
            write(ioqa,'(2f12.4)') ymet1,ymetny
            write(ioqa,'(2e12.4)') emin,emax
c ---       Data, in rows of constant Y
            do j=1,ny
              write(ioqa,'(10000(1pe11.4,1x))') (elev(i,j),i=1,nx)
            enddo
            close(ioqa)
         endif
      else
         close(ioqa, status='DELETE')
      endif

c --- Process landuse [GRD format]
c --------------------------------
      open(ioqa,file='qaluse.grd',status='unknown')
      if(metfm.EQ.1) then
c ---    Set min/max landuse to 10 - 100 range
         lmin=10
         lmax=100
c ---    Header records
c ---    Identify data with entire cell for image-plot
         write(ioqa,'(a4)') 'DSAA'
         write(ioqa,'(2i12)') nx,ny
         if(image.EQ.0) then
            write(ioqa,'(2f12.4)') xmet1,xmetnx
            write(ioqa,'(2f12.4)') ymet1,ymetny
         else
            write(ioqa,'(2f12.4)') xmetLL,xmetUR
            write(ioqa,'(2f12.4)') ymetLL,ymetUR
         endif
         write(ioqa,'(2i12)') lmin,lmax
c ---    Data, in rows of constant Y
         do j=1,ny
           write(ioqa,'(10000(i3,2x))')(IABS(ilandu(i,j)),i=1,nx)
         enddo
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Set up default land use color file in this directory
      open(ioqa,file='luse.clr',status='unknown')
      write(ioqa,'(a)') 'ColorMap 1 1'
      write(ioqa,'(a)') '    0.000000 255 255   0'
      write(ioqa,'(a)') '   11.000000 255 255   0'
      write(ioqa,'(a)') '   11.000000 204 255 102'
      write(ioqa,'(a)') '   22.100000 204 255 102'
      write(ioqa,'(a)') '   22.100000 160 255 160'
      write(ioqa,'(a)') '   33.100000 160 255 160'
      write(ioqa,'(a)') '   33.100000  80 255  80'
      write(ioqa,'(a)') '   44.200000  80 255  80'
      write(ioqa,'(a)') '   44.200000 153 255 255'
      write(ioqa,'(a)') '   50.000000 153 255 255'
      write(ioqa,'(a)') '   50.000000  60 204 255'
      write(ioqa,'(a)') '   55.400000  60 204 255'
      write(ioqa,'(a)') '   55.400000 204 153 204'
      write(ioqa,'(a)') '   66.500000 204 153 204'
      write(ioqa,'(a)') '   66.500000 255 204 153'
      write(ioqa,'(a)') '   77.600000 255 204 153'
      write(ioqa,'(a)') '   77.600000 255 255 204'
      write(ioqa,'(a)') '   88.700000 255 255 204'
      write(ioqa,'(a)') '   88.700000 255 255 255'
      write(ioqa,'(a)') '   99.030000 255 255 255'
      write(ioqa,'(a)') '   99.030000 255   0   0'
      write(ioqa,'(a)') '  100.000000 255   0   0'
      close(ioqa)

c --- Process point sources [DAT format]
c --------------------------------------
      open(ioqa,file='qapnts.dat',status='unknown')
      write(ioqa,'(a27)') '"Xkm" "Ykm" "Elev" "Source"'
      do i=1,npt1
         is=i
         x=xmetLL+xpt1grd(i)*dgridkm
         y=ymetLL+ypt1grd(i)*dgridkm
         write(ioqa,*) x,y,elstak(i),is
      enddo
      do i=1,npt2
         is=npt1+i
         x=xmetLL+tiem2(1,i)*dgridkm
         y=ymetLL+tiem2(2,i)*dgridkm
         write(ioqa,*) x,y,tiem2(5,i),is
      enddo
      npt=npt1+npt2
      if(npt.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process volume sources [DAT format]
c ---------------------------------------
      open(ioqa,file='qavols.dat',status='unknown')
      write(ioqa,'(a27)') '"Xkm" "Ykm" "Elev" "Source"'
      do i=1,nvl1
         is=i
         x=xmetLL+xvl1grd(i)*dgridkm
         y=ymetLL+yvl1grd(i)*dgridkm
         write(ioqa,*) x,y,elvl1(i),is
      enddo
      do i=1,nvl2
         is=nvl1+i
         x=xmetLL+xvl2grd(istep,i)*dgridkm
         y=ymetLL+yvl2grd(istep,i)*dgridkm
         write(ioqa,*) x,y,elvl2(istep,i),is
      enddo
      nvl=nvl1+nvl2
      if(nvl.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process area sources [BNA format]
c -------------------------------------
      open(ioqa,file='qaarea.bna',status='unknown')
      do i=1,nar1
         if(nvert1(i).EQ.3) then
            write(ioqa,'(a15)') '"Area"," AR1",4'
         elseif(nvert1(i).EQ.4) then
            write(ioqa,'(a15)') '"Area"," AR1",5'
         else
            stop 'QAPLOT1:  Areas must have 3 or 4 corners'
         endif
         do j=1,nvert1(i)
            x=xmetLL+xar1grd(j,i)*dgridkm
            y=ymetLL+yar1grd(j,i)*dgridkm
            write(ioqa,'(f12.4,a1,f12.4)') x,',',y
         enddo
c ---    Repeat the first point to close the figure
         x=xmetLL+xar1grd(1,i)*dgridkm
         y=ymetLL+yar1grd(1,i)*dgridkm
         write(ioqa,'(f12.4,a1,f12.4)') x,',',y
      enddo
      do i=1,nar2
         if(nvert2(i).EQ.3) then
            write(ioqa,'(a15)') '"Area"," AR2",4'
         elseif(nvert2(i).EQ.4) then
            write(ioqa,'(a15)') '"Area"," AR2",5'
         else
            stop 'QAPLOT1:  Areas must have 3 or 4 corners'
         endif
         do j=1,nvert2(i)
            x=xmetLL+xar2grd(j,istep,i)*dgridkm
            y=ymetLL+yar2grd(j,istep,i)*dgridkm
            write(ioqa,'(f12.4,a1,f12.4)') x,',',y
         enddo
c ---    Repeat the first point to close the figure
         x=xmetLL+xar2grd(1,istep,i)*dgridkm
         y=ymetLL+yar2grd(1,istep,i)*dgridkm
         write(ioqa,'(f12.4,a1,f12.4)') x,',',y
      enddo
      nar=nar1+nar2
      if(nar.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process buoyant line sources [BNA format]
c ---------------------------------------------
      open(ioqa,file='qaline.bna',status='unknown')
      do i=1,nlines
         write(ioqa,'(a16)') '"Line"," LN1",-2'
            x=xmetLL+xlbeggrd(i)*dgridkm
            y=ymetLL+ylbeggrd(i)*dgridkm
            write(ioqa,'(f12.4,a1,f12.4)') x,',',y
            x=xmetLL+xlendgrd(i)*dgridkm
            y=ymetLL+ylendgrd(i)*dgridkm
            write(ioqa,'(f12.4,a1,f12.4)') x,',',y
      enddo
      do i=1,nln2
         write(ioqa,'(a16)') '"Line"," LN2",-2'
            x=xmetLL+xl2beggrd(istep,i)*dgridkm
            y=ymetLL+yl2beggrd(istep,i)*dgridkm
            write(ioqa,'(f12.4,a1,f12.4)') x,',',y
            x=xmetLL+xl2endgrd(istep,i)*dgridkm
            y=ymetLL+yl2endgrd(istep,i)*dgridkm
            write(ioqa,'(f12.4,a1,f12.4)') x,',',y
      enddo
      nln=nlines+nln2
      if(nln.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process discrete receptors [DAT format]
c -------------------------------------------
      open(ioqa,file='qarecd.dat',status='unknown')
      write(ioqa,'(a25)') '"Xkm" "Ykm" "Elev" "Zagl"'
      do i=1,nrec
         x=xmetLL+xng(i)*dgridkm
         y=ymetLL+yng(i)*dgridkm
         write(ioqa,*) x,y,elevng(i),zng(i)
      enddo
      if(nrec.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process gridded receptors [DAT format]
c ------------------------------------------
      open(ioqa,file='qarecg.dat',status='unknown')
      if(LSAMP) then
         write(ioqa,'(a18)') '"Xkm" "Ykm" "Elev"'
         do j=1,nysam
            do i=1,nxsam
               x=xsamLL+float(i-1)*delsam*fm2km
               y=ysamLL+float(j-1)*delsam*fm2km
               write(ioqa,*) x,y,elev(i,j)
            enddo
         enddo
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process CTSG receptors [DAT format]
c ---------------------------------------
      open(ioqa,file='qarect.dat',status='unknown')
      write(ioqa,'(a18)') '"Xkm" "Ykm" "Elev"'
      do i=1,nctrec
         x=xmetLL+xrct(i)*dgridkm
         y=ymetLL+yrct(i)*dgridkm
         write(ioqa,*) x,y,elrect(i)
      enddo
      if(nctrec.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process OZONE stations [DAT format]
c ---------------------------------------
      open(ioqa,file='qa_ozn.dat',status='unknown')
      write(ioqa,'(a25)') '"Xkm" "Ykm" "Station"'
      do i=1,nozsta
         x=xmetLL+xozm(i)*0.001
         y=ymetLL+yozm(i)*0.001
         write(ioqa,*) x,y,i
      enddo
      if(nozsta.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

c --- Process H2O2 stations [DAT format]
c --------------------------------------
      open(ioqa,file='qah2o2.dat',status='unknown')
      write(ioqa,'(a25)') '"Xkm" "Ykm" "Station"'
      do i=1,nh2o2sta
         x=xmetLL+xh2o2m(i)*0.001
         y=ymetLL+yh2o2m(i)*0.001
         write(ioqa,*) x,y,i
      enddo
      if(nh2o2sta.GT.0) then
         close(ioqa)
      else
         close(ioqa, status='DELETE')
      endif

      return
      end
c----------------------------------------------------------------------
      logical function lrsame(r0,r1,r2)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402                 LRSAME
c                D. Strimaitis,    Earth Tech, Inc.
c ---            From CALPOST V5.2, L991104c
c
c --- PURPOSE:  Compare 2 real numbers (r1,r2) to determine if their
c               fractional difference exceeds r0
c
c --- INPUTS:
c            r0 - real       - Fractional difference allowed
c            r1 - real       - Real value 1
c            r2 - real       - Real value 2
c
c
c --- OUTPUT:
c        lrsame - logical    - Key indicating result of test
c                              .TRUE.  -- values are 'same'
c                              .FALSE. -- values are NOT 'same'
c
c
c --- LRSAME called by:   (utility)
c --- LRSAME calls:       none
c----------------------------------------------------------------------
c
      data half/0.5/

      lrsame=.TRUE.

c --- Direct comparison
      if(r1.EQ.r2) return

      rdif=ABS(r1-r2)
      ravg=half*ABS(r1+r2)

      if(rdif.GE.ravg) then
c ---    Fractional difference greater than one!
         lrsame=.FALSE.
      else
         ftest=rdif/ravg
         if(ftest.GT.r0) lrsame=.FALSE.
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine tfercf
c----------------------------------------------------------------------
c
c --- CALPUFF  Version: 6.262     Level: 030402                  TFERCF
c ---          D. Strimaitis,    Earth Tech, Inc.
c
c --- PURPOSE: Transfer image of control file to scratch file
c
c --- INPUTS:
c
c        Common block /QA/
c           ncommout
c        Parameters: mxcol, iox, io5
c
c --- OUTPUT:
c
c        Common block /QA/
c           ncommout
c
c --- TFERCF called by:  SETUP
c --- TFERCF calls:      none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'params.cal'
      include 'qa.puf'

      character*132 aline, blank
      character*33 blank33

c --- Set blanks
      data blank33/'                                 '/
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Confirm max size of control file record
      if(mxcol.GT.132) then
         write(*,*)'ERROR in TFERCF!'
         write(*,*)'Control file records are assumed to be <= 132'
         write(*,*)'Actual limit is MXCOL = ',mxcol
         write(*,*)'CALPUFF code needs to be modified'
         stop
      endif      

c --- Reposition input control file
      REWIND(io5)

c --- Open scratch file
      OPEN(iox,status='scratch')

c --- Initialize number of records written to scratch file
      ncommout=0

c --- Transfer control file records
10    aline=blank
      read(io5,'(a132)',end=999) aline
      write(iox,'(a132)') aline
      ncommout=ncommout+1
      goto 10

c --- Transfer completed
999   close(io5)

      return
      end
c----------------------------------------------------------------------
      subroutine met1doc
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                MET1DOC
c                D. Strimaitis, Earth Tech, Inc.
c
c --- PURPOSE:  Read header comment records of the CALMET meteorological
c               data files, and place in scratch file.  Replicate full
c               image from file #1, but just the title lines from any
c               subsequent files.
c
c --- UPDATE
c --- V5.7-V6.1     050915  (DGS): Add FILVERS call for dataset version
c
c --- INPUTS:
c     Common block /FILNAM/ variables:
c           NMETDAT, METDATL(mxmetdat)
c     Common block /QA/ variables:
c           NCOMMOUT
c
c     Parameters:
c           MXMETDAT, IO7, IOX
c
c --- OUTPUT:
c     Common block /QA/ variables:
c           NCOMMOUT
c     Common block /DATASET/ variables:
c           vermet
c
c --- MET1DOC called by:  SETUP
c --- MET1DOC calls:      none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'dataset.puf'
      include 'filnam.puf'
      include 'qa.puf'
c
c --- Local Variables
      character*16 dataset,dataver
      character*33 blank33,break33
      character*64 datamod
      character*132 comment1,blank,break

      data blank33/'                                 '/
      data break33/'.................................'/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Set break (132 characters)
      break(1:33)=break33
      break(34:66)=break33
      break(67:99)=break33
      break(100:132)=break33

c --- Loop over CALMET.DAT files
      do k=1,nmetdat
         call FILVERS(io7,'BIN',metdatl(k),'CALMET          ',vercmet)
         open(io7,file=metdatl(k),status='old',form='unformatted')

c ---    Read and test first record to check header format
c ---    Record #1 - File Declaration -- 24 words
         read(io7) dataset,dataver,datamod
         ifilver=0
         if(dataset.EQ.'CALMET.DAT') ifilver=1

         if(ifilver.EQ.0) then
c ---       No comment records
            close(io7)

         elseif(ifilver.EQ.1) then
c ---       To scratch file
            write(iox,'(a132)') blank
            write(iox,'(a132)') break
            write(iox,'(a132)') blank
            write(iox,'(2a16,a64)') dataset,dataver,datamod
            ncommout=ncommout+4
c ---       Number of comment records
            read(io7) ncom
            if(k.EQ.1) then
c ---          Keep entire comment image
               ncommout=ncommout+ncom
               do i=1,ncom
                  comment1=blank
                  read(io7) comment1
                  write(iox,'(a132)') comment1
               enddo
            else
c ---          Keep only title information
               n=MIN(ncom,4)
               do i=1,n
                  comment1=blank
                  read(io7) comment1
                  write(iox,'(a132)') comment1
                  ncommout=ncommout+1
               enddo
            endif
            close(io7)

         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine cav_conc(ldb,nspec,q,qcav,xsgrd,ysgrd,ntr,xtr,ztr,
     &                    flow,dpbl,xcgrd,ycgrd,x115,x115c)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070629             CAV_CONC
c                D. Strimaitis
c
c --- PURPOSE:  Process concentrations at receptors located between
c               source and the end of the cavity transition zone
c               (PRIME building downwash) for current source
c
c --- UPDATE
c                    
c --- V5.7-V6.2   070629 (DGS): Include receptors upwind of source for
c                               cavity concentrations
c                 070629 (DGS): Place cavity impacts from all PRIME
c                               sources into the TOTAL arrays since the
c                               regular arrays are zeroed in the loop
c                               over sources.
c
c --- INPUTS:
c
c           LDB - logical - Debug output flag
c         NSPEC - integer - Number of species
c     Q(mxspec) - real    - Emission rate of each species (g/s)
c                           NOT captured/released from cavity
c  QCAV(mxspec) - real    - Emission rate of each species (g/s)
c                           captured/released from cavity
c         XSGRD - real    - Source x-coordinate (met grid)
c         YSGRD - real    - Source y-coordinate (met grid)
c           NTR - integer - Number of entries in rise table
c   XTR(mxrise) - real    - Distance from source (m) in rise table
c   ZTR(mxrise) - real    - Height above ground (m) in rise table
c          FLOW - real    - Flow vector (radians CW from N)
c          DPBL - real    - Boundary layer depth (m)
c
c     Common block /CTSGDAT/ variables:
c           NCTREC,XRCT(mxrect),YRCT(mxrect)
c     Common block /GRID/ variables:
c           NXSAM,NYSAM,LSAMP,IBSAMP,JBSAMP,DELSAM,
c           DGRID,DGRIDI
c     Common block /NONGRD/ variables:
c           NREC,XNG(mxrec),YNG(mxrec),ZNG(mxrec)
c     Common block /WAKEDAT/ variables:
c           Hb, Wb, xLb, Rb, xLC, xLR, HR, XBADJ, YBADJ,
c           CBYQCAV, XCAV(mxrise), SYCAV(mxrise), SZCAV(mxrise)
c
c --- OUTPUT:
c
c         XCGRD - real    - Cavity source x-coordinate (met grid)
c         YCGRD - real    - Cavity source y-coordinate (met grid)
c          X115 - real    - Distance (m) from primary source to the
c                           end of cavity transition zone
c         X115C - real    - Distance (m) from cavity source to the
c                           end of cavity transition zone
c
c     Common block /CHIFLX/ variables:
c           TCHISAM(mxnxg,mxnyg,mxspec), TCHIREC(mxrec,mxspec),
c           TCHICT(mxrect,mxspec)
c
c
c --- CAV_CONC called by:  POINTS1, POINTS2
c --- CAV_CONC calls    :  CAV_SAMP
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'chiflx.puf'
      include 'ctsgdat.puf'
      include 'grid.puf'
      include 'nongrd.puf'
      include 'wakedat.puf'

      real q(mxspec),qcav(mxspec)
      real xtr(mxrise),ztr(mxrise)

      logical ldb

      data piby2/1.5707963/, rt2pi/2.5066283/

c --- Set trig. factors for flow direction (phi is CCW rotation that
c --- places x-axis along the flow)
      phi=piby2-flow
      sinf=sin(phi)
      cosf=cos(phi)

c --- Convert source location to meters
      xsm=xsgrd*dgrid
      ysm=ysgrd*dgrid

c --- Set centerline of cavity plume relative to center of bldg
c --- Top-hat equivalent width of cavity sigma-y
      wtop=sycav(1)*rt2pi
c --- Max distance from bldg center to centerline of cavity plume
      ybmax=0.5*(Wb-wtop)
      if(ybmax.LE.0.0) then
c ---    Plume spread exceeds bldg width so cavity source is
c ---    centered on bldg
         ycb=0.0
      else
c ---    Source location relative to center of bldg
         ysb=-ybadj
         if(ysb.LT.0.0) then
            ycb=AMAX1(ysb,-ybmax)
         else
            ycb=AMIN1(ysb,ybmax)
         endif
      endif

c --- Identify location of effective cavity source on the met grid
c --- Along-wind coordinate (relative to primary source location)
      xc=xcav(1)      
c --- Cross-wind coordinate (relative to primary source location)
      yc=ycb+ybadj
c --- Rotate from along-wind system to original system
      xco=xc*cosf-yc*sinf
      yco=xc*sinf+yc*cosf
c --- Change to met grid units
      xcgrd=xsgrd+xco*dgridi
      ycgrd=ysgrd+yco*dgridi

c --- Set limits of transition zone at end of cavity
      x115b=xLb+1.15*xLR
      x85b=xLb+0.85*xLR

c --- End of zone relative to primary source
      x115=x115b+xbadj
c --- End of zone relative to cavity source
      x115c=x115-xc

c --- Set denomenator for cavity-end scaling factor
      fcavi=1./(x115b-x85b)

c --- DEBUG output
      if(LDB) then
         write(io6,*)
         write(io6,*)'CAV_CONC:  Flow (rad CW from N) = ',flow
         write(io6,*)'Primary Source (met grid)       = ',xsgrd,ysgrd
         write(io6,*)'Cavity Source (met grid)        = ',xcgrd,ycgrd
         write(io6,*)'  ycb(m) bldg center to cav src = ',ycb
      endif

c --- Loop over gridded receptors
c --------------------------------
      if(LSAMP) then
c ---    All gridded receptors are on the ground
         zr = 0.0
c ---    Compute the start of the sampling grid in MET grid units
         xbsamp=float(ibsamp)-0.5
         ybsamp=float(jbsamp)-0.5
         do 100 isam=1,nxsam
         do 100 jsam=1,nysam
c ---       Get location of the receptor (m) (on met. grid)
            xm = xbsamp*dgrid+float(isam-1)*delsam
            ym = ybsamp*dgrid+float(jsam-1)*delsam
c ---       Locate receptor (m) relative to source (xr is along-flow)
            dx=xm-xsm
            dy=ym-ysm
            xr=dx*cosf+dy*sinf
            yr=dy*cosf-dx*sinf
c ---       Locate receptor relative to center of upwind bldg face
            xrb=xr-xbadj
            yrb=yr-ybadj
c ---       Process receptors downwind of source, in/near cavity
            xtest=AMAX1(xr,xrb)
            if(xtest.GT.0.0 .AND. xrb.LE.x115b) then
c ---          Set cavity/wake transition factors
               fcav=1.0
               fwak=0.0
               if(xrb.GT.x85b) then
c ---             Transition zone at far end of cavity
                  fcav=(x115b-xrb)*fcavi
                  fwak=1.0-fcav
               elseif(xrb.LT.xLb) then
c ---             Transition zone at building
                  fcav=AMAX1(0.0,xrb/xLb)
               endif
c ---          Get coupling
               call CAV_SAMP(ldb,xr,yr,zr,xrb,yrb,ycb,fcav,fwak,
     &                       ntr,xtr,ztr,dpbl,cbyq0,cbyqc)
c ---          Screen out upwind receptor impacts (if any)
               if(xr.LE.0.0) cbyq0=0.0
               if(xrb.LE.0.0) cbyqc=0.0
c ---          Compute concentration for each species
               do is=1,nspec
                  tchisam(isam,jsam,is)=tchisam(isam,jsam,is)+
     &                                  qcav(is)*cbyqc+q(is)*cbyq0
               enddo

c ---          DEBUG output:  report non-zero species 1 concentration
               if(LDB) then
                  write(io6,*)'  gridded i,j,chi(1) = ',isam,jsam,
     &                                         tchisam(isam,jsam,1)
               endif

            endif
100      continue
      endif

c --- Loop over discrete receptors
c --------------------------------
      do ir=1,nrec
         zr=zng(ir)
c ---    Locate receptor (m) relative to source (xr is along-flow)
         dx=xng(ir)*dgrid-xsm
         dy=yng(ir)*dgrid-ysm
         xr=dx*cosf+dy*sinf
         yr=dy*cosf-dx*sinf
c ---    Locate receptor relative to center of upwind bldg face
         xrb=xr-xbadj
         yrb=yr-ybadj
c ---    Process receptors downwind of source, in/near cavity
         xtest=AMAX1(xr,xrb)
         if(xtest.GT.0.0 .AND. xrb.LE.x115b) then
c ---       Set cavity/wake transition factors
            fcav=1.0
            fwak=0.0
            if(xrb.GT.x85b) then
c ---          Transition zone at far end of cavity
               fcav=(x115b-xrb)*fcavi
               fwak=1.0-fcav
            elseif(xrb.LT.xLb) then
c ---          Transition zone at building
               fcav=AMAX1(0.0,xrb/xLb)
            endif
c ---       Get coupling
            call CAV_SAMP(ldb,xr,yr,zr,xrb,yrb,ycb,fcav,fwak,
     &                    ntr,xtr,ztr,dpbl,cbyq0,cbyqc)
c ---       Screen out upwind receptor impacts (if any)
            if(xr.LE.0.0) cbyq0=0.0
            if(xrb.LE.0.0) cbyqc=0.0
c ---       Compute concentration for each species
            do is=1,nspec
               tchirec(ir,is)=tchirec(ir,is)+
     &                        qcav(is)*cbyqc+q(is)*cbyq0
            enddo

c ---       DEBUG output:  report non-zero species 1 concentration
            if(LDB) then
               write(io6,*)'   discrete i,chi(1) = ',ir,tchirec(ir,1)
            endif
         endif
      enddo


c --- Loop over CTSG receptors
c ----------------------------
c --- All CTSG receptors are on the ground
      zr = 0.0
      do ir=1,nctrec
c ---    Locate receptor (m) relative to source (xr is along-flow)
         dx=xrct(ir)*dgrid-xsm
         dy=yrct(ir)*dgrid-ysm
         xr=dx*cosf+dy*sinf
         yr=dy*cosf-dx*sinf
c ---    Locate receptor relative to center of upwind bldg face
         xrb=xr-xbadj
         yrb=yr-ybadj
c ---    Process receptors downwind of source, in/near cavity
         xtest=AMAX1(xr,xrb)
         if(xtest.GT.0.0 .AND. xrb.LE.x115b) then
c ---       Set cavity/wake transition factors
            fcav=1.0
            fwak=0.0
            if(xrb.GT.x85b) then
c ---          Transition zone at far end of cavity
               fcav=(x115b-xrb)*fcavi
               fwak=1.0-fcav
            elseif(xrb.LT.xLb) then
c ---          Transition zone at building
               fcav=AMAX1(0.0,xrb/xLb)
            endif
c ---       Get coupling
            call CAV_SAMP(ldb,xr,yr,zr,xrb,yrb,ycb,fcav,fwak,
     &                    ntr,xtr,ztr,dpbl,cbyq0,cbyqc)
c ---       Screen out upwind receptor impacts (if any)
            if(xr.LE.0.0) cbyq0=0.0
            if(xrb.LE.0.0) cbyqc=0.0
c ---       Compute concentration for each species
            do is=1,nspec
               tchict(ir,is)=tchict(ir,is)+
     &                       qcav(is)*cbyqc+q(is)*cbyq0
            enddo

c ---       DEBUG output:  report non-zero species 1 concentration
            if(LDB) then
               write(io6,*)'   discrete i,chi(1) = ',ir,tchict(ir,1)
            endif
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine cav_samp(ldb,xr,yr,zr,xrb,yrb,ycb,fcav,fwak,
     &                    ntr,xtr,ztr,hlid,cbyq0,cbyqc)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070921             CAV_SAMP
c                D. Strimaitis
c
c --- PURPOSE:  Compute concentration/emission rate at a position
c               between the source and the end of the cavity
c               transition zone (PRIME building downwash)
c
c               Wind speed at the release height is used for the
c               'primary' source, while the speed at the building ht
c               is used for the 'cavity' source
c
c --- UPDATE
c --- V6.2-V6.22   070921 (DGS): Restrict primary source calculations
c                                to receptors downwind of primary source
c                                and add screen for receptors located
c                                far to the side (no impact)
c --- V5.7-V6.2    070629 (DGS): Initialize local receptor ht for
c                                cavity calcs ZRC to ZR
c
c --- INPUTS:
c
c           LDB - logical - Debug output flag
c         XR,YR - real    - Coordinates (m) of receptor relative to
c                           primary source location (x is alongwind)
c            ZR - real    - Receptor height (m) above ground
c       XRB,YRB - real    - Coordinates (m) of receptor relative to
c                           center of windward face of building
c                           (x is alongwind)
c           YCB - real    - Crosswind coordinate (m) of effective
c                           cavity source relative to the
c                           center of windward face of building
c                           (x is alongwind)
c          FCAV - real    - Transition factor for 'internal' cavity
c                           source
c          FWAK - real    - Transition factor for 'external' cavity
c                           source
c           NTR - integer - Number of entries in rise table
c   XTR(mxrise) - real    - Distance from source (m) in rise table
c   ZTR(mxrise) - real    - Height above ground (m) in rise table
c          HLID - real    - Boundary layer depth (m)
c
c     Common block /WAKEDAT/ variables:
c           Hb, Wb, xLb, Rb, xLC, xLR, HR, Ub, Urh,
c           CBYQCAV, SYCAV(mxrise), SZCAV(mxrise)
c
c --- OUTPUT:
c
c         CBYQ0 - real    - Coupling for primary source (s/m3)
c         CBYQC - real    - Coupling for cavity source (s/m3)
c
c
c --- CAV_SAMP called by:  CAV_CONC
c --- CAV_SAMP calls    :  VCOUP, WAKE_XSIG, POSITION, INTERTAB,
c                          CAVITY_HT
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'wakedat.puf'

      real xtr(mxrise),ztr(mxrise)
      logical ldb, nobidprm, nobidcav

      data rt2pi/2.5066283/, zero/0.0/, pi/3.1415927/
      data sigcut/12.0/

c --- Call VCOUP with a fixed puff code of 1 (Gaussian, below lid)
      data icode/1/

c --- Add BID to sigmas for the primary source
      data nobidprm/.FALSE./
      data nobidcav/.TRUE./

c --- Set travel time to receptor, using wind at top of building for
c --- the cavity source, and at release ht. for the primary source
      timec=xr/Ub
      timep=xr/Urh

c --- Set sigmas for primary (sy,sz) and cavity (syc,szc) sources
      call WAKE_XSIG(xr,timep,zero,nobidprm,sz,sy,szcdum,sycdum)
      call WAKE_XSIG(xr,timec,zero,nobidcav,szdum,sydum,szc,syc)

c --- Initialize coupling to zero
      cbyq0=zero
      cbyqc=zero

c --- Process source contributions according to receptor location
c --- relative to wake structures
      call POSITION(xrb,yrb,zr,ipositn)

c --- Primary source
c ------------------
c --- Primary source does not impact upwind
      if(ipositn.GE.3 .AND. xr.GT.0.0) then
c ---    Drop calculation for receptors too far to the side
         if(ABS(yr) .LE. (sigcut*sy)) then
c ---       Primary source contributes outside of cavity
c ---       Set primary source height
            call INTERTAB(xr,ntr,xtr,i1,i2,factor)
            ht=ztr(i1)+factor*(ztr(i2)-ztr(i1))
            fy0=(EXP(-0.5*(yr/sy)**2))/(rt2pi*sy)
            cbyq0=fy0*VCOUP(icode,zr,ht,sz,hlid)/Urh
         endif
      endif

c --- Cavity source
c -----------------
      if(ipositn.LT.4 .AND. syc.GT.zero) then
c ---    Receptor in projected building, cavity, or wake
c ---    Compute concentration due to cavity
c ---    Initialize receptor ht to value passed into subroutine
         zrc=zr
         if(ipositn.EQ.3) then
c ---       Sample vertical distribution when outside cavity, and
c ---       turn off the 'inside' cavity concentration
            cavnear=zero
            if(zr.GT.zero) then
c ---          Set pole height to height above cavity boundary
               if(xrb.LT.(xLb+xLR)) then
                  call CAVITY_HT(Hb,Wb,xLb,Rb,xLC,xLR,HR,xrb,
     &                           zcav,wcav)
                  zrc=AMAX1(zero,zr-zcav)
               endif
            endif
         else
            zrc=zero
c ---       'Inside' cavity cbyq before transition region
            fycn=(EXP(-0.5*((yrb-ycb)/sycav(1))**2))/(rt2pi*sycav(1))
            cavnear=fycn/(rt2pi*szcav(1)*Ub)
         endif
c ---    'Outside' cavity cbyq
         fycf=(EXP(-0.5*((yrb-ycb)/syc)**2))/(rt2pi*syc)
         cavfar=fycf*VCOUP(icode,zrc,zero,szc,hlid)/Ub
c ---    Weighted average
         cbyqc=fcav*cavnear+fwak*cavfar
      endif

c --- DEBUG output
      if(LDB) then
         write(io6,*)'                ------------------'
         write(io6,*)'CAV_SAMP:  xr,yr(m from primary) = ',xr,yr
         write(io6,*)'     xrb,yrb(m from upwind face) = ',xrb,yrb
         write(io6,*)'        [transition]   fcav,fwak = ',fcav,fwak
         write(io6,*)'          receptor position flag = ',ipositn
         write(io6,*)'                 [primary] sy,sz = ',sy,sz
         write(io6,*)'                  [cavity] sy,sz = ',syc,szc
         write(io6,*)'                     cbyq0,cbyqc = ',cbyq0,cbyqc
         write(io6,*)'                ------------------'
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine wake_cav0(sycapt,szcav0,sycav0)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402            WAKE_CAV0
c
c --- Adapted from
c --- PRIME      Version:  1.0     Level:  970812             WAKE_CAV0
c                D. Strimaitis, L. Schulman,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Compute the sigmas for a source placed on the floor
c               of the cavity, which produce the target cavity
c               concentration
c
c --- INPUTS:
c
c        SYCAPT - real    - Sigma-y (m) of plume at point where
c                           mass is captured in cavity
c
c     Common block /WAKEDAT/ variables:
c           Hb, Wb, xLR, xLC, HR, Ub, Urh
c
c --- OUTPUT:
c
c        SZCAV0 - real    - Initial sigma-z (m) of cavity source
c        SYCAV0 - real    - Initial sigma-y (m) of cavity source
c
c                 Note    - These sigmas reproduce the cavity
c                           concentration when the used in:
c                           C = Qc / (pi * ub * szcav0 * sycav0)
c                           where ub is the wind speed at the ht of the
c                           building (i.e., for the cavity source),
c                           and Qc is the mass flux captured by
c                           and released from the cavity.
c
c --- WAKE_CAV0 called by:  WAKE_DFSN
c --- WAKE_CAV0 calls    :  none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'wakedat.puf'

      data rt2pi/2.5066283/, rt2bypi/.7978846/, third/0.3333333/

c --- Interpret plume sigma-y at cavity entry point as equivalent
c --- top-hat;  limit to full width of bldg
      wcapt=AMIN1(rt2pi*sycapt,Wb)

c --- Set width scale for lateral distribution in cavity
      wscale=AMIN1(Wb,3.*Hb)
      wscale=AMAX1(wscale,third*Hb)
      wscale=AMAX1(wscale,wcapt)

c --- Sigma-y for equivalent top-hat distribution
      sycav0=wscale/rt2pi

c --- Set height of cavity behind the bldg
      if(xLC .LT. xLb) then
c ---    Reattachment
         hcav=Hb
      else
c ---    No Reattachment
         hcav=HR
      endif

c --- Set sigma-z that results in centerline concentration equal to
c --- cavity concentration (using wind speed at building height)
c --- Wilson & Britter 1982 approach to cavity concentration
      szcav0=rt2bypi*hcav*third

      return
      end

c-----------------------------------------------------------------------
      subroutine wake_dbg(io,ntr,xtr,ztr,rtr,htr,nobid,hstack)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070629             WAKE_DBG
c
c --- Adapted from
c --- PRIME      Version:  1.0     Level:  970812              WAKE_DBG
c                D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- UPDATE
c --- V5.7-V6.2  070629 (DGS): Initialize dbduw=0.0 for output
c
c --- PURPOSE: Reports salient features of PRIME results to
c              file for DEBUG purposes
c
c --- INPUTS:
c               io - integer     - unit for output file
c         XTR(ntr) - real        - Downwind distance (m)
c         ZTR(ntr) - real        - Plume centerline height (m)
c         RTR(ntr) - real        - Plume radius (m)
c         HTR(ntr) - real        - Plume rise (m) without streamline
c                                  modifications (used for BID)
c            NOBID - logical     - flag for BID
c           HSTACK - real        - height (m) of release
c
c     Common block /PARAMS/ variables:
c           MXRISE, MXNW
c     Common block /WAKEDAT/ variables:
c           XBADJ, Hb, Wb, xLb, Rb, xLR, xLC, HR,
c           XCAV, SZCAV, SYCAV, Ub
c
c --- OUTPUT: (written to file)
c
c          DBXB - real    - Distance (m) from upwind bldg face
c           DBX - real    - Distance (m) from source along wind
c           DBZ - real    - Plume centerline height above ground (m)
c          DBHC - real    - Cavity height above ground (m)
c          DBHW - real    - Wake height above ground (m)
c          DBSZ - real    - Sigma-z (m)
c          DBSY - real    - Sigma-y (m)
c          DBUW - real    - Wind speed factor at DBZ  (u/Ua)
c         DBRSZ - real    - Sigma-z (m) inferred from plume radius
c       IPOSITN - integer - 1: in bldg
c                           2: in cavity
c                           3: in far wake
c                           4: outside bldg influence
c         DBSZC - real    - Sigma-z (m) for cavity source
c         DBSYC - real    - Sigma-y (m) for cavity source
c
c --- WAKE_DBG called by:  POINTS1
c --- WAKE_DBG calls    :  WAKE_XSIG, WAKE_DIM, CAVITY_HT,
c                          POSITION, WAKE_U
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'wakedat.puf'

      REAL XTR(ntr),ZTR(ntr),RTR(ntr),HTR(ntr)
      logical nobid,ldb

      ldb=.FALSE.

      data rt2bypi/0.797885/

c --- Write section header to file
      write(io,*)
      write(io,*)'------------------------------------------------'
      write(io,*)'PRIME Module Results for Current Source and Hour'
      write(io,*)'          (all lengths in meters)'
      write(io,*)'------------------------------------------------'
      write(io,*)
      write(io,100)
      write(io,*)

c --- Report start of cavity as first point if it lies upwind of source
      if(xcav(1).LT.0.0) then
c ---    Set plume coordinates
         dbx=xcav(1)
         dbz=0.0

c ---    Set initial values
         dbsz=0.0
         dbsy=0.0
         dbhw=0.0
         dbhc=0.0
         dbrsz=0.0
         dbuw=1.0
         ipositn=4
         dbduw=0.0

c ---    Compute related data
         rise=0.0
         xb=dbx-xbadj
         yb=-ybadj
         zb=dbz
         dbxb=xb

c ---    Set sigmas
         dbsz=0.0
         dbsy=0.0
         dbszc=szcav(1)
         dbsyc=sycav(1)

c ---    Set dr/dx of plume radius within wake region
         dbdrdx=0.0

         if(xb.GE.0.0) then
c ---       Set wake dimension along center plane from bldg
            call WAKE_DIM(xb,Hb,Wb,Rb,dbhw,dbww)

c ---       Set cavity dimension along centerplane from bldg
            call CAVITY_HT(Hb,Wb,xLb,Rb,xLC,xLR,HR,xb,dbhc,dbwc)

c ---       Set speed factor
            call POSITION(xb,yb,zb,ipositn)
            dbuw=1.0
            if(ipositn.LT.4) call WAKE_U(ldb,xb,yb,zb,dbuw,dbduw)
         endif

c ---    Report values
         write(io,101) dbxb,dbx,dbz,dbhw,dbhc,dbsz,dbsy,dbuw,dbduw,
     &                 dbrsz,dbdrdx,ipositn,dbszc,dbsyc
      endif

c --- Process point of release
c --- Set plume coordinates
      dbx=0.0
      dbz=hstack

c --- Set initial values
      dbsz=0.0
      dbsy=0.0
      dbhw=0.0
      dbhc=0.0
      dbrsz=0.0
      dbuw=1.0
      ipositn=4
      dbduw=0.0

c --- Compute related data
      rise=0.0
      xb=dbx-xbadj
      yb=-ybadj
      zb=dbz
      dbxb=xb

c --- Set sigmas just downwind of source
      xzero=0.001
      tzero=0.001
      call WAKE_XSIG(xzero,tzero,rise,nobid,dbsz,dbsy,dbszc,dbsyc)

c --- Set dr/dx of plume radius within wake region
      call WAKE_DRDX(dbx,dbdrdx)

      if(xb.GE.0.0) then
c ---    Set wake dimension along center plane from bldg
         call WAKE_DIM(xb,Hb,Wb,Rb,dbhw,dbww)

c ---    Set cavity dimension along centerplane from bldg
         call CAVITY_HT(Hb,Wb,xLb,Rb,xLC,xLR,HR,xb,dbhc,dbwc)

c ---    Set speed factor
         call POSITION(xb,yb,zb,ipositn)
         dbuw=1.0
         if(ipositn.LT.4) call WAKE_U(ldb,xb,yb,zb,dbuw,dbduw)
      endif

c --- Report values
      write(io,101) dbxb,dbx,dbz,dbhw,dbhc,dbsz,dbsy,dbuw,dbduw,dbrsz,
     &              dbdrdx,ipositn,dbszc,dbsyc

c --- Now loop over entries in plume rise array
      do it=1,ntr

c ---    Set plume coordinates
         dbx=xtr(it)
         dbz=ztr(it)
         dbrsz=rtr(it)*rt2bypi
         rise=htr(it)

c ---    Use advection wind at top of building to set travel time
         dbt=dbx/Ub

c ---    Set initial values
         dbhw=0.0
         dbhc=0.0
         dbuw=1.0
         ipositn=4

c ---    Compute related data
         xb=dbx-xbadj
         yb=-ybadj
         zb=dbz
         dbxb=xb

c ---    Set sigmas
         call WAKE_XSIG(dbx,dbt,rise,nobid,dbsz,dbsy,dbszc,dbsyc)

c ---    Set dr/dx of plume radius within wake region
         call WAKE_DRDX(dbx,dbdrdx)

         if(xb.GE.0.0) then
c ---       Set wake dimension along center plane from bldg
            call WAKE_DIM(xb,Hb,Wb,Rb,dbhw,dbww)

c ---       Set cavity dimension along centerplane from bldg
            call CAVITY_HT(Hb,Wb,xLb,Rb,xLC,xLR,HR,xb,dbhc,dbwc)

c ---       Set speed factor
            call POSITION(xb,yb,zb,ipositn)
            dbuw=1.0
            if(ipositn.LT.4) call WAKE_U(ldb,xb,yb,zb,dbuw,dbduw)
         endif

c ---    Report values
         write(io,101) dbxb,dbx,dbz,dbhw,dbhc,dbsz,dbsy,dbuw,dbduw,
     &                 dbrsz,dbdrdx,ipositn,dbszc,dbsyc

      enddo
      write(io,*)

100   format('     XB      X      Z   Hwake   Hcav    Sz     S',
     &       'y   Ufac  dUfac  R->Sz   dRdx  Pos  Szcav  Sycav')
101   format(1x,7f7.1,2f7.3,f7.1,f7.3,i4,2f7.1)

      return
      end

c-----------------------------------------------------------------------
      subroutine wake_dfsn(ldbhr,xi,bidsq,sz0,sy0)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070629            WAKE_DFSN
c
c --- Adapted from
c --- PRIME      Version:  1.0     Level:  970812             WAKE_DFSN
c                L. Schulman, D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE: Tabulates sigmas and rate of plume growth as function
c              of location within the wake from modified Weil (1996)
c              analytical expressions
c
c --- UPDATE
c --- V5.712-V6.2    070629  (DGS): Initialize dummy variables passed
c                                   but not used
c                                   SZDUM, ZKDUM, SYDUM, YKDUM
c --- V5.711-V5.712  030822  (DGS): Constrain virtual distance increment
c                                   XVWAK to be positive
c
c --- INPUTS:
c            ldbhr - logical     - Flag for debug write statements
c                                  to upwind bldg wall
c               xi - real        - distance (m) from upwind bldg wall
c                                  to point where plume intersects wake
c            bidsq - real        - square of buoyancy-enhanced sigma
c                                  (m^2) at point of entry into wake
c              sz0 - real        - sigma-z (m) at the source
c              sy0 - real        - sigma-y (m) at the source
c
c     Common block /PARAMS/ variables:
c           MXRISE, MXNW
c     Common block /WAKEDAT/ variables:
c           XBADJ, Hb, Wb, xLb, Rb, xLR, UBKPS
c
c --- OUTPUT:
c
c     Common block /WAKEDAT/ variables:
c           NWAK, XWAK(mxrise), SZWAK(mxrise), SYWAK(mxrise),
c           DRWAK(mxrise), XZVWAK, XYVWAK,
c           NCAV, XCAV(mxrise), SZCAV(mxrise), SYCAV(mxrise),
c           XZVCAV, XYVCAV, LRURL, ISTAB
c
c --- WAKE_DFSN called by:  NUMRISE
c --- WAKE_DFSN calls    :  SIGTZ, SIGTY,
c                           WAKE_XA, WAKE_CAV0, WAKE_TURB,
c                           WAKE_SIG, WAKE_SIGA
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'wakedat.puf'

c --- Define local variable arrays for fine-steps
      real dist(mxnw),asigz(mxnw),asigy(mxnw),dsz(mxnw)
      real csigz(mxnw),csigy(mxnw)

      logical ldbhr,lcav,lwak,lrevcav

c --- Misc. constants
      data zero/0.0/, half/0.5/, one/1.0/
      data fm2km/0.001/, fkm2m/1000.0/
      data rtpiby2/1.253314/
c --- Target stepping length (m)
      data dx0/2.0/

c --- Initialize all dummy vars (passed but not used)
      szdum=0.0
      zkdum=0.0
      sydum=0.0
      ykdum=0.0

c --- Compute xa, where turbulent growth in the wake transitions
c --- to ambient growth rate, measured from upwind face of bldg
      call WAKE_XA(xLb,Rb,xaz,xay)
      xamx=AMAX1(xaz,xay)
      xamn=AMIN1(xaz,xay)

c --- Compute the virtual source offset for sz0,sy0 (km)
      call SIGTZ(sz0,zero,zero,Hb,szdum,tz0,xz0km)
      call SIGTY(sy0,zero,zero,sydum,ty0,xy0km)

c --- Compute the ambient-growth sigmas at point of entry (xi)
      xikm=(xi+xbadj)*fm2km
      xkm=xikm+xz0km
      tsec=xkm/ubkps
      call SIGTZ(zero,xkm,tsec,Hb,szi,tzi,xzikm)
      xkm=xikm+xy0km
      tsec=xkm/ubkps
      call SIGTY(zero,xkm,tsec,syi,tyi,xyikm)

c !!! DEBUG
c      write(io6,*)'xikm,szi,syi = ',xikm,szi,syi

c --- Initialize CAVITY parameters
c --------------------------------
c --- Set distance from upwind face of bldg to END of cavity
      xcave=xLb+xLR
c --- Set distance from source to start of cavity
      distc=xLb+xbadj
c --- Set downwind distance to effective cavity source (when present),
c --- from the upwind face of bldg
      xbc=AMAX1(xi,xLb)
      xbc=AMIN1(xbc,xcave)
c --- Location of downwind edge of PDF region from effective cavity
c --- source
      xdc=xbc+xLR
c --- Set initial sigmas for cavity source using sigma-y at xi,
c --- including BID
      syibid=SQRT(syi*syi+bidsq)
      call WAKE_CAV0(syibid,szcav0,sycav0)
c --- The cavity sigma-y will need to be revised if xi lies upwind of
c --- the downwind face of the bldg.
      if(xi.LT.xLb) then
         lrevcav=.TRUE.
      else
         lrevcav=.FALSE.
      endif

c --- Determine if any plume material in cavity may be modeled
c ------------------------------------------------------------
      if(xi.GE.xcave) then
         lcav=.FALSE.
         lrevcav=.FALSE.
      else
         lcav=.TRUE.
      endif
c --- Initialize output arrays for a cavity source
      ncav=1
      xcav(1)=xbc+xbadj
      szcav(1)=szcav0
      sycav(1)=sycav0
c --- Compute corresponding virtual distances
c --- Note: this virtual distance is added to distance from the
c --- cavity source, not the primary source
      call SIGTZ(szcav0,zero,zero,Hb,szdum,tzvcav,xzvcav)
      call SIGTY(sycav0,zero,zero,sydum,tyvcav,xyvcav)
c --- Convert distance from km to m
      xzvcav=xzvcav*fkm2m
      xyvcav=xyvcav*fkm2m

c --- Is plume altered by wake turbulence?
c ----------------------------------------
c --- Initialize output arrays
      nwak=1
      if(xi.GE.xamx) then
         lwak=.FALSE.
         xwak(1)=zero
         szwak(1)=sz0
         sywak(1)=sy0
         drwak(1)=zero
         xzvwak=xz0km*fkm2m
         xyvwak=xy0km*fkm2m
         if(ldbhr) then
            write(io6,*)'----- WAKE_DFSN:        NWAK = ',nwak
            write(io6,*)'Z-dispersion reaches ambient at: ',(xaz+xbadj)
            write(io6,*)'Y-dispersion reaches ambient at: ',(xay+xbadj)
            write(io6,*)'z,y virtual distances (m)    = ',xzvwak,xyvwak
            write(io6,*)'xadj, yadj, xi        (m)    = ',xbadj,ybadj,xi
            write(io6,*)'Plume NOT altered by wake turbulence!'
            write(io6,*)
         endif
      else
         lwak=.TRUE.
         xwak(1)=xi+xbadj
         szwak(1)=szi
         sywak(1)=syi
         drwak(1)=zero
c ---    Compute corresponding virtual distances
         xasrc=xwak(1)
c ---    Convert virtual distance from km to m
         xzvwak=xzikm*fkm2m
         xyvwak=xyikm*fkm2m
c ---    Set virtual distance as increment
         xzvwak=xzvwak-xasrc
         xyvwak=xyvwak-xasrc
c ---    Constrain virtual distance to be positive
c ---    (Error if more negative than -1m)
         if(xzvwak.LE.-1. .OR. xyvwak.LE.-1.) then
            write(io6,*) 'WAKE_DFSN ERROR:  Negative virtual distance'
            write(io6,*) 'xzvwak = ',xzvwak
            write(io6,*) 'xyvwak = ',xyvwak
            stop 'ERROR in WAKE_DFSN --- see list file'
         else
            xzvwak=AMAX1(zero,xzvwak)
            xyvwak=AMAX1(zero,xyvwak)
         endif
      endif

c !!! DEBUG
c      write(io6,*)
c      write(io6,*)'Ambient sigmas at xi'
c      write(io6,*)'xasrc,xzikm,xzvwak= ',xasrc,xzikm,xzvwak
c      write(io6,*)'xasrc,xyikm,xyvwak= ',xasrc,xyikm,xyvwak
c      write(io6,*)'xadj, yadj, xi    = ',xbadj,ybadj,xi
c      write(io6,*)'Starting steps in wake'

c --- Return now if sigmas in wake do not need to be tabulated
      if(.NOT.lwak .AND. .NOT.lcav) return

c --- Compute location of downwind edge of PDF region from xi
      xd=xi+xLR

c --- Set stepping parameters
      dx=dx0
c --- Range of table is from point of entry into wake (xi), to the point
c --- at which ambient growth rate resumes (xa), plus one "ds" so that
c --- both sigmas reach ambient, and virtual distances are computed.
c --- When cavity sigmas are also computed, range may start at the
c --- downwind bldg face, and extend to end of cavity.
      xlow=xi
      xhi=xamx
      if(lcav) then
         xlow=AMIN1(xi,xbc)
         xhi=AMAX1(xamx,xcave)
      endif
      xrange=xhi-xlow+dx
      np=NINT(xrange/dx)+1
      np=MIN(np,mxnw-1)
      dx=xrange/(FLOAT(np)-one)
      dxi=one/dx
      nws=0
      ncs=0
c --- Set step increment for calls to ambient sigma subroutines
      dxkm=dx*fm2km
      dts=dxkm/ubkps

c --- Fill first element of marching arrays using values at xlow
c --- (dist array measures distance downwind from primary source)
      dist(1)=xlow+xbadj
      if(lwak) then
         asigz(1)=szi
         asigy(1)=syi
c ---    Set inital plume growth rate in wake to zero
         dsz(1)=zero
      endif
      if(lcav) then
         csigz(1)=szcav0
         csigy(1)=sycav0
      endif

c --- Initialize distance (from upwind face of bldg)
      x=xlow

c --- Loop over steps in wake region
c -----------------------------------
      do n=2,np
         xold=x
         x=x+dx
         dist(n)=dist(n-1)+dx

c ---    Check to see if cavity data should be revised based on
c ---    wake sigma from previous step, with BID added
c ---    BID for position xi is used here (approximation)
         if(lrevcav .AND. xold.GE.xLb) then
            syibid=SQRT(asigy(n-1)*asigy(n-1)+bidsq)
            call WAKE_CAV0(syibid,szcav0,sycav0r)
            if(sycav0r.GT.sycav0) then
               sycav0=sycav0r
               sycav(1)=sycav0
c ---          Compute corresponding virtual distance
c ---          Note: this virtual distance is added to distance from
c ---          the cavity source, not the primary source
               call SIGTY(sycav0,zero,zero,sydum,tyvcav,xyvcav)
c ---          Convert distance from km to m
               xyvcav=xyvcav*fkm2m
c ---          Replace sigma-y values in stepping arrays
               do ir=1,n-1
                  csigy(ir)=AMAX1(csigy(ir),sycav0)
               enddo
            endif
            lrevcav=.FALSE.
         endif

c ---    Obtain sigmas for this step

c ---    First, persist initial values if upwind of starting point
         if(lwak .AND. (xi.GE.x)) then
            asigz(n)=asigz(n-1)
            asigy(n)=asigy(n-1)
            dsz(n)=dsz(n-1)
c ---       Set index for skipping entry when filling wake arrays
            nws=n
         endif
         if(lcav .AND. (xbc.GE.x)) then
            csigz(n)=szcav0
            csigy(n)=sycav0
c ---       Set index for skipping entry when filling cav arrays
            ncs=n
         endif

c ---    Now test again and apply full treatment when needed
         if(xold.GT.xamx) then
c ---       Ambient growth region in far wake:  use virtual source
c ---       Primary source ---
            if(lwak .AND. (xi.LT.x)) then
               xzkm=(dist(n)+xzvwak)*fm2km
               xykm=(dist(n)+xyvwak)*fm2km
               tz=xzkm/ubkps
               ty=xykm/ubkps
               call SIGTZ(zero,xzkm,tz,Hb,asigz(n),dtdum,dxdum)
               call SIGTY(zero,xykm,ty,asigy(n),dtdum,dxdum)
               dsz(n)=(asigz(n)-asigz(n-1))*dxi

c !!! DEBUG
c      write(io6,*)'(xold.GT.xamx) and (xi.LT.x):'
c      write(io6,*)'dist(n),xzvwak,xzkm= ',dist(n),xzvwak,xzkm
c      write(io6,*)'dist(n),xyvwak,xykm= ',dist(n),xyvwak,xykm

            endif
c ---       Cavity source ---
            if(lcav .AND. (xbc.LT.x)) then
               distcav=x-xbc
               xzkm=(distcav+xzvcav)*fm2km
               xykm=(distcav+xyvcav)*fm2km
               tz=xzkm/ubkps
               ty=xykm/ubkps
               call SIGTZ(zero,xzkm,tz,Hb,csigz(n),dtdum,dxdum)
               call SIGTY(zero,xykm,ty,csigy(n),dtdum,dxdum)
            endif
         else
            if(x.LT.xamn) then
c ---          Wake growth for both sigz and sigy
c ---          Set x at mid-point of step
               xmid=half*(x+xold)
c ---          Compute turbulence intensities at midpoint
               call WAKE_TURB(xmid,xLb,Rb,wakiz,wakiy)
               if(lwak .AND. (xi.LE.x)) then
c ---             Compute sigmas in wake
                  call WAKE_SIG(x,xd,xold,wakiz,wakiy,asigz(n-1),
     &                          asigy(n-1),Hb,Wb,Rb,zk,yk,
     &                          asigz(n),asigy(n),dsz(n))
c ---             Check for larger ambient sigma
                  xzkm=(dist(n)+xzvwak)*fm2km
                  xykm=(dist(n)+xyvwak)*fm2km
                  tz=xzkm/ubkps
                  ty=xykm/ubkps
                  call WAKE_SIGA('z',asigz(n-1),dxkm,dts,Hb,xzkm,tz,
     &                           asigza,zdxdum,zdtdum)
                  call WAKE_SIGA('y',asigy(n-1),dxkm,dts,zero,xykm,ty,
     &                           asigya,ydxdum,ydtdum)

c !!! DEBUG
c      write(io6,*)'(x.LT.xamn):'
c      write(io6,*)'dist(n),asigz(n),asigza= ',dist(n),asigz(n),asigza
c      write(io6,*)'dist(n),asigy(n),asigya= ',dist(n),asigy(n),asigya

                  asigz(n)=AMAX1(asigz(n),asigza)
                  asigy(n)=AMAX1(asigy(n),asigya)
               endif
c ---          Cavity source ---
               if(lcav .AND. (xbc.LE.x)) then
                  call WAKE_SIG(x,xdc,xold,wakiz,wakiy,csigz(n-1),
     &                          csigy(n-1),Hb,Wb,Rb,zkc,ykc,
     &                          csigz(n),csigy(n),dzrate)
c ---             Check for larger ambient growth rate
                  distcav=x-xbc
                  xzkm=(distcav+xzvcav)*fm2km
                  xykm=(distcav+xyvcav)*fm2km
                  tz=xzkm/ubkps
                  ty=xykm/ubkps
                  call WAKE_SIGA('z',csigz(n-1),dxkm,dts,Hb,xzkm,tz,
     &                           csigza,zdxdum,zdtdum)
                  call WAKE_SIGA('y',csigy(n-1),dxkm,dts,zero,xykm,ty,
     &                           csigya,ydxdum,ydtdum)
                  csigz(n)=AMAX1(csigz(n),csigza)
                  csigy(n)=AMAX1(csigy(n),csigya)
               endif
            else
c ---          At least one of the sigmas reaches ambient growth

c ---          Process SIGMA-Z
c ----------------------------
               if(xold.GE.xaz) then
c ---             Ambient growth region in wake: use virtual source
c ---             Primary source ---
                  if(lwak .AND. (xi.LE.x)) then
                     xzkm=(dist(n)+xzvwak)*fm2km
                     tz=xzkm/ubkps
                     call SIGTZ(zero,xzkm,tz,Hb,asigz(n),dtdum,dxdum)
                     dsz(n)=(asigz(n)-asigz(n-1))*dxi

c !!! DEBUG
c      write(io6,*)'(xold.GE.xaz):'
c      write(io6,*)'dist(n),xzvwak,xzkm= ',dist(n),xzvwak,xzkm

                  endif
c ---             Cavity source ---
                  if(lcav .AND. (xbc.LE.x)) then
                     distcav=x-xbc
                     xzkm=(distcav+xzvcav)*fm2km
                     tz=xzkm/ubkps
                     call SIGTZ(zero,xzkm,tz,Hb,csigz(n),dtdum,dxdum)
                  endif
               elseif(x.GE.xaz) then
c ---             Transition from wake to ambient in current step
                  dxakm=(xaz-xold)*fm2km
                  dtas=dxakm/ubkps
c ---             Compute turbulence intensities at midpoint
                  xmid=half*(xaz+xold)
                  call WAKE_TURB(xmid,xLb,Rb,wakiz,wakiy)
c ---             Primary source ---
                  if(lwak .AND. (xi.LE.xaz)) then
c ---                Compute sigma at xaz
                     call WAKE_SIG(xaz,xd,xold,wakiz,wakiy,asigz(n-1),
     &                             asigy(n-1),Hb,Wb,Rb,zk,ykdum,
     &                             sigzxa,sydum,dzrate)
c ---                Check for larger ambient sigma
                     xasrc=xaz+xbadj
                     xzkm=(xasrc+xzvwak)*fm2km
                     tz=xzkm/ubkps
                     call WAKE_SIGA('z',asigz(n-1),dxakm,dtas,Hb,
     &                              xzkm,tz,asigzxa,dxdum,dtdum)
c ---                Test wake result
                     if(asigzxa.GE.sigzxa) then
                        sigzxa=asigzxa
                        xzvwak=dxdum
                        tzvwak=dtdum
                     else
                        call SIGTZ(sigzxa,zero,zero,Hb,szdum,
     &                             tzvwak,xzvwak)
                     endif
c ---                Set virtual distance increment in m
                     xzvwak=xzvwak*fkm2m-xasrc
c ---                Compute sigma at x
                     xzkm=(dist(n)+xzvwak)*fm2km
                     tz=xzkm/ubkps
                     call SIGTZ(zero,xzkm,tz,Hb,asigz(n),dtdum,dxdum)
                     dsz(n)=(asigz(n)-asigz(n-1))*dxi

c !!! DEBUG
c      write(io6,*)'(x.GE.xaz):'
c      write(io6,*)'dist(n),xzvwak,xzkm= ',dist(n),xzvwak,xzkm

                  endif
c ---             Cavity source ---
                  if(lcav .AND. (xbc.LE.xaz)) then
c ---                Compute sigma at xaz
                     call WAKE_SIG(xaz,xdc,xold,wakiz,wakiy,csigz(n-1),
     &                             csigy(n-1),Hb,Wb,Rb,zkc,ykdum,
     &                             sigzxa,sydum,dzrate)
c ---                Check for larger ambient growth rate
                     xasrc=xaz-xbc
                     xzkm=(xasrc+xzvcav)*fm2km
                     tz=xzkm/ubkps
                     call WAKE_SIGA('z',csigz(n-1),dxakm,dtas,Hb,
     &                              xzkm,tz,csigzxa,dxdum,dtdum)
                     if(csigzxa.GE.sigzxa) then
                        sigzxa=csigzxa
                        xzvcav=dxdum
                        tzvcav=dtdum
                     else
                        call SIGTZ(sigzxa,zero,zero,Hb,szdum,
     &                             tzvcav,xzvcav)
                     endif
c ---                Set virtual distance increment in m
                     xzvcav=xzvcav*fkm2m-xasrc
c ---                Compute sigma at x
                     distcav=x-xbc
                     xzkm=(distcav+xzvcav)*fm2km
                     tz=xzkm/ubkps
                     call SIGTZ(zero,xzkm,tz,Hb,csigz(n),dtdum,dxdum)
                  endif
               else
c ---             Wake growth for sigz
c ---             Set x at mid-point of step
                  xmid=half*(x+xold)
c ---             Compute turbulence intensities at midpoint
                  call WAKE_TURB(xmid,xLb,Rb,wakiz,wakiy)
c ---             Primary source ---
                  if(lwak .AND. (xi.LE.x)) then
c ---                Compute sigmaz
                     call WAKE_SIG(x,xd,xold,wakiz,wakiy,asigz(n-1),
     &                             asigy(n-1),Hb,Wb,Rb,zk,ykdum,
     &                             asigz(n),sydum,dsz(n))
c ---                Check for larger ambient sigma
                     xzkm=(dist(n)+xzvwak)*fm2km
                     tz=xzkm/ubkps
                     call WAKE_SIGA('z',asigz(n-1),dxkm,dts,Hb,xzkm,tz,
     &                              asigza,dxdum,dtdum)

c !!! DEBUG
c      write(io6,*)'(Wake growth for sigz):'
c      write(io6,*)'dist(n),asigz(n),asigza= ',dist(n),asigz(n),asigza

                     asigz(n)=AMAX1(asigz(n),asigza)
                  endif
c ---             Cavity source ---
                  if(lcav .AND. (xbc.LE.x)) then
                     call WAKE_SIG(x,xdc,xold,wakiz,wakiy,csigz(n-1),
     &                             csigy(n-1),Hb,Wb,Rb,zkc,ykdum,
     &                             csigz(n),sydum,dzrate)
c ---                Check for larger ambient growth rate
                     distcav=x-xbc
                     xzkm=(distcav+xzvcav)*fm2km
                     tz=xzkm/ubkps
                     call WAKE_SIGA('z',csigz(n-1),dxkm,dts,Hb,xzkm,tz,
     &                              csigza,zdxdum,zdtdum)
                     csigz(n)=AMAX1(csigz(n),csigza)
                  endif
               endif

c ---          Process SIGMA-Y
c ----------------------------
               if(xold.GE.xay) then
c ---             Ambient growth region in wake: use virtual source
c ---             Primary source ---
                  if(lwak .AND. (xi.LE.x)) then
                     xykm=(dist(n)+xyvwak)*fm2km
                     ty=xykm/ubkps
                     call SIGTY(zero,xykm,ty,asigy(n),dtdum,dxdum)

c !!! DEBUG
c      write(io6,*)'(xold.GE.xay):'
c      write(io6,*)'dist(n),xyvwak,xykm= ',dist(n),xyvwak,xykm

                  endif
c ---             Cavity source ---
                  if(lcav .AND. (xbc.LE.x)) then
                     distcav=x-xbc
                     xykm=(distcav+xyvcav)*fm2km
                     ty=xykm/ubkps
                     call SIGTY(zero,xykm,ty,csigy(n),dtdum,dxdum)
                  endif
               elseif(x.GE.xay) then
c ---             Transition from wake to ambient
                  dxakm=(xay-xold)*fm2km
                  dtas=dxakm/ubkps
c ---             Compute turbulence intensities at midpoint
                  xmid=half*(xay+xold)
                  call WAKE_TURB(xmid,xLb,Rb,wakiz,wakiy)
c ---             Primary source ---
                  if(lwak .AND. (xi.LE.xay)) then
c ---                Compute sigma at xay
                     call WAKE_SIG(xay,xd,xold,wakiz,wakiy,asigz(n-1),
     &                             asigy(n-1),Hb,Wb,Rb,zkdum,yk,
     &                             szdum,sigyxa,dzrate)
c ---                Check for larger ambient sigma
                     xasrc=xay+xbadj
                     xykm=(xasrc+xyvwak)*fm2km
                     ty=xykm/ubkps
                     call WAKE_SIGA('y',asigy(n-1),dxakm,dtas,zero,
     &                              xykm,ty,asigyxa,dxdum,dtdum)

c !!! DEBUG
c      write(io6,*)'(Compute sigma at xay):'
c      write(io6,*)'dxakm,sigyxa,asigyxa= ',dxakm,sigyxa,asigyxa

                     if(asigyxa.GE.sigyxa) then
                        sigyxa=asigyxa
                        xyvwak=dxdum
                        tyvwak=dtdum
                     else
                        call SIGTY(sigyxa,zero,zero,sydum,
     &                             tyvwak,xyvwak)
                     endif
c ---                Set virtual distance increment in m
                     xyvwak=xyvwak*fkm2m-xasrc
c ---                Compute sigma at x
                     xykm=(dist(n)+xyvwak)*fm2km
                     ty=xykm/ubkps
                     call SIGTY(zero,xykm,ty,asigy(n),dtdum,dxdum)

c !!! DEBUG
c      write(io6,*)'(x.GE.xay):'
c      write(io6,*)'dist(n),xyvwak,xykm= ',dist(n),xyvwak,xykm

                  endif
c ---             Cavity source ---
                  if(lcav .AND. (xbc.LE.xay)) then
c ---                Compute sigma at xay
                     call WAKE_SIG(xay,xdc,xold,wakiz,wakiy,csigz(n-1),
     &                             csigy(n-1),Hb,Wb,Rb,zkdum,ykc,
     &                             szdum,sigyxa,dzrate)
c ---               Check for larger ambient growth rate
                     xasrc=xay-xbc
                     xykm=(xasrc+xyvcav)*fm2km
                     ty=xykm/ubkps
                     call WAKE_SIGA('y',csigy(n-1),dxakm,dtas,zero,
     &                              xykm,ty,csigyxa,dxdum,dtdum)
                     if(csigyxa.GE.sigyxa) then
                        sigyxa=csigyxa
                        xyvcav=dxdum
                        tyvcav=dtdum
                     else
                        call SIGTY(sigyxa,zero,zero,sydum,
     &                             tyvcav,xyvcav)
                     endif
c ---                Set virtual distance increment in m
                     xyvcav=xyvcav*fkm2m-xasrc
c ---                Compute sigma at x
                     distcav=x-xbc
                     xykm=(distcav+xyvcav)*fm2km
                     ty=xykm/ubkps
                     call SIGTY(zero,xykm,ty,csigy(n),dtdum,dxdum)
                  endif
               else
c ---             Wake growth for sigy
c ---             Set x at mid-point of step
                  xmid=half*(x+xold)
c ---             Compute turbulence intensities at midpoint
                  call WAKE_TURB(xmid,xLb,Rb,wakiz,wakiy)
c ---             Primary source ---
                  if(lwak .AND. (xi.LE.x)) then
c ---                Compute sigmay
                     call WAKE_SIG(x,xd,xold,wakiz,wakiy,asigz(n-1),
     &                             asigy(n-1),Hb,Wb,Rb,zkdum,yk,
     &                             szdum,asigy(n),dzrate)
c ---                Check for larger ambient sigma
                     xykm=(dist(n)+xyvwak)*fm2km
                     ty=xykm/ubkps
                     call WAKE_SIGA('y',asigy(n-1),dxkm,dts,zero,
     &                              xykm,ty,asigya,dxdum,dtdum)

c !!! DEBUG
c      write(io6,*)'(Wake growth for sigy):'
c      write(io6,*)'dist(n),asigy(n),asigya= ',dist(n),asigy(n),asigya

                     asigy(n)=AMAX1(asigy(n),asigya)
                  endif
c ---             Cavity source
                  if(lcav .AND. (xbc.LE.x)) then
                     call WAKE_SIG(x,xdc,xold,wakiz,wakiy,csigz(n-1),
     &                             csigy(n-1),Hb,Wb,Rb,zkdum,ykc,
     &                             szdum,csigy(n),dzrate)
c ---                Check for larger ambient growth rate
                     distcav=x-xbc
                     xykm=(distcav+xyvcav)*fm2km
                     ty=xykm/ubkps
                     call WAKE_SIGA('y',csigy(n-1),dxkm,dts,zero,
     &                              xykm,ty,csigya,dxdum,dtdum)
                     csigy(n)=AMAX1(csigy(n),csigya)
                  endif
               endif
            endif
         endif

c --- Next distance
      enddo

c --- Construct arrays for /WAKEDAT/
c ----------------------------------

      if(lwak) then
c ---    WAK arrays:
         npw=np-nws

c ---    Add points for portion of trajectory that lies upwind of xi,
c ---    using the same step interval, including the source location
         xwak1=xi+xbadj
         npup=xwak1*dxi+1
         if(npup.GE.1) then
            nptot=npw+npup
            xwak(1)=zero
            szwak(1)=sz0
            sywak(1)=sy0
            drwak(1)=zero
         else
            write(io6,*)' ERROR:  plume enters wake UPWIND of source'
            write(io6,*)' Distance from source (m) = ',xwak1
            stop
         endif

         if(nptot.GE.mxrise) then
c ---       Sample a subset of the nptot points
            nwak=mxrise
            xwak(nwak)=dist(np)
            szwak(nwak)=asigz(np)
            sywak(nwak)=asigy(np)
            drwak(nwak)=rtpiby2*dsz(np)
            if(nptot.LE.2*mxrise) then
c ---          Fill elements with nearest values
               deln=FLOAT(nptot)/FLOAT(nwak)
               do in=2,nwak-1
                  jn=in*deln
                  if(jn.LE.npup) then
c ---                Compute ambient sigmas
                     xtraj=jn*dx
                     xkm=xtraj*fm2km+xz0km
                     ts=xkm/ubkps
                     call SIGTZ(zero,xkm,ts,Hb,szwak(in),dtdum,dxdum)
                     xkm=xtraj*fm2km+xy0km
                     ts=xkm/ubkps
                     call SIGTY(zero,xkm,ts,sywak(in),dtdum,dxdum)
                     xwak(in)=xtraj
                     drwak(in)=zero
                  else
c ---                Pass wake array values
                     jn=jn-npup+nws
                     xwak(in)=dist(jn)
                     szwak(in)=asigz(jn)
                     sywak(in)=asigy(jn)
                     drwak(in)=rtpiby2*dsz(jn)
                  endif
               enddo
            else
c ---          Use sliding step-size to sample nearfield more frequently
               deln=2.*FLOAT(nptot-mxrise)/FLOAT(mxrise*(mxrise-1))
               rn=one
               do in=2,nwak-1
                  rn=rn+one+(in-1)*deln
                  if(INT(rn).LE.npup) then
c ---                Compute ambient sigmas
                     xtraj=rn*dx
                     xkm=xtraj*fm2km+xz0km
                     ts=xkm/ubkps
                     call SIGTZ(zero,xkm,ts,Hb,szwak(in),dtdum,dxdum)
                     xkm=xtraj*fm2km+xy0km
                     ts=xkm/ubkps
                     call SIGTY(zero,xkm,ts,sywak(in),dtdum,dxdum)
                     xwak(in)=xtraj
                     drwak(in)=zero
                  else
c ---                Pass wake array values
                     jn=rn-npup+nws
                     xwak(in)=dist(jn)
                     szwak(in)=asigz(jn)
                     sywak(in)=asigy(jn)
                     drwak(in)=rtpiby2*dsz(jn)
                  endif
               enddo
            endif
         else
c ---       Fill only those elements used
            nwak=nptot
            do in=2,nptot
               if(in.LE.npup) then
c ---             Compute ambient sigmas
                  xtraj=in*dx
                  xkm=xtraj*fm2km+xz0km
                  ts=xkm/ubkps
                  call SIGTZ(zero,xkm,ts,Hb,szwak(in),dtdum,dxdum)
                  xkm=xtraj*fm2km+xy0km
                  ts=xkm/ubkps
                  call SIGTY(zero,xkm,ts,sywak(in),dtdum,dxdum)
                  xwak(in)=xtraj
                  drwak(in)=zero
               else
c ---             Pass wake array values
                  jn=in-npup+nws
                  xwak(in)=dist(jn)
                  szwak(in)=asigz(jn)
                  sywak(in)=asigy(jn)
                  drwak(in)=rtpiby2*dsz(jn)
               endif
            enddo
         endif
      endif

      if(lcav) then
c ---    CAV arrays:
         npc=np-ncs

c ---    Place initial values into first element, using distance 
c ---    downwind of primary source
         xcav(1)=xbc+xbadj
         szcav(1)=szcav0
         sycav(1)=sycav0
         if(npc.GE.mxrise) then
c ---       Sample a subset of the npc points
            ncav=mxrise
            xcav(ncav)=dist(np)
            szcav(ncav)=csigz(np)
            sycav(ncav)=csigy(np)
            if(npc.LE.2*mxrise) then
c ---          Fill elements with nearest values
               deln=FLOAT(npc)/FLOAT(ncav)
               do in=2,ncav-1
                  jn=in*deln+ncs
                  xcav(in)=dist(jn)
                  szcav(in)=csigz(jn)
                  sycav(in)=csigy(jn)
               enddo
            else
c ---          Use sliding step-size to sample nearfield more frequently
               deln=2.*FLOAT(npc-mxrise)/FLOAT(mxrise*(mxrise-1))
               rn=one
               do in=2,ncav-1
                  rn=rn+one+(in-1)*deln
                  jn=rn+ncs
                  xcav(in)=dist(jn)
                  szcav(in)=csigz(jn)
                  sycav(in)=csigy(jn)
               enddo
            endif
         else
c ---       Fill only those elements used
            ncav=npc
            do in=2,npc
               inp=in+ncs
               xcav(in)=dist(inp)
               szcav(in)=csigz(inp)
               sycav(in)=csigy(inp)
            enddo
         endif
      endif

      if(ldbhr) then

         write(io6,*)
         write(io6,*)'----- WAKE_DFSN:        NWAK = ',nwak
         write(io6,*)'Z-dispersion reaches ambient at: ',(xaz+xbadj)
         write(io6,*)'Y-dispersion reaches ambient at: ',(xay+xbadj)
         write(io6,*)'z,y virtual dist (m) - WAKE  = ',xzvwak,xyvwak
         write(io6,*)'z,y virtual dist (m) - CAV   = ',xzvcav,xyvcav
         write(io6,*)'xadj, yadj, xi        (m)    = ',xbadj,ybadj,xi
         write(io6,*)'xbc,distc,xdc         (m)    = ',xbc,distc,xdc
         write(io6,*)'lwak, nws, npw               = ',lwak,nws,npw
         write(io6,*)'      npup, nptot            = ',npup,nptot
         write(io6,*)'lcav, ncs, npc               = ',lcav,ncs,npc
         write(io6,*)
c
c ---    Write the arrays passed back to the calling routine
         write(io6,28)
28       format(/4x,'I',9x,'XWAK',6x,'SZWAK',6x,'SYWAK',6x,'DRWAK',/)
         do i=1,nwak
            write(io6,32)i,xwak(i),szwak(i),sywak(i),drwak(i)
32          format(i5,3x,4(f10.4,1x))
         enddo
         write(io6,*)

         write(io6,29)
29       format(/4x,'I',9x,'XCAV',6x,'SZCAV',6x,'SYCAV',/)
         do i=1,ncav
            write(io6,33)i,xcav(i),szcav(i),sycav(i)
33          format(i5,3x,3(f10.4,1x))
         enddo
         write(io6,*)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine wake_siga(cyz,sigold,dxkm,dts,ht,xkm,ts,
     &                     sigma,xvkm,tvs)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402            WAKE_SIGA
c
c
c --- PURPOSE: Computes a sigma for ambient growth over an incremental
c              step, and for ambient growth from the source, and
c              returns the larger of the two.
c
c --- INPUTS:
c              cyz - char*1      - Flag for either sigma-y or sigma-z
c                                  'y' = sigma-y
c                                  'z' = sigma-z
c           sigold - real        - Sigma (m) at start of increment
c             dxkm - real        - Incremental distance (km)
c              dts - real        - Incremental time (s)
c               ht - real        - Height (m) above ground (for sigma-z)
c              xkm - real        - Effective travel distance (km) from
c                                  source, including virtual-source
c               ts - real        - Effective travel time (s) from
c                                  source, including virtual-source
c
c     Common block /PARAMS/ variables:
c           MXRISE, MXNW
c
c --- OUTPUT:
c            sigma - real        - Ambient-growth sigma (m)
c             xvkm - real        - Effective travel distance (km) from
c                                  source, including virtual-source
c              tvs - real        - Effective travel time (s) from
c                                  source, including virtual-source
c
c
c --- WAKE_SIGA called by:  WAKE_DFSN
c --- WAKE_SIGA calls    :  SIGTZ, SIGTY,
c----------------------------------------------------------------------

      character*1 cyz
      logical lz

      data zero/0.0/

c --- Define logical for either sigma-z or sigma-y
      if(cyz.EQ.'z') then
         lz=.TRUE.
      elseif(cyz.EQ.'y') then
         lz=.FALSE.
      else
         write(*,*)
         write(*,*)'WAKE_SIGA:  Error!'
         write(*,*)'First argument must be y or z'
         write(*,*)'Found:                ',cyz
         stop
      endif

c --- Compute sigma for an incremental step
      if(LZ) then
         call SIGTZ(sigold,dxkm,dts,ht,sig1,dt1,dx1)
      else
         call SIGTY(sigold,dxkm,dts,sig1,dt1,dx1)
      endif

c --- Compute sigma for total effective transport from source
      if(LZ) then
         call SIGTZ(zero,xkm,ts,ht,sig2,dt2,dx2)
      else
         call SIGTY(zero,xkm,ts,sig2,dt2,dx2)
      endif

c --- Select the larger of the two sigmas
      if(sig1.GT.sig2) then
         sigma=sig1
         xvkm=dx1
         tvs=dt1
      else
         sigma=sig2
         xvkm=dx2
         tvs=dt2
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine wake_dim(x,H,W,R,hwake,wwake)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402             WAKE_DIM
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812              WAKE_DIM
c                D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE: Calculates the vertical height and lateral half-width
c              of a building wake at a distance x from the upwind
c              face of the bldg
c
c --- INPUTS:
c                x - real        - dist (m) from upwind bldg face
c                H - real        - building height (m)
c                W - real        - building width (m)
c                R - real        - wake scaling length (m)
c
c --- OUTPUT:
c
c            hwake - real        - wake height (m)
c            wwake - real        - wake half-width (m)
c
c --- WAKE_DIM called by:  POSITION, WAKE_SIG
c --- WAKE_DIM calls    :  none
c----------------------------------------------------------------------
c --- Wake height from combination of Wilson (1979) and Weil (1996)
c --- limits for uniform approach wind

c --- Set const. used in wake height formula
      data cwkht/1.2/

c --- Misc. constants
      data half/0.5/, third/0.3333333/, zero/0.0/

c --- Scale distance by R
      xbyr=x/R
      xbyr3rd=xbyr**third

c --- Compute match to bdlg height at x=0
      xpbyr=-(H/(cwkht*R))**3
      dxbyr=xbyr-xpbyr

c --- Wake height
      hwake=zero
      if(xbyr.GT.zero) hwake =cwkht*R*dxbyr**third

c --- Wake half-width from empirical fit to Snyder wind tunnel data
      wwake=zero
      if(xbyr.GT.zero) wwake=half*W+(third*R)*xbyR3rd

      return
      end

c----------------------------------------------------------------------
      subroutine wake_drdx(x,drdx)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402            WAKE_DRDX
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812             WAKE_DRDX
c                J. Scire, D. Strimaitis,  EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Compute the plume radius growth rate in the wake
c               by interpolating among the stored values.
c
c --- INPUTS:
c                X - real       - Downwind distance (m) from source
c
c     Common block /PARAMS/ variables:
c           MXRISE
c     Common block /WAKEDAT/ variables:
c           NWAK, XWAK(mxrise), DRWAK(mxrise)
c
c --- OUTPUT:
c             DRDX - real       - Rate of growth of plume radius at
c                                 downwind distance X from source
c
c --- WAKE_DRDX called by:  NUMRISE
c --- WAKE_DRDX calls:      none
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'wakedat.puf'
c
c --- Set growth rate to zero outside interpolation region
c --- (all x outside wake)
      if(x.gt.xwak(nwak) .OR. x.lt.xwak(1))then
         drdx=0.0
      elseif(nwak.le.1) then
c ---    Wake turbulence does not alter this plume
         drdx=0.0
      else
         nwkm1=nwak-1
         drdx=drwak(1)
         do i=nwkm1,1,-1
            if(x.ge.xwak(i))then
               ip1=i+1
               drdx=drwak(ip1)-(drwak(ip1)-drwak(i))*(xwak(ip1)-x)/
     1              (xwak(ip1)-xwak(i))
               return
            endif
         enddo
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine wake_fqc(ldb,xbi,xtr,ztr,ntr)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070629             WAKE_FQC
c
c --- Adapted from
c --- PRIME      Version:  1.0     Level:  970812              WAKE_FQC
c                D. Strimaitis, L. Schulman,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE: Computes the maximum plume mass captured by cavity.
c ---          Plume centerline enters wake boundary before clearing
c ---          downwind end of cavity, so WAKE_FQC is used to find
c ---          point where mass in cavity is greatest.  Note that
c ---          distances are measured from center of upwind face of bldg
c
c --- UPDATE
c --- V5.71-V6.2    070629  (DGS): Initialize xmax, fzmax to 0.0 since
c                                  these are in debug writes, but may 
c                                  not be set
c --- V5.7-V5.71    030528  (DGS): Recast MAX as MAX1 with real args
c
c --- INPUTS:
c              ldb - logical     - Debug output switch
c              xbi - real        - Downwind distance (m) from upwind
c                                  face of bldg to point where plume
c                                  centerline enters wake
c         XTR(ntr) - real        - Downwind distance from source (m)
c         ZTR(ntr) - real        - Plume centerline height (m)
c              NTR - integer     - Number of entries in arrays
c
c     Common block /PARAMS/ variables:
c           MXRISE, MXNW
c     Common block /WAKEDAT/ variables:
c           Hb, Wb, xLb, Rb, xLC, xLR, HR, XBADJ, YBADJ, Ub
c
c --- OUTPUT:
c
c     Common block /WAKEDAT/ variables:
c           FQCAV
c
c --- WAKE_FQC called by:  NUMRISE
c --- WAKE_FQC calls    :  NUMGRAD, WAKE_XSIG, CAVITY_HT, FRGAUSS
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'wakedat.puf'

      REAL XTR(ntr),ZTR(ntr)
      logical ldb, nobid

c --- Add BID to ambient sigmas
      data nobid/.FALSE./

      fqcav=0.0
      xmax=0.0
      fzmax=0.0

c --- Define range of distances from upwind face of bldg at which to
c --- evaluate plume mass fraction within cavity
      xbstart=AMAX1(xbi,xLb)
      xbend=xLb+xLR
      xrange=0.99*(xbend-xbstart)
      yba=ABS(ybadj)
c --- Distance from source to end of cavity
      xend=xbend+xbadj
c --- Travel time (use transport at top of building)
      tend=xend/Ub

c --- Use at least 5 steps, with a maximum length of 10 m
      nstep=MAX1(5.,(1.+xrange/10.))
      xstep=xrange/FLOAT(nstep)

c --- For vertical plane, compute mass fraction below Hb at the
c --- downwind end of the cavity.  This allows the influence of plume
c --- rise to continue lifting plume mass out of the influence of
c --- of the cavity structure for strongly buoyant releases.
c --- Use this value as a cap to fractz.
      call NUMGRAD(xend,xtr,ztr,ntr,zplm)
      call WAKE_XSIG(xend,tend,0.0,nobid,sz,sy,szc,syc)
      call FRGAUSS(zplm,sz,Hb,-Hb,fractz0)

      do is=0,nstep
         xb=xbstart+is*xstep
         x=xb+xbadj
         time=x/Ub
         call NUMGRAD(x,xtr,ztr,ntr,zplm)
         call CAVITY_HT(Hb,Wb,xLb,Rb,xLC,xLR,HR,xb,zcav,ycav)
         call WAKE_XSIG(x,time,0.0,nobid,sz,sy,szc,syc)
         call FRGAUSS(zplm,sz,zcav,-zcav,fractz)
         call FRGAUSS(yba,sy,ycav,-ycav,fracty)
         fz=AMIN1(fractz,fractz0)
         fract=fz*fracty
         if(fract.GT.fqcav) then
            fqcav=fract
            xmax=x
            fzmax=fz
         endif
      enddo

c --- Additional constraint:  account for fluctuations in cavity
c --- boundary on capturing low-level plumes by imposing a maximum
c --- capture fraction that linearly drops from 1.0 at 85% of the
c --- cavity length, to 0% at the end of the cavity.
      xb85=xLb+0.85*xLR
      if(xbstart.GT.xb85) then
         fq85=AMAX1( 0.0, 1.-(xbstart-xb85)/(xbend-xb85) )
         fqcav=AMIN1(fqcav,fq85)
      endif

      if(ldb) then
         write(io6,*)
         write(io6,*)'WAKE_FQC:'
         write(io6,*)'xbi,xbstart,xbend  = ',xbi, xbstart, xbend
         write(io6,*)'xstep,nstep,fractz0= ',xstep, nstep, fractz0
         write(io6,*)'xb85,xmax          = ',xb85,xmax
         write(io6,*)'fqcav,fzmax        = ',fqcav,fzmax
         write(io6,*)
      endif

      return
      end

c----------------------------------------------------------------------
      subroutine wake_fin(ldbhr,nw,xw,szw,syw,drw,szw0,syw0,
     &                    nc,xc,szc,syc,szc0,syc0,fqcav0)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402             WAKE_FIN
c                D. Strimaitis, EARTH TECH
c
c --- PURPOSE:  Places wake and cavity data for current source into
c               source arrays
c
c --- INPUTS:
c
c      LDBHR - logical - Debug output written when .TRUE.
c
c     Common block /WAKEDAT/ variables:
c           NWAK, XWAK(mxrise), SZWAK(mxrise), SYWAK(mxrise),
c           DRWAK(mxrise), XZVWAK, XYVWAK,
c           NCAV, XCAV(mxrise), SZCAV(mxrise), SYCAV(mxrise),
c           XZVCAV, XYVCAV, FQCAV, Ub, ubkps
c
c     Parameters:
c           MXRISE
c
c --- OUTPUT:
c
c          NW - integer - Number of entries in wake arrays
c  XW(mxrise) - real    - Downwind distance (m) from primary source
c SZW(mxrise) - real    - Wake sigma-z (m) at position XW
c SYW(mxrise) - real    - Wake sigma-y (m) at position XW
c DRW(mxrise) - real    - Plume growth rate at position XW expressed
c                         as d/dx(plume radius) for equivalent top-hat
c        SZW0 - real    - Initial sigma-z (m) that produces the wake
c                         SZW(NW) using current ambient diffusion
c        SYW0 - real    - Initial sigma-y (m) that produces the wake
c                         SYW(NW) using current ambient diffusion
c          NC - integer - Number of entries in cavity arrays
c  XC(mxrise) - real    - Downwind distance (m) from cavity source
c SZC(mxrise) - real    - Cavity sigma-z (m) at position XC
c SYC(mxrise) - real    - Cavity sigma-y (m) at position XC
c        SZC0 - real    - Initial sigma-z (m) that produces the cavity
c                         SZC(NC) using current ambient diffusion
c        SYC0 - real    - Initial sigma-y (m) that produces the cavity
c                         SYC(NC) using current ambient diffusion
c      FQCAV0 - real    - Fraction of plume mass captured by cavity
c
c     Common block /WAKEDAT/ variables:
c           CBYQCAV
c
c --- WAKE_FIN called by:  POINTS1, POINTS2
c --- WAKE_FIN calls:      SIGTZ, SIGTY
c----------------------------------------------------------------------
c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'wakedat.puf'

c --- Declare output arrays
      real xw(mxrise),szw(mxrise),syw(mxrise),drw(mxrise)
      real xc(mxrise),szc(mxrise),syc(mxrise)

      logical ldbhr
      data zero/0.0/
      data pi/3.1415927/
      data fm2km/0.001/
      data fsmall/0.000001/

c --- Pass contents of sigma arrays for wake region
      nw=nwak
      do i=1,nw
         xw(i)=xwak(i)
         szw(i)=szwak(i)
         syw(i)=sywak(i)
         drw(i)=drwak(i)
      enddo
      nwp1=nw+1
      do i=nwp1,mxrise
         xw(i)=zero
         szw(i)=zero
         syw(i)=zero
         drw(i)=zero
      enddo

c --- Pass contents of sigma arrays for cavity region, with distance
c --- referenced to the cavity source location rather than the primary
      nc=ncav
      do i=1,nc
         xc(i)=xcav(i)-xcav(1)
         szc(i)=szcav(i)
         syc(i)=sycav(i)
      enddo
      ncp1=nc+1
      do i=ncp1,mxrise
         xc(i)=zero
         szc(i)=zero
         syc(i)=zero
      enddo

c --- Pass fraction of mass captured in cavity
      fqcav0=fqcav

c --- Pass centerline Chi/Q in cavity into /WAKEDAT/
      if(fqcav0.LT.fsmall) then
         cbyqcav=zero
      else
         cbyqcav=fqcav0/(pi*Ub*szc(1)*syc(1))
      endif

c !!! DEBUG
c      write(*,*)'WAKE_FIN: Primary Source xzvwak,xyvwak= ',xzvwak,xyvwak
c      write(*,*)'WAKE_FIN:  Cavity Source xzvcav,xyvcav= ',xzvcav,xyvcav

c --- Assign effective sigmas at the source which reproduce the
c --- sigmas at the end of the wake region for the dispersion
c --- conditions at the time of release
c --- Primary source
c ------------------
      xzvkm=xzvwak*fm2km
      tzv=xzvkm/ubkps
      call SIGTZ(zero,xzvkm,tzv,Hb,szw0,tdum,xdum)
      xyvkm=xyvwak*fm2km
      tyv=xyvkm/ubkps
      call SIGTY(zero,xyvkm,tyv,syw0,tdum,xdum)

c --- Cavity source
c -----------------
      xzvkm=xzvcav*fm2km
      tzv=xzvkm/ubkps
      call SIGTZ(zero,xzvkm,tzv,Hb,szc0,tdum,xdum)
      xyvkm=xyvcav*fm2km
      tyv=xyvkm/ubkps
      call SIGTY(zero,xyvkm,tyv,syc0,tdum,xdum)

c --- Debug output
      if(ldbhr) then
         write(io6,*)
         write(io6,*) 'WAKE_FIN: transition sy,sz = ',syw(nw),szw(nw)
         write(io6,*) '          xw,xyvwak,xzvwak = ',xw(nw),xyvwak,
     &                                                xzvwak
         write(io6,*) '                   tyv,tzv = ',tyv,tzv
         write(io6,*)
         write(io6,*) 'Compare with ambient sigmas'
         write(io6,*) '    x (m)   szwak   szamb   sywak   syamb'
         do i=1,nw
            xwkm=xw(i)*0.001
            tw=xwkm/ubkps
            call SIGTZ(zero,xwkm,tw,Hb,szamb,tdum,xdum)
            call SIGTY(zero,xwkm,tw,syamb,tdum,xdum)
            write(io6,'(5f8.2)') xw(i),szw(i),szamb,syw(i),syamb
         enddo
         write(io6,*)
         write(io6,*)'WAKE_FIN:  nwak,ncav =',nw,nc
         write(io6,*)'Initial (primary) syw0,szw0 = ',syw0,szw0
         write(io6,*)'Initial (cavity)  syc0,szc0 = ',syc0,szc0
         write(io6,*)'cbyqcav = fqcav0/(pi*Ub*szc(1)*syc(1))'
         write(io6,*)'cbyqcav,fqcav0,Ub = ',cbyqcav,fqcav0,Ub
         write(io6,*)
         write(io6,*)'Wake X,SigY,SigZ  ---  Cavity X,SigY,SigZ'
         do ii=1,nw
            write(io6,'(i6,6f10.2)') ii,xw(ii),syw(ii),szw(ii),
     &                                  xc(ii),syc(ii),szc(ii)
         enddo
         write(io6,*)
         write(io6,*)
      endif

      return
      end

c----------------------------------------------------------------------
      subroutine wake_ini(ldbhr,kst,irural,dsbh,dsbw,dsbl,
     &                    xadj,yadj,ubldg,ustack,
     &                    svbldg,swbldg,idopty,idoptz)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402             WAKE_INI
c
c --- Adapted from
c --- PRIME      Version:  1.0     Level:  970812              WAKE_INI
c                D. Strimaitis, EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Refreshes variables in /wakedat/ and /wakedfsn/ commons
c
c --- UPDATE
c --- V5.7          030402  (DGS): assign current values of ambient
c                                    turbulence intensity
c                                  pass CALPUFF integer for RURAL/URBAN
c                                  initialize virtuals & cavity fraction
c
c --- INPUTS:
c
c      LDBHR - logical - Debug output written when .TRUE.
c        KST - integer - PG stability class
c     IRURAL - integer - Rural(0) or urban(1) flag
c       DSBH - real    - Effective building height (m)
c       DSBW - real    - Effective building width (m) across flow
c       DSBL - real    - Effective building length (m) along flow
c       XADJ - real    - Distance (m) from source to upwind face of bldg
c                        along flow
c       XADJ - real    - Distance (m) from source to center of upwind
c                        face of bldg across flow
c      UBLDG - real    - Wind speed (m/s) at top of building
c     USTACK - real    - Wind speed (m/s) at release height
c     SVBLDG - real    - Turbulence sigma-v (m/s) at top of building
c     SWBLDG - real    - Turbulence sigma-w (m/s) at top of building
c     IDOPTY - real    - CALPUFF dispersion option for sigma-y
c     IDOPTZ - real    - CALPUFF dispersion option for sigma-z
c
c     Common block /WAKEDFSN/ variables:
c           rurliz,rurliy,urbniz,urbniy
c
c     Parameters:
c           IO6, MXRISE
c
c --- OUTPUT:
c
c     Common block /WAKEDFSN/ variables:
c           AMBIZ, AMBIY
c     Common block /WAKEDAT/ variables:
c           HB,WB,XLB,RB,HR,XLR,XLC,XBADJ,YBADJ,
c           NWAK, XWAK, SZWAK, SYWAK, DRWAK, NCAV, XCAV, SZCAV, SYCAV,
c           UB, UBKPS, URH, LRURL, ISTAB
c           XZVWAK,XYVWAK,XZVCAV,XYVCAV,FQCAV,CBYQCAV
c
c --- WAKE_INI called by:  POINTS1, POINTS2
c --- WAKE_INI calls:      WAKE_SCALES
c----------------------------------------------------------------------
c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'wakedfsn.puf'
      include 'wakedat.puf'

      logical ldbhr
      data zero/0.0/, fm2km/0.001/

c --- Transfer arguments to /wakedat/ variables
      istab =kst
      Hb    =dsbh
      Wb    =dsbw
      xLb   =dsbl
      xbadj =xadj
      ybadj =yadj
      Ub    =ubldg
      ubkps =ubldg*fm2km
      Urh   =ustack
      if(irural.EQ.0) then
         lrurl=.TRUE.
      elseif(irural.EQ.1) then
         lrurl=.FALSE.
      else
         write(io6,*) 'WAKE_INI:  invalid value for rural/urban flag:'
         write(io6,*) '           IRURAL (0 or 1) = ',irural
         write(*,*)
         stop 'Halted in WAKE_INI -- see list file'
      endif

c --- Compute wake dimensions and related parameters
      call WAKE_SCALES(ldbhr)

c --- Reset contents of sigma arrays for wake region (primary and
c --- cavity sources)
      nwak=1
      xwak(1)=zero
      szwak(1)=zero
      sywak(1)=zero
      drwak(1)=zero
      ncav=1
      xcav(1)=zero
      szcav(1)=zero
      sycav(1)=zero

c --- Reset virtuals and cavity fraction
      xzvwak=zero
      xyvwak=zero
      xzvcav=zero
      xyvcav=zero
      fqcav=zero
      cbyqcav=zero

c --- Set ambient turb. intensities (at building height) in /WAKEDFSN/
      if(idopty.LT.3 .OR. idopty.GT.4) then
c ---    Compute from turbulence velocities at building-height
         ambiy=svbldg/ubldg
      else
c ---    Use defaults for distance-based dispersion curves
         if(lrurl) then
            ambiy=rurliy(istab)
         else
            ambiy=urbniy(istab)
         endif
      endif
      if(idoptz.LT.3 .OR. idoptz.GT.4) then
c ---    Compute from turbulence velocities at building-height
         ambiz=swbldg/ubldg
      else
c ---    Use defaults for distance-based dispersion curves
         if(lrurl) then
            ambiz=rurliz(istab)
         else
            ambiz=urbniz(istab)
         endif
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine wake_scales(ldbhr)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402          WAKE_SCALES
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812           WAKE_SCALES
c                L. Schulman, D. Strimaitis,  J. Scire,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Calculates length scale and wake dimensions
c
c --- INPUTS:
c            LDBHR - logical           - Control variable for debug
c                                        write statements
c
c     Common block /WAKEDAT/ variables:
c           Hb,Wb,xLb
c     Parameters:  IO6
c
c --- OUTPUT:
c
c     Common block /WAKEDAT/ variables:
c           Rb,HR,xLR,xLC
c
c --- WAKE_SCALES called by:  WAKE_INI
c --- WAKE_SCALES calls:      none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include commons
      include 'wakedat.puf'

      logical ldbhr

c --- Set misc. constants
      data third/0.3333333/, twoby3/0.6666667/

      if(HB.le.0.) then
c ---    No building
         Rb=0.0
         Hb=0.0
         xLR=0.0
         xLC=0.0
      else
c
c ---    Set ratios
         rw = Wb/Hb
         rl = xLb/Hb
c ---    Fackrell limits on aspect ratio L/H
         if(rl .lt. 0.3) rl=0.3
         if(rl .gt. 3.0) rl=3.0
c
c ---    Length scale R --- Wilson
c ---    Wilson limits for length scale R
c ---    H/W or W/H not greater than 8 --  already behaves as 2-D
         HH=Hb                    ! only modify H to calculate R
         WW=Wb                    ! only modify W to calculate R
         if(HH.gt.8.0*WW)HH=8.0*WW
         if(WW.gt.8.0*HH)WW=8.0*HH
         Rb= (amin1(HH,WW)**twoby3) * (amax1(HH,WW)**third)
c
c ---    Reattachment for LC < L
         xLC = 0.9*Rb
c
c ---    Recirculation cavity length---Fackrell
c ---    Modify Fackrell for W/H less than 1 by weakening dependence
c ---    on L/H.  Snyder found that cavity did not increase in length
c ---    as W/H = L/H decreased from 1 to 0.33.
c ---    Let L/H dependence decrease from Fackrell dependence at W/H=1
c ---    to no dependence at W/H=0.33.
         explh = 0.3
         if(rw .lt. 1.) explh=AMAX1(0.0,0.3*(rw-0.33)/0.67)
         xLR = 1.8*Wb/(rl**explh*(1.+0.24*rw))
c
c ---    Maximum cavity height  (Wilson,ASHRAE):
         HR = Hb+0.22*Rb

      endif

c --- Write the results
      if(ldbhr)then
         write(io6,*)
         write(io6,*)'WAKE_SCALES inputs: '
         write(io6,*)'   HB    = ',Hb,' (m)'
         write(io6,*)'   WB    = ',Wb,' (m)'
         write(io6,*)'   LB    = ',xLb,' (m)'
         write(io6,*)
         write(io6,*)'WAKE_SCALES output: '
         write(io6,*)'   Scale length (R)               = ',Rb
         write(io6,*)'   Max. cavity height (HR)        = ',HR
         write(io6,*)'   Length of downwind cavity (LR) = ',xLR
         write(io6,*)'   Length of roof cavity (LC)     = ',xLC
         write(io6,*)
      endif
c
      return
      end

c-----------------------------------------------------------------------
      subroutine wake_sig(x,xd,xold,turbz,turby,szold,syold,
     &                    H,W,R,zk,yk,sz,sy,dsz)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402             WAKE_SIG
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812              WAKE_SIG
c                D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE: Calculates sigmas and d(sigma)/dx within the wake
c              at a distance x from the upwind face of the bldg,
c              prior to the ambient growth regime, for a "small"
c              distance increment
c
c --- INPUTS:
c                x - real        - dist (m) from upwind bldg face
c               xd - real        - dist (m) at which PDF growth ends
c             xold - real        - starting x of this step (m)
c     turbz, turby - real        - current turbulence intensities
c     szold, syold - real        - sigmas (m) at start of step
c   htwake, hwwake - real        - height and half-width (m) of wake
c           zk, yk - real        - matching constants for PDF transition
c
c --- OUTPUT:
c
c           zk, yk - real        - matching constants for PDF transition
c           sz, sy - real        - sigmas (m) at end of step
c              dsz - real        - d(sigmaz)/dx over step
c
c --- WAKE_SIG called by:  WAKE_DFSN
c --- WAKE_SIG calls    :  WAKE_DIM
c----------------------------------------------------------------------
c --- Wake height from combination of Wilson (1979) and Weil (1996)
c --- limits for uniform approach wind

c --- Misc. constants
      data two/2.0/

c --- Get wake dimensions
      call WAKE_DIM(x,H,W,R,htwake,hwwake)

c --- Use full width of the wake to scale lateral diffusivity
      fwwake=two*hwwake

      delx=x-xold
      xstepi=1./delx
      if(x.LT.xd) then
c ---    Pure PDF Form
         dsz=turbz
         sz=szold + delx*turbz
         sy=syold + delx*turby
      elseif(xold.GT.xd) then
c ---    Pure Wake Diffusivity Form
         dsz2=zk*turbz*htwake
         dsy2=yk*turby*fwwake
         sz=SQRT(szold**2+delx*dsz2)
         sy=SQRT(syold**2+delx*dsy2)
         dsz=(sz-szold)*xstepi
      else
c ---    Transition from PDF to Diffusivity Form
c ---    To end of PDF:
         delx=xd-xold
         sigzd=szold + delx*turbz
         sigyd=syold + delx*turby
         zk=two*sigzd/htwake
         yk=two*sigyd/fwwake
c ---    Beyond end of PDF:
         delx=x-xd
         dsz2=zk*turbz*htwake
         dsy2=yk*turby*fwwake
         sz=SQRT(sigzd**2+delx*dsz2)
         sy=SQRT(sigyd**2+delx*dsy2)
         dsz=(sz-szold)*xstepi
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine wake_turb(x,L,R,tiz,tiy)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402            WAKE_TURB
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812             WAKE_TURB
c                L. Schulman, D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE: Calculates turbulence intensity as a function of
c              location within the wake from modified Weil (1996)
c              analytical expressions
c
c --- UPDATE
c --- V5.7          030402  (DGS): ambient turbulence intensity set in
c                                  /WAKEDFSN/
c
c --- INPUTS:
c                x - real        - distance (m) from upwind bldg wall
c                L - real        - dist (m) of downwind bldg wall from
c                                  upwind bldg wall
c                R - real        - wake scaling length (m)
c
c     Common block /WAKEDFSN/ variables:
c           wiz0,wiy0,wfz,wfy,
c           dua_ua,xdecay,xdecayi,
c           ambiy,ambiz
c
c --- OUTPUT:
c
c              tiz - real        - turbulence intensity sigw/u
c              tiy - real        - turbulence intensity sigv/u
c
c --- WAKE_TURB called by:  WAKE_DFSN
c --- WAKE_TURB calls    :  none
c----------------------------------------------------------------------
c
      include 'wakedfsn.puf'

      real L

c --- Misc. constants
      data one/1.0/, zero/0.0/

c --- Compute asymptotic turbulence intensity in far wake
      fariz=AMIN1(wiz0,ambiz)
      fariy=AMIN1(wiy0,ambiy)

c --- Compute turbulence intensity at position downwind of bldg
      xmL=AMAX1(zero,x-L)
      xfac=one/(((xmL+R)/R)**xdecay-dua_ua)
      tiz=fariz*(one+((wfz*wiz0/fariz-one)+dua_ua)*xfac)
      tiy=fariy*(one+((wfy*wiy0/fariy-one)+dua_ua)*xfac)

c --- Interpolate turbulence intensity if over roof of bldg
      if(x.LT.L) then
         xfrac=x/L
         tiz=ambiz+xfrac*(tiz-ambiz)
         tiy=ambiy+xfrac*(tiy-ambiy)
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine wake_u(ldb,x,y,z,ubyua,dufac)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402               WAKE_U
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  990726 (99207)        WAKE_U
c                D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE: Calculates speed ratio u(wake)/u(ambient) as a function
c              of location within the wake
c
c              Modified by B. de Foy, 26th July 1999,
c              To set fmin as a minimum value for ubyua
c
c --- INPUTS:
c              ldb - logical     - flag for debug output
c                x - real        - downwind distance (m) from upwind
c                                  bldg wall
c                y - real        - crosswind distance (m) from center of
c                                  upwind bldg wall
c                z - real        - height (m) above ground
c
c     Common block /PARAMS/ variables:
c           MXRISE, MXNW
c     Common block /WAKEDAT/ variables:
c           Hb, Wb, xLb, Rb, xLR
c     Common block /WAKEDFSN/ variables:
c           dua_ua,xdecay,xdecayi
c
c --- OUTPUT:
c
c            ubyua - real        - U(x,z)/Ua speed in wake scaled by
c                                  ambient speed
c            dufac - real        - Gradient in speed factor above
c                                  Zcav
c
c --- WAKE_U called by:  NUMRISE, WAKE_DBG
c --- WAKE_U calls    :  CAVITY_HT, WAKE_DIM
c----------------------------------------------------------------------
c
      include 'params.puf'
      include 'wakedfsn.puf'
      include 'wakedat.puf'

      logical ldb

c --- Misc. constants
      data two/2.0/, one/1.0/, zero/0.0/
      data fmin/0.01/

c --- Compute cavity height above ground, and width
      call CAVITY_HT(Hb,Wb,xLb,Rb,xLC,xLR,HR,x,zcav,ycav)

c --- Compute far wake height above ground, and width
      call WAKE_DIM(x,Hb,Wb,Rb,hwake,wwake)

c --- Return "null" values if point is outside wake
      yabs=ABS(y)
      ubyua=one
      dufac=zero
      if(z.GE.hwake .OR. yabs.GE.wwake) return

c --- Adjust "base" speed deficit dua_ua if lateral position is
c --- beyond bldg width projection, but within the wake
      ymin=AMAX1(0.5*Wb,wwake-Rb/3.)
      du_ua=dua_ua
      ydiff=wwake-ymin
      if(yabs.GT.ymin .AND. ydiff.GT.zero) then
         du_ua=dua_ua*(one-(yabs-ymin)/ydiff)
      endif

c --- Scale speed deficit (Ua-U)/Ua =  du_ua in wake for
c --- position x downwind of bldg face
      xmL=AMAX1(zero,x-xLb)
      du_ua=du_ua*((xmL+Rb)/Rb)**(-xdecay)
c --- Interpolate factor if over roof of bldg (linear)
      if(x.LT.xLb) then
         xfrac=x/xLb
         du_ua=xfrac*du_ua
      endif

c --- Compute speed factor Ucav/Ua at top of cavity
c --- Assume that speed is constant below ZCAV, and increases linearly
c --- with height to ambient speed at HWAKE
      ucbyua=AMAX1(zero,(one-two*hwake*du_ua/(hwake+zcav)))

c --- Compute gradient in speed factor (zero below Zcav)
      dufac=zero
      if(z.GT.zcav) then
         dufac=(one-ucbyua)/(hwake-zcav)
      endif

c --- Compute speed factor U/Ua at height z
      zz=AMIN1(z,hwake)
c --- Ensure fmin as lower bound for ubyua
      ubyua=AMAX1(fmin,(ucbyua+dufac*(zz-zcav)))

      if(ldb) then
        write(io6,*)'WAKE_U         '
        write(io6,*)'       x,y,z = ',x,y,z
        write(io6,*)'hwake, zcav  = ',hwake, zcav
        write(io6,*)'wwake, ymin  = ',wwake, ymin
        write(io6,*)'du_ua, ucbyua= ',du_ua, ucbyua
        write(io6,*)'ubyua, dufac = ',ubyua,dufac
        write(io6,*)
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine wake_xa(L,R,xaz,xay)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402              WAKE_XA
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  980310               WAKE_XA
c                D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE: Calculates the distance from the upwind face of the
c              building to the point at which the turbulence intensity
c              in the wake approaches that in the ambient flow.
c
c              Final distances are limited to "xbyrmax" scale-lengths
c              (R) set in prime1, measured from downwind bldg face
c
c --- UPDATE
c --- V5.7          030402  (DGS): ambient turbulence intensity set in
c                                  /WAKEDFSN/
c
c --- INPUTS:
c                L - real        - dist (m) of downwind bldg wall from
c                                  upwind bldg wall
c                R - real        - wake scaling length (m)
c
c     Common block /WAKEDFSN/ variables:
c           afac,xbyrmax,wiz0,wiy0,wfz,wfy,
c           dua_ua,xdecay,xdecayi,
c           ambiy,ambiz
c
c --- OUTPUT:
c
c              xaz - real        - distance (m) from upwind bldg wall
c                                  at which wake turbulence Iz = ambient
c              xay - real        - distance (m) from upwind bldg wall
c                                  at which wake turbulence Iy = ambient
c
c --- WAKE_XA called by:  WAKE_DFSN
c --- WAKE_XA calls    :  none
c----------------------------------------------------------------------
c
      include 'wakedfsn.puf'
      real L

c --- Misc. constants
      data one/1.0/

c --- Compute asymptotic turbulence intensity in far wake
      fariz=AMIN1(wiz0,ambiz)
      fariy=AMIN1(wiy0,ambiy)

c --- Define the turbulence intensity at the transition point
      farizt=AMAX1(ambiz,afac*fariz)
      fariyt=AMAX1(ambiy,afac*fariy)

c --- Compute leading term
      x0byr=L/R-one

c --- Compute scaled distance at which Iz equals transition Iz
      xaz=x0byr+(dua_ua+(wfz*wiz0-fariz*(one-dua_ua))/
     &       (farizt-fariz))**xdecayi

c --- Compute distance at which Iy equals transition Iy
      xay=x0byr+(dua_ua+(wfy*wiy0-fariy*(one-dua_ua))/
     &       (fariyt-fariy))**xdecayi

c --- Cap distances
      xbyr=L/R+xbyrmax
      xaz=R*AMIN1(xbyr,xaz)
      xay=R*AMIN1(xbyr,xay)

      return
      end
c----------------------------------------------------------------------
      subroutine wake_xsig(x,t,rise,NOBID,sz,sy,szc,syc)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402            WAKE_XSIG
c
c --- Adapted from
c --- PRIME      Version:  1.0     Level:  970812             WAKE_XSIG
c                D. Strimaitis,  EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Extract sigmas in the wake by interpolating among the
c               stored /WAKEDAT/ values; compute sigmas outside
c               tabulated range using HOST sigma curves with BID or
c               virtual source adjustments
c
c --- INPUTS:
c                X - real       - Downwind distance (m) from primary
c                                 source
c                T - real       - Travel time (s) from primary source
c             RISE - real       - Gradual plume rise (m)
c            NOBID - logical    - Directs use of buoyancy enhancement
c
c     Common block /PARAMS/ variables:
c           MXRISE
c     Common block /WAKEDAT/ variables:
c           UBKPS,
c           NWAK, XWAK(mxrise), SZWAK(mxrise), SYWAK(mxrise),
c           XZVWAK, XYVWAK
c           NCAV, XCAV(mxrise), SZCAV(mxrise), SYCAV(mxrise),
c           XZVCAV, XYVCAV
c
c --- OUTPUT:
c             SZ - real       - Sigma-z (m) at downwind distance X
c                               due to primary source
c             SY - real       - Sigma-y (m) at downwind distance X
c                               due to primary source
c            SZC - real       - Sigma-z (m) of cavity source at
c                               downwind distance X from primary source
c            SYC - real       - Sigma-y (m) of cavity source at
c                               downwind distance X from primary source
c
c --- WAKE_XSIG called by:  WAKE_DBG, WAKE_FQC, CAV_SRC
c --- WAKE_XSIG calls:      SIGTZ, SIGTY, INTERTAB
c----------------------------------------------------------------------
c --- Note:  sigmas tabulated in /WAKEDAT/ use distance measured from
c --- the primary source, and start from either the primary source or
c --- the cavity source, depending on which lies further upwind.  The
c --- virtual source distances in /WAKEDAT/ produce the corresponding
c --- sigma at the end of the tabulation, when added to the actual
c --- distance from the corresponding source.  None of these sigmas
c --- has BID added.

      include 'params.puf'
      include 'wakedat.puf'

      logical NOBID

c --- Misc. constants
      data zero/0.0/
      data fm2km/0.001/

c --- Convert distance to kilometers
      xkm=x*fm2km

c --- Primary source:
c -------------------
c --- Set virtuals
      xzvkm=xzvwak*fm2km
      xyvkm=xyvwak*fm2km
      tzv=xzvkm/ubkps
      tyv=xyvkm/ubkps
c --- Set total effective distance(km), time(s)
      xzkm=xkm+xzvkm
      xykm=xkm+xyvkm
      tz=t+tzv
      ty=t+tyv
      if(x.LE.0.0) then
c ---    Report null values (these should never get used!)
         sz=0.0
         sy=0.0
      elseif(nwak.LE.1 .OR. x.gt.xwak(nwak)) then
c ---    Plume never altered by wake turbulence, or
c ---    Point lies downwind of transition to ambient growth:
c ---    use HOST curves with the virtual offset
         call SIGTZ(zero,xzkm,tz,Hb,sz,tzvdum,xzvdum)
         call SIGTY(zero,xykm,ty,sy,tyvdum,xyvdum)
      else
c ---    Point lies within range of tabulated values
         call INTERTAB(x,nwak,xwak,i1,i2,factor)
         sz=szwak(i1)+factor*(szwak(i2)-szwak(i1))
         sy=sywak(i1)+factor*(sywak(i2)-sywak(i1))
      endif
      if(.not.NOBID) then
         bidsq=(rise/3.5)**2
         sz=SQRT(sz**2+bidsq)
         sy=SQRT(sy**2+bidsq)
      endif

c --- Cavity source:
c -------------------
c --- Set virtuals
      xzvkm=xzvcav*fm2km
      xyvkm=xyvcav*fm2km
      tzv=xzvkm/ubkps
      tyv=xyvkm/ubkps
c --- Set total effective distance(km), time(s)
      xzkm=xkm+xzvkm
      xykm=xkm+xyvkm
      tz=t+tzv
      ty=t+tyv
      if(ncav.LE.1) then
c ---    No contribution from cavity source (report initial values)
         szc=szcav(1)
         syc=sycav(1)
      elseif(x.lt.xcav(1)) then
c ---    Point lies upwind of cavity region (report initial values)
         szc=szcav(1)
         syc=sycav(1)
      elseif(x.gt.xcav(ncav)) then
c ---    Point lies downwind of transition to ambient growth:
c ---    use HOST curves with the virtual offset
c ---    Compute sigmas
         call SIGTZ(zero,xzkm,tz,Hb,szc,dtdum,dxdum)
         call SIGTY(zero,xykm,ty,syc,dtdum,dxdum)
      else
c ---    Point lies within range of tabulated values
         call INTERTAB(x,ncav,xcav,i1,i2,factor)
         szc=szcav(i1)+factor*(szcav(i2)-szcav(i1))
         syc=sycav(i1)+factor*(sycav(i2)-sycav(i1))
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine cavity_ht(H,W,L,R,LC,LR,HR,x,zcav,ycav)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402            CAVITY_HT
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812             CAVITY_HT
c                L. Schulman, EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Calculates height of cavity envelope as function of x
c
c --- INPUTS:
c                H - real              - Building height above ground
c                W - real              - Projected building width
c                L - real              - Along-wind building length
c                                        building face
c                R - real              - Scale length from H and W
c               LC - real              - Length of roof cavity
c               LR - real              - Length of downwind cavity from
c                                         lee face
c               HR - real              - Maximum cavity height above
c                                         ground
c                x - real              - downwind distances
c
c --- OUTPUT:
c
c          zcav    - real              - cavity height as function of x
c
c          ycav    - real              - cavity half-width as f(x)

c --- CAVITY_HT called by:  PRIME
c --- CAVITY_HT calls:      none
c----------------------------------------------------------------------
c
c
c
      real H,W,L,R,HR,LR,LC
      real x

c --- Initialize
      zcav=0.0
      ycav=0.0

c --- Cavity is not present upwind of bldg or at/beyond L+LR
      if(x.GE.(L+LR)) then
         return
      elseif(x.LT.0.0) then
         return
      endif
c
c     calculate x-y near wake boundary
c
      if(x.ge.0. .and. x.le.R) then
        ycav=(W/2.+R/3.)-(x-R)**2/(3.*R)
      elseif(x.gt.R .and. x.le.(L+LR)) then
        ycav=(W/2.+R/3.)*(1.-((x-R)/(L+LR-R))**2)**0.5
      endif

c     calculate x-z near wake boundary
c
      if(LC .lt. L)then       ! reattachment
c
        if(x.ge.0. .and. x.le.L) then
          zcav=H
        elseif(x.ge.L .and. x.le.(L+LR)) then
          zcav=H*(1.-((x-L)/LR)**2)**0.5
        endif
c
      else                    ! nonreattachment
        if(x.ge.0. .and. x.le.0.5*R) then
        zcav=HR+4.*(x-0.5*R)**2*(H-HR)/(R**2)
        elseif(x.gt.0.5*R .and. x.le.(L+LR)) then
          zcav=HR*(1.-((x-0.5*R)/(L+LR-0.5*R))**2)**0.5
        endif
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine FRGAUSS(hcntr,sigma,h1,h2,fract)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402              FRGAUSS
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812               FRGAUSS
c                J. Scire, D. Strimaitis,  EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Compute the fraction of a Gaussian distribution between
c               two limits
c
c --- INPUTS:
c            HCNTR - real    - Center of Gaussian distribution (m)
c            SIGMA - real    - Standard deviation (m) of the
c                              distribution
c           H1, H2 - real    - Limits between which the distribution
c                              is to be integrated
c
c --- OUTPUT:
c            FRACT - real    - Fraction of the Gaussian distribution
c                              between H1 and H2
c
c --- FRGAUSS called by: WAKE_FQC
c --- FRGAUSS calls:     ERFDIF
c----------------------------------------------------------------------
c
      data sqrt2/1.4142136/,small/1.e-5/
c
c --- Prevent numerical problems with very small sigmas
      s=sqrt2*AMAX1(sigma,small)
c
      z1=(h1-hcntr)/s
      z2=(h2-hcntr)/s
c
      fract=0.5*ABS(ERFDIF(z1,z2))
c
      return
      end
c----------------------------------------------------------------------
      subroutine numgrad(x,xtr,ztr,ntr,zeff)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402              NUMGRAD
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812               NUMGRAD
c                J. Scire,  EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Compute the effective gradual plume height by
c               interpolation of the stored values.  Effective
c               plume height is the stack height + plume rise.
c
c --- INPUTS:
c                X - real       - Downwind distance (m)
c         XTR(ntr) - real array - Array of stored downwind distances (m)
c         ZTR(ntr) - real array - Array of stored effective plume height
c                                 at each downwind distance
c              NTR - integer    - Number of stored values in XTR, ZTR
c
c --- OUTPUT:
c             ZEFF - real       - Effective plume height (m) at
c                                 downwind distance X
c
c --- NUMGRAD called by:  PHEFF
c --- NUMGRAD calls:      none
c----------------------------------------------------------------------
c
      real xtr(ntr),ztr(ntr)
c
      if(x.ge.xtr(ntr))then
         zeff=ztr(ntr)
      else
         ntrm1=ntr-1
         zeff=ztr(1)
         do i=ntrm1,1,-1
            if(x.ge.xtr(i))then
               ip1=i+1
               zeff=ztr(ip1)-(ztr(ip1)-ztr(i))*(xtr(ip1)-x)/
     1          (xtr(ip1)-xtr(i))
               return
            endif
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine position(x,y,z,ipositn)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402             POSITION
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812              POSITION
c                L. Schulman, J. Scire, D. Strimaitis,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Identifies if (x,y,z) location is in the building,
c               in the near wake, in the far wake, or outside.
c               IPOSITN is set to: 1 if within the bldg.
c                                  2 if within the near wake
c                                  3 if within the far wake
c                                  4 if outside wake region
c
c --- INPUTS:
c                x - real              - downwind distance from center
c                                        of upwind face of bldg
c                y - real              - crosswind distance from center
c                                        of upwind face of bldg
c                z - real              - height above ground
c
c     Common block /WAKEDAT/ variables:
c           Hb,Wb,xLb,Rb,HR,xLR,xLC
c
c --- OUTPUT:
c
c          ipositn - integer           - 1 if (x,y,z) within building
c                                        2 if location within near wake
c                                        3 if location within far wake
c                                        4 if location outside
c
c --- POSITION called by:  NUMRISE, PCALC (HOST subroutine)
c --- POSITION calls:      WAKE_DIM
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'

c --- Include commons
      include 'wakedat.puf'

      data zero/0.0/, third/0.333333/, half/0.5/

c --- Define a fractional boundary just inside building
      data skin/0.99998/

c --- Initialize
      iposy=4
      iposz=4
      ipositn=4

c --- Screen out any cases without building
      if(Hb.le.zero) return

c --- Screen out positions upwind of building (and on windward face)
      if(x.le.zero) return

c --- Set y positive for calculations
      ypos=ABS(y)

c --- Set selected length scale products
      rby2=half*Rb
      rby3=third*Rb
      wby2=half*Wb

c --- Set ipositn to 1 if location within building
      xtest=x/xLB
      ytest=ypos/wby2
      ztest=z/Hb
      if(xtest.lt.skin .and. ztest.lt.skin .and. ytest.lt.skin) then
         ipositn=1
         return
      endif

c --- Calculate if location below height of near wake boundary
      if(xLC .lt. xLb)then
c ---    Reattachment
         if(x.lt.xLb) then
c ---       Cavity height equal to building height
            zcav=Hb
            if(z .le. zcav) iposz=2
         elseif(x.lt.(xLb+xLR)) then
c ---       Cavity height is ellipse with a=LR and b=H
            zcav=Hb*SQRT(1.-((x-xLb)/xLR)**2)
            if(z .le. zcav) iposz=2
         endif
      else
c ---    No reattachment
         if(x.le.rby2) then
c ---       Cavity height is parabola with vertex at height MAX(0.5R,HR)
c ---       and passing thru upwind building edge (0,H)
            zcav=HR+4.*(x-rby2)**2*(Hb-HR)/(Rb**2)
            if(z .le. zcav) iposz=2
         elseif(x.lt.(xLb+xLR)) then
c ---       Cavity height is ellipse with a=LR+L-0.5R and b=HR
            zcav=HR*SQRT(1.-((x-rby2)/(xLb+xLR-rby2))**2)
            if(z .le. zcav) iposz=2
         endif
      endif

c --- Calculate x-y near wake boundary
      if(x.le.Rb) then
c ---    Cavity width is parabola with vertex @ width MAX(R,W/2+R/3)
c ---    and passing thru upwind building edge (0,W/2)
         ycav=(wby2+rby3)-(x-Rb)**2/(3.*Rb)
         if(ypos .le. ycav) iposy=2
      elseif(x.lt.(xLb+xLR)) then
c ---    Cavity width is ellipse with a=W/2+R/3 and b=LR+L-R
         ycav=(wby2+rby3)*SQRT(1.-((x-Rb)/(xLb+xLR-Rb))**2)
         if(ypos .le. ycav) iposy=2
      endif

c --- Set ipositn to 2 if (x,y,z) location within near wake
      if( iposz .eq. 2 .and. iposy .eq. 2) ipositn=2

c --- Test for position in far wake if still 4
      if(ipositn.EQ.4) then
         call WAKE_DIM(x,Hb,Wb,Rb,zwake,ywake)
         if(z.le.zwake .AND. ypos.le.ywake) ipositn=3
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine zstream(H,W,L,R,LR,HR,x,y,z,dzdx)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402              ZSTREAM
c
c --- Adopted from
c --- PRIME      Version:  1.0     Level:  970812               ZSTREAM
c                L. Schulman, J. Scire,   EARTH TECH
c                Prepared for EPRI under contract WO3527-01
c
c --- PURPOSE:  Estimates the local mean slope of streamlines in the
c               vicinity of buildings.  The local slope is equal to
c               w/u, where w is the local mean vertical velocity and
c               u the local mean longitudinal velocity.  For modeling
c               plume rise, the streamline deflection effect is modeled
c               as (w/u)(dx).
c
c --- INPUTS:
c                H - real              - Building height above ground
c                W - real              - Projected building width
c                L - real              - Along-wind building length
c                R - real              - Scale length from H and W
c               LR - real              - Length of downwind cavity from
c                                         lee face
c               HR - real              - Maximum cavity height above
c                                         ground
c                x - real              - downwind distances
c                y - real              - crosswind distances
c                z - real              - heights above ground
c
c --- OUTPUT:
c             dzdx - real              - Vertical streamline slope
c
c --- ZSTREAM called by:  NUMRISE
c --- ZSTREAM calls:      none
c----------------------------------------------------------------------
c
      real H,W,L,R,HR,LR,expz1,expz2,expzg,expx
      real x,y,z,dzdx2,zslope,dzdx,ypos
      data expx/1./,expz1/3./,expz2/1./
c
c --- Check for a building
      if(h.le.0.0)then
         dzdx=0.0
         go to 900
      endif

c --- Set a few constants
      hbyw=H/W
      ypos=abs(y)
      onebyr=1.0/R
      wby2=0.5*W
      rby2=0.5*R

c --- Power law exponent for slope approaching zero at ground
c --- Exponent modified for tall, narrow buidings
c --- zg is level below which slope is zero in far wake
      zg=0.
      expzg=0.3
      if(hbyw .ge. 2.) expzg=expzg*(0.5*hbyw)**2

c
c --- Local streamline slope (zslope) at z=H
c --- Local two-dimensional streamline slope (dzdx2)
c --- Local three-dimensional streamline slope (dzdx)
c --- (x,y,z)=(0,0,0) at ground of center of upwind building face
c
      if(x .lt. -R) then
c ---    Upwind of building influence
         zslope = 0.
         dzdx2  = 0.

      elseif(x .lt. 0.) then
c ---    Ascent upwind of building:
c ---    parobolic fit to slope=0 at (-R,0) with increasing slope
c ---    to (0,(HR-H))
c ---    vertical decay above building using expz1
c ---    below building nonzero slope above 2/3 H for R<H reducing
c ---    to ground as R approaches 2H
         zslope = 2.*(HR-H)*(x+R)*onebyr**2.
         if(z .gt. H) then
            dzdx2 = zslope/((z-H+R)*onebyr)**expz1
         elseif(R .le. H .and. z .le. 0.67*H) then
            dzdx2 = 0.
         elseif(R .le. H .and. z .gt. 0.67*H) then
            dzdx2 = zslope
         elseif(R .gt. H .and. z .le. 0.67*(2*H-R)) then
            dzdx2 = 0.
         elseif(R .gt. H .and. z .gt. 0.67*(2*H-R)) then
            dzdx2 = zslope
         else
            print *,'z out of bounds      ',x,z
         endif

      elseif(x .le. rby2) then
c ---    Ascent over building
c ---    parobolic fit from (0,0) with decreasing slope to
c ---    to (0.5R,(HR-H))
c ---    vertical decay above building using expz1
         zslope = (-(HR-H)*4.*onebyr)*(2.*x*onebyr-1.)
         if(z .le. H) then
            dzdx2 = zslope
         else
            dzdx2 = zslope/((z-H+R)*onebyr)**expz1
         endif

      elseif(x .le. L+LR) then
c ---    Descent over building to end of near wake
c ---    parobolic fit from (.5R,(HR-H)) with increasing slope to
c ---    to (L+LR,-H/2)
c ---    vertical decay above z=H using expz2
c ---    vertical decay below z=H using expzg
         zslope = (HR-H)*(R-2.*x)/((L-rby2+LR)**2)
         if(z .gt. H) then
            dzdx2 = zslope/((z-H+R)*onebyr)**expz2
         elseif(z .le. zg) then
            dzdx2 = 0.
         else
            dzdx2 = zslope*((z-zg)/(H-zg))**expzg
         endif

      else
c ---    Descent beyond near wake (far wake)
c ---    horizontal decay beyond L+LR using expx
c ---    vertical decay above z=H using expz2
c ---    vertical decay below z=H using expzg
         zslopeLR  = -2.*(HR-H)/(L-rby2+LR)
         zslope = zslopeLR/((x-(L+LR-R))*onebyr)**expx
         if(z .gt. H) then
            dzdx2 = zslope/((z-H+R)*onebyr)**expz2
         elseif(z .le. zg) then
            dzdx2 = 0.
         else
            dzdx2 = zslope*((z-zg)/(H-zg))**expzg
         endif

      endif

c --- Calculate 3-D slopes,: dzdx : from 2-d centerplane slope,: dzdx2
      if(ypos .gt. (wby2+R/3.))then
         dzdx=0.
      elseif(ypos .le. wby2)then
         dzdx=dzdx2
      else
         yscale=1.+(3.*onebyr)*(wby2-ypos)
         dzdx=dzdx2*yscale
      endif

900   continue
      return
      end
c----------------------------------------------------------------------
      subroutine intertab(val,nt,tab,i,j,fac)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030402             INTERTAB
c ---            D. Strimaitis, EarthTech
c
c --- PURPOSE:  Finds pointers in an array to bracket a value, and
c               returns the interpolation factor.
c               Tabulation is assumed to be monotonic.
c               Use:  val = tab(i) + fac * (tab(j) - tab(i))
c
c --- INPUTS:
c           VAL - real     - Value to interpolate in table
c            NT - integer  - Number of points in table
c       TAB(nt) - real     - Tabulated values
c
c --- OUTPUT:
c             I - integer  - Index 1 bracketing value
c             J - integer  - Index 2 bracketing value
c           FAC - real     - Interpolation factor
c                            fac=0.0 at tab(i1)
c                            fac=1.0 at tab(i2)
c
c --- INTERTAB called by:  
c --- INTERTAB calls:      none
c----------------------------------------------------------------------
      real tab(nt)
      data zero/0.0/

c --- Check for increasing values in table, and treat special cases
      if(tab(nt).GT.tab(1)) then
         increase=1
         if(val.LE.tab(1)) then
            i=1
            j=1
            fac=zero
            return
         elseif(val.GE.tab(nt)) then
            i=nt
            j=nt
            fac=zero
            return
         endif
      elseif(tab(1).GT.tab(nt)) then
         increase=-1
         if(val.GE.tab(1)) then
            i=1
            j=1
            fac=zero
            return
         elseif(val.LE.tab(nt)) then
            i=nt
            j=nt
            fac=zero
            return
         endif
      elseif(tab(1).EQ.tab(nt)) then
c ---    Single value in table (should not happen)
         i=1
         j=1
         fac=zero
         return
      endif

c --- Set starting point by assuming a linear trend
      iguess=1+(nt-1)*(val-tab(1))/(tab(nt)-tab(1))

c --- Set do loop range
      i1=iguess
      if(val.GE.tab(iguess)) then
         if(increase.EQ.1) then
            istep=1
            i2=nt-istep
         else
            istep=-1
            i2=1-istep
         endif
      elseif(val.LE.tab(iguess)) then
         if(increase.EQ.1) then
            istep=-1
            i2=1-istep
         else
            istep=1
            i2=nt-istep
         endif
      endif

c --- Set factor for 'GT' tests
      ifac=increase*istep

c --- Step through loop until val is in the range i to i+istep
      do i=i1,i2,istep
         j=i+istep
         if(ifac*tab(j).GT.ifac*val) then
c ---       Compute interpolation factor
            fac=(val-tab(i))/(tab(j)-tab(i))
            return
         endif
      enddo

c --- Problem if this point is reached
      write(*,*)
      write(*,*) 'INTERTAB:  val,nt   = ',val,nt
      write(*,*) '   tab(1),tab(nt)   = ',tab(1),tab(nt)
      write(*,*) ' increase, iguess   = ',increase,iguess
      write(*,*) '      i1,i2,istep   = ',i1,i2,istep
      write(*,*)
      stop 'Halted in INTERTAB -- interpolator failed!'

      end
c----------------------------------------------------------------------
      subroutine wake_tab(istype,is,it,idw,x,sy,sz,z,rise,xlast,idone)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520             WAKE_TAB
c ---            D. Strimaitis
c
c --- PURPOSE:  Interpolates sigmas for the distance X from a source
c               and does same for the height (gradual rise), using
c               arrays of tabulated values.  Distance is measured
c               in the x-y plane along the puff trajectory.
c
c --- UPDATE
c --- V6.1-V6.261   080520  (DGS): Replace individual PT1,PT2 rise
c                                  tables with /SRCTAB/ arrays from
c                                  Direct Access file
c --- V5.7-V6.1     050915  (DGS): Add emission timestep to inputs to
c                                  avoid including /CURRENT/
c                           (DGS): Add emission timestep arg to PT2
c                                  arrays
c
c --- INPUTS:
c        ISTYPE - integer  - Source type         (not needed 080520)
c            IS - integer  - Source index        (not needed 080520)
c            IT - integer  - Emission step index (not needed 080520)
c           IDW - integer  - PRIME Downwash flag
c                            3 = Primary source
c                            4 = Cavity source
c             X - real     - Distance (m) from source to point for
c                            obtaining sigmas
c     Parameters:
c           MXRISE, IO6
c
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c --- OUTPUT:
c            SY - real     - Sigma-y (m) without BID
c            SZ - real     - Sigma-z (m) without BID
c             Z - real     - Height (m) above ground
c          RISE - real     - Plume rise (m) without streamline
c                            deflection near buildings
c         XLAST - real     - Distance (m) from source to the last
c                            entry in the wake array
c         IDONE - integer  - Completion flag
c                            0:  No interpolation
c                            1:  Interpolation completed
c
c --- Note:  If idone=0, sigmas at the end of the 
c
c --- WAKE_TAB called by:  SETPUF, PUFRECS
c --- WAKE_TAB calls:      INTERTAB
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'srctab.puf'

c --- Initialize NULL return condition
      idone=0
      z=0.0
      rise=0.0
      sz=0.0
      sy=0.0
      xlast=0.0

      if(idw.EQ.3) then
c ---    Primary source (PRIME downwash)
         xlast=xwk(nwk)
         sz=szwk(nwk)
         sy=sywk(nwk)
         if(x.LE.xwk(nwk)) then
c ---       Extract height and rise without streamline modifications
            call INTERTAB(x,ntr,xtr,i1,i2,fac)
            z=ztr(i1)+fac*(ztr(i2)-ztr(i1))
            rise=htr(i1)+fac*(htr(i2)-htr(i1))
c ---       Extract sigmas
            call INTERTAB(x,nwk,xwk,i1,i2,fac)
            sz=szwk(i1)+fac*(szwk(i2)-szwk(i1))
            sy=sywk(i1)+fac*(sywk(i2)-sywk(i1))
            idone=1
         endif
      elseif(idw.EQ.4) then
c ---    Cavity source (PRIME downwash)
         xlast=xcv(ncv)
         sz=szcv(ncv)
         sy=sycv(ncv)
         if(x.LE.xcv(ncv)) then
c ---       Cavity source is on the ground
            z=0.0
            rise=0.0
c ---       Extract sigmas
            call INTERTAB(x,ncv,xcv,i1,i2,fac)
            sz=szcv(i1)+fac*(szcv(i2)-szcv(i1))
            sy=sycv(i1)+fac*(sycv(i2)-sycv(i1))
            idone=1
         endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine rdhdbc2(io)
c-----------------------------------------------------------------------
c
c --- CALPUFF   Version: 6.262          Level: 040503           RDHDBC2
c ---           D. Strimaitis, Earth Tech, Inc.
c
c  PURPOSE:     Reads header information from concentration file
c               used as a boundary condition file and passes information
c               to main program through common /headbc2/.  Process
c               header information into /BCS/ variables.
c
c --- UPDATE
c --- V5.72(030528) to V5.721(040503)  (DGS)
c        File unit passed to subroutine YR4 for listfile output was
c        not defined so that error reports attempted to write to 
c        unit 0.  Changed io1 to io6 in YR4 call argument.
c
c  ARGUMENTS:
c     PASSED:   io      Unit number for accessing input file         [i]
c
c
c --- INPUTS:
c     Common block /BCS/:
c           HTMINBC
c     Common block /GEN/:
c           NSPEC,NSE,ISPLST(4,mxspec),CSPEC(mxspec),XMOL(mxspec)
c     Common block /GRID/:
c           DGRID, DGRIDI, IBCOMP, JBCOMP, IECOMP, JECOMP
c     Parameters:
c           MXNX, MXSG, MXVAR, MXSPEC, IO15, IO6,
c           MXP2, MXBC
c
c --- OUTPUT:
c
c     Common block /BCS/:
c           XLENBC, YLENBC, IBCU, FUNITSBC(4), CUNITSBC(4),
c           NBC,XBCGRD(mxbc),YBCGRD(mxbc),ITYPEBC(mxbc),
c           IBC(mxbc),NEWBC(mxbc),
c           NTYPEBC1,HTBC(mxbc),CONBC(mxspec,mxbc),
c           ivbc(mxspec,mxbc),iq12bc(mxspec,mxbc),CNAMTYP(mxbc),
c           FNAMEBC, NTYPEBC2, NSPECBC, IBYDBC, IBHBC,
c           IEYDBC, IEHBC, VRSBC, LBLBC, CSPECBC(mxspec),
c           XMWTBC(mxspec), IBEGBC, IENDBC
c     Common block /HEADBC2/:
c           all
c
c
c  CALLING ROUTINES:    SETUP
c
c  EXTERNAL ROUTINES:   INCR, YR4, BC2DOC, QCHECK
c-----------------------------------------------------------------------
      INCLUDE 'params.puf'

      INCLUDE 'headbc2.puf'
c -- Note: all declaration statements for data read in by RDHDBC2
c          are contained in this common

      include 'bcs.puf'
      include 'chiflx.puf'
      include 'flags.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'qa.puf'

      real dxrecbc(mxbc),dyrecbc(mxbc)
      character*1 nsew(4)
      character*48 msg(8),msg0
      logical lfatal, lemit

      data nsew/'N','S','E','W'/

      data msg0  /'  **********************************************'/
      data msg(1)/'  *      FATAL Problem Found in RDHDBC2!       *'/
      data msg(2)/'  * ------------------------------------------ *'/
      data msg(3)/'  *  Size of Array(s) in BCON.DAT too Large    *'/
      data msg(4)/'  *  Re-size Array Parameter(s) in PARAMS.PUF  *'/
      data msg(5)/'  *         and Recompile CALPUFF              *'/
      data msg(6)/'  * ------------------------------------------ *'/
      data msg(7)/'  * Parameter       PARAMS.PUF       BCON.DAT  *'/
      data msg(8)/'  * ---------       ----------       --------  *'/

      data lfatal/.FALSE./, lemit/.false./

c --- Process first section of CALPUFF output file (including comment
c --- records), and determine dataset version
      call BC2DOC(io,idtype)
c
c  Read control variables
      if(idtype.EQ.0) then
         i2drhBC=0
         read(io) amodelBC,averBC,alevBC,msyrBC,mjsdayBC,mshrBC,
     *         mnhrsBC,mavgBC,ielmetBC,jelmetBC,delxBC,delyBC,nzBC,
     *         xorigkmBC,yorigkmBC,nsdumBC,
     *         iastarBC,iastopBC,jastarBC,jastopBC,
     *         isastrBC,jsastrBC,isastpBC,jsastpBC,
     *         meshdnBC,nptsBC,nareasBC,nlinesBC,nvolsBC,
     *         ndrecBC,nctrecBC,LSGRIDBC,nszoutBC,lcomprsBC
      else
c ---    Dataset version 2.0 format
         read(io) amodelBC,averBC,alevBC,msyrBC,mjsdayBC,mshrBC,
     *         mnhrsBC,mavgBC,ielmetBC,jelmetBC,delxBC,delyBC,nzBC,
     *         xorigkmBC,yorigkmBC,nsdumBC,
     *         iastarBC,iastopBC,jastarBC,jastopBC,
     *         isastrBC,jsastrBC,isastpBC,jsastpBC,
     *         meshdnBC,nptsBC,nareasBC,nlinesBC,nvolsBC,
     *         ndrecBC,nctrecBC,LSGRIDBC,nszoutBC,lcomprsBC,i2drhBC,
     *         iutmznBC,feastBC,fnorthBC,rnlat0BC,relon0BC,
     *         xlat1BC,xlat2BC,pmapBC,utmhemBC,datumBC,datenBC,
     *         clat0BC,clon0BC,clat1BC,clat2BC
      endif

c --- Set logicals for discrete and CTSG receptors
      ldiscbc=.FALSE.
      if(ndrecbc.GT.0) ldiscbc=.TRUE.
      lctsgbc=.FALSE.
      if(nctrecbc.GT.0) lctsgbc=.TRUE.

c --- Set flag indicating CALPUFF data version is 'MOD5' or older
      ipver=1
      call YR4(io6,msyrBC,ierry)
      if(ierry.NE.0) stop 'Halted in RDHDBC2'
c --- Move starting time back 1 hour to identify the start of the
c --- first hour
      call INCR(io6,msyrBC,mjsdayBC,mshrBC,-1)
c --- Set period step to 1 hour
      nsecdtBC=3600
      mssecBC=0
c --- Rename averaging period variables
      mnrunBC=mnhrsBC
      mavgpdBC=mavgBC
c
c  Use nsdumBC to satisfy compiler checks
      if(nsdumBC .EQ. 1) nsdumBC=1
c
c  Check size of array dimensions (compute gridded rec. array dims.)
c  with limits contained in PARAMS.PUF file
      ngxBC=(isastpBC-isastrBC)*meshdnBC+1
      ngyBC=(jsastpBC-jsastrBC)*meshdnBC+1
      ngrecBC=ngxBC*ngyBC
      if(ngxBC .GT. mxnxg) lfatal=.TRUE.
      if(ngyBC .GT. mxnyg) lfatal=.TRUE.
      if(ndrecBC .GT. mxrec) lfatal=.TRUE.
      if(nctrecBC .GT. mxrect) lfatal=.TRUE.
      if(nszoutBC .GT. mxspec) lfatal=.TRUE.

      if(LFATAL) then
c ---    Report problem information and quit
c ---    List File:
         write(io6,*)
         write(io6,100) msg0
         do i=1,8
            write(io6,100) msg(i)
         enddo
         write(io6,101)'  *    MXNXG',mxnxg,ngxBC
         write(io6,101)'  *    MXNYG',mxnyg,ngyBC
         write(io6,101)'  *    MXREC',mxrec,ndrecBC
         write(io6,101)'  *   MXRECT',mxrect,nctrecBC
         write(io6,101)'  *   MXSPEC',mxspec,nszoutBC
         write(io6,100) msg0
c ---    Screen:
         write(*,*)
         write(*,100) msg0
         do i=1,8
            write(*,100) msg(i)
         enddo
         write(*,101)'  *    MXNXG',mxnxg,ngxBC
         write(*,101)'  *    MXNYG',mxnyg,ngyBC
         write(*,101)'  *    MXREC',mxrec,ndrecBC
         write(*,101)'  *   MXRECT',mxrect,nctrecBC
         write(*,101)'  *   MXSPEC',mxspec,nszoutBC
         write(*,100) msg0

         stop
      endif
c
c  Read title of run
      read(io) atitleBC
c
c  Read specie/level list
      read(io) (asplstBC(i),i=1,nszoutBC)
c
c  Read coordinates of non-gridded receptors if any are used
      if(ndrecBC .NE. 0) read(io) (xrecBC(i),i=1,ndrecBC),
     *                          (yrecBC(i),i=1,ndrecBC),
     *                          (zrecBC(i),i=1,ndrecBC)
c
c  Read coordinates of complex terrain receptors if any are used
      if(nctrecBC .NE. 0) read(io) (xctrBC(i),i=1,nctrecBC),
     *                           (yctrBC(i),i=1,nctrecBC),
     *                           (zctrBC(i),i=1,nctrecBC),
     *                           (ihillBC(i),i=1,nctrecBC)
c
c  Generate coordinates of gridded receptors if any are used
      if(LSGRIDBC .AND. ngrecBC .NE. 0) then
c  Compute coord. for lower-left point in sampling grid, and spacing
         gx0=xorigkmBC+delxBC*(isastrBC-0.5)
         gy0=yorigkmBC+delyBC*(jsastrBC-0.5)
         delgx=delxBC/meshdnBC
         delgy=delyBC/meshdnBC
c  Fill out arrays
         do i=1,ngxBC
            do j=1,ngyBC
               xgrdBC(i,j)=gx0+(i-1)*delgx
               ygrdBC(i,j)=gy0+(j-1)*delgy
            enddo
         enddo
      endif

100   format(1x,a48)
101   format(1x,a12,2(8x,i8),'   *')


c --- Configure information for /BCS/ variables
c ---------------------------------------------

c --- Set air-mass/species with variation factors to zero
      nsbc=0

c --- Set fractional offset from edge of domain for BC source location
c --- to 0.1% of grid cell
      fuzz=.001

c --- Set coordinates for corners if comp grid (met grid units)
      xbcw=ibcomp-1
      ybcs=jbcomp-1
      xbce=iecomp
      ybcn=jecomp

c --- Set boundary segments equal to the computational grid cell sides
      nbcx=iecomp-ibcomp+1
      nbcy=jecomp-jbcomp+1
      xlenbc=dgrid
      ylenbc=dgrid
      nbc=2*(nbcx+nbcy)

c --- Set concentration units (g/m3)
      ibcu=1

c --- Air-mass species; use approx MWT of air (29)
      nspecbc=nszoutBC
      do i=1,nspecbc
         cspecbc(i)=asplstBC(i)
         xmwtbc(i)=29.0
      enddo

c --- Number of air-mass types (each segment is an air-mass type)
      ntypebc1=0
      ntypebc2=nbc

c --- Set layer height of each air-mass to HTMINBC;
c --- assign airmass type name
      do i=1,nbc
         htbc(i)=htminbc
         write(cnamtyp(i),'(i6)') i
      enddo
      
c --- QA check
      call QCHECK(mxspec,io6,nspec,nse,isplst,cspec,xmol,lemit,
     1 fnambc,nspecbc,cspecbc,xmwtbc,ierr,ixrembc)
      if(ierr.EQ.1) lfatal=.TRUE.

c --- Map air-mass segments along comp grid boundary
      j=0
c --- Set NORTH boundary (ibc=1) from west to east
      ygrd=ybcn-fuzz
      do i=1,nbcx
         j=j+1
         ibc(j)=1
         itypebc(j)=j
         xbcgrd(j)=xbcw+(FLOAT(i)-.5)
         ybcgrd(j)=ygrd
      enddo
c --- Set SOUTH boundary (ibc=2) from west to east
      ygrd=ybcs+fuzz
      do i=1,nbcx
         j=j+1
         ibc(j)=2
         itypebc(j)=j
         xbcgrd(j)=xbcw+(FLOAT(i)-.5)
         ybcgrd(j)=ygrd
      enddo
c --- Set EAST boundary (ibc=3) from north to south
      xgrd=xbce-fuzz
      do i=1,nbcy
         j=j+1
         ibc(j)=3
         itypebc(j)=j
         xbcgrd(j)=xgrd
         ybcgrd(j)=ybcn-(FLOAT(i)-.5)
      enddo
c --- Set WEST boundary (ibc=4) from north to south
      xgrd=xbcw+fuzz
      do i=1,nbcy
         j=j+1
         ibc(j)=4
         itypebc(j)=j
         xbcgrd(j)=xgrd
         ybcgrd(j)=ybcn-(FLOAT(i)-.5)
      enddo
      if(j.NE.nbc) then
         write(*,*)'RDHDBC2:  boundary segment assignment is BAD!'
         write(*,*)'Number Set      = ',j
         write(*,*)'Number Expected = ',nbc
         lfatal=.true.
      endif

c --- Set date-time information
c --- End-time of first period in file
      jbyr=msyrBC
      jbdy=mjsdayBC
      ibhbc=mshrBC
      call INCR(io6,jbyr,jbdy,ibhbc,1)
      ibydbc=jbyr*1000+jbdy
c --- End-time of last period in file
      jeyr=jbyr
      jedy=jbdy
      iehbc=ibhbc
      call INCR(io6,jeyr,jedy,iehbc,mnhrsbc)
      ieydbc=jeyr*1000+jedy

c --- Initialize "current" beginning/ending date-time to zero
      ibegbc=0
      iendbc=0

c --- Assign nearest receptor to each air-mass segment
c ----------------------------------------------------
c --- Initialize arrays
      do k=1,mxbc
         irecbc(k)=0
         jrecbc(k)=0
         d2recbc(k)=100.
      enddo
c --- Loop over segments
      do k=1,nbc

c ---    Loop over discrete receptors
         do i=1,ndrecbc
c ---       Compute receptor location in grid units
            xg=(xrecbc(i)*1000.-xorig)*dgridi
            yg=(yrecbc(i)*1000.-yorig)*dgridi
            dxg=ABS(xg-xbcgrd(k))
            dyg=ABS(yg-ybcgrd(k))
c ---       Screen for receptor 'in' the correct boundary
            if((ibc(k).LE.2 .AND. dyg.LT.1.0) .OR.
     &         (ibc(k).GE.3 .AND. dxg.LT.1.0)) then
c ---          Check distance for minimum
               dsq=dxg**2+dyg**2
               if(dsq.LT.d2recbc(k)) then
c ---             Update receptor for this segment
                  irecbc(k)=i
                  d2recbc(k)=dsq
                  dxrecbc(k)=dxg
                  dyrecbc(k)=dyg
               endif
            endif
         enddo

c ---    Loop over gridded receptors
         if(LSGRIDBC) then
           do i=1,ngxBC
           do j=1,ngyBC
c ---        Compute receptor location in grid units
             xg=(xgrdbc(i,j)*1000.-xorig)*dgridi
             yg=(ygrdbc(i,j)*1000.-yorig)*dgridi
             dxg=ABS(xg-xbcgrd(k))
             dyg=ABS(yg-ybcgrd(k))
c ---        Screen for receptor 'in' the correct boundary
             if((ibc(k).LE.2 .AND. dyg.LT.1.0) .OR.
     &          (ibc(k).GE.3 .AND. dxg.LT.1.0)) then
c ---           Check distance for minimum
                dsq=dxg**2+dyg**2
                if(dsq.LT.d2recbc(k)) then
c ---              Update receptor for this segment
                   irecbc(k)=i
                   jrecbc(k)=j
                   d2recbc(k)=dsq
                   dxrecbc(k)=dxg
                   dyrecbc(k)=dyg
                endif
             endif
           enddo
           enddo
         endif

      enddo


c --- QA checks
c -------------

c --- Check units selection (only 4 types)
      if(ibcu.LT.1 .OR. ibcu.GT.4) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC2 -- units choice must be ',
     &   '1-4  -- ','IBCU = ',ibcu
         lfatal=.TRUE.
      endif

c --- Check number of air-mass types
      ntypebc=ntypebc1+ntypebc2
      if(ntypebc.gt.mxbc)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC2 -- too many air-mass ',
     &   'types -- ','NTYPEBC = ',ntypebc,' MXBC = ',mxbc
         lfatal=.TRUE.
      endif

c --- Check number of species
      if(nspecbc.gt.nspec)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC2 -- number of species ',
     &   'exceeds number modeled -- '
         write(io6,*)'NSPECBC = ',nspecbc,' NSPEC = ',nspec
         lfatal=.TRUE.
      endif

c --- Check number of species/air-mass types
      ntest=nspecbc*ntypebc
      if(nsbc.gt.ntest)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC -- number of species/ ',
     &   'air-mass combinations exceeds number possible -- '
         write(io6,*)'NSBC = ',nsbc,' NSPECBC*NTYPEBC = ',ntest
         lfatal=.TRUE.
      endif

c --- All segments must have a valid receptor index
      nzero=0
      do k=1,nbc
         if(irecbc(k).EQ.0) nzero=nzero+1
      enddo
      if(nzero.GT.0) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC2 -- a segment mid-pt is',
     &   ' not assigned a valid receptor index'
         lfatal=.TRUE.
      endif

c --- Check max distance from segment midpoint to nearest receptor
      d2max=0.0
      do k=1,nbc
         if(d2max.LT.d2recbc(k)) d2max=d2recbc(k)
      enddo
      if(d2max.GT.25.) then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR in subr. RDHDBC2 -- segment mid-pt is ',
     &   'more than 5 grid cells from nearest receptor'
         lfatal=.TRUE.
      endif

c --  Report configuration to the list file
c ------------------------------------------
      write(io6,*)
      write(io6,*)
      write(io6,*)'   ****   BOUNDARY CONDITION DATA  ****'
      write(io6,*)
      write(io6,*)'dataset type                     = ','CONC.DAT'
      write(io6,*)'segments on N&S borders          = ',nbcx
      write(io6,*)'         segment length (m)      = ',xlenbc
      write(io6,*)'segments on E&W borders          = ',nbcy
      write(io6,*)'         segment length (m)      = ',ylenbc
      write(io6,*)
      write(io6,*)'concentration units              = ',cunitsbc(ibcu)
      write(io6,*)'species and units conversion factor to g/m^3:'
      do j=1,nspecbc
         factor=funitsbc(ibcu)
         if(ibcu.GT.2) factor=factor*xmwtbc(j)
         write(io6,'(20x,a12,1pe11.4)') cspecbc(j),factor
      enddo
      write(io6,*)
      write(io6,*)'Species cross-reference vector:'
      do j=1,nspecbc
         write(io6,'(20x,a12,i5)') cspecbc(j),ixrembc(j)
      enddo
      write(io6,*)
      write(io6,*)'time-variable air-mass types     = ',ntypebc2
      if(ntypebc2.GT.0) then
         write(io6,*)'    beginning date (YYYYJJJ)     = ',ibydbc
         write(io6,*)'    beginning hour (00-23 LST)   = ',ibhbc
         write(io6,*)'    ending date (YYYYJJJ)        = ',ieydbc
         write(io6,*)'    ending hour (00-23 LST)      = ',iehbc
      endif
      write(io6,*)
      write(io6,*)'Characteristics of each Air-mass segment:'
      write(io6,*)'   Bndy Ht   Type  xgrd    ygrd irec jrec dxg  dyg'
      write(io6,*)
      do i=1,nbc
         write(io6,'(i4,1x,a1,f7.1,i4,2f8.2,2i4,2f5.1)') i,nsew(ibc(i)),
     &         htbc(i),itypebc(i),xbcgrd(i),ybcgrd(i),
     &         irecbc(i),jrecbc(i),dxrecbc(i),dyrecbc(i)
      enddo
      write(io6,*)
      write(io6,*)


c --- Terminate run if QA detected a fatal flaw
999   if(LFATAL) then
         write(*,*)
         stop 'Halted in RDHDBC2 -- see list file.'
      endif


      return
      end
c----------------------------------------------------------------------
      subroutine bc2doc(io,ifilver)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030528                 BC2DOC
c                D. Strimaitis, Earth Tech, Inc.
c
c --- PURPOSE:  Read header comment records of the CALPUFF output
c               data file used for boundary conditions, and set file
c               type.
c
c --- INPUTS:
c            io - integer    - Unit number for CALPUFF file
c     Common block /QA/ variables:
c           NCOMMOUT
c
c     Parameters:
c           IO6, IOX
c
c --- OUTPUT:
c       ifilver - integer    - Dataset version flag
c                              0: Before 2.0
c                              1: 2.0 or later
c     Common block /QA/ variables:
c           NCOMMOUT
c
c --- BC2DOC called by:  RDHDBC2
c --- BC2DOC calls:      none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
c --- Include common blocks
      include 'filnam.puf'
      include 'qa.puf'
c
c --- Local Variables
      character*16 dataset,dataver
      character*33 blank33,break33
      character*64 datamod
      character*132 comment1,blank,break

      data blank33/'                                 '/
      data break33/'.................................'/

c --- Set blank (132 characters)
      blank(1:33)=blank33
      blank(34:66)=blank33
      blank(67:99)=blank33
      blank(100:132)=blank33

c --- Set break (132 characters)
      break(1:33)=break33
      break(34:66)=break33
      break(67:99)=break33
      break(100:132)=break33

c --- Read and test first record to check header format
c --- Record #1 - File Declaration -- 24 words
      read(io) dataset,dataver,datamod
      ifilver=0
      if(dataset.EQ.'CONC.DAT') then
         ifilver=1
      endif

      if(ifilver.EQ.0) then
c ---    Old file format with no comment records
         REWIND(io)

      elseif(ifilver.EQ.1) then
c ---    To scratch file
         write(iox,'(a132)') blank
         write(iox,'(a132)') break
         write(iox,'(a132)') blank
         write(iox,'(2a16,a64)') dataset,dataver,datamod
         ncommout=ncommout+4
c ---    Number of comment records
         read(io) ncom
c ---    Keep only title information in scratch file
         do i=1,ncom
            comment1=blank
            read(io) comment1
            if(i.LE.4) then
               write(iox,'(a132)') comment1
               ncommout=ncommout+1
            endif
         enddo

      endif

      return
      end
c----------------------------------------------------------------------
      subroutine RDEMBC2(ldb,ndathr)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 030528                RDEMBC2
c                D. Strimaitis   Earth Tech
c
c --- PURPOSE:  Read the time-varying records of the BCON boundary
c               conditions file (unit IO15) and update data in the
c               air-mass arrays for these air-mass types
c               MBCON=2:  process a CONC.DAT file
c
c --- INPUTS:
c              LDB - logical    - Flag controlling printing of debug
c                                 data
c           NDATHR - integer    - Current modeling date/time
c                                 (YYYYJJJHH)
c
c     Common block /BCS/:
c           HTBC(mxbc),CONBC(mxspec,mxbc),IBCU,FUNITSBC(4),
c           NTYPEBC2, NSPECBC, CSPECBC(mxspec), XMWTBC(mxspec)
c
c     Parameters:
c           MXBC, MXSPEC, IO15, IO6
c
c --- OUTPUT:
c
c     Common block /BCS/:
c           CONBC(mxspec,mxbc),
c           IBEGBC, IENDBC
c
c --- RDEMBC2 called by: INITPUF
c --- RDEMBC2 calls:     GETRCRD, YR4
c----------------------------------------------------------------------
c
      include 'params.puf'
      INCLUDE 'headbc2.puf'
      include 'bcs.puf'

c --- Local variables for reading air-mass data
      real tcd(mxrec),tcg(mxnxg,mxnyg),tct(mxrect)

      logical ldb

c --- Set the array size parameters for GETRCRD call (not zero)
      if(lsgridbc) then
         nxdum=ngxBC
         nydum=ngyBC
      else
         nxdum=mxnxg
         nydum=mxnyg
      endif
      if(ldiscbc) then
         nddum=ndrecbc
      else
         nddum=mxrec
      endif
      if(lctsgbc) then
         ntdum=nctrecbc
      else
         ntdum=mxrect
      endif
c --- Read data for the next hour in the file
101   call GETRCRD(io15,tcg,tcd,tct,nxdum,nydum,nddum,ntdum,ierr)

      if(ierr.GT.1) then
         write(*,*)
         stop 'Halted in RDEMBC2'
      elseif(ierr.EQ.1) then
         write(*,*)
         write(*,*)'Reached end of BCON.DAT while searching for'
         write(*,*)'time period = ',ndathr
         write(*,*)'Last period = ',ibegbc
         stop 'Halted in RDEMBC2'
      endif

c --- Test for valid time period
      if(ndathr.GT.iendbc) then
c ---    Try next set of records
         goto 101
      elseif(ndathr.LT.ibegbc)then
         write(io6,*)
         write(io6,*)'*********  FATAL  ***********'
         write(io6,*)'ERROR -- BCON date/time exceeds current'
         write(io6,*)'      -- current date/time :',ndathr
         write(io6,*)'      -- BCON date/time    :',ibegbc
         write(*,*)
         stop 'ERROR -- BCON date/time exceeds current --'
      endif

c --- Report valid time period
      if(ldb)then
         write(io6,*)
         write(io6,*)'Time-varying BCON data'
         write(io6,*)'IBEG = ',ibegbc,' IEND = ',iendbc
         write(io6,*)'Updated BCON data'
         write(io6,*)'Air-mass  Layer(m) Concentrations (g/m^3)'
         write(io6,*)'--------  -------- ----------------------'
      endif

c --- Loop over air-mass types and scale data
      do ityp=1,nbc
         do is=1,nspecbc
            conbc(is,ityp)=conbc(is,ityp)*funitsbc(ibcu)
            if(ibcu.GT.2) conbc(is,ityp)=conbc(is,ityp)*xmwtbc(is)
c ---       Report new data values
            if(ldb)then
               if(is.EQ.1) then
                 write(io6,'(a12,f6.0,1pe11.4,4x,a12)')
     &           cnamtyp(ityp),htbc(ityp),conbc(is,ityp),cspecbc(is)
               else
                 write(io6,'(18x,1pe11.4,4x,a12)')
     &           conbc(is,ityp),cspecbc(is)
               endif
            endif
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine getrcrd(io,tcg,tcd,tct,ix,iy,idrec,itrec,ierr)
c-----------------------------------------------------------------------
c
c --- CALPUFF   Version: 6.262          Level: 040503           GETRCRD
c ---           D. Strimaitis, Earth Tech, Inc.
c
c  PURPOSE:     Reads hourly data records from "CONC.DAT" file
c
c
c --- UPDATE
c --- V5.72(030528) to V5.721(040503)  (DGS)
c        File unit passed to subroutine YR4 for listfile output was
c        not defined so that error reports attempted to write to 
c        unit 0.  Changed io1 to io6 in YR4 call argument.
c
c  ARGUMENTS:
c     PASSED:   io        Unit number for accessing input file       [i]
c               tcg(i,j)  Temporary gridded receptor array          [ra]
c               tcd(i)    Temporary discrete receptor array         [ra]
c               tct(i)    Temporary complex terrain receptor array  [ra]
c               ix,iy     Dimensions for tcg array                   [i]
c               idrec     Dimension for tcd array                    [i]
c               itrec     Dimension for tct array                    [i]
c               ierr      Error flag:                                [i]
c                          0=No error
c                          1=EOF encountered
c                          2=Species name does not match
c
c  
c --- OUTPUT:
c     Common block /BCS/:
c           CONBC(mxspec,mxbc),
c           IBEGBC, IENDBC
c
c  CALLING ROUTINES:    RDEMBC2
c
c  EXTERNAL ROUTINES:   YR4
c-----------------------------------------------------------------------
c
      INCLUDE 'params.puf'
      INCLUDE 'headbc2.puf'
      include 'bcs.puf'
c
c --- Declare temporary variables using actual array dimensions
      character*15 tsplv
      character*12 csptest
      real tcg(ix,iy),tcd(idrec),tct(itrec)
      real xwork1(mxnxg,mxnyg),xwork2(mxrec),xwork3(mxrect)

      ierr=0

c --- Read time record
      read(io,end=999) myre,mjdaye,mhre
c --- Enforce YYYY format for year
      call YR4(io6,myre,ierr)
      if(ierr.NE.0) stop 'Halted in GETRCRD'
c --- Set date-time
      ibegbc=myre*100000+mjdaye*100+mhre
      iendbc=ibegbc

c --- Read data records
c --- Loop over chemical species/levels
      do isl=1,nszoutBC
c
c ---    Read concentration data
         if(LSGRIDBC) then
            if(lcomprsBC)then
               nwords=ix*iy
               read(io)ii
               call uncomprs(xwork1,ii,io,nwords,tsplv,tcg)
            else
               read(io) tsplv,tcg
            endif
            csptest=tsplv(1:12)
            if(csptest.NE.cspecbc(isl)) then
               ierr=2
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR -- BCON species does not match'
               write(io6,*)'      -- Expected species  :',cspecbc(isl)
               write(io6,*)'      -- BCON species      :',csptest
               write(*,*)
               write(*,*)'ERROR -- BCON species does not match --'
               return
            endif
         endif
c
         if(ndrecBC .GT. 0) then
            if(lcomprsBC)then
               read(io)ii
               call uncomprs(xwork2,ii,io,idrec,tsplv,tcd)
            else
               read(io) tsplv,tcd
            endif
            csptest=tsplv(1:12)
            if(csptest.NE.cspecbc(isl)) then
               ierr=2
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR -- BCON species does not match'
               write(io6,*)'      -- Expected species  :',cspecbc(isl)
               write(io6,*)'      -- BCON species      :',csptest
               write(*,*)
               write(*,*)'ERROR -- BCON species does not match --'
               return
            endif
         endif
c
         if(nctrecBC .GT. 0) then
            if(lcomprsBC)then
               read(io)ii
               call uncomprs(xwork3,ii,io,itrec,tsplv,tct)
            else
               read(io) tsplv,tct
            endif
            csptest=tsplv(1:12)
            if(csptest.NE.cspecbc(isl)) then
               ierr=2
               write(io6,*)
               write(io6,*)'*********  FATAL  ***********'
               write(io6,*)'ERROR -- BCON species does not match'
               write(io6,*)'      -- Expected species  :',cspecbc(isl)
               write(io6,*)'      -- BCON species      :',csptest
               write(*,*)
               write(*,*)'ERROR -- BCON species does not match --'
               return
            endif
         endif

c ---    Update boundary concentrations
         do k=1,nbc
            if(jrecbc(k).EQ.0) then
               conbc(isl,k)=tcd(irecbc(k))
            else
               conbc(isl,k)=tcg(irecbc(k),jrecbc(k))
            endif
         enddo

      enddo
c

      return
c
c  EOF encountered in date-time record
999   ierr=1
      return
c
      end
c----------------------------------------------------------------------
      subroutine uncomprs(xwork,ii,io,nwords,clabel,xdat)
c----------------------------------------------------------------------
c
c --- CALPUFF   Version: 6.262          Level: 960422          UNCOMPRS
c                J. Scire, EARTH TECH
c
c --- PURPOSE:  Read a compressed data records and uncompress
c               the data
c
c --- INPUTS:
c        XWORK(nwork) - real array - Work array to temporarily store
c                                    compressed array
c                  II - integer    - Number of words in compressed
c                                    data record
c                  IO - integer    - Unit number of input file
c              NWORDS - integer    - Number of values in data array
c                                    after uncompression
c      PARAMETERS: IO6
c
c --- OUTPUTS:
c              CLABEL - char*15    - Character record header
c        XDAT(nwords) - real array - Array of uncompressed data to be
c                                    output
c
c --- UNCOMPRS called by: GETRCRD
c --- UNCOMPRS calls:     none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      real xwork(ii),xdat(nwords)
      character*15 clabel
c
c --- Read the compressed data record
      read(io)clabel,xwork
c
c --- Uncompress the data
      jj=0
      do 100 i=1,ii
      if(xwork(i).gt.0.0)then
         jj=jj+1
         xdat(jj)=xwork(i)
      else
         nzero=-xwork(i)
         do j=1,nzero
            jj=jj+1
            xdat(jj)=0.0
         enddo
      endif
100   continue
c
c --- QA check that expanded array is correct size
      if(jj.ne.nwords)then
         write(io6,*)'ERROR in Subr. UNCOMPRS -- Expanded array ',
     1   'is not the correct size -- JJ = ',jj,' NWORDS = ',nwords
         stop
      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine tchiflx(imode)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 031017                TCHIFLX
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Manage concentration, dry & wet deposition flux
c               fields for totals and source contributions
c
c --- INPUTS:
c                 IMODE - integer    - Update mode
c                    1: Add source contribution to Total CHIFLX arrays
c                    2: Swap Total CHIFLX arrays into standard arrays
c
c     Common block /CHIFLX/ variables
c          CHISAM(mxnxg,mxnyg,mxspec), DFSAM(mxnxg,mxnyg,mxspec),
c          WFSAM(mxnxg,mxnyg,mxspec), CHIREC(mxrec,mxspec),
c          DFREC(mxrec,mxspec), WFREC(mxrec,mxspec),
c          CHICT(mxrect,mxspec)
c          TCHISAM(mxnxg,mxnyg,mxspec), TDFSAM(mxnxg,mxnyg,mxspec),
c          TWFSAM(mxnxg,mxnyg,mxspec), TCHIREC(mxrec,mxspec),
c          TDFREC(mxrec,mxspec), TWFREC(mxrec,mxspec),
c          TCHICT(mxrect,mxspec)
c     Common block /CTSGDAT/ variables
c          NCTREC
c     Common block /GEN/ variables
c          NSPEC
c     Common block /GRID/ variables
c          NXSAM, NYSAM, LSAMP
c     Common block /NONGRD/ variables
c          NREC
c     Parameters: MXNXG, MXNYG, MXSPEC, MXREC, MXRECT,
c                 IO6
c
c --- OUTPUT:  none
c
c --- TCHIFLX called by: COMP
c --- TCHIFLX calls:     none
c----------------------------------------------------------------------
c
c --- Include parameter statements
      include 'params.puf'
c
      include 'chiflx.puf'
      include 'ctsgdat.puf'
      include 'gen.puf'
      include 'grid.puf'
      include 'nongrd.puf'
c

      if(imode.EQ.1) then
c ---    Add source contribution to Total CHIFLX arrays

c ---    Gridded receptor concentrations
         if(lsamp) then
           do k=1,nspec
             do j=1,nysam
               do i=1,nxsam
                 tchisam(i,j,k)=tchisam(i,j,k)+chisam(i,j,k)
                 tdfsam(i,j,k) =tdfsam(i,j,k)+dfsam(i,j,k)
                 twfsam(i,j,k) =twfsam(i,j,k)+wfsam(i,j,k)
               enddo
             enddo
           enddo
         endif
c ---    Discrete receptor concentrations
         if(nrec.GT.0) then
           do k=1,nspec
             do i=1,nrec
               tchirec(i,k)=tchirec(i,k)+chirec(i,k)
               tdfrec(i,k) =tdfrec(i,k)+dfrec(i,k)
               twfrec(i,k) =twfrec(i,k)+wfrec(i,k)
             enddo
           enddo
         endif
c ---    Discrete CTSG receptor concentrations
         if(nctrec.GT.0) then
           do k=1,nspec
             do i=1,nctrec
               tchict(i,k)=tchict(i,k)+chict(i,k)
             enddo
           enddo
         endif


      elseif(imode.EQ.2) then
c ---    Swap from Total CHIFLX arrays into standard CHIFLX arrays

c ---    Gridded receptor concentrations
         if(lsamp) then
           do k=1,nspec
             do j=1,nysam
               do i=1,nxsam
                 chisam(i,j,k)=tchisam(i,j,k)
                 dfsam(i,j,k) =tdfsam(i,j,k)
                 wfsam(i,j,k) =twfsam(i,j,k)
               enddo
             enddo
           enddo
         endif
c ---    Discrete receptor concentrations
         if(nrec.GT.0) then
           do k=1,nspec
             do i=1,nrec
               chirec(i,k)=tchirec(i,k)
               dfrec(i,k) =tdfrec(i,k)
               wfrec(i,k) =twfrec(i,k)
             enddo
           enddo
         endif
c ---    Discrete CTSG receptor concentrations
         if(nctrec.GT.0) then
           do k=1,nspec
             do i=1,nctrec
               chict(i,k)=tchict(i,k)
             enddo
           enddo
         endif

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine warn(astring,value)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 040109                    WARN
c                D. Strimaitis   Earth Tech, Inc.
c
c --- PURPOSE:  Screens data associated with potential problems and
c               reports outcome to list file (diagnostic)
c
c --- INPUTS:
c       ASTRING - char*12 - subroutine/action string
c         VALUE - real    - value to process
c
c --- Parameters: IO6
c
c --- OUTPUT:
c             (List File)
c
c --- WARN called by: SIGTY, FIN
c --- WARN calls:     none
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'

      logical LWARN
      character*12 astring

c --- Initialize via data statements
      data lwarn/.FALSE./
      data sigtysec/0.0/, ntsigty/0/
      data sigtykm/0.0/, nxsigty/0/

      if(astring.EQ.'SIGTY-t     ') then

c ---    Process negative delta-t from SIGTY
         if(value.LT.sigtysec) sigtysec=value
         ntsigty=ntsigty+1
         ntsigty=MIN(ntsigty,1000001)
         lwarn=.TRUE.

      elseif(astring.EQ.'SIGTY-x     ') then

c ---    Process negative delta-x from SIGTY
         if(value.LT.sigtykm) sigtykm=value
         nxsigty=nxsigty+1
         nxsigty=MIN(nxsigty,1000001)
         lwarn=.TRUE.

      elseif(astring.EQ.'FIN         ') then

c ---    Report diagnostic
         if(LWARN) then
            write(io6,*)
            write(io6,*)
            write(io6,*)
            write(io6,*)'Diagnostic for SIGTY:'
            write(io6,*)'         Minimum dt(sec) = ',sigtysec
            if(ntsigty.GT.100000) then
               write(io6,*)'  Number less than -.01s > ',ntsigty
            else
               write(io6,*)'  Number less than -.01s = ',ntsigty
            endif
            write(io6,*)'         Minimum dx(km)  = ',sigtykm
            if(nxsigty.GT.100000) then
               write(io6,*)'  Number less than -.01m > ',nxsigty
            else
               write(io6,*)'  Number less than -.01m = ',nxsigty
            endif
            write(io6,*)
            write(io6,*)
         endif

      else

c ---    Problem here
         write(*,*)
         write(*,*)'ERROR in subroutine WARN!'
         write(*,*)'Unexpected arguments:'
         write(*,*)'    arg1 = ',astring
         write(*,*)'    arg2 = ',value
         write(*,*)
         stop

      endif

      return
      end

c----------------------------------------------------------------------
      subroutine aerswv(io6,ldbhr,ustar,xl,wstar,zi,ziconv,zimech,
     &                  uatzi,z,sigw,sigv)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050225                 AERSWV
c                D. Strimaitis   Earth Tech, Inc.
c
c --- PURPOSE:  Compute the standard deviation of vertical velocity
c               (sigw) and the horizontal crosswind velocity (sigv)
c               based on micrometeorological parameters, using
c               AERMOD formulation.
c
c --- INPUTS:
c
c               IO6 - integer - Unit number for list file
c             LDBHR - logical - Debug output (T,F)
c             USTAR - real    - Friction velocity (m/s)
c             WSTAR - real    - Convective velocity scale (m/s)
c                XL - real    - Monin-Obukhov length (m)
c                ZI - real    - Mixing height (m)
c            ZICONV - real    - Convective Mixing height (m)
c            ZIMECH - real    - Mechanical Mixing height (m)
c             UATZI - real    - Wind speed at ZI (m/s)
c                 Z - real    - Plume height (m)
c
c --- OUTPUTS:
c
c              SIGW - real    - Standard deviation of vertical
c                               velocity (m/s)
c              SIGV - real    - Standard deviation of horizontal
c                               crosswind velocity (m/s)
c
c --- AERSWV called by:  TURBSET
c --- AERSWV calls:      REFSV, REFSW
c
c----------------------------------------------------------------------
c
      logical ldbhr
      data xlmn/1.e-2/
c
      sigv=0.0
      sigw=0.0
c
c --- Enforce minimum M-O length to prevent numerical problems
      xmon=AMIN1(xlmn,ABS(xl))
      if(xl.LT.0.0) xmon=-xmon

c --- Set the residual sigma-w at the top of the boundary layer
      swrmax = 0.02*uatzi

c --- Obtain sigmas using AERMOD subroutine
      call REFSV ( z,ustar,wstar,xmon,ziconv,zimech, sigv )
      call REFSW ( z,ustar,wstar,xmon,zi,ziconv,swrmax, sigw )

c
      if(LDBHR) then
         write(io6,*)'AERSWV:  (MDISP = 2)'
         write(io6,*)'       el,ustar,wstar= ',xl,ustar,wstar
         write(io6,*)'       uatzi,z,zi    = ',uatzi,z,zi
         write(io6,*)'       ziconv,zimech = ',ziconv,zimech
         write(io6,*)'       sigv,sigw     = ',sigv,sigw
         write(io6,*)'       (before minimum values imposed)'
      endif
c
      return
      end


c----------------------------------------------------------------------
      SUBROUTINE REFSV ( HEIGHT,ustar,wstar,xmon,ziconv,zimech,
     &                   VALUE )
c dgs SUBROUTINE REFSV ( HEIGHT, VALUE )
C=======================================================================
C                REFSV Module of the AERMOD Dispersion Model
C
C   Purpose:     To compute the value of sigma-V, the horizontal
C                (lateral) dispersion parameter from the surface
C                friction velocity and convective scaling velocity
C                alone (i.e., no observations of sigma-V)
C
C   Input:       Mixing height (ZI)
C                Friction velocity (USTAR)
C                Convective scaling velocity (WSTAR)
C                Height at which sigma-V is needed (HEIGHT)
C
C   Output:      sigmaV at the required level (VALUE)
C
C   Assumptions: Mixing height, friction and convective scaling
C                velocities are nonmissing
C
C   Programmer:  Jim Paumier                        30 September 1993
C                Pacific Environmental Services
C
C   Revision history:
C                <none>
C
C   Reference(s):
C
C-----------------------------------------------------------------------
C
C---- Variable declarations
C
c dgs USE MAIN1
c dgs IMPLICIT NONE
c dgs CHARACTER MODNAM*12

c dgs SAVE
      REAL      HEIGHT, VALUE, SVC, SVM
C
C---- Data dictionary
C
C---- Data initializations
C
c dgs MODNAM = 'REFSV '
C
C.......................................................................
C
c dgs IF( UNSTAB )THEN
      if(xmon.LT.0.0) then
C        Compute the convective component of sigma-v, SVC
c dgs    CALL REFSVC( HEIGHT, SVC )
         CALL REFSVC( HEIGHT,wstar,ziconv, SVC )

C        Compute the mechanical component of sigma-v, SVM
c dgs    CALL REFSVM( HEIGHT, SVM )
         CALL REFSVM( HEIGHT,ustar,zimech, SVM )

         VALUE = SQRT( SVC*SVC + SVM*SVM )

c dgs ELSEIF( STABLE )THEN
      ELSE
C        Compute the mechanical component of sigma-v, SVM
c dgs    CALL REFSVM( HEIGHT, SVM )
         CALL REFSVM( HEIGHT,ustar,zimech, SVM )

         VALUE = SVM

      ENDIF

C
      RETURN
      END

c----------------------------------------------------------------------
      SUBROUTINE REFSVC ( HEIGHT,wstar,ziconv, VALUE )
c dgs SUBROUTINE REFSVC ( HEIGHT, VALUE )
C=======================================================================
C                REFSVC Module of the AERMOD Dispersion Model
C
C   Purpose:     To compute the value of sigma-V, the horizontal
C                (lateral) dispersion parameter from the surface
C                friction velocity and convective scaling velocity
C                alone (i.e., no observations of sigma-V)
C
C   Input:       Mixing height (ZI)
C                Friction velocity (USTAR)
C                Convective scaling velocity (WSTAR)
C                Height at which sigma-V is needed (HEIGHT)
C
C   Output:      sigmaV at the required level (VALUE)
C
C   Assumptions: Mixing height, friction and convective scaling
C                velocities are nonmissing
C
C   Programmer:  Jim Paumier                        30 September 1993
C                Pacific Environmental Services
C
C   Revision history:
C                <none>
C
C   Reference(s):
C
C-----------------------------------------------------------------------
C
C---- Variable declarations
C
c dgs USE MAIN1
c dgs IMPLICIT NONE
c dgs CHARACTER MODNAM*12

c dgs SAVE
      REAL      HEIGHT, VALUE, SV2, ZDCRS, ATZI, SV2DCR, VAL2
C
C---- Data dictionary
C     SV2    = variance of the horizontal component of the wind
C     ZDCRS  = value of 1.2 * ZICONV used in profiling SV2
C     ATZI   = value of SV at ZICONV
C     AT1PT2 = the fraction of and above the mixing height
C              through which the parameter is changing
C
C     AT1PT2 is defined in a PARAMETER statement in MAIN1.INC
C
      PARAMETER (AT1PT2 = 1.2)

C---- Data initializations
C
c dgs MODNAM = 'REFSVC'
      ZDCRS  =  AT1PT2 * ZICONV
C
C.......................................................................
C
      SV2 = 0.35 * WSTAR**2
C
      IF( HEIGHT  .LE.  ZICONV )THEN
         VALUE = SQRT( SV2 )

      ELSEIF( HEIGHT .GT. ZICONV  .AND.  HEIGHT .LE. ZDCRS )THEN
C        COMPUTE sigmaV at 1.2*ZI
         SV2DCR = AMIN1( SV2, 0.25 )
C        INTERPOLATE between value of SV2 at ZI and at 1.2*ZI
         CALL GINTRP ( ZICONV, SV2, ZDCRS, SV2DCR, HEIGHT, VAL2 )
         VALUE = SQRT( VAL2 )

      ELSE   ! requested height is above 1.2*mixing height
         ATZI  = SQRT( SV2 )
         VALUE = AMIN1( ATZI, 0.5 )

      ENDIF
C
      RETURN
      END

c----------------------------------------------------------------------
      SUBROUTINE REFSVM ( HEIGHT,ustar,zimech, VALUE )
c dgs SUBROUTINE REFSVM ( HEIGHT, VALUE )
C=======================================================================
C                REFSVM Module of the AERMOD Dispersion Model
C
C   Purpose:     To compute the value of sigma-V, the horizontal
C                (lateral) dispersion parameter from the surface
C                friction velocity and convective scaling velocity
C                alone (i.e., no observations of sigma-V)
C
C   Input:       Mixing height (ZI)
C                Friction velocity (USTAR)
C                Convective scaling velocity (WSTAR)
C                Height at which sigma-V is needed (HEIGHT)
C
C   Output:      sigmaV at the required level (VALUE)
C
C   Assumptions: Mixing height, friction and convective scaling
C                velocities are nonmissing
C
C   Programmer:  Jim Paumier                        30 September 1993
C                Pacific Environmental Services
C
C   Revision history:
C                <none>
C
C   Reference(s):
C
C-----------------------------------------------------------------------
C
C---- Variable declarations
C
c dgs USE MAIN1
c dgs IMPLICIT NONE
c dgs CHARACTER MODNAM*12

c dgs SAVE
      REAL      HEIGHT, VALUE, SV02, SV2ZI, VARV
C
C---- Data dictionary
C     SV02   = variance of the horizontal component of the wind at the
C              surface.
C
C---- Data initializations
C
c dgs MODNAM = 'REFSVM'
C
C.......................................................................
C
C     Compute SV2 at the surface
      SV02 = 3.6 * USTAR**2
C
C     Compute SV2 at ZI;
C     Do not let SV2 at ZI exceed the surface value.
      SV2ZI = AMIN1( SV02, 0.25 )

      IF( HEIGHT  .LE.  ZIMECH )THEN
C        INTERPOLATE between these two values of the variance if HEIGHT is
C        below ZIMECH
         CALL GINTRP ( 0., SV02, ZIMECH, SV2ZI, HEIGHT, VARV )
         VALUE = SQRT(VARV)

      ELSE
C        Persist value at ZIMECH upward.
         VALUE = SQRT(SV2ZI)

      ENDIF
C
      RETURN
      END

c----------------------------------------------------------------------
      SUBROUTINE REFSW ( HEIGHT,ustar,wstar,xmon,zi,ziconv,swrmax,
     &                   VALUE )
c     SUBROUTINE REFSW ( HEIGHT, VALUE )
C=======================================================================
C                REFSW Module of the AERMOD Dispersion Model
C
C   Purpose:     To compute the value of sigma-W, the vertical
C                dispersion parameter from the surface friction
C                velocity and convective scaling velocity alone
C                (i.e., no observations of sigma-W)
C
C   Input:
C
C
C
C
C   Output:      Value of the parameter at the required level
C
C   Assumptions: Mixing height, friction and convective scaling
C                velocities are nonmissing
C
C   Programmer:  Jim Paumier                        30 September 1993
C                Pacific Environmental Services
C
C   Revision history:
C                Jim Paumier, PES                    5 July 1995
C                  - modified the coefficient on the u* term for CBL;
C                  - made the value 1.2 a parameter in MAIN1;
C                  - modified the form of sigma-w at all height for SBL;
C
C   Reference(s):
C
C-----------------------------------------------------------------------
C
C---- Variable declarations
C
c dgs USE MAIN1
c dgs IMPLICIT NONE
c dgs CHARACTER MODNAM*12

c dgs SAVE
      REAL      HEIGHT, VALUE, SWC, SWM
C
C---- Data dictionary
C
C     SWC    = convective component of the variance of the vertical velocity
C     SWM    = mechanical component of the variance of the vertical velocity
C
C---- Data initializations
C
c dgs MODNAM = 'REFSW '
C
C.......................................................................
C
c dgs IF (UNSTAB )THEN
      if(xmon.LT.0.0) then
C        Compute the convective component of sigma-w, SWC
c dgs    CALL REFSWC( HEIGHT, SWC )
         CALL REFSWC( HEIGHT,wstar,ziconv, SWC )

C        Compute the mechanical component of sigma-w, SWM
c dgs    CALL REFSWM( HEIGHT, SWM )
         CALL REFSWM( HEIGHT,ustar,zi,swrmax, SWM )

C        Apply lower limit to sigma-w to avoid potential math errors
         SWC = AMAX1( SWC, 0.00001 )
         SWM = AMAX1( SWM, 0.00001 )

         VALUE = SQRT( SWC*SWC + SWM*SWM )

crwb     Output convective and mechanical components of profile.
crwb         if (METEOR) then
crwb            if (height .eq. 0.0) then
crwb               write(dbmunt,909) kurdat, ziconv, zimech, zi
crwb909            format(1x,'DATE= ',i8,2x,'ZIc= ',f8.2,2x,'ZIm= ',f8.2,2x,
crwb     &                'ZI = ',f8.2,/,
crwb     &          '   GRIDHT    SIGW_COVN      SIGW_MECH       SIGW_TOT')
crwb            end if
crwb            write(dbmunt,919) height, swc, swm, value
crwb919         format(1x,f8.2,3(3x,g13.5))
crwb         end if

c dgs ELSE IF (STABLE) THEN
      ELSE

C        Compute the mechanical component of sigma-w, SWM
c dgs    CALL REFSWM( HEIGHT, SWM )
         CALL REFSWM( HEIGHT,ustar,zi,swrmax, SWM )

         VALUE = AMAX1( SWM, 0.00001 )

      END IF

      RETURN
      END

c----------------------------------------------------------------------
      SUBROUTINE REFSWC ( HEIGHT,wstar,ziconv, VALUE )
c dgs SUBROUTINE REFSWC ( HEIGHT, VALUE )
C=======================================================================
C                REFSWC Module of the AERMOD Dispersion Model
C
C   Purpose:     To compute the value of sigma-W, the vertical
C                dispersion parameter from the surface friction
C                velocity and convective scaling velocity alone
C                for the convective boundary layer.
C                (i.e., no observations of sigma-W)
C
C   Input:
C
C
C
C
C   Output:      Value of the parameter at the required level
C
C   Assumptions: Mixing height, friction and convective scaling
C                velocities are nonmissing
C
C   Programmer:  Jim Paumier                        30 September 1993
C                Pacific Environmental Services
C
C   Revision history:
C                Jim Paumier, PES                    5 July 1995
C                  - modified the coefficient on the u* term for CBL;
C                  - made the value 1.2 a parameter in MAIN1;
C                  - modified the form of sigma-w at all height for SBL;
C
C   Reference(s):
C
C-----------------------------------------------------------------------
C
C---- Variable declarations
C
c dgs USE MAIN1
c dgs IMPLICIT NONE
c dgs CHARACTER MODNAM*12

c dgs SAVE
      REAL      HEIGHT, VALUE, SW2
C
C---- Data dictionary
C
C     SW2    = variance of the vertical velocity
C
C---- Data initializations
C
c dgs MODNAM = 'REFSWC'
C
C.......................................................................
C
      IF( HEIGHT  .LE.  0.1*ZICONV )THEN
         SW2 = 1.6 * ( HEIGHT / ZICONV )**0.667 * WSTAR**2
         VALUE  = SQRT( SW2 )

      ELSEIF( HEIGHT .GT. 0.1*ZICONV  .AND.  HEIGHT .LE. ZICONV )THEN
         VALUE = SQRT( 0.35 * WSTAR**2 )

      ELSEIF( HEIGHT .GT. ZICONV )THEN
         SW2 = 0.35 * WSTAR**2 * EXP( -(6.*(HEIGHT - ZICONV)/ZICONV) )
         VALUE = SQRT( SW2 )

      ENDIF
C

      RETURN
      END

c----------------------------------------------------------------------
      SUBROUTINE REFSWM ( HEIGHT,ustar,zi,swrmax, VALUE )
c dgs SUBROUTINE REFSWM ( HEIGHT, VALUE )
C=======================================================================
C                REFSWM Module of the AERMOD Dispersion Model
C
C   Purpose:     To compute the value of sigma-W, the vertical
C                dispersion parameter from the surface friction
C                velocity and convective scaling velocity alone
C                for the mechanical boundary layer.
C                (i.e., no observations of sigma-W)
C
C   Input:
C
C
C
C
C   Output:      Value of the parameter at the required level
C
C   Assumptions: Mixing height, friction and convective scaling
C                velocities are nonmissing
C
C   Programmer:  Jim Paumier                        30 September 1993
C                Pacific Environmental Services
C
C   Revision history:
C                Jim Paumier, PES                    5 July 1995
C                  - modified the coefficient on the u* term for CBL;
C                  - made the value 1.2 a parameter in MAIN1;
C                  - modified the form of sigma-w at all height for SBL;
C
C   Reference(s):
C
C-----------------------------------------------------------------------
C
C---- Variable declarations
C
c dgs USE MAIN1
c dgs IMPLICIT NONE
c dgs CHARACTER MODNAM*12

c dgs SAVE
      REAL      HEIGHT, VALUE, SWR, SWBL
C
C---- Data dictionary
C
C     SWR    = variance of the vertical velocity due to residual turbulence
C     SWBL   = variance of the vertical velocity in the boundary layer
C
C---- Data initializations
C
c dgs MODNAM = 'REFSWM'
C
C.......................................................................
C
C

      SWR  = SWRMAX * MIN( 1.0, HEIGHT/ZI)

      IF (HEIGHT .LT. ZI) THEN
         SWBL = 1.3 * USTAR * SQRT( 1.0 - HEIGHT/ZI)
      ELSE
         SWBL = 0.0
      END IF

      VALUE = SQRT ( SWR*SWR + SWBL*SWBL )


      RETURN
      END

c----------------------------------------------------------------------
      SUBROUTINE GINTRP ( HTBELO,VBELOW, HTABOV,VABOVE, REQDHT,VALUE )
C***********************************************************************
C             GINTRP Module of the AMS/EPA Regulatory Model - AERMOD
C
C   Purpose:     A generalized interpolation routine
C
C   Input:       Height below the required height (HTBELO)
C                Value below the required height (VBELOW)
C                Height above the required height (HTBELO)
C                Value above the required height (VBELOW)
C                Height at which a value is required (REQDHT)
C
C   Output:      Value of the parameter at the required level (VALUE)
C
C   Called by:   Utility routine called by many modules
C
C   Assumptions:
C
C   Programmer:  Jim Paumier, PES, Inc.
C
C   Date:        September 30, 1993
C
C   Revision history:
C                <none>
C
C   Reference(s):
C
C***********************************************************************
C
C---- Variable declarations
C
      REAL   VALUE, HTBELO, VBELOW, HTABOV, VABOVE, REQDHT
C
C---- Data dictionary
C
C---- Data initializations
C
C.......................................................................
C
C---- Interpolate

      VALUE = VBELOW + ( (REQDHT - HTBELO) / (HTABOV - HTBELO) ) *
     &                   (VABOVE - VBELOW)

      RETURN
      END

c-----------------------------------------------------------------------
      subroutine tauly(ldb,sigv,sigw,el,zi,zht,tau)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050225                   TAULY
c                D. Strimaitis   Earth Tech, Inc.
c
c --- PURPOSE:  Estimates the Lagrangian timescale using elements from
c               SCIPUFF
c
c --- INPUTS:
c             LDB - logical  - Flag controlling printing of debug data
c            sigv - real     - Sigma-v (m/s)
c            sigw - real     - Sigma-w (m/s)
c              el - real     - Monin-Obukhov length (m)
c              zi - real     - Surface boundary layer height (m)
c             zht - real     - Height above ground (m)
c
c --- OUTPUT:
c             tau - real     - Lagrangian timescale (s) for lateral
c                              wind fluctuations
c
c
c --- TAULY called by: SETCSIG
c --- TAULY calls:     none
c----------------------------------------------------------------------
      include 'params.puf'

      logical LDB

c --- Set lateral length scale above boundary layer (m)
      data ymeso/1000./
c --- Do not evaluate timescale nearer the surface than zmin (m)
      data zmin/5./
      data vonk/0.4/

c --- Zi should not be zero (e.g., < 1.)
      if(zi.LT.1.) then
         write(io6,*)
         write(io6,*)'Fatal ERROR in subroutine TAULY'
         write(io6,*)'Mixing height is too small: ',zi
         stop 'Halted in TAULY -- see list file for details.'
      endif

      z=AMAX1(zht,zmin)

c --- Total variance (assume sigma-u = sigma-v)
      q=SQRT(2.*sigv*sigv+sigw*sigw)
      if(q.LE.0.) then
         write(io6,*)
         write(io6,*)'Fatal ERROR in subroutine TAULY'
         write(io6,*)'Turbulence is zero'
         stop 'Halted in TAULY -- see list file for details.'
      endif

c --- Estimate length scale
      if(z.GT.zi) then
c ---    Length scale is fixed above zi
         yl=ymeso
      else
c ---    Length scale is a weighted average of shear and buoyancy
c ---    scales
         ylshear=1./(SQRT(1./(0.3*zi)**2 + 1./(0.65*z)**2))
         ylbuoy=0.3*zi
         if(el.GE.0.) then
c ---       Stable - neutral
            wtshear=1.0
            wtbuoy=0.0
         else
c ---       Convective - neutral
            zbyzi=z/zi
            a=1.-zbyzi
            b=0.052*(-zi/(vonk*el))**0.66667
            wtshear=a/(a+b*(1+1.5*EXP(-zbyzi)))
         endif
         wtbuoy=1.-wtshear
         yl=wtshear*ylshear+wtbuoy*ylbuoy
      endif

c --- Compute time scale
      tau=yl/(0.75*q)

      if(LDB) then
         write(io6,*)'TAULY:  (Lagragian timescale - horizontal)'
         write(io6,*)'       el,sigv,sigw  = ',el,sigv,sigw
         write(io6,*)'       zht,zi        = ',zht,zi
         write(io6,*)'     ylshear,ylbuoy  = ',ylshear,ylbuoy
         write(io6,*)'     wtshear,wtbuoy  = ',wtshear,wtbuoy
         write(io6,*)'            TAU, YL  = ',tau, yl
      endif

      return
      end

c----------------------------------------------------------------------
      subroutine tperiod(ibe,ndhr,nsec,ndhrb,nsecb,ndhre,nsece,ilocate)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262     Level: 990709               TPERIOD
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Tests year/day/hour and seconds variables at beginning
c               and end of period against target date-time to see if
c               target lies within period
c
c --- INPUTS:
c           IBE - integer - Treatment of Beginning and End of period
c                           -1: Beginning time within period (not end)
c                            0: Beginning & End are within period
c                            1: Ending time within period (not begin)
c          NDHR - integer - YYYYJJJHH of target (year-day-hour)
c          NSEC - integer - SSSS of target (seconds)
c         NDHRB - integer - YYYYJJJHH at beginning of period
c         NSECB - integer - SSSS at beginning of period
c         NDHRE - integer - YYYYJJJHH at end of period
c         NSECE - integer - SSSS at end of period
c
c
c --- OUTPUT:
c       ILOCATE - integer - Location of target relative to period
c                           -1: target preceeds period
c                            0: target within period
c                            1: target lies beyond period
c
c --- TPERIOD called by:  COMP, METQA, EMQA, SIGSET
c                         RDMET, RDSIG, RDISC,RDPLM, RDMET4
c --- TPERIOD calls:      TCLOCK
c----------------------------------------------------------------------

      ilocate=0

      if(ndhr.LT.ndhrb) then
c ---    Target date-hr before start of period
         ilocate=-1
      elseif(ndhr.GT.ndhre) then
c ---    Target date-hr after end of period
         ilocate=1
      elseif(ndhr.EQ.ndhrb) then
         if(nsec.LT.nsecb) then
c ---       Target time before start of period
            ilocate=-1
         elseif(ibe.EQ.1 .AND. nsec.EQ.nsecb) then
c ---       Target time before start of period
            ilocate=-1
         elseif(ndhrb.EQ.ndhre) then
            if(nsec.GT.nsece) then
c ---          Target time after end of period
               ilocate=1
            elseif(ibe.EQ.-1 .AND. nsec.EQ.nsece) then
c ---          Target time after end of period
               ilocate=1
            endif
         endif
      elseif(ndhr.EQ.ndhre) then
         if(nsec.GT.nsece) then
c ---       Target time after end of period
            ilocate=1
         elseif(ibe.EQ.-1 .AND. nsec.EQ.nsece) then
c ---       Target time after end of period
            ilocate=1
         endif
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine tclock(io,ndhr,nyr,njul,nhr,nsec)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262     Level: 050915                TCLOCK
c                D. Strimaitis,  Earth Tech
c
c --- PURPOSE:  Tests year/day/hour and seconds variables and changes
c               them if needed to fall within standard clock times
c               (HH:SSSS) between 00:0000 and 23:3599
c
c --- INPUTS:
c            IO - integer - List file unit number
c          NDHR - integer - YYYYJJJHH (year-Julian day-hour)
c           NYR - integer - YYYY (year)
c          NJUL - integer - JJJ (Julian day)
c           NHR - integer - HH (hour)
c          NSEC - integer - SSSS (seconds)
c
c
c --- OUTPUT:
c          NDHR - integer - YYYYJJJHH of target (year-day-hour)
c           NYR - integer - YYYY (year)
c          NJUL - integer - JJJ (Julian day)
c           NHR - integer - HH (hour)
c          NSEC - integer - SSSS of target (seconds)
c
c --- TCLOCK called by:  (utility)
c --- TCLOCK calls:      INCR
c----------------------------------------------------------------------

      if(ndhr.GT.0) then
c ---    Extract date/hour elements
         iyr=ndhr/100000
         jjjhh=ndhr-iyr*100000
         jul=jjjhh/100
         ihr=jjjhh-jul*100
      else
c ---    Assign input values
         iyr=nyr
         jul=njul
         ihr=nhr
      endif

      if(nsec.LT.3600 .AND. ihr.LT.24) return

c --- Condition times (HH:SSSS) to be between 00:0000 and 23:3599
      khr=nsec/3600
      nsec=nsec-khr*3600
      ihr=ihr+khr
      if(ihr.GT.23) then
         khr=ihr-23
         ihr=23
         call INCR(io,iyr,jul,ihr,khr)
      endif
      if(ndhr.GT.0) then
         ndhr=iyr*100000+jul*100+ihr
      else
         nyr=iyr
         njul=jul
         nhr=ihr
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine timeset
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                TIMESET
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Set date/time variables for the start of the run
c
c --- INPUT:
c
c     Common block /GEN/
c        IBYR, IBMO, IBDAY, IBHR, IBSEC, NSECDT
c
c --- OUTPUT:
c
c     Common block /DATEHR/
c        nyrb,nmob,ndayb,njulb,nhrb,nsecb,ndathrb,
c        nyre,nmoe,ndaye,njule,nhre,nsece,ndathre,
c        nyrm,njulm,nhrm,nsecm,ndathrm,
c        nhrind
c        
c
c --- TIMESET called by: SETUP
c --- TIMESET calls:     JULDAY,  GRDAY,  INCRS
c----------------------------------------------------------------------
      include 'params.puf'
c
c --- Include common blocks
      include 'datehr.puf'
      include 'gen.puf'

c --- Mark periods with both the beginning and ending time
c --- Length of period is NSECDT in seconds
c --- Half of period is NSECDT2 seconds
      nsecdt2=nsecdt/2
c
c --- Set beginning time of first period
      nyrb=ibyr
      nmob=ibmo
      ndayb=ibdy
      nhrb=ibhr
      nsecb=ibsec
      call JULDAY(io6,nyrb,nmob,ndayb,njulb)
      ndathrb=nyrb*100000+njulb*100+nhrb
c
c --- Set time at the middle of first period
      nyrm=nyrb
      njulm=njulb
      nhrm=nhrb
      nsecm=nsecb
      call INCRS(io6,nyrm,njulm,nhrm,nsecm,nsecdt2)
      ndathrm=nyrm*100000+njulm*100+nhrm
c
c --- Set ending time of first period
      nyre=nyrb
      njule=njulb
      nhre=nhrb
      nsece=nsecb
      call INCRS(io6,nyre,njule,nhre,nsece,nsecdt)
      call GRDAY(io6,nyre,njule,nmoe,ndaye)
      ndathre=nyre*100000+njule*100+nhre
c
c --- Use midpoint of period to assign an hour index (1-24)
      nhrind=nhrm+1

      return
      end
c----------------------------------------------------------------------
      subroutine timeup(i)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 050915                 TIMEUP
c                D. Strimaitis, Earth Tech
c
c --- PURPOSE:  Update date/time variables by 1 timestep
c
c --- INPUT:
c               I - integer      - Direction of update
c                                  i=+1  Forward 1 step
c                                  i=-1  Backward 1 step
c
c     Common block /DATEHR/
c        nyrb,nmob,ndayb,njulb,nhrb,nsecb,ndathrb,
c        nyre,nmoe,ndaye,njule,nhre,nsece,ndathre,
c        nyrm,njulm,nhrm,nsecm,ndathrm,
c     Common block /GEN/
c        NSECDT
c
c --- OUTPUT:
c
c     Common block /DATEHR/
c        nyrb,nmob,ndayb,njulb,nhrb,nsecb,ndathrb,
c        nyre,nmoe,ndaye,njule,nhre,nsece,ndathre,
c        nyrm,njulm,nhrm,nsecm,ndathrm,
c        nhrind
c        
c
c --- TIMEUP called by: COMP
c --- TIMEUP calls:     JULDAY,  GRDAY,  INCRS
c----------------------------------------------------------------------
      include 'params.puf'
c
c --- Include common blocks
      include 'datehr.puf'
      include 'gen.puf'

c --- Set the update step (seconds)
      nstep=nsecdt*i

      if(i.EQ.1) then
c ---    Forward 1 step
c ---    Beginning
         nyrb=nyre
         nmob=nmoe
         ndayb=ndaye
         njulb=njule
         nhrb=nhre
         nsecb=nsece
         ndathrb=ndathre
c ---    Mid-point
         call INCRS(io6,nyrm,njulm,nhrm,nsecm,nstep)
         ndathrm=nyrm*100000+njulm*100+nhrm
c ---    Ending
         call INCRS(io6,nyre,njule,nhre,nsece,nstep)
         call GRDAY(io6,nyre,njule,nmoe,ndaye)
         ndathre=nyre*100000+njule*100+nhre

      elseif(i.EQ.-1) then
c ---    Backward 1 step
c ---    Ending
         nyre=nyrb
         nmoe=nmob
         ndaye=ndayb
         njule=njulb
         nhre=nhrb
         nsece=nsecb
         ndathre=ndathrb
c ---    Mid-point
         call INCRS(io6,nyrm,njulm,nhrm,nsecm,nstep)
         ndathrm=nyrm*100000+njulm*100+nhrm
c ---    Beginning
         call INCRS(io6,nyrb,njulb,nhrb,nsecb,nstep)
         call GRDAY(io6,nyrb,njulb,nmob,ndayb)
         ndathre=nyre*100000+njule*100+nhre

      else
c ---    Argument must be either -1 or 1
         write(*,*)
         write(*,*)'FATAL ERROR in TIMEUP---'
         write(*,*)'The update step is not -1 or 1: ',i
         stop
      endif

c --- Use midpoint of period to assign an hour index (1-24)
      nhrind=nhrm+1

      return
      end
c-----------------------------------------------------------------------
      subroutine filvers(io,ab,fname,ftype,dataver)
c-----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 070404                 FILVERS
c                D. Strimaitis
c
c --- PURPOSE:  Opens file of input data for the application and sets
c               the file version format based on information from one
c               or more header records.  (File is closed on exit)
c
c --- UPDATE
c --- V6.11-V6.116 070404  (DGS): change read for first record of the
c                                 restart file to access just the first
c                                 variable expected (avoids possibility
c                                 of attempting to read past end of
c                                 record)
c --- V6.1-V6.11   060309  (DGS): filename c*70 to c*132
c                                 remove LTYPE2 declaration (not used)
c
c --- INPUTS:
c            io - integer      - file unit number
c            ab - character*3  - file form (ASC or BIN)
c         fname - character*132- full filename
c         ftype - character*12 - type of file (e.g., 'BAEMARB')
c
c
c --- OUTPUT:
c       dataver - character*16 - file version identifier (e.g., '2.0')
c
c --- FILVERS called by: SETUP
c --- FILVERS calls:     none
c----------------------------------------------------------------------
c
      parameter(mxftype=15)

      integer iquote(4)
      character*132 aline
      character*80 title(3)
      character*132 fname
      character*64 adoc
      character*16 anames(2,mxftype),blank16,var16
      character*16 dataset,dataver
      character*12 ftype
      character*12 ver0, var12
      character*8 vermet,levmet
      character*3 ab
      character*1 aquote
      logical lascii

c --- Set fixed characters
      data aquote/''''/
      data blank16/'                '/

c --- Set file type names
      data anames/'CALMET          ','CALMET.DAT      ',
     &            'ISCMET          ','ISCMET.DAT      ',
     &            'PLMMET          ','PLMMET.DAT      ',
     &            'PROFILE         ','PROFILE.DAT     ',
     &            'SURFACE         ','SURFACE.DAT     ',
     &            'PTEMARB         ','PTEMARB.DAT     ',
     &            'BAEMARB         ','BAEMARB.DAT     ',
     &            'LNEMARB         ','LNEMARB.DAT     ',
     &            'VOLEMARB        ','VOLEMARB.DAT    ',
     &            'OZONE           ','OZONE.DAT       ',
     &            'H2O2            ','H2O2.DAT        ',
     &            'COASTLN         ','COASTLN.DAT     ',
     &            'FLUXBDY         ','FLUXBDY.DAT     ',
     &            'BCON            ','BCON.DAT        ',
     &            'RESTART         ','RESTART.DAT     '/

c --- Initialize dataset version
      dataver=blank16

c --- Identify file type
      itype=0
      do k=1,mxftype
         if(ftype.EQ.anames(1,k)) itype=k
      enddo
      if(itype.EQ.0) then
         write(*,*)'FATAL Error in FILVERS - unknown file type: ',
     &              ftype
         write(*,*)'Expected one of the following: '
         do k=1,mxftype
            write(*,*) anames(1,k)
         enddo
         stop
      endif

c --- Open file
      if(ab.EQ.'BIN') then
         lascii=.FALSE.
         open(io,file=fname,status='old',form='unformatted',err=999)
      elseif(ab.EQ.'ASC') then
         lascii=.TRUE.
         open(io,file=fname,status='old',err=999)
      else
         write(*,*)'FATAL Error in FILVERS - unknown file format: ',ab
         write(*,*)'Expected BIN or ASC'
         write(*,*)'File Type input: ',ftype
         stop
      endif

      if(LASCII) then

c ---    Read first record into string
         read(io,'(a132)') aline
c ---    Assume type 2 file first
         if(aline(1:16).EQ.anames(2,itype)) then
            dataver=blank16
            j=0
            do i=17,32
               if(aline(i:i).NE.' ') then
                  j=j+1
                  dataver(j:j)=aline(i:i)
               endif
            enddo
         else
c ---       Process file formats by file type

            if(itype.EQ.2) then
c ---          ISC met file
c ---          ------------
               if(aline(1:3) .EQ. 'BEG') then
c ---             CALPUFF MOD-6.0 ISC format conventions
                  dataver(1:3)='1.6'
               else
c ---             Standard ISC format conventions
                  dataver(1:3)='1.0'
               endif

            elseif(itype.EQ.3) then
c ---          PLM met file
c ---          ------------
c ---          Standard PLM format conventions
               dataver(1:3)='1.0'

            elseif(itype.EQ.4) then
c ---          CTDM or AERMET PROFILE met file
c ---          -------------------------------
               if(aline(1:3) .EQ. 'BEG') then
c ---             CALPUFF MOD-6.0 PROFILE format conventions
                  dataver(1:3)='1.6'
               else
c ---             Standard PROFILE format conventions
                  dataver(1:3)='1.0'
               endif

            elseif(itype.EQ.5) then
c ---          CTDM or AERMET SURFACE met file
c ---          -------------------------------
               if(aline(1:3) .EQ. 'BEG') then
c ---             CALPUFF MOD-6.0 SURFACE format conventions
                  dataver(1:3)='1.6'
               else
c ---             Standard SURFACE format conventions
                  dataver(1:3)='1.0'
               endif

            elseif(itype.GE.6 .AND. itype.LE.9) then
c ---          Variable emissions files
c ---          ------------------------
c ---          Free-format with quoted character variables
c ---          Find position of first 4 quotes
               iq=0
               do k=1,132
                  if(aline(k:k).EQ.aquote .AND. iq.LT.4) then
                     iq=iq+1
                     iquote(iq)=k
                  endif
               enddo
               if(iq.NE.4) then
                  write(*,*)'FATAL Error in FILVERS - unknown header'
                  write(*,*)'Expected at least 2 quoted strings'
                  write(*,*)'Number of quotes found: ',iq
                  write(*,*) aline
                  stop
               endif
c ---          Check name
               i1=iquote(1)+1
               i2=iquote(2)-1
               i3=i2-i1+1
               k1=iquote(3)+1
               k2=iquote(4)-1
               k3=k2-k1+1
               if(aline(i1:i2).EQ.anames(1,itype)(1:i3)) then
                  dataver(1:k3)=aline(k1:k2)
               else
                  write(*,*)'FATAL Error in FILVERS - unknown header'
                  write(*,*)'Expected: ',anames(1,itype)(1:i3)
                  write(*,*)'   Found: ',aline(i1:i2)
                  write(*,*) aline
                  stop
               endif
c ---          Construct uniform dataset version
               read(dataver,'(f16.0)') dver
               iver10=NINT(10.*dver)
               if(iver10.GE.60) then
                  dataver='1.6             '
               elseif(iver10.GE.54) then
                  dataver='1.54            '
               elseif(iver10.GE.50) then
                  dataver='1.5             '
               else
                  write(*,*)'FATAL Error in FILVERS - bad version'
                  write(*,*)'Expected: 5.0. 5.4, or 6.0'
                  write(*,*)'   Found: ',dataver
                  write(*,*) aline
                  stop
               endif

            elseif(itype.GE.10 .AND. itype.LE.14) then
c ---          Remaining ASCII files
c ---          ---------------------
c ---          These have only 1 dataset version before 2.0
               dataver(1:3)='1.5'
            endif

         endif

      else

         if(itype.EQ.1) then
c ---       CALMET file
c ---       -----------
            read(io) dataset,dataver,adoc
            if(dataset.NE.anames(2,itype)) then
c ---          Older dataset 

               REWIND(io)
c ---          record #1 - run title -- 60 words
               read(io)title
c ---          record #2 - run control parameters
               read(io)vermet,levmet

               read(levmet(1:6),'(i6)') ilevmet
               read(vermet(1:6),'(f6.0)') rvermet
               if(ilevmet.GE.980304 .OR. rvermet.GT.5.1) then
                  dataver='1.5'
               else
                  dataver='1.0'
               endif
            endif

         elseif(itype.EQ.15) then
c ---       RESTART file
c ---       ------------
c ---       Determine major difference in format from first variable
            var16=anames(2,itype)
            var12=blank16(1:12)
            read(io) var12
            var16(1:12)=var12
            REWIND(io)

            if(var16.EQ.anames(2,itype)) then
               read(io) dataset,dataver,adoc
            else
c ---          Older dataset 
               read(io)ver0
               read(ver0(1:6),'(f6.0)') rver
               if(rver.LT.6.0) then
                  dataver='1.0             '
               else
                  dataver='1.6             '
               endif
            endif

         endif

      endif

c --- Close file
      close(io)

      return

999   write(*,*)
      write(*,*)'FATAL Error in FILVERS - bad filename:'
      write(*,*)fname
      stop

      end
c----------------------------------------------------------------------
      subroutine varsam(ldb,temit,tleft,secdt,smxi,mxnew,ws,
     &                  nsstr,nsam,tsamp2,tsampf)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262     Level: 080227                VARSAM
c                D. Strimaitis
c
c --- PURPOSE:  Computes sampling step information in first timestep
c               for puffs/slugs released from sources with variable
c               release parameters.  The first sampling step is the
c               emitting step for this puff, with duration TEMIT.
c               Subsequent steps are consistent with parameters XMXLEN
c               and MXNEW until the last step, which is the residual
c               needed to close out the timestep.  
c
c --- UPDATE
c --- V6.24-V6.25    080227 (DGS): Replace MXSAM cap with MXNEW cap
c                                  Revise subroutine to include 3-part
c                                  sampling step structure
c --- V6.22-V6.24    080208 (DGS): Condition tsamp2 output to be equal
c                                  to temit when difference is less
c                                  than precision
c --- V6.1-V6.22     070921 (DGS): Impose MXSAM limit on NSAM result
c --- V6.0-V6.1      050915 (DGS): Remove emission step index (stored
c                                  in /PUFF/ now)
c
c --- INPUTS:
c           LDB - logical   - Output debug writes when .TRUE.
c         TEMIT - real      - Duration of emission for puff/slug (s)
c         TLEFT - real      - Time remaining in this timestep after
c                             puff/slug is emitted, expressed as
c                             fraction of timestep
c         SECDT - real      - Length of timestep (s)
c          SMXI - real      - Reciprocal of speed required to travel
c                             max allowed distance in 1 timestep (s/m)
c         MXNEW - integer   - Maximum number of new puffs allowed for
c                             one emission period
c            WS - real      - Wind speed (m/s)
c
c
c --- OUTPUT:
c         NSSTR - integer   - Starting sampling step for current puff
c          NSAM - integer   - Total number of sampling steps for
c                             this timestep
c        TSAMP2 - real      - Sampling step duration for period after
c                             emission step
c        TSAMPF - real      - Sampling step duration for final step
c
c --- VARSAM called by:  COMP
c --- VARSAM calls:      LRSAME
c----------------------------------------------------------------------
c
c --- Include parameters
      include 'params.puf'
c
      logical ldb
      logical lrsame

      data zero/0.0/

c --- Set minimum time (sec) that is treated as significant enough to
c --- use as the last sampling step (residual time difference may not
c --- be zero due to precision)
      data tzero/0.01/

c --- Number of emitting steps allowed in full timestep (for constant Q)
      nsam=ws*smxi+1
      nsam=MIN(nsam,mxnew)
c --- Time for each step
      tsamp2=secdt/FLOAT(nsam)
c --- Avoid meaningless difference between temit and tsamp2 that
c --- may arise from single precision resolution
      if(LRSAME(1.0e-05,temit,tsamp2)) tsamp2=temit

      if(tleft.LE.zero) then
c ---    Emission of current puff/slug ends at end of this timestep,
c ---    so there is only one sampling step
         nsstr=nsam
         tsamp2=zero
         tsampf=temit
      else
c ---    Configure sampling step properties after emitting step
         secleft=tleft*secdt
c ---    Number of full sampling steps after puff is emitted
         nfull=secleft/tsamp2
c ---    Partial step needed to complete timestep period
         tsampf=secleft-(nfull*tsamp2)
         if(tsampf.LE.tzero) then
            nlast=0
            tsampf=tsamp2
         else
            nlast=1
c ---       Avoid meaningless difference between tsampf and tsamp2 that
c ---       may arise from single precision resolution
            if(LRSAME(1.0e-05,tsampf,tsamp2)) tsampf=tsamp2
         endif
c ---    Finish sampling step configuration
         nsstr=nsam-(nfull+nlast)
         if(nsstr.LE.0) then
            nsam=nsam+1-nsstr
            nsstr=1
         endif
      endif

c --- Debug output
      if(LDB) then
         write(io6,*)'VARSAM -- ws,temit,tleft: ',ws,temit,tleft
         write(io6,*)'        secdt,mxnew,smxi: ',secdt,mxnew,smxi
         write(io6,*)'              nsstr,nsam: ',nsstr,nsam
         write(io6,*)'           tsamp2,tsampf: ',tsamp2,tsampf
      endif

c --- Reset TLEFT to zero (release use of tmtotb array)
      tleft=zero

      return
      end

c----------------------------------------------------------------------
      subroutine geofmt(dataset,dataver,pmap,iutm,utmhem,
     &                  clat0,clon0,clat1,clat2,
     &                  datum,daten,xyunit,tzone)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                 GEOFMT
c                D. Strimaitis
c
c --- PURPOSE:  Condition character strings of geo-referencing data
c               before use, and apply first level QA
c
c --- UPDATE
c --- V6.22-V6.26    080430 (DGS): Dimension CSTOR1,CSTOR2 arrays to
c                                  MXCOL, as defined in PARAMS.CAL,
c                                  to be consistent with CALUTIL subs
c
c --- INPUT:
c          DATASET - char*16 - Name of dataset (file type) containing
c                              the geo data
c          DATAVER - char*16 - Version of dataset
c             PMAP - char*8  - Character code for input map projection
c                              LL  :  Latitude/longitude
c                              UTM :  Universal Transverse Mercator
c                              LCC :  Lambert Conformal Conic
c                              PS  :  Polar Stereographic
c                              EM  :  Equatorial Mercator
c                              LAZA:  Lambert Azimuthal Equal Area
c                              TTM :  Tangential Transverse Mercator
c             IUTM - integer - UTM zone in which the station
c                              coordinates are specified
c           UTMHEM - char*4  - Base hemisphere for UTM projection
c                               (S=southern, N=northern)
c      CLAT0,CLON0 - char*16 - Latitude & longitude of x=0 and y=0
c           (deg)              of map projection (Used only if PMAP =
c                              LCC, PS, EM, TTM or LAZA), and
c      CLAT1,CLAT2 - char*16 - Matching latitude(s) for projection
c           (deg)             (Used only if PMAP3= LCC, PS, or EM)
c                              LCC :  Projection cone slices through
c                                     Earth's surface at XLAT1 and XLAT2
c                              PS  :  Projection plane slices through
c                                     Earth at XLAT1
c                              EM  :  Projection cylinder slices through
c                                     Earth at [+/-] XLAT1
c            DATUM - char*8  - Datum-Region for grid coordinates
c            DATEN - char*8  - NIMA date for datum parameters
c                                    (MM-DD-YYYY  )
c           XYUNIT - char*4  - Units for coordinates (e.g., KM)
c            TZONE - char*8  - Time zone (UTC+nnnn)
c                             (GMT=UTC+0000, EST=UTC-0500, CET=UTC+0100)
c
c --- OUTPUT:
c             (all inputs returned)
c
c
c --- GEOFMT called by: 
c --- GEOFMT calls:     ALLCAP, TLEFT
c----------------------------------------------------------------------
      include 'params.puf'
      include 'params.cal'

      character*4 utmhem, xyunit
      character*8 pmap, datum, tzone
      character*12 daten
      character*16 dataset,dataver
      character*16 clat0,clon0,clat1,clat2,clatlon4(4)
      character*1 cstor1(mxcol), cstor2(mxcol)

      logical lfatal

      lfatal=.FALSE.

c --- Swap lat/lon variables into array
      clatlon4(1)=clat0
      clatlon4(2)=clon0
      clatlon4(3)=clat1
      clatlon4(4)=clat2

c --- Convert characters to upper case and left-justify all strings
c -----------------------------------------------------------------

c --- PMAP
      do j=1,8
         cstor1(j)=pmap(j:j)
      enddo
      call ALLCAP(cstor1,8)
      call TLEFT(cstor1,1,8,cstor2,nlim)
      do j=1,8
         pmap(j:j)=cstor2(j)
      enddo

c --- UTMHEM
      do j=1,4
         cstor1(j)=utmhem(j:j)
      enddo
      call ALLCAP(cstor1,4)
      call TLEFT(cstor1,1,4,cstor2,nlim)
      do j=1,4
         utmhem(j:j)=cstor2(j)
      enddo

c --- DATUM
      do j=1,8
         cstor1(j)=datum(j:j)
      enddo
      call ALLCAP(cstor1,8)
      call TLEFT(cstor1,1,8,cstor2,nlim)
      do j=1,8
         datum(j:j)=cstor2(j)
      enddo

c --- DATEN
      do j=1,12
         cstor1(j)=daten(j:j)
      enddo
      call ALLCAP(cstor1,12)
      call TLEFT(cstor1,1,12,cstor2,nlim)
      do j=1,12
         daten(j:j)=cstor2(j)
      enddo

c --- XYUNIT
      do j=1,4
         cstor1(j)=xyunit(j:j)
      enddo
      call ALLCAP(cstor1,4)
      call TLEFT(cstor1,1,4,cstor2,nlim)
      do j=1,4
         xyunit(j:j)=cstor2(j)
      enddo

c --- TZONE
      do j=1,8
         cstor1(j)=tzone(j:j)
      enddo
      call ALLCAP(cstor1,8)
      call TLEFT(cstor1,1,8,cstor2,nlim)
      do j=1,8
         tzone(j:j)=cstor2(j)
      enddo

c --- Lat/Lon specs
      do k=1,4
         do j=1,16
            cstor1(j)=clatlon4(k)(j:j)
         enddo
         call ALLCAP(cstor1,16)
         call TLEFT(cstor1,1,16,cstor2,nlim)
         do j=1,16
            clatlon4(k)(j:j)=cstor2(j)
         enddo
      enddo

c --- QA
c -------

c --- Screen for valid projection strings
      ifound=0
      if(pmap.EQ.'LL      ')  ifound=1
      if(pmap.EQ.'UTM     ')  ifound=1
      if(pmap.EQ.'LCC     ')  ifound=1
      if(pmap.EQ.'PS      ')  ifound=1
      if(pmap.EQ.'EM      ')  ifound=1
      if(pmap.EQ.'LAZA    ')  ifound=1
      if(pmap.EQ.'TTM     ')  ifound=1
      if(ifound .EQ. 0) then
         write(io6,*)
         write(io6,*)'FATAL Error:  Invalid Map Projection'
         write(io6,*)'Expected PMAP = LL,UTM,LCC,PS,EM,LAZA,TTM'
         write(io6,*)'Found    PMAP = ',pmap
         lfatal=.TRUE.
      endif

      if(pmap(1:3).EQ.'UTM') then
c ---    UTMHEM is N or S
         if(utmhem.NE.'N   ' .AND. utmhem.NE.'S   ') then
            write(io6,*)
            write(io6,*)'FATAL Error:  UTMHEM must be N or S'
            write(io6,*)'Found UTMHEM = ',utmhem
            lfatal=.TRUE.
         endif
c ---    IUTM is 1 to 60
         if(iutm.LT.1 .OR. iutm.GT.60) then
            write(io6,*)
            write(io6,*)'FATAL Error:  IUTM must be 1 to 60'
            write(io6,*)'Found IUTM = ',iutm
            lfatal=.TRUE.
         endif

      else
c ---    Screen lat/lon strings for blanks before right-most character
         do k=1,4
            ilast=16
            do i=1,16
               if(clatlon4(k)(i:i).NE.' ') ilast=i
            enddo
            nblank=0
            do i=1,ilast
               if(clatlon4(k)(i:i).EQ.' ') nblank=nblank+1
            enddo
c ---       Require at least 2 characters, and allow 1 blank between
c ---       characters
            if(nblank.GT.1 .OR. ilast.LT.3) then
               write(io6,*)
               write(io6,*)'FATAL Error:  invalid lat/lon data'
               write(io6,*)'Expected numbers with 1 character in each'
               write(io6,*)'Found:  ',clatlon4(k)
               lfatal=.TRUE.
            endif
         enddo
      endif

      if(pmap(1:3).NE.'LL ') then
c ---    Distance must be KM
         if(xyunit.NE.'KM  ') then
            write(io6,*)
            write(io6,*)'FATAL Error:  XYUNIT must be KM'
            write(io6,*)'Found XYUNIT = ',xyunit
            lfatal=.TRUE.
         endif
      endif

c --- Time zone must be UTC+hhmm in whole hours
         if(tzone(7:8).NE.'00') then
            write(io6,*)'FATAL Error: Time Zone format'
            write(io6,*)'Expected whole hour, Found: ',tzone
            lfatal=.TRUE.
         endif
         if(tzone(1:3).NE.'UTC') then
            write(io6,*)'FATAL Error: Time Zone format'
            write(io6,*)'Expected UTC+hh00, Found: ',tzone
            lfatal=.TRUE.
         endif

      if(LFATAL) then
         write(io6,*)
         write(io6,*)'Troubled file is type: ',dataset
         write(io6,*)'              version: ',dataver
         write(*,*)
         stop 'Halted in subr. GEOFMT -- see list file'
      endif

      return
      end

c----------------------------------------------------------------------
      subroutine NRISEHD(itype,i,ndhrb,nsecb,ndhre,nsece,
     &                   ndhrqb,nsecqb,ndhrqe,nsecqe,zelev,zht,
     &                   tdegk,reff,weff,xgrd,ygrd)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430                NRISEHD
c                D. Strimaitis
c
c --- PURPOSE:  Prepare data header record for RISE.DAT file and 
c               place in scratch file
c
c --- INPUTS:
c         ITYPE - integer - Source type
c             I - integer - Source index
c         NDHRB - integer - Julian day, hour beginning of timestep
c         NSECB - integer - Seconds at beginning of timestep
c         NDHRE - integer - Julian day, hour at end of timestep
c         NSECE - integer - Seconds at end of timestep
c        NDHRQB - integer - Julian day, hour beginning current data
c        NSECQB - integer - Seconds at beginning of current data
c        NDHRQE - integer - Julian day, hour at end of current data
c        NSECQE - integer - Seconds at end of current data
c
c     Common block /OUTPT/ variables:
c           INRISE
c     Common block /GRID/ variables:
c           DGRID, XORIG, YORIG
c     Parameters:
c           IO6, IOX
c
c --- OUTPUT:
c
c --- NRISEHD called by:  AREAS2
c --- NRISEHD calls:      (none)
c----------------------------------------------------------------------

      include 'params.puf'
      include 'grid.puf'
      include 'outpt.puf'

c --- Check output directive
      if(inrise.EQ.0) then
         return
      elseif(inrise.NE.1) then
         write(io6,*)
         write(io6,*)'Error in NRISEHD:  Bad INRISE value = ',inrise
         write(io6,*)'Expected either 0 or 1'
         stop 'Halted in NRISEHD:  See list file'
      endif

c --- Convert source location from grid units to KM
      xkm=0.001*(xgrd*dgrid+xorig)
      ykm=0.001*(ygrd*dgrid+yorig)

c --- Rewind temporary file for intermediate rise information
      REWIND(iox)

c --- Write time period of the model timestep
      write(iox,*) ndhrb,nsecb,ndhre,nsece

c --- Write source information
      write(iox,*) itype,i,xkm,ykm,zelev,zht,tdegk,reff,weff

c --- Write time period of the emissions data for this source
      write(iox,*) ndhrqb,nsecqb,ndhrqe,nsecqe

      return
      end
c----------------------------------------------------------------------
      subroutine NRISEOUT(krise,mprime)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080430               NRISEOUT
c                D. Strimaitis
c
c --- PURPOSE:  Prepare data header record for RISE.DAT file and open
c               scratch file
c
c --- INPUTS:
c         KRISE - integer - Number of data records
c        MPRIME - integer - Flag indicating NUMRISE configuration
c                           0:  Standard plume rise
c                           1:  Modified rise with PRIME building
c                               downwash
c
c     Parameters:
c           IO38, IOX
c
c --- OUTPUT:
c
c --- NRISEOUT called by:  NUMRISE
c --- NRISEOUT calls:      (none)
c----------------------------------------------------------------------

      include 'params.puf'

      character*50 adoc
      data adoc/'s,x,y,z,rad,us,u,v,w,denp,tp,ua,dena,ta,dudz,dpdz '/

c --- Reset scratch file position
      REWIND(iox)

c --- Time period of the time step
      read(iox,*) ndhrb,nsecb,ndhre,nsece
      write(io38,*) ndhrb,nsecb,ndhre,nsece

c --- Source information (with MPRIME added)
      read(iox,*) itype,i,xkm,ykm,zelev,zht,tdegk,reff,weff
      write(io38,*) itype,i,xkm,ykm,zelev,zht,tdegk,reff,weff,mprime

c --- Emissions time period (with number of records added)
      read(iox,*) ndhrb,nsecb,ndhre,nsece
      write(io38,*) ndhrb,nsecb,ndhre,nsece,krise

c --- Document data each time
      write(io38,*) adoc

c --- Transfer rise records
      do k=1,krise
         read(iox,*)s,x,y,zc,r,usc,u,v,w,den,tp,ua,ra,ta,dudz,dpdz
         write(io38,*)s,x,y,zc,r,usc,u,v,w,den,tp,ua,ra,ta,dudz,dpdz
      enddo

c --- Done with file (rewind, do not close)
      REWIND(iox)

      return
      end
c----------------------------------------------------------------------
      subroutine ZEROTAB
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                ZEROTAB
c                D. Strimaitis
c
c --- PURPOSE:  Reset all array tables in /SRCTAB/
c
c --- INPUTS:
c     Parameters:
c           MXRISE
c
c --- OUTPUT:
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c --- ZEROTAB called by:  POINTS1, POINTS2, AREAS2, LINES1, LINES2
c --- ZEROTAB calls:      (none)
c----------------------------------------------------------------------

      include 'params.puf'
      include 'srctab.puf'

      data zero/0.0/

c --- Reset number of stored elements
      ntr=0
      nwk=0
      ncv=0

c --- Reset arrays
      do i=1,mxrise
         xtr(i)=zero
         ztr(i)=zero
         rtr(i)=zero
         htr(i)=zero
         xwk(i)=zero
         sywk(i)=zero
         szwk(i)=zero
         drwk(i)=zero
         xcv(i)=zero
         sycv(i)=zero
         szcv(i)=zero
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine swaptab(i,j)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520                SWAPTAB
c                D. Strimaitis
c
c --- PURPOSE:  Transfers Direct Access file record from puff index "J"
c               to index "I".  These records hold source tables for a
c               puff that are computed at the time of release.
c
c --- INPUTS:
c             I - integer - New record (puff) index
c             J - integer - Old record (puff) index
c
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c     Parameters:
c           MXRISE, IO6, IOTAB
c
c --- OUTPUT:
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c --- SWAPTAB called by: SWAP
c --- SWAPTAB calls:     none
c----------------------------------------------------------------------

c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'srctab.puf'

      if(i.EQ.0 .OR. j.EQ.0 .OR. i.EQ.j) then
         write(io6,*)
         write(io6,*)'Error in SWAPTAB:  Invalid index'
         write(io6,*)'Expected I,J not equal to 0'
         write(io6,*)'Expected I not equal to J'
         write(io6,*)'Found I,J = ',i,j
         stop 'Halted in SWAPTAB:  See list file'
      endif

c --- Read record J into arrays
      read(iotab,rec=j)  isrctyp,isrcnum,irlsnum,ntr,nwk,ncv,
     &                   xtr,ztr,rtr,htr,xwk,sywk,szwk,drwk,
     &                   xcv,sycv,szcv

c --- Write arrays into record I
      write(iotab,rec=i) isrctyp,isrcnum,irlsnum,ntr,nwk,ncv,
     &                   xtr,ztr,rtr,htr,xwk,sywk,szwk,drwk,
     &                   xcv,sycv,szcv

      return
      end
c----------------------------------------------------------------------
      subroutine srctabin(np,ityp0,isrc0,irls0)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520               SRCTABIN
c                D. Strimaitis
c
c --- PURPOSE:  Reads one Direct Access file record for puff index "NP"
c               and places data into /SRCTAB/ arrays
c
c --- INPUTS:
c            NP - integer - Record (puff) index
c         ITYP0 - integer - Expected source type index
c         ISRC0 - integer - Expected source number index
c         IRLS0 - integer - Expected release number index
c
c     Parameters:
c           MXRISE, IO6, IOTAB
c
c --- OUTPUT:
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c --- SRCTABIN called by: COMP, RESTARTO
c --- SRCTABIN calls:     none
c----------------------------------------------------------------------

c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'srctab.puf'

      if(np.LE.0) then
         write(io6,*)
         write(io6,*)'Error in SRCTABIN:  Invalid record index'
         write(io6,*)'Expected NP greater than 0'
         write(io6,*)'Found NP = ',np
         stop 'Halted in SRCTABIN:  See list file'
      endif

c --- Read record NP into arrays
      read(iotab,rec=np)  ityp,isrc,irls,ntr,nwk,ncv,
     &                    xtr,ztr,rtr,htr,xwk,sywk,szwk,drwk,
     &                    xcv,sycv,szcv

c --- Check expected source information
      if(ityp.NE.ityp0 .OR. isrc.NE.isrc0 .OR. irls.NE.irls0) then
         write(io6,*)
         write(io6,*)'Error in SRCTABIN:  Invalid Source'
         write(io6,*)'                Expected  Found'
         write(io6,*)'Source type    = ',ityp0,ityp
         write(io6,*)'Source number  = ',isrc0,isrc
         write(io6,*)'Release number = ',irls0,irls
         write(io6,*)'Puff number    = ',np
         write(io6,*)'ntr,nwk,ncv    = ',ntr,nwk,ncv
         stop 'Halted in SRCTABIN:  See list file'
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine srctabout(np,ityp,isrc,irls)
c----------------------------------------------------------------------
c
c --- CALPUFF    Version: 6.262    Level: 080520              SRCTABOUT
c                D. Strimaitis
c
c --- PURPOSE:  Writes one Direct Access file record for puff index
c               "NP" from /SRCTAB/ arrays
c
c --- INPUTS:
c            NP - integer - Record (puff) index
c          ITYP - integer - Source type index
c          ISRC - integer - Source number index
c          IRLS - integer - Release number index
c
c     Common block /SRCTAB/ variables:
c           NTR, NWK, NCV,
c           XTR(mxrise),ZTR(mxrise),RTR(mxrise),HTR(mxrise),
c           XWK(mxrise),SYWK(mxrise),SZWK(mxrise),DRWK(mxrise),
c           XCV(mxrise),SYCV(mxrise),SZCV(mxrise)
c
c     Parameters:
c           MXRISE, IO6, IOTAB
c
c --- OUTPUT:
c
c --- SRCTABOUT called by: 
c --- SRCTABOUT calls:     none
c----------------------------------------------------------------------

c --- Include parameters
      include 'params.puf'

c --- Include common blocks
      include 'srctab.puf'

      if(np.LE.0) then
         write(io6,*)
         write(io6,*)'Error in SRCTABOUT:  Invalid record index'
         write(io6,*)'Expected NP greater than 0'
         write(io6,*)'Found NP = ',np
         stop 'Halted in SRCTABOUT:  See list file'
      endif

c --- Write record NP to disk
      write(iotab,rec=np)  ityp,isrc,irls,ntr,nwk,ncv,
     &                     xtr,ztr,rtr,htr,xwk,sywk,szwk,drwk,
     &                     xcv,sycv,szcv

      return
      end
